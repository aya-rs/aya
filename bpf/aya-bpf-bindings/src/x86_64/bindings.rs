#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type __u8 = ::aya_bpf_cty::c_uchar;
pub type __s16 = ::aya_bpf_cty::c_short;
pub type __u16 = ::aya_bpf_cty::c_ushort;
pub type __s32 = ::aya_bpf_cty::c_int;
pub type __u32 = ::aya_bpf_cty::c_uint;
pub type __s64 = ::aya_bpf_cty::c_longlong;
pub type __u64 = ::aya_bpf_cty::c_ulonglong;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_long_t = ::aya_bpf_cty::c_long;
pub type __kernel_ulong_t = ::aya_bpf_cty::c_ulong;
pub type __kernel_pid_t = ::aya_bpf_cty::c_int;
pub type __kernel_uid32_t = ::aya_bpf_cty::c_uint;
pub type __kernel_gid32_t = ::aya_bpf_cty::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_loff_t = ::aya_bpf_cty::c_longlong;
pub type __kernel_time64_t = ::aya_bpf_cty::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::aya_bpf_cty::c_int;
pub type __kernel_clockid_t = ::aya_bpf_cty::c_int;
pub type __poll_t = ::aya_bpf_cty::c_uint;
pub type __kernel_dev_t = u32_;
pub type dev_t = __kernel_dev_t;
pub type umode_t = ::aya_bpf_cty::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type size_t = __kernel_size_t;
pub type ssize_t = __kernel_ssize_t;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = ::aya_bpf_cty::c_uint;
pub type fmode_t = ::aya_bpf_cty::c_uint;
pub type phys_addr_t = u64_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub counter: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut callback_head)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const ::aya_bpf_cty::c_char,
    pub fs_flags: ::aya_bpf_cty::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: *mut ::aya_bpf_cty::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ::aya_bpf_cty::c_int,
    pub burst: ::aya_bpf_cty::c_int,
    pub printed: ::aya_bpf_cty::c_int,
    pub missed: ::aya_bpf_cty::c_int,
    pub begin: ::aya_bpf_cty::c_ulong,
    pub flags: ::aya_bpf_cty::c_ulong,
}
pub type fl_owner_t = *mut ::aya_bpf_cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::aya_bpf_cty::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf_cty::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf_cty::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::aya_bpf_cty::c_int,
    >,
    pub mmap_supported_flags: ::aya_bpf_cty::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: fl_owner_t) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf_cty::c_int,
            arg2: *mut file,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut file_lock,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: ::aya_bpf_cty::c_int,
            arg4: size_t,
            arg5: *mut loff_t,
            arg6: ::aya_bpf_cty::c_int,
        ) -> ssize_t,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: ::aya_bpf_cty::c_ulong,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
    pub check_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub setfl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ::aya_bpf_cty::c_ulong) -> ::aya_bpf_cty::c_int,
    >,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut file_lock,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ssize_t,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ssize_t,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_int,
            arg3: loff_t,
            arg4: loff_t,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: size_t,
            arg6: ::aya_bpf_cty::c_uint,
        ) -> ssize_t,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: loff_t,
            arg6: ::aya_bpf_cty::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub type time64_t = __s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::aya_bpf_cty::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ::aya_bpf_cty::c_long,
}
pub mod timespec_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TT_NONE: Type = 0;
    pub const TT_NATIVE: Type = 1;
    pub const TT_COMPAT: Type = 2;
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut restart_block) -> ::aya_bpf_cty::c_long,
    >,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type::Type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::aya_bpf_cty::c_int,
    pub has_timeout: ::aya_bpf_cty::c_int,
    pub tv_sec: ::aya_bpf_cty::c_ulong,
    pub tv_nsec: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_info {
    pub flags: ::aya_bpf_cty::c_ulong,
    pub syscall_work: ::aya_bpf_cty::c_ulong,
    pub status: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ::aya_bpf_cty::c_uint,
    pub a_flags: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct load_weight {
    pub weight: ::aya_bpf_cty::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::aya_bpf_cty::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub exec_max: u64_,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct util_est {
    pub enqueued: ::aya_bpf_cty::c_uint,
    pub ewma: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: ::aya_bpf_cty::c_ulong,
    pub runnable_avg: ::aya_bpf_cty::c_ulong,
    pub util_avg: ::aya_bpf_cty::c_ulong,
    pub util_est: util_est,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: ::aya_bpf_cty::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub nr_migrations: u64_,
    pub statistics: sched_statistics,
    pub depth: ::aya_bpf_cty::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub avg: sched_avg,
}
impl sched_entity {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: ::aya_bpf_cty::c_ulong,
    pub watchdog_stamp: ::aya_bpf_cty::c_ulong,
    pub time_slice: ::aya_bpf_cty::c_uint,
    pub on_rq: ::aya_bpf_cty::c_ushort,
    pub on_list: ::aya_bpf_cty::c_ushort,
    pub back: *mut sched_rt_entity,
}
pub type ktime_t = s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
pub mod hrtimer_restart {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const HRTIMER_NORESTART: Type = 0;
    pub const HRTIMER_RESTART: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart::Type>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub pi_se: *mut sched_dl_entity,
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: ::aya_bpf_cty::c_uint,
        dl_yielded: ::aya_bpf_cty::c_uint,
        dl_non_contending: ::aya_bpf_cty::c_uint,
        dl_overrun: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uclamp_se {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl uclamp_se {
    #[inline]
    pub fn value(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn bucket_id(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bucket_id(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_defined(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user_defined(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value: ::aya_bpf_cty::c_uint,
        bucket_id: ::aya_bpf_cty::c_uint,
        active: ::aya_bpf_cty::c_uint,
        user_defined: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let value: u32 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let bucket_id: u32 = unsafe { ::core::mem::transmute(bucket_id) };
            bucket_id as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let active: u32 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let user_defined: u32 = unsafe { ::core::mem::transmute(user_defined) };
            user_defined as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [::aya_bpf_cty::c_ulong; 128usize],
}
pub type cpumask_t = cpumask;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_info {
    pub pcount: ::aya_bpf_cty::c_ulong,
    pub run_delay: ::aya_bpf_cty::c_ulonglong,
    pub last_arrival: ::aya_bpf_cty::c_ulonglong,
    pub last_queued: ::aya_bpf_cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: ::aya_bpf_cty::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmacache {
    pub seqnum: u64_,
    pub vmas: [*mut vm_area_struct; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_rss_stat {
    pub events: ::aya_bpf_cty::c_int,
    pub count: [::aya_bpf_cty::c_int; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: ::aya_bpf_cty::c_uint,
    pub expiry_active: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub scheduled: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub sig: [::aya_bpf_cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: ::aya_bpf_cty::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut ::aya_bpf_cty::c_char,
    pub offset: ::aya_bpf_cty::c_ulong,
    pub len: ::aya_bpf_cty::c_ulong,
    pub on_dispatch: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [::aya_bpf_cty::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount {
    pub sequence: ::aya_bpf_cty::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::core::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::core::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::core::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::core::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::core::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::core::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::core::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: u64_,
    pub xcomp_bv: u64_,
    pub reserved: [u64_; 6usize],
}
#[repr(C)]
pub struct xregs_state {
    pub i387: fxregs_state,
    pub header: xstate_header,
    pub extended_state_area: __IncompleteArrayField<u8_>,
}
#[repr(C)]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u64; 512usize],
}
#[repr(C)]
pub struct fpu {
    pub last_cpu: ::aya_bpf_cty::c_uint,
    pub avx512_timestamp: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub state: fpregs_state,
}
#[repr(C)]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ::aya_bpf_cty::c_ulong,
    pub es: ::aya_bpf_cty::c_ushort,
    pub ds: ::aya_bpf_cty::c_ushort,
    pub fsindex: ::aya_bpf_cty::c_ushort,
    pub gsindex: ::aya_bpf_cty::c_ushort,
    pub fsbase: ::aya_bpf_cty::c_ulong,
    pub gsbase: ::aya_bpf_cty::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: ::aya_bpf_cty::c_ulong,
    pub ptrace_dr7: ::aya_bpf_cty::c_ulong,
    pub cr2: ::aya_bpf_cty::c_ulong,
    pub trap_nr: ::aya_bpf_cty::c_ulong,
    pub error_code: ::aya_bpf_cty::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub fpu: fpu,
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
pub struct task_struct {
    pub thread_info: thread_info,
    pub state: ::aya_bpf_cty::c_long,
    pub stack: *mut ::aya_bpf_cty::c_void,
    pub usage: refcount_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub ptrace: ::aya_bpf_cty::c_uint,
    pub on_cpu: ::aya_bpf_cty::c_int,
    pub wake_entry: __call_single_node,
    pub cpu: ::aya_bpf_cty::c_uint,
    pub wakee_flips: ::aya_bpf_cty::c_uint,
    pub wakee_flip_decay_ts: ::aya_bpf_cty::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: ::aya_bpf_cty::c_int,
    pub wake_cpu: ::aya_bpf_cty::c_int,
    pub on_rq: ::aya_bpf_cty::c_int,
    pub prio: ::aya_bpf_cty::c_int,
    pub static_prio: ::aya_bpf_cty::c_int,
    pub normal_prio: ::aya_bpf_cty::c_int,
    pub rt_priority: ::aya_bpf_cty::c_uint,
    pub sched_class: *const sched_class,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub sched_task_group: *mut task_group,
    pub dl: sched_dl_entity,
    pub uclamp_req: [uclamp_se; 2usize],
    pub uclamp: [uclamp_se; 2usize],
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: ::aya_bpf_cty::c_uint,
    pub policy: ::aya_bpf_cty::c_uint,
    pub nr_cpus_allowed: ::aya_bpf_cty::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut ::aya_bpf_cty::c_void,
    pub migration_disabled: ::aya_bpf_cty::c_ushort,
    pub migration_flags: ::aya_bpf_cty::c_ushort,
    pub trc_reader_nesting: ::aya_bpf_cty::c_int,
    pub trc_ipi_to_cpu: ::aya_bpf_cty::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_reader_checked: bool_,
    pub trc_holdout_list: list_head,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub vmacache: vmacache,
    pub rss_stat: task_rss_stat,
    pub exit_state: ::aya_bpf_cty::c_int,
    pub exit_code: ::aya_bpf_cty::c_int,
    pub exit_signal: ::aya_bpf_cty::c_int,
    pub pdeath_signal: ::aya_bpf_cty::c_int,
    pub jobctl: ::aya_bpf_cty::c_ulong,
    pub personality: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub atomic_flags: ::aya_bpf_cty::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: ::aya_bpf_cty::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut ::aya_bpf_cty::c_int,
    pub clear_child_tid: *mut ::aya_bpf_cty::c_int,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ::aya_bpf_cty::c_ulong,
    pub nivcsw: ::aya_bpf_cty::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: ::aya_bpf_cty::c_ulong,
    pub maj_flt: ::aya_bpf_cty::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [::aya_bpf_cty::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: ::aya_bpf_cty::c_ulong,
    pub last_switch_time: ::aya_bpf_cty::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: ::aya_bpf_cty::c_ulong,
    pub sas_ss_size: size_t,
    pub sas_ss_flags: ::aya_bpf_cty::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: ::aya_bpf_cty::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut ::aya_bpf_cty::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: ::aya_bpf_cty::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub psi_flags: ::aya_bpf_cty::c_uint,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: ::aya_bpf_cty::c_int,
    pub cpuset_slab_spread_rotor: ::aya_bpf_cty::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32_,
    pub rmid: u32_,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: ::aya_bpf_cty::c_uint,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: ::aya_bpf_cty::c_short,
    pub pref_node_fork: ::aya_bpf_cty::c_short,
    pub numa_scan_seq: ::aya_bpf_cty::c_int,
    pub numa_scan_period: ::aya_bpf_cty::c_uint,
    pub numa_scan_period_max: ::aya_bpf_cty::c_uint,
    pub numa_preferred_nid: ::aya_bpf_cty::c_int,
    pub numa_migrate_retry: ::aya_bpf_cty::c_ulong,
    pub node_stamp: u64_,
    pub last_task_numa_placement: u64_,
    pub last_sum_exec_runtime: u64_,
    pub numa_work: callback_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut ::aya_bpf_cty::c_ulong,
    pub total_numa_faults: ::aya_bpf_cty::c_ulong,
    pub numa_faults_locality: [::aya_bpf_cty::c_ulong; 3usize],
    pub numa_pages_migrated: ::aya_bpf_cty::c_ulong,
    pub rseq: *mut rseq,
    pub rseq_sig: u32_,
    pub rseq_event_mask: ::aya_bpf_cty::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub __bindgen_anon_1: task_struct__bindgen_ty_1,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: ::aya_bpf_cty::c_int,
    pub nr_dirtied_pause: ::aya_bpf_cty::c_int,
    pub dirty_paused_when: ::aya_bpf_cty::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub curr_ret_stack: ::aya_bpf_cty::c_int,
    pub curr_ret_depth: ::aya_bpf_cty::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: ::aya_bpf_cty::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace: ::aya_bpf_cty::c_ulong,
    pub trace_recursion: ::aya_bpf_cty::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: ::aya_bpf_cty::c_int,
    pub memcg_nr_pages_over_high: ::aya_bpf_cty::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub throttle_queue: *mut request_queue,
    pub utask: *mut uprobe_task,
    pub sequential_io: ::aya_bpf_cty::c_uint,
    pub sequential_io_avg: ::aya_bpf_cty::c_uint,
    pub kmap_ctrl: kmap_ctrl,
    pub pagefault_disabled: ::aya_bpf_cty::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub patch_state: ::aya_bpf_cty::c_int,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub mce_vaddr: *mut ::aya_bpf_cty::c_void,
    pub mce_kflags: __u64,
    pub mce_addr: u64_,
    pub _bitfield_align_3: [u64; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub mce_kill_me: callback_head,
    pub kretprobe_instances: llist_head,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub thread: thread_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union task_struct__bindgen_ty_1 {
    pub rcu_users: refcount_t,
    pub rcu: callback_head,
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_psi_wake_requeue(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_psi_wake_requeue(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_memstall(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_memstall(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sched_reset_on_fork: ::aya_bpf_cty::c_uint,
        sched_contributes_to_load: ::aya_bpf_cty::c_uint,
        sched_migrated: ::aya_bpf_cty::c_uint,
        sched_psi_wake_requeue: ::aya_bpf_cty::c_uint,
        sched_remote_wakeup: ::aya_bpf_cty::c_uint,
        in_execve: ::aya_bpf_cty::c_uint,
        in_iowait: ::aya_bpf_cty::c_uint,
        restore_sigmask: ::aya_bpf_cty::c_uint,
        in_user_fault: ::aya_bpf_cty::c_uint,
        no_cgroup_migration: ::aya_bpf_cty::c_uint,
        frozen: ::aya_bpf_cty::c_uint,
        use_memdelay: ::aya_bpf_cty::c_uint,
        in_memstall: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_psi_wake_requeue: u32 =
                unsafe { ::core::mem::transmute(sched_psi_wake_requeue) };
            sched_psi_wake_requeue as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let in_memstall: u32 = unsafe { ::core::mem::transmute(in_memstall) };
            in_memstall as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mce_ripv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_ripv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce_whole_page(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_whole_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __mce_reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set___mce_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        mce_ripv: __u64,
        mce_whole_page: __u64,
        __mce_reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mce_ripv: u64 = unsafe { ::core::mem::transmute(mce_ripv) };
            mce_ripv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mce_whole_page: u64 = unsafe { ::core::mem::transmute(mce_whole_page) };
            mce_whole_page as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let __mce_reserved: u64 = unsafe { ::core::mem::transmute(__mce_reserved) };
            __mce_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::aya_bpf_cty::c_ulong,
    pub r14: ::aya_bpf_cty::c_ulong,
    pub r13: ::aya_bpf_cty::c_ulong,
    pub r12: ::aya_bpf_cty::c_ulong,
    pub bp: ::aya_bpf_cty::c_ulong,
    pub bx: ::aya_bpf_cty::c_ulong,
    pub r11: ::aya_bpf_cty::c_ulong,
    pub r10: ::aya_bpf_cty::c_ulong,
    pub r9: ::aya_bpf_cty::c_ulong,
    pub r8: ::aya_bpf_cty::c_ulong,
    pub ax: ::aya_bpf_cty::c_ulong,
    pub cx: ::aya_bpf_cty::c_ulong,
    pub dx: ::aya_bpf_cty::c_ulong,
    pub si: ::aya_bpf_cty::c_ulong,
    pub di: ::aya_bpf_cty::c_ulong,
    pub orig_ax: ::aya_bpf_cty::c_ulong,
    pub ip: ::aya_bpf_cty::c_ulong,
    pub cs: ::aya_bpf_cty::c_ulong,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub sp: ::aya_bpf_cty::c_ulong,
    pub ss: ::aya_bpf_cty::c_ulong,
}
pub type pteval_t = ::aya_bpf_cty::c_ulong;
pub type pmdval_t = ::aya_bpf_cty::c_ulong;
pub type pudval_t = ::aya_bpf_cty::c_ulong;
pub type pgdval_t = ::aya_bpf_cty::c_ulong;
pub type pgprotval_t = ::aya_bpf_cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: page__bindgen_ty_1__bindgen_ty_7,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub mapping: *mut address_space,
    pub index: ::aya_bpf_cty::c_ulong,
    pub private: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub dma_addr: dma_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub slab_cache: *mut kmem_cache,
    pub freelist: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub slab_list: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut page,
    pub pages: ::aya_bpf_cty::c_int,
    pub pobjects: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub s_mem: *mut ::aya_bpf_cty::c_void,
    pub counters: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn inuse(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inuse(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn objects(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_objects(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inuse: ::aya_bpf_cty::c_uint,
        objects: ::aya_bpf_cty::c_uint,
        frozen: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let inuse: u32 = unsafe { ::core::mem::transmute(inuse) };
            inuse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let objects: u32 = unsafe { ::core::mem::transmute(objects) };
            objects as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub compound_head: ::aya_bpf_cty::c_ulong,
    pub compound_dtor: ::aya_bpf_cty::c_uchar,
    pub compound_order: ::aya_bpf_cty::c_uchar,
    pub compound_mapcount: atomic_t,
    pub compound_nr: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _compound_pad_1: ::aya_bpf_cty::c_ulong,
    pub hpage_pinned_refcount: atomic_t,
    pub deferred_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    pub _pt_pad_1: ::aya_bpf_cty::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub ptl: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_7 {
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: ::aya_bpf_cty::c_uint,
    pub active: ::aya_bpf_cty::c_uint,
    pub units: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub lock: mutex,
    pub vdso: *mut ::aya_bpf_cty::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mmap: *mut vm_area_struct,
    pub mm_rb: rb_root,
    pub vmacache_seqnum: u64_,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: ::aya_bpf_cty::c_ulong,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
    pub mmap_base: ::aya_bpf_cty::c_ulong,
    pub mmap_legacy_base: ::aya_bpf_cty::c_ulong,
    pub mmap_compat_base: ::aya_bpf_cty::c_ulong,
    pub mmap_compat_legacy_base: ::aya_bpf_cty::c_ulong,
    pub task_size: ::aya_bpf_cty::c_ulong,
    pub highest_vm_end: ::aya_bpf_cty::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub mm_count: atomic_t,
    pub has_pinned: atomic_t,
    pub write_protect_seq: seqcount_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: ::aya_bpf_cty::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: ::aya_bpf_cty::c_ulong,
    pub hiwater_vm: ::aya_bpf_cty::c_ulong,
    pub total_vm: ::aya_bpf_cty::c_ulong,
    pub locked_vm: ::aya_bpf_cty::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: ::aya_bpf_cty::c_ulong,
    pub exec_vm: ::aya_bpf_cty::c_ulong,
    pub stack_vm: ::aya_bpf_cty::c_ulong,
    pub def_flags: ::aya_bpf_cty::c_ulong,
    pub arg_lock: spinlock_t,
    pub start_code: ::aya_bpf_cty::c_ulong,
    pub end_code: ::aya_bpf_cty::c_ulong,
    pub start_data: ::aya_bpf_cty::c_ulong,
    pub end_data: ::aya_bpf_cty::c_ulong,
    pub start_brk: ::aya_bpf_cty::c_ulong,
    pub brk: ::aya_bpf_cty::c_ulong,
    pub start_stack: ::aya_bpf_cty::c_ulong,
    pub arg_start: ::aya_bpf_cty::c_ulong,
    pub arg_end: ::aya_bpf_cty::c_ulong,
    pub env_start: ::aya_bpf_cty::c_ulong,
    pub env_end: ::aya_bpf_cty::c_ulong,
    pub saved_auxv: [::aya_bpf_cty::c_ulong; 46usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub core_state: *mut core_state,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub numa_next_scan: ::aya_bpf_cty::c_ulong,
    pub numa_scan_offset: ::aya_bpf_cty::c_ulong,
    pub numa_scan_seq: ::aya_bpf_cty::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: bool_,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub pasid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: ::aya_bpf_cty::c_ulong,
    pub vm_end: ::aya_bpf_cty::c_ulong,
    pub vm_next: *mut vm_area_struct,
    pub vm_prev: *mut vm_area_struct,
    pub vm_rb: rb_node,
    pub rb_subtree_gap: ::aya_bpf_cty::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: ::aya_bpf_cty::c_ulong,
    pub shared: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: ::aya_bpf_cty::c_ulong,
    pub vm_file: *mut file,
    pub vm_prfile: *mut file,
    pub vm_private_data: *mut ::aya_bpf_cty::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: ::aya_bpf_cty::c_long,
    pub regs: *mut pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut ::aya_bpf_cty::c_void,
    pub size: ::aya_bpf_cty::c_ulong,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: ::aya_bpf_cty::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ::aya_bpf_cty::c_uint,
    pub wait: swait_queue_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: ::aya_bpf_cty::c_ulong,
    pub saved_trap_nr: ::aya_bpf_cty::c_uint,
    pub saved_tf: ::aya_bpf_cty::c_uint,
}
pub mod uprobe_task_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const UTASK_RUNNING: Type = 0;
    pub const UTASK_SSTEP: Type = 1;
    pub const UTASK_SSTEP_ACK: Type = 2;
    pub const UTASK_SSTEP_TRAPPED: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state::Type,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: ::aya_bpf_cty::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: ::aya_bpf_cty::c_ulong,
    pub stack: ::aya_bpf_cty::c_ulong,
    pub orig_ret_vaddr: ::aya_bpf_cty::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut ::aya_bpf_cty::c_void,
    pub size: ::aya_bpf_cty::c_ulong,
    pub alt: ::aya_bpf_cty::c_ulong,
    pub alt_len: ::aya_bpf_cty::c_ulong,
    pub extable_base: ::aya_bpf_cty::c_ulong,
    pub extable_len: ::aya_bpf_cty::c_ulong,
    pub extable: *const ::aya_bpf_cty::c_void,
    pub sym_vvar_start: ::aya_bpf_cty::c_long,
    pub sym_vvar_page: ::aya_bpf_cty::c_long,
    pub sym_pvclock_page: ::aya_bpf_cty::c_long,
    pub sym_hvclock_page: ::aya_bpf_cty::c_long,
    pub sym_timens_page: ::aya_bpf_cty::c_long,
    pub sym_VDSO32_NOTE_MASK: ::aya_bpf_cty::c_long,
    pub sym___kernel_sigreturn: ::aya_bpf_cty::c_long,
    pub sym___kernel_rt_sigreturn: ::aya_bpf_cty::c_long,
    pub sym___kernel_vsyscall: ::aya_bpf_cty::c_long,
    pub sym_int80_landing_pad: ::aya_bpf_cty::c_long,
    pub sym_vdso32_sigreturn_landing_pad: ::aya_bpf_cty::c_long,
    pub sym_vdso32_rt_sigreturn_landing_pad: ::aya_bpf_cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut ::aya_bpf_cty::c_void,
}
pub type errseq_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: ::aya_bpf_cty::c_ulong,
    pub nrexceptional: ::aya_bpf_cty::c_ulong,
    pub writeback_index: ::aya_bpf_cty::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub wb_err: errseq_t,
    pub private_lock: spinlock_t,
    pub private_list: list_head,
    pub private_data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: ::aya_bpf_cty::c_ulong,
    pub end_pfn: ::aya_bpf_cty::c_ulong,
    pub reserve: ::aya_bpf_cty::c_ulong,
    pub free: ::aya_bpf_cty::c_ulong,
    pub align: ::aya_bpf_cty::c_ulong,
    pub alloc: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: ::aya_bpf_cty::c_ulong,
    pub data: *mut percpu_ref_data,
}
pub mod memory_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MEMORY_DEVICE_PRIVATE: Type = 1;
    pub const MEMORY_DEVICE_FS_DAX: Type = 2;
    pub const MEMORY_DEVICE_GENERIC: Type = 3;
    pub const MEMORY_DEVICE_PCI_P2PDMA: Type = 4;
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: *mut percpu_ref,
    pub internal_ref: percpu_ref,
    pub done: completion,
    pub type_: memory_type::Type,
    pub flags: ::aya_bpf_cty::c_uint,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut ::aya_bpf_cty::c_void,
    pub nr_range: ::aya_bpf_cty::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub ranges: __BindgenUnionField<[range; 0usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
pub mod rw_hint {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const WRITE_LIFE_NOT_SET: Type = 0;
    pub const WRITE_LIFE_NONE: Type = 1;
    pub const WRITE_LIFE_SHORT: Type = 2;
    pub const WRITE_LIFE_MEDIUM: Type = 3;
    pub const WRITE_LIFE_LONG: Type = 4;
    pub const WRITE_LIFE_EXTREME: Type = 5;
}
pub mod pid_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PIDTYPE_PID: Type = 0;
    pub const PIDTYPE_TGID: Type = 1;
    pub const PIDTYPE_PGID: Type = 2;
    pub const PIDTYPE_SID: Type = 3;
    pub const PIDTYPE_MAX: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type::Type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_ra_state {
    pub start: ::aya_bpf_cty::c_ulong,
    pub size: ::aya_bpf_cty::c_uint,
    pub async_size: ::aya_bpf_cty::c_uint,
    pub ra_pages: ::aya_bpf_cty::c_uint,
    pub mmap_miss: ::aya_bpf_cty::c_uint,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_u: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_write_hint: rw_hint::Type,
    pub f_count: atomic_long_t,
    pub f_flags: ::aya_bpf_cty::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64_,
    pub f_security: *mut ::aya_bpf_cty::c_void,
    pub private_data: *mut ::aya_bpf_cty::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub fu_llist: llist_node,
    pub fu_rcuhead: callback_head,
}
pub type vm_fault_t = ::aya_bpf_cty::c_uint;
pub mod page_entry_size {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PE_SIZE_PTE: Type = 0;
    pub const PE_SIZE_PMD: Type = 1;
    pub const PE_SIZE_PUD: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_fault, arg2: page_entry_size::Type) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_fault,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub pagesize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct) -> ::aya_bpf_cty::c_ulong,
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: ::aya_bpf_cty::c_int,
            arg5: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct) -> *const ::aya_bpf_cty::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: *mut mempolicy,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf_cty::c_ulong,
        ) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct, arg2: ::aya_bpf_cty::c_ulong) -> *mut page,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault {
    pub vma: *mut vm_area_struct,
    pub flags: ::aya_bpf_cty::c_uint,
    pub gfp_mask: gfp_t,
    pub pgoff: ::aya_bpf_cty::c_ulong,
    pub address: ::aya_bpf_cty::c_ulong,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub orig_pte: pte_t,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
pub type isolate_mode_t = ::aya_bpf_cty::c_uint;
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: ::aya_bpf_cty::c_int,
    pub nr_to_scan: ::aya_bpf_cty::c_ulong,
    pub nr_scanned: ::aya_bpf_cty::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
    pub batch: ::aya_bpf_cty::c_long,
    pub seeks: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_uint,
    pub list: list_head,
    pub id: ::aya_bpf_cty::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub kill: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dev_pagemap)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dev_pagemap)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: ::aya_bpf_cty::c_int,
    pub ns: *mut pid_namespace,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid {
    pub count: refcount_t,
    pub level: ::aya_bpf_cty::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ::aya_bpf_cty::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: ::aya_bpf_cty::c_uint,
    pub active_bases: ::aya_bpf_cty::c_uint,
    pub clock_was_set_seq: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: ::aya_bpf_cty::c_uint,
    pub nr_retries: ::aya_bpf_cty::c_ushort,
    pub nr_hangs: ::aya_bpf_cty::c_ushort,
    pub max_hang_time: ::aya_bpf_cty::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: ::aya_bpf_cty::c_uint,
        in_hrtirq: ::aya_bpf_cty::c_uint,
        hang_detected: ::aya_bpf_cty::c_uint,
        softirq_activated: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::aya_bpf_cty::c_int,
    pub sival_ptr: *mut ::aya_bpf_cty::c_void,
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::aya_bpf_cty::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::aya_bpf_cty::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_lsb: ::aya_bpf_cty::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::aya_bpf_cty::c_char; 8usize],
    pub _lower: *mut ::aya_bpf_cty::c_void,
    pub _upper: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::aya_bpf_cty::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::aya_bpf_cty::c_long,
    pub _fd: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::aya_bpf_cty::c_void,
    pub _syscall: ::aya_bpf_cty::c_int,
    pub _arch: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: ::aya_bpf_cty::c_int,
    pub si_errno: ::aya_bpf_cty::c_int,
    pub si_code: ::aya_bpf_cty::c_int,
    pub _sifields: __sifields,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub processes: atomic_t,
    pub sigpending: atomic_t,
    pub fanotify_listeners: atomic_t,
    pub epoll_watches: atomic_long_t,
    pub mq_bytes: ::aya_bpf_cty::c_ulong,
    pub locked_shm: ::aya_bpf_cty::c_ulong,
    pub unix_inflight: ::aya_bpf_cty::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub nr_watches: atomic_t,
    pub ratelimit: ratelimit_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ::aya_bpf_cty::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: ::aya_bpf_cty::c_int,
    pub ac_exitcode: ::aya_bpf_cty::c_long,
    pub ac_mem: ::aya_bpf_cty::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: ::aya_bpf_cty::c_ulong,
    pub ac_majflt: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: ::aya_bpf_cty::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: ::aya_bpf_cty::c_int,
    pub notify_count: ::aya_bpf_cty::c_int,
    pub group_exit_task: *mut task_struct,
    pub group_stop_count: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub posix_timer_id: ::aya_bpf_cty::c_int,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: ::aya_bpf_cty::c_int,
    pub tty: *mut tty_struct,
    pub autogroup: *mut autogroup,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ::aya_bpf_cty::c_ulong,
    pub nivcsw: ::aya_bpf_cty::c_ulong,
    pub cnvcsw: ::aya_bpf_cty::c_ulong,
    pub cnivcsw: ::aya_bpf_cty::c_ulong,
    pub min_flt: ::aya_bpf_cty::c_ulong,
    pub maj_flt: ::aya_bpf_cty::c_ulong,
    pub cmin_flt: ::aya_bpf_cty::c_ulong,
    pub cmaj_flt: ::aya_bpf_cty::c_ulong,
    pub inblock: ::aya_bpf_cty::c_ulong,
    pub oublock: ::aya_bpf_cty::c_ulong,
    pub cinblock: ::aya_bpf_cty::c_ulong,
    pub coublock: ::aya_bpf_cty::c_ulong,
    pub maxrss: ::aya_bpf_cty::c_ulong,
    pub cmaxrss: ::aya_bpf_cty::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: ::aya_bpf_cty::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: ::aya_bpf_cty::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: ::aya_bpf_cty::c_short,
    pub oom_score_adj_min: ::aya_bpf_cty::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: ::aya_bpf_cty::c_uint,
        has_child_subreaper: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: rseq__bindgen_ty_1,
    pub flags: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rseq__bindgen_ty_1 {
    pub ptr64: __u64,
    pub ptr: __u64,
}
impl rseq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_class {
    pub uclamp_enabled: ::aya_bpf_cty::c_int,
    pub enqueue_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
    >,
    pub dequeue_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
    >,
    pub yield_task: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub yield_to_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> bool_,
    >,
    pub check_preempt_curr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
    >,
    pub pick_next_task:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq) -> *mut task_struct>,
    pub put_prev_task:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub set_next_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: bool_),
    >,
    pub balance: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rq,
            arg2: *mut task_struct,
            arg3: *mut rq_flags,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub select_task_rq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut task_struct,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub migrate_task_rq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: ::aya_bpf_cty::c_int),
    >,
    pub task_woken:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub set_cpus_allowed: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *const cpumask, arg3: u32_),
    >,
    pub rq_online: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub rq_offline: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub find_lock_rq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut rq) -> *mut rq,
    >,
    pub task_tick: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
    >,
    pub task_fork: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub task_dead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub switched_from:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub switched_to:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub prio_changed: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
    >,
    pub get_rr_interval: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> ::aya_bpf_cty::c_uint,
    >,
    pub update_curr: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub task_change_group: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: ::aya_bpf_cty::c_int),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: ::aya_bpf_cty::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: ::aya_bpf_cty::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: ::aya_bpf_cty::c_int,
    pub rcu: callback_head,
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [::aya_bpf_cty::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut ::aya_bpf_cty::c_void,
    pub data: [*mut ::aya_bpf_cty::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub watchers: *mut watch_list,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: ::aya_bpf_cty::c_ushort,
    pub datalen: ::aya_bpf_cty::c_ushort,
    pub state: ::aya_bpf_cty::c_short,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: ::aya_bpf_cty::c_ulong,
    pub len_desc: ::aya_bpf_cty::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub nr_tasks: atomic_t,
    pub lock: spinlock_t,
    pub ioprio: ::aya_bpf_cty::c_ushort,
    pub icq_tree: xarray,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const ::aya_bpf_cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: ::aya_bpf_cty::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [::aya_bpf_cty::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: ::aya_bpf_cty::c_ulong,
    pub d_fsdata: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: ::aya_bpf_cty::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: ::aya_bpf_cty::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut ::aya_bpf_cty::c_void,
    pub i_ino: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: ::aya_bpf_cty::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: ::aya_bpf_cty::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: ::aya_bpf_cty::c_ulong,
    pub dirtied_time_when: ::aya_bpf_cty::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: ::aya_bpf_cty::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_info,
    pub i_verity_info: *mut fsverity_info,
    pub i_private: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: ::aya_bpf_cty::c_uint,
    pub __i_nlink: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut ::aya_bpf_cty::c_char,
    pub i_dir_seq: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ::aya_bpf_cty::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: *const qstr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ::aya_bpf_cty::c_int>,
    pub d_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf_cty::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: ::aya_bpf_cty::c_int,
        ) -> *mut ::aya_bpf_cty::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl dentry_operations {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtd_info {
    _unused: [u8; 0],
}
pub type qsize_t = ::aya_bpf_cty::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: ::aya_bpf_cty::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: ::aya_bpf_cty::c_ulong,
    pub dqi_bgrace: ::aya_bpf_cty::c_uint,
    pub dqi_igrace: ::aya_bpf_cty::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: ::aya_bpf_cty::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: ::aya_bpf_cty::c_int,
    pub gp_count: ::aya_bpf_cty::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut ::aya_bpf_cty::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: ::aya_bpf_cty::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: ::aya_bpf_cty::c_int,
    pub memcg_aware: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: ::aya_bpf_cty::c_uchar,
    pub s_blocksize: ::aya_bpf_cty::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: ::aya_bpf_cty::c_ulong,
    pub s_iflags: ::aya_bpf_cty::c_ulong,
    pub s_magic: ::aya_bpf_cty::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: ::aya_bpf_cty::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut ::aya_bpf_cty::c_void,
    pub s_xattr: *mut *const xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_master_keys: *mut key,
    pub s_vop: *const fsverity_operations,
    pub s_encoding: *mut unicode_map,
    pub s_encoding_flags: __u16,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: ::aya_bpf_cty::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut ::aya_bpf_cty::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [::aya_bpf_cty::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: ::aya_bpf_cty::c_uint,
    pub s_mode: fmode_t,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const ::aya_bpf_cty::c_char,
    pub s_d_op: *const dentry_operations,
    pub cleancache_poolid: ::aya_bpf_cty::c_int,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_inode_refs: atomic_long_t,
    pub s_readonly_remount: ::aya_bpf_cty::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl super_block {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: ::aya_bpf_cty::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: ::aya_bpf_cty::c_long,
}
#[repr(C)]
#[derive(Debug)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub lru: __IncompleteArrayField<*mut list_lru_one>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub memcg_lrus: *mut list_lru_memcg,
    pub nr_items: ::aya_bpf_cty::c_long,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl list_lru_node {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub mod migrate_mode {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MIGRATE_ASYNC: Type = 0;
    pub const MIGRATE_SYNC_LIGHT: Type = 1;
    pub const MIGRATE_SYNC: Type = 2;
    pub const MIGRATE_SYNC_NO_COPY: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
pub type request_key_actor_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut key, arg2: *mut ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    pub name: *const ::aya_bpf_cty::c_char,
    pub def_datalen: size_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub vet_description: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_char) -> ::aya_bpf_cty::c_int,
    >,
    pub preparse: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut key_preparsed_payload) -> ::aya_bpf_cty::c_int,
    >,
    pub free_preparse:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut key_preparsed_payload)>,
    pub instantiate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut key,
            arg2: *mut key_preparsed_payload,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut key,
            arg2: *mut key_preparsed_payload,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub match_preparse: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut key_match_data) -> ::aya_bpf_cty::c_int,
    >,
    pub match_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key_match_data)>,
    pub revoke: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>,
    pub describe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const key, arg2: *mut seq_file)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const key,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub request_key: request_key_actor_t,
    pub lookup_restriction: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_char) -> *mut key_restriction,
    >,
    pub asym_query: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kernel_pkey_params,
            arg2: *mut kernel_pkey_query,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub asym_eds_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernel_pkey_params,
            arg2: *const ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub asym_verify_signature: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernel_pkey_params,
            arg2: *const ::aya_bpf_cty::c_void,
            arg3: *const ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub link: list_head,
    pub lock_class: lock_class_key,
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut key,
        arg2: *const key_type,
        arg3: *const key_payload,
        arg4: *mut key,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: ::aya_bpf_cty::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub arg: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kiocb,
            arg2: ::aya_bpf_cty::c_long,
            arg3: ::aya_bpf_cty::c_long,
        ),
    >,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub ki_flags: ::aya_bpf_cty::c_int,
    pub ki_hint: u16_,
    pub ki_ioprio: u16_,
    pub __bindgen_anon_1: kiocb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kiocb__bindgen_ty_1 {
    pub ki_cookie: ::aya_bpf_cty::c_uint,
    pub ki_waitq: *mut wait_page_queue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iattr {
    pub ia_valid: ::aya_bpf_cty::c_uint,
    pub ia_mode: umode_t,
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
pub mod quota_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const USRQUOTA: Type = 0;
    pub const GRPQUOTA: Type = 1;
    pub const PRJQUOTA: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: ::aya_bpf_cty::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: ::aya_bpf_cty::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ::aya_bpf_cty::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ::aya_bpf_cty::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ::aya_bpf_cty::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: ::aya_bpf_cty::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: ::aya_bpf_cty::c_int,
    pub d_spc_warns: ::aya_bpf_cty::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_type_state {
    pub flags: ::aya_bpf_cty::c_uint,
    pub spc_timelimit: ::aya_bpf_cty::c_uint,
    pub ino_timelimit: ::aya_bpf_cty::c_uint,
    pub rt_spc_timelimit: ::aya_bpf_cty::c_uint,
    pub spc_warnlimit: ::aya_bpf_cty::c_uint,
    pub ino_warnlimit: ::aya_bpf_cty::c_uint,
    pub rt_spc_warnlimit: ::aya_bpf_cty::c_uint,
    pub ino: ::aya_bpf_cty::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: ::aya_bpf_cty::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: ::aya_bpf_cty::c_int,
    pub i_flags: ::aya_bpf_cty::c_uint,
    pub i_spc_timelimit: ::aya_bpf_cty::c_uint,
    pub i_ino_timelimit: ::aya_bpf_cty::c_uint,
    pub i_rt_spc_timelimit: ::aya_bpf_cty::c_uint,
    pub i_spc_warnlimit: ::aya_bpf_cty::c_uint,
    pub i_ino_warnlimit: ::aya_bpf_cty::c_uint,
    pub i_rt_spc_warnlimit: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *const path,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut qc_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ::aya_bpf_cty::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut writeback_control) -> ::aya_bpf_cty::c_int,
    >,
    pub readpage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut page) -> ::aya_bpf_cty::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_page_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> ::aya_bpf_cty::c_int>,
    pub readpages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut address_space,
            arg3: *mut list_head,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut address_space,
            arg3: loff_t,
            arg4: ::aya_bpf_cty::c_uint,
            arg5: ::aya_bpf_cty::c_uint,
            arg6: *mut *mut page,
            arg7: *mut *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut address_space,
            arg3: loff_t,
            arg4: ::aya_bpf_cty::c_uint,
            arg5: ::aya_bpf_cty::c_uint,
            arg6: *mut page,
            arg7: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidatepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
        ),
    >,
    pub releasepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: gfp_t) -> ::aya_bpf_cty::c_int,
    >,
    pub freepage: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub migratepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut page,
            arg3: *mut page,
            arg4: migrate_mode::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub isolate_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: isolate_mode_t) -> bool_,
    >,
    pub putback_page: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub launder_page:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> ::aya_bpf_cty::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut bool_, arg3: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> ::aya_bpf_cty::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut swap_info_struct,
            arg2: *mut file,
            arg3: *mut sector_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const ::aya_bpf_cty::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf_cty::c_int) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *const ::aya_bpf_cty::c_char,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: dev_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *mut dentry,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut iattr) -> ::aya_bpf_cty::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const path,
            arg2: *mut kstat,
            arg3: u32_,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
        ) -> ssize_t,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            arg3: u64_,
            arg4: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            arg4: ::aya_bpf_cty::c_uint,
            arg5: umode_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut posix_acl,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl inode_operations {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32_,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_blocker: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_blocked_requests: list_head,
    pub fl_blocked_member: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: ::aya_bpf_cty::c_uint,
    pub fl_type: ::aya_bpf_cty::c_uchar,
    pub fl_pid: ::aya_bpf_cty::c_uint,
    pub fl_link_cpu: ::aya_bpf_cty::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: ::aya_bpf_cty::c_ulong,
    pub fl_downgrade_time: ::aya_bpf_cty::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: ::aya_bpf_cty::c_int,
    pub debug_id: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut list_head,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut ::aya_bpf_cty::c_void),
    >,
    pub lm_breaker_owns_lease:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: ::aya_bpf_cty::c_int,
    pub fa_fd: ::aya_bpf_cty::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf_cty::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut writeback_control,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf_cty::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
    >,
    pub freeze_fs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
    >,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
    >,
    pub unfreeze_fs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
    >,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ::aya_bpf_cty::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_char,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_char,
            arg4: size_t,
            arg5: loff_t,
        ) -> ssize_t,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: size_t,
            arg5: loff_t,
        ) -> ssize_t,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub bdev_try_to_free_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut page,
            arg3: gfp_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub real_loop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> *mut file>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iomap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    pub encode_fh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut __u32,
            arg3: *mut ::aya_bpf_cty::c_int,
            arg4: *mut inode,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fh_to_dentry: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut fid,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
        ) -> *mut dentry,
    >,
    pub fh_to_parent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut fid,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
        ) -> *mut dentry,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: *mut dentry,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_parent: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> *mut dentry>,
    pub commit_metadata:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf_cty::c_int>,
    pub get_uuid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut u8_,
            arg3: *mut u32_,
            arg4: *mut u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_blocks: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: loff_t,
            arg3: u64_,
            arg4: *mut iomap,
            arg5: bool_,
            arg6: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub commit_blocks: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut iomap,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *mut iattr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flags: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xattr_handler {
    pub name: *const ::aya_bpf_cty::c_char,
    pub prefix: *const ::aya_bpf_cty::c_char,
    pub flags: ::aya_bpf_cty::c_int,
    pub list: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> bool_>,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const xattr_handler,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *const ::aya_bpf_cty::c_char,
            arg5: *mut ::aya_bpf_cty::c_void,
            arg6: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const xattr_handler,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *const ::aya_bpf_cty::c_char,
            arg5: *const ::aya_bpf_cty::c_void,
            arg6: size_t,
            arg7: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    pub flags: ::aya_bpf_cty::c_uint,
    pub key_prefix: *const ::aya_bpf_cty::c_char,
    pub get_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const ::aya_bpf_cty::c_void,
            arg3: size_t,
            arg4: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_dummy_policy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> *const fscrypt_policy,
    >,
    pub empty_dir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> bool_>,
    pub max_namelen: ::aya_bpf_cty::c_uint,
    pub has_stable_inodes:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> bool_>,
    pub get_ino_and_lblk_bits: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_int,
        ),
    >,
    pub get_num_devices: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
    >,
    pub get_devices: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut *mut request_queue),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_operations {
    pub begin_enable_verity:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf_cty::c_int>,
    pub end_enable_verity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf_cty::c_void,
            arg3: size_t,
            arg4: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_verity_descriptor: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub read_merkle_tree_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> *mut page,
    >,
    pub write_merkle_tree_block: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const ::aya_bpf_cty::c_void,
            arg3: u64_,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const ::aya_bpf_cty::c_char,
        arg3: ::aya_bpf_cty::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: ::aya_bpf_cty::c_uint,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
pub type fs_param_type = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_parameter_spec {
    pub name: *const ::aya_bpf_cty::c_char,
    pub type_: fs_param_type,
    pub opt: u8_,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub data: *const ::aya_bpf_cty::c_void,
}
pub type __s8 = ::aya_bpf_cty::c_schar;
pub type s8 = __s8;
pub type __le32 = __u32;
pub type irq_hw_number_t = ::aya_bpf_cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: ::aya_bpf_cty::c_int,
    pub name_offset: ::aya_bpf_cty::c_int,
    pub namespace_offset: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ::aya_bpf_cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: ::aya_bpf_cty::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ::aya_bpf_cty::c_int,
    pub file_disp: ::aya_bpf_cty::c_int,
    pub line: ::aya_bpf_cty::c_ushort,
    pub flags: ::aya_bpf_cty::c_ushort,
}
pub type cpumask_var_t = *mut cpumask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ::aya_bpf_cty::c_void,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub prio: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ::aya_bpf_cty::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut ::aya_bpf_cty::c_void,
    pub iterator: *mut ::aya_bpf_cty::c_void,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: ::aya_bpf_cty::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
}
pub type tracepoint_ptr_t = ::aya_bpf_cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut ::aya_bpf_cty::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl bpf_raw_event_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub mod perf_event_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PERF_EVENT_STATE_DEAD: Type = 4294967292;
    pub const PERF_EVENT_STATE_EXIT: Type = 4294967293;
    pub const PERF_EVENT_STATE_ERROR: Type = 4294967294;
    pub const PERF_EVENT_STATE_OFF: Type = 4294967295;
    pub const PERF_EVENT_STATE_INACTIVE: Type = 0;
    pub const PERF_EVENT_STATE_ACTIVE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local64_t {
    pub a: local_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    pub type_: __u32,
    pub size: __u32,
    pub config: __u64,
    pub __bindgen_anon_1: perf_event_attr__bindgen_ty_1,
    pub sample_type: __u64,
    pub read_format: __u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub __bindgen_anon_2: perf_event_attr__bindgen_ty_2,
    pub bp_type: __u32,
    pub __bindgen_anon_3: perf_event_attr__bindgen_ty_3,
    pub __bindgen_anon_4: perf_event_attr__bindgen_ty_4,
    pub branch_sample_type: __u64,
    pub sample_regs_user: __u64,
    pub sample_stack_user: __u32,
    pub clockid: __s32,
    pub sample_regs_intr: __u64,
    pub aux_watermark: __u32,
    pub sample_max_stack: __u16,
    pub __reserved_2: __u16,
    pub aux_sample_size: __u32,
    pub __reserved_3: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_1 {
    pub sample_period: __u64,
    pub sample_freq: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_2 {
    pub wakeup_events: __u32,
    pub wakeup_watermark: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_3 {
    pub bp_addr: __u64,
    pub kprobe_func: __u64,
    pub uprobe_path: __u64,
    pub config1: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_4 {
    pub bp_len: __u64,
    pub kprobe_addr: __u64,
    pub probe_offset: __u64,
    pub config2: __u64,
}
impl perf_event_attr {
    #[inline]
    pub fn disabled(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pinned(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_user(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_user(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_kernel(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_kernel(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_hv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_hv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_idle(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_idle(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn freq(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_freq(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_stat(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit_stat(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_on_exec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_on_exec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn task(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_task(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn watermark(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_watermark(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn precise_ip(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_precise_ip(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap_data(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap_data(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_id_all(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sample_id_all(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_host(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_host(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_guest(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_guest(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_kernel(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_kernel(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_user(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_user(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap2(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm_exec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm_exec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_clockid(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_use_clockid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn context_switch(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_context_switch(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_backward(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_write_backward(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn namespaces(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_namespaces(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ksymbol(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ksymbol(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bpf_event(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bpf_event(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aux_output(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aux_output(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cgroup(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cgroup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_poke(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_text_poke(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 30u8) as u64) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disabled: __u64,
        inherit: __u64,
        pinned: __u64,
        exclusive: __u64,
        exclude_user: __u64,
        exclude_kernel: __u64,
        exclude_hv: __u64,
        exclude_idle: __u64,
        mmap: __u64,
        comm: __u64,
        freq: __u64,
        inherit_stat: __u64,
        enable_on_exec: __u64,
        task: __u64,
        watermark: __u64,
        precise_ip: __u64,
        mmap_data: __u64,
        sample_id_all: __u64,
        exclude_host: __u64,
        exclude_guest: __u64,
        exclude_callchain_kernel: __u64,
        exclude_callchain_user: __u64,
        mmap2: __u64,
        comm_exec: __u64,
        use_clockid: __u64,
        context_switch: __u64,
        write_backward: __u64,
        namespaces: __u64,
        ksymbol: __u64,
        bpf_event: __u64,
        aux_output: __u64,
        cgroup: __u64,
        text_poke: __u64,
        __reserved_1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disabled: u64 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inherit: u64 = unsafe { ::core::mem::transmute(inherit) };
            inherit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pinned: u64 = unsafe { ::core::mem::transmute(pinned) };
            pinned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exclusive: u64 = unsafe { ::core::mem::transmute(exclusive) };
            exclusive as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exclude_user: u64 = unsafe { ::core::mem::transmute(exclude_user) };
            exclude_user as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let exclude_kernel: u64 = unsafe { ::core::mem::transmute(exclude_kernel) };
            exclude_kernel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let exclude_hv: u64 = unsafe { ::core::mem::transmute(exclude_hv) };
            exclude_hv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exclude_idle: u64 = unsafe { ::core::mem::transmute(exclude_idle) };
            exclude_idle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmap: u64 = unsafe { ::core::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let comm: u64 = unsafe { ::core::mem::transmute(comm) };
            comm as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let freq: u64 = unsafe { ::core::mem::transmute(freq) };
            freq as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inherit_stat: u64 = unsafe { ::core::mem::transmute(inherit_stat) };
            inherit_stat as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_on_exec: u64 = unsafe { ::core::mem::transmute(enable_on_exec) };
            enable_on_exec as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let task: u64 = unsafe { ::core::mem::transmute(task) };
            task as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let watermark: u64 = unsafe { ::core::mem::transmute(watermark) };
            watermark as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let precise_ip: u64 = unsafe { ::core::mem::transmute(precise_ip) };
            precise_ip as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mmap_data: u64 = unsafe { ::core::mem::transmute(mmap_data) };
            mmap_data as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sample_id_all: u64 = unsafe { ::core::mem::transmute(sample_id_all) };
            sample_id_all as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let exclude_host: u64 = unsafe { ::core::mem::transmute(exclude_host) };
            exclude_host as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let exclude_guest: u64 = unsafe { ::core::mem::transmute(exclude_guest) };
            exclude_guest as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let exclude_callchain_kernel: u64 =
                unsafe { ::core::mem::transmute(exclude_callchain_kernel) };
            exclude_callchain_kernel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let exclude_callchain_user: u64 =
                unsafe { ::core::mem::transmute(exclude_callchain_user) };
            exclude_callchain_user as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mmap2: u64 = unsafe { ::core::mem::transmute(mmap2) };
            mmap2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let comm_exec: u64 = unsafe { ::core::mem::transmute(comm_exec) };
            comm_exec as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_clockid: u64 = unsafe { ::core::mem::transmute(use_clockid) };
            use_clockid as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let context_switch: u64 = unsafe { ::core::mem::transmute(context_switch) };
            context_switch as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let write_backward: u64 = unsafe { ::core::mem::transmute(write_backward) };
            write_backward as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let namespaces: u64 = unsafe { ::core::mem::transmute(namespaces) };
            namespaces as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ksymbol: u64 = unsafe { ::core::mem::transmute(ksymbol) };
            ksymbol as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bpf_event: u64 = unsafe { ::core::mem::transmute(bpf_event) };
            bpf_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let aux_output: u64 = unsafe { ::core::mem::transmute(aux_output) };
            aux_output as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let cgroup: u64 = unsafe { ::core::mem::transmute(cgroup) };
            cgroup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let text_poke: u64 = unsafe { ::core::mem::transmute(text_poke) };
            text_poke as u64
        });
        __bindgen_bitfield_unit.set(34usize, 30u8, {
            let __reserved_1: u64 = unsafe { ::core::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event_extra {
    pub config: u64_,
    pub reg: ::aya_bpf_cty::c_uint,
    pub alloc: ::aya_bpf_cty::c_int,
    pub idx: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_hw_breakpoint {
    pub address: ::aya_bpf_cty::c_ulong,
    pub mask: ::aya_bpf_cty::c_ulong,
    pub len: u8_,
    pub type_: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hw_perf_event {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_1,
    pub target: *mut task_struct,
    pub addr_filters: *mut ::aya_bpf_cty::c_void,
    pub addr_filters_gen: ::aya_bpf_cty::c_ulong,
    pub state: ::aya_bpf_cty::c_int,
    pub prev_count: local64_t,
    pub sample_period: u64_,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_2,
    pub interrupts_seq: u64_,
    pub interrupts: u64_,
    pub freq_time_stamp: u64_,
    pub freq_count_stamp: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hw_perf_event__bindgen_ty_1 {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: hw_perf_event__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: hw_perf_event__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: hw_perf_event__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: hw_perf_event__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_1 {
    pub config: u64_,
    pub last_tag: u64_,
    pub config_base: ::aya_bpf_cty::c_ulong,
    pub event_base: ::aya_bpf_cty::c_ulong,
    pub event_base_rdpmc: ::aya_bpf_cty::c_int,
    pub idx: ::aya_bpf_cty::c_int,
    pub last_cpu: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub extra_reg: hw_perf_event_extra,
    pub branch_reg: hw_perf_event_extra,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_2 {
    pub hrtimer: hrtimer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_3 {
    pub tp_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_4 {
    pub pwr_acc: u64_,
    pub ptsc: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_5 {
    pub info: arch_hw_breakpoint,
    pub bp_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_6 {
    pub iommu_bank: u8_,
    pub iommu_cntr: u8_,
    pub padding: u16_,
    pub conf: u64_,
    pub conf1: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hw_perf_event__bindgen_ty_2 {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_2__bindgen_ty_1 {
    pub last_period: u64_,
    pub period_left: local64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_2__bindgen_ty_2 {
    pub saved_metric: u64_,
    pub saved_slots: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_work {
    pub node: __call_single_node,
    pub func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_work)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_addr_filters_head {
    pub list: list_head,
    pub lock: raw_spinlock_t,
    pub nr_file_filters: ::aya_bpf_cty::c_uint,
}
pub type perf_overflow_handler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut perf_sample_data, arg3: *mut pt_regs),
>;
pub type ftrace_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::aya_bpf_cty::c_ulong,
        arg2: ::aya_bpf_cty::c_ulong,
        arg3: *mut ftrace_ops,
        arg4: *mut ftrace_regs,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops_hash {
    pub notrace_hash: *mut ftrace_hash,
    pub filter_hash: *mut ftrace_hash,
    pub regex_lock: mutex,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops {
    pub func: ftrace_func_t,
    pub next: *mut ftrace_ops,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub saved_func: ftrace_func_t,
    pub local_hash: ftrace_ops_hash,
    pub func_hash: *mut ftrace_ops_hash,
    pub old_hash: ftrace_ops_hash,
    pub trampoline: ::aya_bpf_cty::c_ulong,
    pub trampoline_size: ::aya_bpf_cty::c_ulong,
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    pub event_entry: list_head,
    pub sibling_list: list_head,
    pub active_list: list_head,
    pub group_node: rb_node,
    pub group_index: u64_,
    pub migrate_entry: list_head,
    pub hlist_entry: hlist_node,
    pub active_entry: list_head,
    pub nr_siblings: ::aya_bpf_cty::c_int,
    pub event_caps: ::aya_bpf_cty::c_int,
    pub group_caps: ::aya_bpf_cty::c_int,
    pub group_leader: *mut perf_event,
    pub pmu: *mut pmu,
    pub pmu_private: *mut ::aya_bpf_cty::c_void,
    pub state: perf_event_state::Type,
    pub attach_state: ::aya_bpf_cty::c_uint,
    pub count: local64_t,
    pub child_count: atomic64_t,
    pub total_time_enabled: u64_,
    pub total_time_running: u64_,
    pub tstamp: u64_,
    pub shadow_ctx_time: u64_,
    pub attr: perf_event_attr,
    pub header_size: u16_,
    pub id_header_size: u16_,
    pub read_size: u16_,
    pub hw: hw_perf_event,
    pub ctx: *mut perf_event_context,
    pub refcount: atomic_long_t,
    pub child_total_time_enabled: atomic64_t,
    pub child_total_time_running: atomic64_t,
    pub child_mutex: mutex,
    pub child_list: list_head,
    pub parent: *mut perf_event,
    pub oncpu: ::aya_bpf_cty::c_int,
    pub cpu: ::aya_bpf_cty::c_int,
    pub owner_entry: list_head,
    pub owner: *mut task_struct,
    pub mmap_mutex: mutex,
    pub mmap_count: atomic_t,
    pub rb: *mut perf_buffer,
    pub rb_entry: list_head,
    pub rcu_batches: ::aya_bpf_cty::c_ulong,
    pub rcu_pending: ::aya_bpf_cty::c_int,
    pub waitq: wait_queue_head_t,
    pub fasync: *mut fasync_struct,
    pub pending_wakeup: ::aya_bpf_cty::c_int,
    pub pending_kill: ::aya_bpf_cty::c_int,
    pub pending_disable: ::aya_bpf_cty::c_int,
    pub pending: irq_work,
    pub event_limit: atomic_t,
    pub addr_filters: perf_addr_filters_head,
    pub addr_filter_ranges: *mut perf_addr_filter_range,
    pub addr_filters_gen: ::aya_bpf_cty::c_ulong,
    pub aux_event: *mut perf_event,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub callback_head: callback_head,
    pub ns: *mut pid_namespace,
    pub id: u64_,
    pub clock: ::core::option::Option<unsafe extern "C" fn() -> u64_>,
    pub overflow_handler: perf_overflow_handler_t,
    pub overflow_handler_context: *mut ::aya_bpf_cty::c_void,
    pub orig_overflow_handler: perf_overflow_handler_t,
    pub prog: *mut bpf_prog,
    pub tp_event: *mut trace_event_call,
    pub filter: *mut event_filter,
    pub ftrace_ops: ftrace_ops,
    pub cgrp: *mut perf_cgroup,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub sb_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub nr_extents: u32_,
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ns_common {
    pub stashed: atomic_long_t,
    pub ops: *const proc_ns_operations,
    pub inum: ::aya_bpf_cty::c_uint,
    pub count: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: ::aya_bpf_cty::c_int,
    pub count: ::aya_bpf_cty::c_int,
    pub nreg: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::aya_bpf_cty::c_int,
    >,
    pub dir: ctl_dir,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub parent: *mut user_namespace,
    pub level: ::aya_bpf_cty::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub parent_could_setfcap: bool_,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub persistent_keyring_register: *mut key,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [::aya_bpf_cty::c_int; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::aya_bpf_cty::c_int,
    pub events: ::aya_bpf_cty::c_short,
    pub revents: ::aya_bpf_cty::c_short,
}
pub type smp_call_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ::aya_bpf_cty::c_void,
}
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wait_queue_entry,
        arg2: ::aya_bpf_cty::c_uint,
        arg3: ::aya_bpf_cty::c_int,
        arg4: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: ::aya_bpf_cty::c_uint,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
pub type wait_queue_entry_t = wait_queue_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ::aya_bpf_cty::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [::aya_bpf_cty::c_ulong; 4usize],
    pub len: ::aya_bpf_cty::c_long,
    pub enabled: u8_,
    pub offloaded: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [::aya_bpf_cty::c_ulong; 2usize],
    pub srcu_unlock_count: [::aya_bpf_cty::c_ulong; 2usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ::aya_bpf_cty::c_ulong,
    pub srcu_gp_seq_needed_exp: ::aya_bpf_cty::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ::aya_bpf_cty::c_ulong,
    pub cpu: ::aya_bpf_cty::c_int,
    pub ssp: *mut srcu_struct,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl srcu_data {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [::aya_bpf_cty::c_ulong; 4usize],
    pub srcu_data_have_cbs: [::aya_bpf_cty::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ::aya_bpf_cty::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ::aya_bpf_cty::c_int,
    pub grphi: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: [srcu_node; 521usize],
    pub level: [*mut srcu_node; 4usize],
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: ::aya_bpf_cty::c_uint,
    pub srcu_gp_seq: ::aya_bpf_cty::c_ulong,
    pub srcu_gp_seq_needed: ::aya_bpf_cty::c_ulong,
    pub srcu_gp_seq_needed_exp: ::aya_bpf_cty::c_ulong,
    pub srcu_last_gp_end: ::aya_bpf_cty::c_ulong,
    pub sda: *mut srcu_data,
    pub srcu_barrier_seq: ::aya_bpf_cty::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub work: delayed_work,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    pub root: *mut anon_vma,
    pub rwsem: rw_semaphore,
    pub refcount: atomic_t,
    pub degree: ::aya_bpf_cty::c_uint,
    pub parent: *mut anon_vma,
    pub rb_root: rb_root_cached,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    pub refcnt: atomic_t,
    pub mode: ::aya_bpf_cty::c_ushort,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub v: mempolicy__bindgen_ty_1,
    pub w: mempolicy__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mempolicy__bindgen_ty_1 {
    pub preferred_node: ::aya_bpf_cty::c_short,
    pub nodes: nodemask_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mempolicy__bindgen_ty_2 {
    pub cpuset_mems_allowed: nodemask_t,
    pub user_nodemask: nodemask_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_binfmt {
    pub lh: list_head,
    pub module: *mut module,
    pub load_binary: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut linux_binprm) -> ::aya_bpf_cty::c_int,
    >,
    pub load_shlib:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf_cty::c_int>,
    pub core_dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut coredump_params) -> ::aya_bpf_cty::c_int,
    >,
    pub min_coredump: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 5usize],
    pub nr_free: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct zone_padding {
    pub x: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: ::aya_bpf_cty::c_ulong,
    pub file_cost: ::aya_bpf_cty::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [::aya_bpf_cty::c_ulong; 2usize],
    pub flags: ::aya_bpf_cty::c_ulong,
    pub pgdat: *mut pglist_data,
}
#[repr(C)]
pub struct zone {
    pub _watermark: [::aya_bpf_cty::c_ulong; 3usize],
    pub watermark_boost: ::aya_bpf_cty::c_ulong,
    pub nr_reserved_highatomic: ::aya_bpf_cty::c_ulong,
    pub lowmem_reserve: [::aya_bpf_cty::c_long; 5usize],
    pub node: ::aya_bpf_cty::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub pageset: *mut per_cpu_pageset,
    pub pageset_high: ::aya_bpf_cty::c_int,
    pub pageset_batch: ::aya_bpf_cty::c_int,
    pub zone_start_pfn: ::aya_bpf_cty::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: ::aya_bpf_cty::c_ulong,
    pub present_pages: ::aya_bpf_cty::c_ulong,
    pub name: *const ::aya_bpf_cty::c_char,
    pub nr_isolate_pageblock: ::aya_bpf_cty::c_ulong,
    pub span_seqlock: seqlock_t,
    pub initialized: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub _pad1_: zone_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ::aya_bpf_cty::c_ulong,
    pub lock: spinlock_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub _pad2_: zone_padding,
    pub percpu_drift_mark: ::aya_bpf_cty::c_ulong,
    pub compact_cached_free_pfn: ::aya_bpf_cty::c_ulong,
    pub compact_cached_migrate_pfn: [::aya_bpf_cty::c_ulong; 2usize],
    pub compact_init_migrate_pfn: ::aya_bpf_cty::c_ulong,
    pub compact_init_free_pfn: ::aya_bpf_cty::c_ulong,
    pub compact_considered: ::aya_bpf_cty::c_uint,
    pub compact_defer_shift: ::aya_bpf_cty::c_uint,
    pub compact_order_failed: ::aya_bpf_cty::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub _pad3_: zone_padding,
    pub vm_stat: [atomic_long_t; 11usize],
    pub vm_numa_stat: [atomic_long_t; 6usize],
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 56usize]>,
}
impl zone {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 5121usize],
}
pub mod zone_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ZONE_DMA: Type = 0;
    pub const ZONE_DMA32: Type = 1;
    pub const ZONE_NORMAL: Type = 2;
    pub const ZONE_MOVABLE: Type = 3;
    pub const ZONE_DEVICE: Type = 4;
    pub const __MAX_NR_ZONES: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct deferred_split {
    pub split_queue_lock: spinlock_t,
    pub split_queue: list_head,
    pub split_queue_len: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
pub struct pglist_data {
    pub node_zones: [zone; 5usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: ::aya_bpf_cty::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: ::aya_bpf_cty::c_ulong,
    pub node_present_pages: ::aya_bpf_cty::c_ulong,
    pub node_spanned_pages: ::aya_bpf_cty::c_ulong,
    pub node_id: ::aya_bpf_cty::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub kswapd: *mut task_struct,
    pub kswapd_order: ::aya_bpf_cty::c_int,
    pub kswapd_highest_zoneidx: zone_type::Type,
    pub kswapd_failures: ::aya_bpf_cty::c_int,
    pub kcompactd_max_order: ::aya_bpf_cty::c_int,
    pub kcompactd_highest_zoneidx: zone_type::Type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub totalreserve_pages: ::aya_bpf_cty::c_ulong,
    pub min_unmapped_pages: ::aya_bpf_cty::c_ulong,
    pub min_slab_pages: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub _pad1_: zone_padding,
    pub deferred_split_queue: deferred_split,
    pub __lruvec: lruvec,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub _pad2_: zone_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 38usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl pglist_data {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_pages {
    pub count: ::aya_bpf_cty::c_int,
    pub high: ::aya_bpf_cty::c_int,
    pub batch: ::aya_bpf_cty::c_int,
    pub lists: [list_head; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_pageset {
    pub pcp: per_cpu_pages,
    pub expire: s8,
    pub vm_numa_stat_diff: [u16_; 6usize],
    pub stat_threshold: s8,
    pub vm_stat_diff: [s8; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 38usize],
}
pub mod irq_domain_bus_token {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DOMAIN_BUS_ANY: Type = 0;
    pub const DOMAIN_BUS_WIRED: Type = 1;
    pub const DOMAIN_BUS_GENERIC_MSI: Type = 2;
    pub const DOMAIN_BUS_PCI_MSI: Type = 3;
    pub const DOMAIN_BUS_PLATFORM_MSI: Type = 4;
    pub const DOMAIN_BUS_NEXUS: Type = 5;
    pub const DOMAIN_BUS_IPI: Type = 6;
    pub const DOMAIN_BUS_FSL_MC_MSI: Type = 7;
    pub const DOMAIN_BUS_TI_SCI_INTA_MSI: Type = 8;
    pub const DOMAIN_BUS_WAKEUP: Type = 9;
    pub const DOMAIN_BUS_VMD_MSI: Type = 10;
}
#[repr(C)]
pub struct irq_domain {
    pub link: list_head,
    pub name: *const ::aya_bpf_cty::c_char,
    pub ops: *const irq_domain_ops,
    pub host_data: *mut ::aya_bpf_cty::c_void,
    pub flags: ::aya_bpf_cty::c_uint,
    pub mapcount: ::aya_bpf_cty::c_uint,
    pub fwnode: *mut fwnode_handle,
    pub bus_token: irq_domain_bus_token::Type,
    pub gc: *mut irq_domain_chip_generic,
    pub parent: *mut irq_domain,
    pub hwirq_max: irq_hw_number_t,
    pub revmap_direct_max_irq: ::aya_bpf_cty::c_uint,
    pub revmap_size: ::aya_bpf_cty::c_uint,
    pub revmap_tree: xarray,
    pub revmap_tree_mutex: mutex,
    pub linear_revmap: __IncompleteArrayField<::aya_bpf_cty::c_uint>,
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ctl_table,
        arg2: ::aya_bpf_cty::c_int,
        arg3: *mut ::aya_bpf_cty::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const ::aya_bpf_cty::c_char,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub maxlen: ::aya_bpf_cty::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ::aya_bpf_cty::c_void,
    pub extra2: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ctl_table_header,
            arg2: *mut ctl_table,
            arg3: *mut kuid_t,
            arg4: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ctl_table_header,
            arg2: *mut ctl_table,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Off = __u64;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: ::aya_bpf_cty::c_uchar,
    pub st_other: ::aya_bpf_cty::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [::aya_bpf_cty::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: ::aya_bpf_cty::c_uint,
    pub idr_next: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: ::aya_bpf_cty::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_root {
    pub kn: *mut kernfs_node,
    pub flags: ::aya_bpf_cty::c_uint,
    pub ino_idr: idr,
    pub last_id_lowbits: u32_,
    pub id_highbits: u32_,
    pub syscall_ops: *mut kernfs_syscall_ops,
    pub supers: list_head,
    pub deactivate_waitq: wait_queue_head_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const ::aya_bpf_cty::c_char,
    pub rb: rb_node,
    pub ns: *const ::aya_bpf_cty::c_void,
    pub hash: ::aya_bpf_cty::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub id: u64_,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_ops {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub seq_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: loff_t,
        ) -> ssize_t,
    >,
    pub atomic_write_len: size_t,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: loff_t,
        ) -> ssize_t,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut kernfs_root) -> ::aya_bpf_cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_node,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: umode_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_node) -> ::aya_bpf_cty::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_node,
            arg2: *mut kernfs_node,
            arg3: *const ::aya_bpf_cty::c_char,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut kernfs_node,
            arg3: *mut kernfs_root,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut ::aya_bpf_cty::c_char,
    pub size: size_t,
    pub from: size_t,
    pub count: size_t,
    pub pad_until: size_t,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: ::aya_bpf_cty::c_int,
    pub file: *const file,
    pub private: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: ::aya_bpf_cty::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut ::aya_bpf_cty::c_char,
    pub atomic_write_len: size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type poll_queue_proc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut wait_queue_head_t,
        arg3: *mut poll_table_struct,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    pub _qproc: poll_queue_proc,
    pub _key: __poll_t,
}
pub mod kobj_ns_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const KOBJ_NS_TYPE_NONE: Type = 0;
    pub const KOBJ_NS_TYPE_NET: Type = 1;
    pub const KOBJ_NS_TYPES: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type::Type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_bpf_cty::c_void>,
    pub netlink_ns: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock) -> *const ::aya_bpf_cty::c_void,
    >,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const ::aya_bpf_cty::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const ::aya_bpf_cty::c_char,
    pub mode: umode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_group {
    pub name: *const ::aya_bpf_cty::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: ::aya_bpf_cty::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: ::aya_bpf_cty::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const ::aya_bpf_cty::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *mut kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: ::aya_bpf_cty::c_uint,
        state_in_sysfs: ::aya_bpf_cty::c_uint,
        state_add_uevent_sent: ::aya_bpf_cty::c_uint,
        state_remove_uevent_sent: ::aya_bpf_cty::c_uint,
        uevent_suppress: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: size_t,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut ::aya_bpf_cty::c_char,
            arg5: loff_t,
            arg6: size_t,
        ) -> ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut ::aya_bpf_cty::c_char,
            arg5: loff_t,
            arg6: size_t,
        ) -> ssize_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut vm_area_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut ::aya_bpf_cty::c_char,
        ) -> ssize_t,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: size_t,
        ) -> ssize_t,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_attrs: *mut *mut attribute,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kobject) -> *const ::aya_bpf_cty::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kobject, arg2: *mut kuid_t, arg3: *mut kgid_t),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut ::aya_bpf_cty::c_char; 3usize],
    pub envp: [*mut ::aya_bpf_cty::c_char; 64usize],
    pub envp_idx: ::aya_bpf_cty::c_int,
    pub buf: [::aya_bpf_cty::c_char; 2048usize],
    pub buflen: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kset, arg2: *mut kobject) -> ::aya_bpf_cty::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kset, arg2: *mut kobject) -> *const ::aya_bpf_cty::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kset,
            arg2: *mut kobject,
            arg3: *mut kobj_uevent_env,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: ::aya_bpf_cty::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf_cty::c_char,
            arg2: *const kernel_param,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_char,
            arg2: *const kernel_param,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const ::aya_bpf_cty::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut ::aya_bpf_cty::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: ::aya_bpf_cty::c_uint,
    pub string: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: ::aya_bpf_cty::c_uint,
    pub elemsize: ::aya_bpf_cty::c_uint,
    pub num: *mut ::aya_bpf_cty::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut ::aya_bpf_cty::c_void,
}
pub mod module_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MODULE_STATE_LIVE: Type = 0;
    pub const MODULE_STATE_COMING: Type = 1;
    pub const MODULE_STATE_GOING: Type = 2;
    pub const MODULE_STATE_UNFORMED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_layout {
    pub base: *mut ::aya_bpf_cty::c_void,
    pub size: ::aya_bpf_cty::c_uint,
    pub text_size: ::aya_bpf_cty::c_uint,
    pub ro_size: ::aya_bpf_cty::c_uint,
    pub ro_after_init_size: ::aya_bpf_cty::c_uint,
    pub mtn: mod_tree_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_arch_specific {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: ::aya_bpf_cty::c_uint,
    pub strtab: *mut ::aya_bpf_cty::c_char,
    pub typetab: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state::Type,
    pub list: list_head,
    pub name: [::aya_bpf_cty::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const ::aya_bpf_cty::c_char,
    pub srcversion: *const ::aya_bpf_cty::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: ::aya_bpf_cty::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: ::aya_bpf_cty::c_uint,
    pub num_gpl_syms: ::aya_bpf_cty::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub using_gplonly_symbols: bool_,
    pub unused_syms: *const kernel_symbol,
    pub unused_crcs: *const s32,
    pub num_unused_syms: ::aya_bpf_cty::c_uint,
    pub num_unused_gpl_syms: ::aya_bpf_cty::c_uint,
    pub unused_gpl_syms: *const kernel_symbol,
    pub unused_gpl_crcs: *const s32,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub gpl_future_syms: *const kernel_symbol,
    pub gpl_future_crcs: *const s32,
    pub num_gpl_future_syms: ::aya_bpf_cty::c_uint,
    pub num_exentries: ::aya_bpf_cty::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_int>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: ::aya_bpf_cty::c_ulong,
    pub num_bugs: ::aya_bpf_cty::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut ::aya_bpf_cty::c_char,
    pub percpu: *mut ::aya_bpf_cty::c_void,
    pub percpu_size: ::aya_bpf_cty::c_uint,
    pub noinstr_text_start: *mut ::aya_bpf_cty::c_void,
    pub noinstr_text_size: ::aya_bpf_cty::c_uint,
    pub num_tracepoints: ::aya_bpf_cty::c_uint,
    pub tracepoints_ptrs: *mut tracepoint_ptr_t,
    pub num_srcu_structs: ::aya_bpf_cty::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: ::aya_bpf_cty::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub btf_data_size: ::aya_bpf_cty::c_uint,
    pub btf_data: *mut ::aya_bpf_cty::c_void,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: ::aya_bpf_cty::c_uint,
    pub num_trace_bprintk_fmt: ::aya_bpf_cty::c_uint,
    pub trace_bprintk_fmt_start: *mut *const ::aya_bpf_cty::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: ::aya_bpf_cty::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: ::aya_bpf_cty::c_uint,
    pub num_ftrace_callsites: ::aya_bpf_cty::c_uint,
    pub ftrace_callsites: *mut ::aya_bpf_cty::c_ulong,
    pub kprobes_text_start: *mut ::aya_bpf_cty::c_void,
    pub kprobes_text_size: ::aya_bpf_cty::c_uint,
    pub kprobe_blacklist: *mut ::aya_bpf_cty::c_ulong,
    pub num_kprobe_blacklist: ::aya_bpf_cty::c_uint,
    pub num_static_call_sites: ::aya_bpf_cty::c_int,
    pub static_call_sites: *mut static_call_site,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: ::aya_bpf_cty::c_ulong,
    pub etype: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut ::aya_bpf_cty::c_char,
        ) -> ssize_t,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: size_t,
        ) -> ssize_t,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const ::aya_bpf_cty::c_char),
    >,
    pub test:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ::aya_bpf_cty::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut ::aya_bpf_cty::c_char,
    pub symndx: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: ::aya_bpf_cty::c_int,
    pub fixup: ::aya_bpf_cty::c_int,
    pub handler: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event {
    pub node: hlist_node,
    pub list: list_head,
    pub type_: ::aya_bpf_cty::c_int,
    pub funcs: *mut trace_event_functions,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_event_call {
    pub list: list_head,
    pub class: *mut trace_event_class,
    pub __bindgen_anon_1: trace_event_call__bindgen_ty_1,
    pub event: trace_event,
    pub print_fmt: *mut ::aya_bpf_cty::c_char,
    pub filter: *mut event_filter,
    pub mod_: *mut ::aya_bpf_cty::c_void,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub flags: ::aya_bpf_cty::c_int,
    pub perf_refcount: ::aya_bpf_cty::c_int,
    pub perf_events: *mut hlist_head,
    pub prog_array: *mut bpf_prog_array,
    pub perf_perm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_event_call,
            arg2: *mut perf_event,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union trace_event_call__bindgen_ty_1 {
    pub name: *mut ::aya_bpf_cty::c_char,
    pub tp: *mut tracepoint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_eval_map {
    pub system: *const ::aya_bpf_cty::c_char,
    pub eval_string: *const ::aya_bpf_cty::c_char,
    pub eval_value: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub sibling: list_head,
    pub children: list_head,
    pub rstat_css_node: list_head,
    pub id: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_id {
    pub id: ::aya_bpf_cty::c_int,
    pub ref_: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_counter {
    pub usage: atomic_long_t,
    pub min: ::aya_bpf_cty::c_ulong,
    pub low: ::aya_bpf_cty::c_ulong,
    pub high: ::aya_bpf_cty::c_ulong,
    pub max: ::aya_bpf_cty::c_ulong,
    pub parent: *mut page_counter,
    pub emin: ::aya_bpf_cty::c_ulong,
    pub min_usage: atomic_long_t,
    pub children_min_usage: atomic_long_t,
    pub elow: ::aya_bpf_cty::c_ulong,
    pub low_usage: atomic_long_t,
    pub children_low_usage: atomic_long_t,
    pub watermark: ::aya_bpf_cty::c_ulong,
    pub failcnt: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmpressure {
    pub scanned: ::aya_bpf_cty::c_ulong,
    pub reclaimed: ::aya_bpf_cty::c_ulong,
    pub tree_scanned: ::aya_bpf_cty::c_ulong,
    pub tree_reclaimed: ::aya_bpf_cty::c_ulong,
    pub sr_lock: spinlock_t,
    pub events: list_head,
    pub events_lock: mutex,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: ::aya_bpf_cty::c_ulong,
    pub notify_timer: timer_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_thresholds {
    pub primary: *mut mem_cgroup_threshold_ary,
    pub spare: *mut mem_cgroup_threshold_ary,
}
#[repr(C)]
#[derive(Debug)]
pub struct memcg_padding {
    pub x: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
pub mod memcg_kmem_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const KMEM_NONE: Type = 0;
    pub const KMEM_ALLOCATED: Type = 1;
    pub const KMEM_ONLINE: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_global {
    pub events: percpu_counter,
    pub period: ::aya_bpf_cty::c_uint,
    pub sequence: seqcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_domain {
    pub lock: spinlock_t,
    pub completions: fprop_global,
    pub period_timer: timer_list,
    pub period_time: ::aya_bpf_cty::c_ulong,
    pub dirty_limit_tstamp: ::aya_bpf_cty::c_ulong,
    pub dirty_limit: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wb_completion {
    pub cnt: atomic_t,
    pub waitq: *mut wait_queue_head_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memcg_cgwb_frn {
    pub bdi_id: u64_,
    pub memcg_id: ::aya_bpf_cty::c_int,
    pub at: u64_,
    pub done: wb_completion,
}
#[repr(C)]
pub struct mem_cgroup {
    pub css: cgroup_subsys_state,
    pub id: mem_cgroup_id,
    pub memory: page_counter,
    pub __bindgen_anon_1: mem_cgroup__bindgen_ty_1,
    pub kmem: page_counter,
    pub tcpmem: page_counter,
    pub high_work: work_struct,
    pub soft_limit: ::aya_bpf_cty::c_ulong,
    pub vmpressure: vmpressure,
    pub oom_group: bool_,
    pub oom_lock: bool_,
    pub under_oom: ::aya_bpf_cty::c_int,
    pub swappiness: ::aya_bpf_cty::c_int,
    pub oom_kill_disable: ::aya_bpf_cty::c_int,
    pub events_file: cgroup_file,
    pub events_local_file: cgroup_file,
    pub swap_events_file: cgroup_file,
    pub thresholds_lock: mutex,
    pub thresholds: mem_cgroup_thresholds,
    pub memsw_thresholds: mem_cgroup_thresholds,
    pub oom_notify: list_head,
    pub move_charge_at_immigrate: ::aya_bpf_cty::c_ulong,
    pub move_lock: spinlock_t,
    pub move_lock_flags: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub _pad1_: memcg_padding,
    pub vmstats: [atomic_long_t; 41usize],
    pub vmevents: [atomic_long_t; 96usize],
    pub memory_events: [atomic_long_t; 8usize],
    pub memory_events_local: [atomic_long_t; 8usize],
    pub socket_pressure: ::aya_bpf_cty::c_ulong,
    pub tcpmem_active: bool_,
    pub tcpmem_pressure: ::aya_bpf_cty::c_int,
    pub kmemcg_id: ::aya_bpf_cty::c_int,
    pub kmem_state: memcg_kmem_state::Type,
    pub objcg: *mut obj_cgroup,
    pub objcg_list: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub _pad2_: memcg_padding,
    pub moving_account: atomic_t,
    pub move_lock_task: *mut task_struct,
    pub vmstats_local: *mut memcg_vmstats_percpu,
    pub vmstats_percpu: *mut memcg_vmstats_percpu,
    pub cgwb_list: list_head,
    pub cgwb_domain: wb_domain,
    pub cgwb_frn: [memcg_cgwb_frn; 4usize],
    pub event_list: list_head,
    pub event_list_lock: spinlock_t,
    pub deferred_split_queue: deferred_split,
    pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mem_cgroup__bindgen_ty_1 {
    pub swap: page_counter,
    pub memsw: page_counter,
}
impl mem_cgroup {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    pub idr: idr,
    pub rcu: callback_head,
    pub pid_allocated: ::aya_bpf_cty::c_uint,
    pub child_reaper: *mut task_struct,
    pub pid_cachep: *mut kmem_cache,
    pub level: ::aya_bpf_cty::c_uint,
    pub parent: *mut pid_namespace,
    pub bacct: *mut fs_pin,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub reboot: ::aya_bpf_cty::c_int,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: ::aya_bpf_cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    pub count: atomic_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    pub mq_list: list_head,
    pub cb_list: list_head,
    pub rq_count: ::aya_bpf_cty::c_ushort,
    pub multiple_queues: bool_,
    pub nowait: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    pub reclaimed_slab: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: ::aya_bpf_cty::c_uint,
    pub lock: raw_spinlock_t,
}
pub mod wb_reason {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const WB_REASON_BACKGROUND: Type = 0;
    pub const WB_REASON_VMSCAN: Type = 1;
    pub const WB_REASON_SYNC: Type = 2;
    pub const WB_REASON_PERIODIC: Type = 3;
    pub const WB_REASON_LAPTOP_TIMER: Type = 4;
    pub const WB_REASON_FS_FREE_SPACE: Type = 5;
    pub const WB_REASON_FORKER_THREAD: Type = 6;
    pub const WB_REASON_FOREIGN_FLUSH: Type = 7;
    pub const WB_REASON_MAX: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: ::aya_bpf_cty::c_ulong,
    pub last_old_flush: ::aya_bpf_cty::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub stat: [percpu_counter; 4usize],
    pub congested: ::aya_bpf_cty::c_ulong,
    pub bw_time_stamp: ::aya_bpf_cty::c_ulong,
    pub dirtied_stamp: ::aya_bpf_cty::c_ulong,
    pub written_stamp: ::aya_bpf_cty::c_ulong,
    pub write_bandwidth: ::aya_bpf_cty::c_ulong,
    pub avg_write_bandwidth: ::aya_bpf_cty::c_ulong,
    pub dirty_ratelimit: ::aya_bpf_cty::c_ulong,
    pub balanced_dirty_ratelimit: ::aya_bpf_cty::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: ::aya_bpf_cty::c_int,
    pub start_all_reason: wb_reason::Type,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub dirty_sleep: ::aya_bpf_cty::c_ulong,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: ::aya_bpf_cty::c_ulong,
    pub io_pages: ::aya_bpf_cty::c_ulong,
    pub refcnt: kref,
    pub capabilities: ::aya_bpf_cty::c_uint,
    pub min_ratio: ::aya_bpf_cty::c_uint,
    pub max_ratio: ::aya_bpf_cty::c_uint,
    pub max_prop_frac: ::aya_bpf_cty::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: xarray,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [::aya_bpf_cty::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 13usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: ::aya_bpf_cty::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 13usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
pub type compat_uptr_t = u32_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
pub type compat_long_t = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_groups {
    pub tree: rb_root,
    pub index: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_context {
    pub pmu: *mut pmu,
    pub lock: raw_spinlock_t,
    pub mutex: mutex,
    pub active_ctx_list: list_head,
    pub pinned_groups: perf_event_groups,
    pub flexible_groups: perf_event_groups,
    pub event_list: list_head,
    pub pinned_active: list_head,
    pub flexible_active: list_head,
    pub nr_events: ::aya_bpf_cty::c_int,
    pub nr_active: ::aya_bpf_cty::c_int,
    pub is_active: ::aya_bpf_cty::c_int,
    pub nr_stat: ::aya_bpf_cty::c_int,
    pub nr_freq: ::aya_bpf_cty::c_int,
    pub rotate_disable: ::aya_bpf_cty::c_int,
    pub rotate_necessary: ::aya_bpf_cty::c_int,
    pub refcount: refcount_t,
    pub task: *mut task_struct,
    pub time: u64_,
    pub timestamp: u64_,
    pub parent_ctx: *mut perf_event_context,
    pub parent_gen: u64_,
    pub generation: u64_,
    pub pin_count: ::aya_bpf_cty::c_int,
    pub nr_cgroups: ::aya_bpf_cty::c_int,
    pub task_ctx_data: *mut ::aya_bpf_cty::c_void,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_delay_info {
    pub lock: raw_spinlock_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub blkio_start: u64_,
    pub blkio_delay: u64_,
    pub swapin_delay: u64_,
    pub blkio_count: u32_,
    pub swapin_count: u32_,
    pub freepages_start: u64_,
    pub freepages_delay: u64_,
    pub thrashing_start: u64_,
    pub thrashing_delay: u64_,
    pub freepages_count: u32_,
    pub thrashing_count: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub ret: ::aya_bpf_cty::c_ulong,
    pub func: ::aya_bpf_cty::c_ulong,
    pub calltime: ::aya_bpf_cty::c_ulonglong,
    pub subtime: ::aya_bpf_cty::c_ulonglong,
    pub retp: *mut ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity {
    pub profile: *const blk_integrity_profile,
    pub flags: ::aya_bpf_cty::c_uchar,
    pub tuple_size: ::aya_bpf_cty::c_uchar,
    pub interval_exp: ::aya_bpf_cty::c_uchar,
    pub tag_size: ::aya_bpf_cty::c_uchar,
}
pub mod rpm_status {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RPM_ACTIVE: Type = 0;
    pub const RPM_RESUMING: Type = 1;
    pub const RPM_SUSPENDED: Type = 2;
    pub const RPM_SUSPENDING: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64_,
    pub min: u64_,
    pub max: u64_,
    pub nr_samples: u32_,
    pub batch: u64_,
}
pub mod blk_zoned_model {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BLK_ZONED_NONE: Type = 0;
    pub const BLK_ZONED_HA: Type = 1;
    pub const BLK_ZONED_HM: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queue_limits {
    pub bounce_pfn: ::aya_bpf_cty::c_ulong,
    pub seg_boundary_mask: ::aya_bpf_cty::c_ulong,
    pub virt_boundary_mask: ::aya_bpf_cty::c_ulong,
    pub max_hw_sectors: ::aya_bpf_cty::c_uint,
    pub max_dev_sectors: ::aya_bpf_cty::c_uint,
    pub chunk_sectors: ::aya_bpf_cty::c_uint,
    pub max_sectors: ::aya_bpf_cty::c_uint,
    pub max_segment_size: ::aya_bpf_cty::c_uint,
    pub physical_block_size: ::aya_bpf_cty::c_uint,
    pub logical_block_size: ::aya_bpf_cty::c_uint,
    pub alignment_offset: ::aya_bpf_cty::c_uint,
    pub io_min: ::aya_bpf_cty::c_uint,
    pub io_opt: ::aya_bpf_cty::c_uint,
    pub max_discard_sectors: ::aya_bpf_cty::c_uint,
    pub max_hw_discard_sectors: ::aya_bpf_cty::c_uint,
    pub max_write_same_sectors: ::aya_bpf_cty::c_uint,
    pub max_write_zeroes_sectors: ::aya_bpf_cty::c_uint,
    pub max_zone_append_sectors: ::aya_bpf_cty::c_uint,
    pub discard_granularity: ::aya_bpf_cty::c_uint,
    pub discard_alignment: ::aya_bpf_cty::c_uint,
    pub max_segments: ::aya_bpf_cty::c_ushort,
    pub max_integrity_segments: ::aya_bpf_cty::c_ushort,
    pub max_discard_segments: ::aya_bpf_cty::c_ushort,
    pub misaligned: ::aya_bpf_cty::c_uchar,
    pub discard_misaligned: ::aya_bpf_cty::c_uchar,
    pub raid_partial_stripes_expensive: ::aya_bpf_cty::c_uchar,
    pub zoned: blk_zoned_model::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bsg_class_device {
    pub class_dev: *mut device,
    pub minor: ::aya_bpf_cty::c_int,
    pub queue: *mut request_queue,
    pub ops: *const bsg_ops,
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: gfp_t,
        arg2: *mut ::aya_bpf_cty::c_void,
    ) -> *mut ::aya_bpf_cty::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void, arg2: *mut ::aya_bpf_cty::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: ::aya_bpf_cty::c_int,
    pub curr_nr: ::aya_bpf_cty::c_int,
    pub elements: *mut *mut ::aya_bpf_cty::c_void,
    pub pool_data: *mut ::aya_bpf_cty::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
pub type mempool_t = mempool_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: ::aya_bpf_cty::c_uint,
    pub bio_pool: mempool_t,
    pub bvec_pool: mempool_t,
    pub bio_integrity_pool: mempool_t,
    pub bvec_integrity_pool: mempool_t,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub last_merge: *mut request,
    pub elevator: *mut elevator_queue,
    pub q_usage_counter: percpu_ref,
    pub stats: *mut blk_queue_stats,
    pub rq_qos: *mut rq_qos,
    pub mq_ops: *const blk_mq_ops,
    pub queue_ctx: *mut blk_mq_ctx,
    pub queue_depth: ::aya_bpf_cty::c_uint,
    pub queue_hw_ctx: *mut *mut blk_mq_hw_ctx,
    pub nr_hw_queues: ::aya_bpf_cty::c_uint,
    pub backing_dev_info: *mut backing_dev_info,
    pub queuedata: *mut ::aya_bpf_cty::c_void,
    pub queue_flags: ::aya_bpf_cty::c_ulong,
    pub pm_only: atomic_t,
    pub id: ::aya_bpf_cty::c_int,
    pub bounce_gfp: gfp_t,
    pub queue_lock: spinlock_t,
    pub kobj: kobject,
    pub mq_kobj: *mut kobject,
    pub integrity: blk_integrity,
    pub dev: *mut device,
    pub rpm_status: rpm_status::Type,
    pub nr_pending: ::aya_bpf_cty::c_uint,
    pub nr_requests: ::aya_bpf_cty::c_ulong,
    pub dma_pad_mask: ::aya_bpf_cty::c_uint,
    pub dma_alignment: ::aya_bpf_cty::c_uint,
    pub ksm: *mut blk_keyslot_manager,
    pub rq_timeout: ::aya_bpf_cty::c_uint,
    pub poll_nsec: ::aya_bpf_cty::c_int,
    pub poll_cb: *mut blk_stat_callback,
    pub poll_stat: [blk_rq_stat; 16usize],
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub nr_active_requests_shared_sbitmap: atomic_t,
    pub icq_list: list_head,
    pub blkcg_pols: [::aya_bpf_cty::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub limits: queue_limits,
    pub required_elevator_features: ::aya_bpf_cty::c_uint,
    pub nr_zones: ::aya_bpf_cty::c_uint,
    pub conv_zones_bitmap: *mut ::aya_bpf_cty::c_ulong,
    pub seq_zones_wlock: *mut ::aya_bpf_cty::c_ulong,
    pub max_open_zones: ::aya_bpf_cty::c_uint,
    pub max_active_zones: ::aya_bpf_cty::c_uint,
    pub sg_timeout: ::aya_bpf_cty::c_uint,
    pub sg_reserved_size: ::aya_bpf_cty::c_uint,
    pub node: ::aya_bpf_cty::c_int,
    pub debugfs_mutex: mutex,
    pub blk_trace: *mut blk_trace,
    pub fq: *mut blk_flush_queue,
    pub requeue_list: list_head,
    pub requeue_lock: spinlock_t,
    pub requeue_work: delayed_work,
    pub sysfs_lock: mutex,
    pub sysfs_dir_lock: mutex,
    pub unused_hctx_list: list_head,
    pub unused_hctx_lock: spinlock_t,
    pub mq_freeze_depth: ::aya_bpf_cty::c_int,
    pub bsg_dev: bsg_class_device,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub mq_freeze_lock: mutex,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub bio_split: bio_set,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub rqos_debugfs_dir: *mut dentry,
    pub mq_sysfs_init_done: bool_,
    pub cmd_size: size_t,
    pub write_hints: [u64_; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psi_group {
    pub avgs_lock: mutex,
    pub pcpu: *mut psi_group_cpu,
    pub avg_total: [u64_; 5usize],
    pub avg_last_update: u64_,
    pub avg_next_update: u64_,
    pub avgs_work: delayed_work,
    pub total: [u64_; 10usize],
    pub avg: [::aya_bpf_cty::c_ulong; 15usize],
    pub poll_task: *mut task_struct,
    pub poll_timer: timer_list,
    pub poll_wait: wait_queue_head_t,
    pub poll_wakeup: atomic_t,
    pub trigger_lock: mutex,
    pub triggers: list_head,
    pub nr_triggers: [u32_; 5usize],
    pub poll_states: u32_,
    pub poll_min_period: u64_,
    pub polling_total: [u64_; 5usize],
    pub polling_next_update: u64_,
    pub polling_until: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_bpf {
    pub effective: [*mut bpf_prog_array; 38usize],
    pub progs: [list_head; 38usize],
    pub flags: [u32_; 38usize],
    pub storages: list_head,
    pub inactive: *mut bpf_prog_array,
    pub refcnt: percpu_ref,
    pub release_work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: ::aya_bpf_cty::c_int,
    pub nr_frozen_descendants: ::aya_bpf_cty::c_int,
    pub nr_frozen_tasks: ::aya_bpf_cty::c_int,
}
#[repr(C)]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub level: ::aya_bpf_cty::c_int,
    pub max_depth: ::aya_bpf_cty::c_int,
    pub nr_descendants: ::aya_bpf_cty::c_int,
    pub nr_dying_descendants: ::aya_bpf_cty::c_int,
    pub max_descendants: ::aya_bpf_cty::c_int,
    pub nr_populated_csets: ::aya_bpf_cty::c_int,
    pub nr_populated_domain_children: ::aya_bpf_cty::c_int,
    pub nr_populated_threaded_children: ::aya_bpf_cty::c_int,
    pub nr_threaded_children: ::aya_bpf_cty::c_int,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 13usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 13usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_cpu: *mut cgroup_rstat_cpu,
    pub rstat_css_list: list_head,
    pub last_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: psi_group,
    pub bpf: cgroup_bpf,
    pub congestion_count: atomic_t,
    pub freezer: cgroup_freezer_state,
    pub ancestor_ids: __IncompleteArrayField<u64_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [::aya_bpf_cty::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
    pub ac_btime64: __u64,
}
impl taskstats {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_page_queue {
    pub page: *mut page,
    pub bit_nr: ::aya_bpf_cty::c_int,
    pub wait: wait_queue_entry_t,
}
pub mod writeback_sync_modes {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const WB_SYNC_NONE: Type = 0;
    pub const WB_SYNC_ALL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: ::aya_bpf_cty::c_long,
    pub pages_skipped: ::aya_bpf_cty::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes::Type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub wb: *mut bdi_writeback,
    pub inode: *mut inode,
    pub wb_id: ::aya_bpf_cty::c_int,
    pub wb_lcand_id: ::aya_bpf_cty::c_int,
    pub wb_tcand_id: ::aya_bpf_cty::c_int,
    pub wb_bytes: size_t,
    pub wb_lcand_bytes: size_t,
    pub wb_tcand_bytes: size_t,
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_background(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_reclaim(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_reclaim(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_sync(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn punt_to_cgroup(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_punt_to_cgroup(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: ::aya_bpf_cty::c_uint,
        for_background: ::aya_bpf_cty::c_uint,
        tagged_writepages: ::aya_bpf_cty::c_uint,
        for_reclaim: ::aya_bpf_cty::c_uint,
        range_cyclic: ::aya_bpf_cty::c_uint,
        for_sync: ::aya_bpf_cty::c_uint,
        no_cgroup_owner: ::aya_bpf_cty::c_uint,
        punt_to_cgroup: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let for_reclaim: u32 = unsafe { ::core::mem::transmute(for_reclaim) };
            for_reclaim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let punt_to_cgroup: u32 = unsafe { ::core::mem::transmute(punt_to_cgroup) };
            punt_to_cgroup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct readahead_control {
    pub file: *mut file,
    pub mapping: *mut address_space,
    pub _index: ::aya_bpf_cty::c_ulong,
    pub _nr_pages: ::aya_bpf_cty::c_uint,
    pub _batch_count: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub type_: ::aya_bpf_cty::c_uint,
    pub iov_offset: size_t,
    pub count: size_t,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub pipe: *mut pipe_inode_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iov_iter__bindgen_ty_2__bindgen_ty_1 {
    pub head: ::aya_bpf_cty::c_uint,
    pub start_head: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_cluster_info {
    pub lock: spinlock_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl swap_cluster_info {
    #[inline]
    pub fn data(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: ::aya_bpf_cty::c_uint,
        flags: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_cluster_list {
    pub head: swap_cluster_info,
    pub tail: swap_cluster_info,
}
#[repr(C)]
pub struct swap_info_struct {
    pub flags: ::aya_bpf_cty::c_ulong,
    pub prio: ::aya_bpf_cty::c_short,
    pub list: plist_node,
    pub type_: ::aya_bpf_cty::c_schar,
    pub max: ::aya_bpf_cty::c_uint,
    pub swap_map: *mut ::aya_bpf_cty::c_uchar,
    pub cluster_info: *mut swap_cluster_info,
    pub free_clusters: swap_cluster_list,
    pub lowest_bit: ::aya_bpf_cty::c_uint,
    pub highest_bit: ::aya_bpf_cty::c_uint,
    pub pages: ::aya_bpf_cty::c_uint,
    pub inuse_pages: ::aya_bpf_cty::c_uint,
    pub cluster_next: ::aya_bpf_cty::c_uint,
    pub cluster_nr: ::aya_bpf_cty::c_uint,
    pub cluster_next_cpu: *mut ::aya_bpf_cty::c_uint,
    pub percpu_cluster: *mut percpu_cluster,
    pub swap_extent_root: rb_root,
    pub bdev: *mut block_device,
    pub swap_file: *mut file,
    pub old_block_size: ::aya_bpf_cty::c_uint,
    pub frontswap_map: *mut ::aya_bpf_cty::c_ulong,
    pub frontswap_pages: atomic_t,
    pub lock: spinlock_t,
    pub cont_lock: spinlock_t,
    pub discard_work: work_struct,
    pub discard_clusters: swap_cluster_list,
    pub avail_lists: __IncompleteArrayField<plist_node>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    pub kobj: kobject,
    pub owner: *mut module,
    pub ops: *const file_operations,
    pub list: list_head,
    pub dev: dev_t,
    pub count: ::aya_bpf_cty::c_uint,
}
pub mod dl_dev_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DL_DEV_NO_DRIVER: Type = 0;
    pub const DL_DEV_PROBING: Type = 1;
    pub const DL_DEV_DRIVER_BOUND: Type = 2;
    pub const DL_DEV_UNBINDING: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_message {
    pub event: ::aya_bpf_cty::c_int,
}
pub type pm_message_t = pm_message;
pub mod rpm_request {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RPM_REQ_NONE: Type = 0;
    pub const RPM_REQ_IDLE: Type = 1;
    pub const RPM_REQ_SUSPEND: Type = 2;
    pub const RPM_REQ_AUTOSUSPEND: Type = 3;
    pub const RPM_REQ_RESUME: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: ::aya_bpf_cty::c_uint,
    pub request: rpm_request::Type,
    pub runtime_status: rpm_status::Type,
    pub runtime_error: ::aya_bpf_cty::c_int,
    pub autosuspend_delay: ::aya_bpf_cty::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: ::aya_bpf_cty::c_uint,
        async_suspend: ::aya_bpf_cty::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        must_resume: ::aya_bpf_cty::c_uint,
        may_skip_resume: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: ::aya_bpf_cty::c_uint,
        idle_notification: ::aya_bpf_cty::c_uint,
        request_pending: ::aya_bpf_cty::c_uint,
        deferred_resume: ::aya_bpf_cty::c_uint,
        runtime_auto: ::aya_bpf_cty::c_uint,
        ignore_children: bool_,
        no_callbacks: ::aya_bpf_cty::c_uint,
        irq_safe: ::aya_bpf_cty::c_uint,
        use_autosuspend: ::aya_bpf_cty::c_uint,
        timer_autosuspends: ::aya_bpf_cty::c_uint,
        memalloc_noio: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const ::aya_bpf_cty::c_char,
    pub type_: *const device_type,
    pub bus: *mut bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut ::aya_bpf_cty::c_void,
    pub driver_data: *mut ::aya_bpf_cty::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub em_pd: *mut em_perf_domain,
    pub msi_domain: *mut irq_domain,
    pub pins: *mut dev_pin_info,
    pub msi_list: list_head,
    pub dma_ops: *const dma_map_ops,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *const bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: ::aya_bpf_cty::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *mut class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: ::aya_bpf_cty::c_ulong,
    pub bd_read_only: bool_,
    pub bd_dev: dev_t,
    pub bd_openers: ::aya_bpf_cty::c_int,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_mutex: mutex,
    pub bd_claiming: *mut ::aya_bpf_cty::c_void,
    pub bd_device: device,
    pub bd_holder: *mut ::aya_bpf_cty::c_void,
    pub bd_holders: ::aya_bpf_cty::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_disks: list_head,
    pub bd_holder_dir: *mut kobject,
    pub bd_partno: u8_,
    pub bd_part_count: ::aya_bpf_cty::c_uint,
    pub bd_size_lock: spinlock_t,
    pub bd_disk: *mut gendisk,
    pub bd_bdi: *mut backing_dev_info,
    pub bd_fsfreeze_count: ::aya_bpf_cty::c_int,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_fsfreeze_sb: *mut super_block,
    pub bd_meta_info: *mut partition_meta_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_log {
    pub prefix: *const ::aya_bpf_cty::c_char,
    pub log: *mut fc_log,
}
pub mod fs_context_purpose {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FS_CONTEXT_FOR_MOUNT: Type = 0;
    pub const FS_CONTEXT_FOR_SUBMOUNT: Type = 1;
    pub const FS_CONTEXT_FOR_RECONFIGURE: Type = 2;
}
pub mod fs_context_phase {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FS_CONTEXT_CREATE_PARAMS: Type = 0;
    pub const FS_CONTEXT_CREATING: Type = 1;
    pub const FS_CONTEXT_AWAITING_MOUNT: Type = 2;
    pub const FS_CONTEXT_AWAITING_RECONF: Type = 3;
    pub const FS_CONTEXT_RECONF_PARAMS: Type = 4;
    pub const FS_CONTEXT_RECONFIGURING: Type = 5;
    pub const FS_CONTEXT_FAILED: Type = 6;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    pub ops: *const fs_context_operations,
    pub uapi_mutex: mutex,
    pub fs_type: *mut file_system_type,
    pub fs_private: *mut ::aya_bpf_cty::c_void,
    pub sget_key: *mut ::aya_bpf_cty::c_void,
    pub root: *mut dentry,
    pub user_ns: *mut user_namespace,
    pub net_ns: *mut net,
    pub cred: *const cred,
    pub log: p_log,
    pub source: *const ::aya_bpf_cty::c_char,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub s_fs_info: *mut ::aya_bpf_cty::c_void,
    pub sb_flags: ::aya_bpf_cty::c_uint,
    pub sb_flags_mask: ::aya_bpf_cty::c_uint,
    pub s_iflags: ::aya_bpf_cty::c_uint,
    pub lsm_flags: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl fs_context {
    #[inline]
    pub fn purpose(&self) -> fs_context_purpose::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_purpose(&mut self, val: fs_context_purpose::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn phase(&self) -> fs_context_phase::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_phase(&mut self, val: fs_context_phase::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn need_free(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_need_free(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn global(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_global(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oldapi(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oldapi(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        purpose: fs_context_purpose::Type,
        phase: fs_context_phase::Type,
        need_free: bool_,
        global: bool_,
        oldapi: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let purpose: u32 = unsafe { ::core::mem::transmute(purpose) };
            purpose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let phase: u32 = unsafe { ::core::mem::transmute(phase) };
            phase as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let need_free: u8 = unsafe { ::core::mem::transmute(need_free) };
            need_free as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let global: u8 = unsafe { ::core::mem::transmute(global) };
            global as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oldapi: u8 = unsafe { ::core::mem::transmute(oldapi) };
            oldapi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct filename {
    pub name: *const ::aya_bpf_cty::c_char,
    pub uptr: *const ::aya_bpf_cty::c_char,
    pub refcnt: ::aya_bpf_cty::c_int,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
pub type blk_status_t = u8_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: ::aya_bpf_cty::c_uint,
    pub bi_idx: ::aya_bpf_cty::c_uint,
    pub bi_bvec_done: ::aya_bpf_cty::c_uint,
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: ::aya_bpf_cty::c_uint,
    pub bv_offset: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_disk: *mut gendisk,
    pub bi_opf: ::aya_bpf_cty::c_uint,
    pub bi_flags: ::aya_bpf_cty::c_ushort,
    pub bi_ioprio: ::aya_bpf_cty::c_ushort,
    pub bi_write_hint: ::aya_bpf_cty::c_ushort,
    pub bi_status: blk_status_t,
    pub bi_partno: u8_,
    pub __bi_remaining: atomic_t,
    pub bi_iter: bvec_iter,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut ::aya_bpf_cty::c_void,
    pub bi_blkg: *mut blkcg_gq,
    pub bi_issue: bio_issue,
    pub bi_iocost_cost: u64_,
    pub bi_crypt_context: *mut bio_crypt_ctx,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: ::aya_bpf_cty::c_ushort,
    pub bi_max_vecs: ::aya_bpf_cty::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_integrity: *mut bio_integrity_payload,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_binprm {
    pub vma: *mut vm_area_struct,
    pub vma_pages: ::aya_bpf_cty::c_ulong,
    pub mm: *mut mm_struct,
    pub p: ::aya_bpf_cty::c_ulong,
    pub argmin: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub executable: *mut file,
    pub interpreter: *mut file,
    pub file: *mut file,
    pub cred: *mut cred,
    pub unsafe_: ::aya_bpf_cty::c_int,
    pub per_clear: ::aya_bpf_cty::c_uint,
    pub argc: ::aya_bpf_cty::c_int,
    pub envc: ::aya_bpf_cty::c_int,
    pub filename: *const ::aya_bpf_cty::c_char,
    pub interp: *const ::aya_bpf_cty::c_char,
    pub fdpath: *const ::aya_bpf_cty::c_char,
    pub interp_flags: ::aya_bpf_cty::c_uint,
    pub execfd: ::aya_bpf_cty::c_int,
    pub loader: ::aya_bpf_cty::c_ulong,
    pub exec: ::aya_bpf_cty::c_ulong,
    pub rlim_stack: rlimit,
    pub buf: [::aya_bpf_cty::c_char; 256usize],
}
impl linux_binprm {
    #[inline]
    pub fn have_execfd(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_have_execfd(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn execfd_creds(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_execfd_creds(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secureexec(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secureexec(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn point_of_no_return(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_point_of_no_return(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        have_execfd: ::aya_bpf_cty::c_uint,
        execfd_creds: ::aya_bpf_cty::c_uint,
        secureexec: ::aya_bpf_cty::c_uint,
        point_of_no_return: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let have_execfd: u32 = unsafe { ::core::mem::transmute(have_execfd) };
            have_execfd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let execfd_creds: u32 = unsafe { ::core::mem::transmute(execfd_creds) };
            execfd_creds as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let secureexec: u32 = unsafe { ::core::mem::transmute(secureexec) };
            secureexec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let point_of_no_return: u32 = unsafe { ::core::mem::transmute(point_of_no_return) };
            point_of_no_return as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coredump_params {
    pub siginfo: *const kernel_siginfo_t,
    pub regs: *mut pt_regs,
    pub file: *mut file,
    pub limit: ::aya_bpf_cty::c_ulong,
    pub mm_flags: ::aya_bpf_cty::c_ulong,
    pub written: loff_t,
    pub pos: loff_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct em_perf_state {
    pub frequency: ::aya_bpf_cty::c_ulong,
    pub power: ::aya_bpf_cty::c_ulong,
    pub cost: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct em_perf_domain {
    pub table: *mut em_perf_state,
    pub nr_perf_states: ::aya_bpf_cty::c_int,
    pub milliwatts: ::aya_bpf_cty::c_int,
    pub cpus: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub freeze:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub thaw:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub poweroff:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub restore:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: ::aya_bpf_cty::c_uint,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const ::aya_bpf_cty::c_char,
    pub id: ::aya_bpf_cty::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: ::aya_bpf_cty::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: ::aya_bpf_cty::c_ulong,
    pub active_count: ::aya_bpf_cty::c_ulong,
    pub relax_count: ::aya_bpf_cty::c_ulong,
    pub expire_count: ::aya_bpf_cty::c_ulong,
    pub wakeup_count: ::aya_bpf_cty::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: bool_)>,
    pub activate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_type {
    pub name: *const ::aya_bpf_cty::c_char,
    pub dev_name: *const ::aya_bpf_cty::c_char,
    pub dev_root: *mut device,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut device_driver) -> ::aya_bpf_cty::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut kobj_uevent_env) -> ::aya_bpf_cty::c_int,
    >,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub online:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub offline:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf_cty::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub num_vf:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub pm: *const dev_pm_ops,
    pub iommu_ops: *const iommu_ops,
    pub p: *mut subsys_private,
    pub lock_key: lock_class_key,
    pub need_parent_lock: bool_,
}
pub mod probe_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PROBE_DEFAULT_STRATEGY: Type = 0;
    pub const PROBE_PREFER_ASYNCHRONOUS: Type = 1;
    pub const PROBE_FORCE_SYNCHRONOUS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_driver {
    pub name: *const ::aya_bpf_cty::c_char,
    pub bus: *mut bus_type,
    pub owner: *mut module,
    pub mod_name: *const ::aya_bpf_cty::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type::Type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf_cty::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub p: *mut driver_private,
}
pub mod iommu_cap {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IOMMU_CAP_CACHE_COHERENCY: Type = 0;
    pub const IOMMU_CAP_INTR_REMAP: Type = 1;
    pub const IOMMU_CAP_NOEXEC: Type = 2;
}
pub mod iommu_attr {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DOMAIN_ATTR_GEOMETRY: Type = 0;
    pub const DOMAIN_ATTR_PAGING: Type = 1;
    pub const DOMAIN_ATTR_WINDOWS: Type = 2;
    pub const DOMAIN_ATTR_FSL_PAMU_STASH: Type = 3;
    pub const DOMAIN_ATTR_FSL_PAMU_ENABLE: Type = 4;
    pub const DOMAIN_ATTR_FSL_PAMUV1: Type = 5;
    pub const DOMAIN_ATTR_NESTING: Type = 6;
    pub const DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE: Type = 7;
    pub const DOMAIN_ATTR_IO_PGTABLE_CFG: Type = 8;
    pub const DOMAIN_ATTR_MAX: Type = 9;
}
pub mod iommu_dev_features {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IOMMU_DEV_FEAT_AUX: Type = 0;
    pub const IOMMU_DEV_FEAT_SVA: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_ops {
    pub capable: ::core::option::Option<unsafe extern "C" fn(arg1: iommu_cap::Type) -> bool_>,
    pub domain_alloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_uint) -> *mut iommu_domain,
    >,
    pub domain_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>,
    pub attach_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> ::aya_bpf_cty::c_int,
    >,
    pub detach_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device)>,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: phys_addr_t,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_int,
            arg6: gfp_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub unmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: size_t,
            arg4: *mut iommu_iotlb_gather,
        ) -> size_t,
    >,
    pub flush_iotlb_all: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>,
    pub iotlb_sync_map: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>,
    pub iotlb_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut iommu_iotlb_gather),
    >,
    pub iova_to_phys: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: dma_addr_t) -> phys_addr_t,
    >,
    pub probe_device:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_device>,
    pub release_device: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub probe_finalize: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub device_group:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_group>,
    pub domain_get_attr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: iommu_attr::Type,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub domain_set_attr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: iommu_attr::Type,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_resv_regions:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut list_head)>,
    pub put_resv_regions:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut list_head)>,
    pub apply_resv_region: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut iommu_domain,
            arg3: *mut iommu_resv_region,
        ),
    >,
    pub domain_window_enable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: u32_,
            arg3: phys_addr_t,
            arg4: u64_,
            arg5: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub domain_window_disable:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: u32_)>,
    pub of_xlate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut of_phandle_args) -> ::aya_bpf_cty::c_int,
    >,
    pub is_attach_deferred: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> bool_,
    >,
    pub dev_has_feat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: iommu_dev_features::Type) -> bool_,
    >,
    pub dev_feat_enabled: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: iommu_dev_features::Type) -> bool_,
    >,
    pub dev_enable_feat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: iommu_dev_features::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dev_disable_feat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: iommu_dev_features::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub aux_attach_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> ::aya_bpf_cty::c_int,
    >,
    pub aux_detach_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device)>,
    pub aux_get_pasid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> ::aya_bpf_cty::c_int,
    >,
    pub sva_bind: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut mm_struct,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> *mut iommu_sva,
    >,
    pub sva_unbind: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_sva)>,
    pub sva_get_pasid: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_sva) -> u32_>,
    pub page_response: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut iommu_fault_event,
            arg3: *mut iommu_page_response,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cache_invalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: *mut device,
            arg3: *mut iommu_cache_invalidate_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sva_bind_gpasid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: *mut device,
            arg3: *mut iommu_gpasid_bind_data,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sva_unbind_gpasid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: u32_) -> ::aya_bpf_cty::c_int,
    >,
    pub def_domain_type:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub pgsize_bitmap: ::aya_bpf_cty::c_ulong,
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_type {
    pub name: *const ::aya_bpf_cty::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut kobj_uevent_env) -> ::aya_bpf_cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut umode_t,
            arg3: *mut kuid_t,
            arg4: *mut kgid_t,
        ) -> *mut ::aya_bpf_cty::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub pm: *const dev_pm_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class {
    pub name: *const ::aya_bpf_cty::c_char,
    pub owner: *mut module,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_kobj: *mut kobject,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut kobj_uevent_env) -> ::aya_bpf_cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut umode_t) -> *mut ::aya_bpf_cty::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device) -> *const ::aya_bpf_cty::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut kuid_t, arg3: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
    pub p: *mut subsys_private,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_device_id {
    pub name: [::aya_bpf_cty::c_char; 32usize],
    pub type_: [::aya_bpf_cty::c_char; 32usize],
    pub compatible: [::aya_bpf_cty::c_char; 128usize],
    pub data: *const ::aya_bpf_cty::c_void,
}
pub type kernel_ulong_t = ::aya_bpf_cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 9usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: ::aya_bpf_cty::c_uint,
    pub min_align_mask: ::aya_bpf_cty::c_uint,
    pub segment_boundary_mask: ::aya_bpf_cty::c_ulong,
}
pub mod dma_data_direction {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DMA_BIDIRECTIONAL: Type = 0;
    pub const DMA_TO_DEVICE: Type = 1;
    pub const DMA_FROM_DEVICE: Type = 2;
    pub const DMA_NONE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_map_ops {
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut dma_addr_t,
            arg4: gfp_t,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: dma_addr_t,
            arg5: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub alloc_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut dma_addr_t,
            arg4: dma_data_direction::Type,
            arg5: gfp_t,
        ) -> *mut page,
    >,
    pub free_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut page,
            arg4: dma_addr_t,
            arg5: dma_data_direction::Type,
        ),
    >,
    pub alloc_noncoherent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut dma_addr_t,
            arg4: dma_data_direction::Type,
            arg5: gfp_t,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub free_noncoherent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: size_t,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: dma_addr_t,
            arg5: dma_data_direction::Type,
        ),
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut vm_area_struct,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: dma_addr_t,
            arg5: size_t,
            arg6: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_sgtable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut sg_table,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: dma_addr_t,
            arg5: size_t,
            arg6: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut page,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: size_t,
            arg5: dma_data_direction::Type,
            arg6: ::aya_bpf_cty::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: size_t,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub map_sg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf_cty::c_int,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub unmap_sg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf_cty::c_int,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub map_resource: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: phys_addr_t,
            arg3: size_t,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_resource: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: size_t,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub sync_single_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: size_t,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_single_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: size_t,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_sg_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf_cty::c_int,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_sg_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf_cty::c_int,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub cache_sync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: size_t,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub dma_supported: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: u64_) -> ::aya_bpf_cty::c_int,
    >,
    pub get_required_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> u64_>,
    pub max_mapping_size: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> size_t>,
    pub get_merge_boundary:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_region {
    pub cpu_start: phys_addr_t,
    pub dma_start: dma_addr_t,
    pub size: u64_,
    pub offset: u64_,
}
pub type phandle = u32_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    pub name: *const ::aya_bpf_cty::c_char,
    pub phandle: phandle,
    pub full_name: *const ::aya_bpf_cty::c_char,
    pub fwnode: fwnode_handle,
    pub properties: *mut property,
    pub deadprops: *mut property,
    pub parent: *mut device_node,
    pub child: *mut device_node,
    pub sibling: *mut device_node,
    pub _flags: ::aya_bpf_cty::c_ulong,
    pub data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_mod {
    pub next: *mut static_call_mod,
    pub mod_: *mut module,
    pub sites: *mut static_call_site,
}
#[repr(C)]
#[derive(Debug)]
pub struct ring_buffer_event {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub array: __IncompleteArrayField<u32_>,
}
impl ring_buffer_event {
    #[inline]
    pub fn type_len(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_type_len(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn time_delta(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_time_delta(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_len: u32_, time_delta: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let type_len: u32 = unsafe { ::core::mem::transmute(type_len) };
            type_len as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let time_delta: u32 = unsafe { ::core::mem::transmute(time_delta) };
            time_delta as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_buf {
    pub buffer: *mut ::aya_bpf_cty::c_char,
    pub size: size_t,
    pub len: size_t,
    pub readpos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_seq {
    pub buffer: [::aya_bpf_cty::c_char; 4096usize],
    pub seq: seq_buf,
    pub full: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_mem_data_src {
    pub val: __u64,
    pub __bindgen_anon_1: perf_mem_data_src__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct perf_mem_data_src__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_mem_data_src__bindgen_ty_1 {
    #[inline]
    pub fn mem_op(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_op(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 14u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoop(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoop(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lock(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lock(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dtlb(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_mem_dtlb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl_num(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl_num(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_remote(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mem_remote(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoopx(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoopx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_rsvd(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_mem_rsvd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_op: __u64,
        mem_lvl: __u64,
        mem_snoop: __u64,
        mem_lock: __u64,
        mem_dtlb: __u64,
        mem_lvl_num: __u64,
        mem_remote: __u64,
        mem_snoopx: __u64,
        mem_rsvd: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mem_op: u64 = unsafe { ::core::mem::transmute(mem_op) };
            mem_op as u64
        });
        __bindgen_bitfield_unit.set(5usize, 14u8, {
            let mem_lvl: u64 = unsafe { ::core::mem::transmute(mem_lvl) };
            mem_lvl as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let mem_snoop: u64 = unsafe { ::core::mem::transmute(mem_snoop) };
            mem_snoop as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let mem_lock: u64 = unsafe { ::core::mem::transmute(mem_lock) };
            mem_lock as u64
        });
        __bindgen_bitfield_unit.set(26usize, 7u8, {
            let mem_dtlb: u64 = unsafe { ::core::mem::transmute(mem_dtlb) };
            mem_dtlb as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let mem_lvl_num: u64 = unsafe { ::core::mem::transmute(mem_lvl_num) };
            mem_lvl_num as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let mem_remote: u64 = unsafe { ::core::mem::transmute(mem_remote) };
            mem_remote as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let mem_snoopx: u64 = unsafe { ::core::mem::transmute(mem_snoopx) };
            mem_snoopx as u64
        });
        __bindgen_bitfield_unit.set(40usize, 24u8, {
            let mem_rsvd: u64 = unsafe { ::core::mem::transmute(mem_rsvd) };
            mem_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_branch_entry {
    pub from: __u64,
    pub to: __u64,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_branch_entry {
    #[inline]
    pub fn mispred(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mispred(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn predicted(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_predicted(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_tx(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_in_tx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abort(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_abort(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cycles(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_cycles(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 40u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 40u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mispred: __u64,
        predicted: __u64,
        in_tx: __u64,
        abort: __u64,
        cycles: __u64,
        type_: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mispred: u64 = unsafe { ::core::mem::transmute(mispred) };
            mispred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let predicted: u64 = unsafe { ::core::mem::transmute(predicted) };
            predicted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_tx: u64 = unsafe { ::core::mem::transmute(in_tx) };
            in_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let abort: u64 = unsafe { ::core::mem::transmute(abort) };
            abort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let cycles: u64 = unsafe { ::core::mem::transmute(cycles) };
            cycles as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let type_: u64 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 40u8, {
            let reserved: u64 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct new_utsname {
    pub sysname: [::aya_bpf_cty::c_char; 65usize],
    pub nodename: [::aya_bpf_cty::c_char; 65usize],
    pub release: [::aya_bpf_cty::c_char; 65usize],
    pub version: [::aya_bpf_cty::c_char; 65usize],
    pub machine: [::aya_bpf_cty::c_char; 65usize],
    pub domainname: [::aya_bpf_cty::c_char; 65usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uts_namespace {
    pub name: new_utsname,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_namespace {
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsset {
    pub flags: ::aya_bpf_cty::c_uint,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub cred: *const cred,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ns_operations {
    pub name: *const ::aya_bpf_cty::c_char,
    pub real_ns_name: *const ::aya_bpf_cty::c_char,
    pub type_: ::aya_bpf_cty::c_int,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct) -> *mut ns_common>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common)>,
    pub install: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nsset, arg2: *mut ns_common) -> ::aya_bpf_cty::c_int,
    >,
    pub owner:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut user_namespace>,
    pub get_parent:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut ns_common>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucounts {
    pub node: hlist_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub count: ::aya_bpf_cty::c_int,
    pub ucount: [atomic_t; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmu {
    pub entry: list_head,
    pub module: *mut module,
    pub dev: *mut device,
    pub attr_groups: *mut *const attribute_group,
    pub attr_update: *mut *const attribute_group,
    pub name: *const ::aya_bpf_cty::c_char,
    pub type_: ::aya_bpf_cty::c_int,
    pub capabilities: ::aya_bpf_cty::c_int,
    pub pmu_disable_count: *mut ::aya_bpf_cty::c_int,
    pub pmu_cpu_context: *mut perf_cpu_context,
    pub exclusive_cnt: atomic_t,
    pub task_ctx_nr: ::aya_bpf_cty::c_int,
    pub hrtimer_interval_ms: ::aya_bpf_cty::c_int,
    pub nr_addr_filters: ::aya_bpf_cty::c_uint,
    pub pmu_enable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub pmu_disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub event_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    pub event_mapped:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    pub event_unmapped:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    pub add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
    >,
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
    >,
    pub read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub start_txn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu, arg2: ::aya_bpf_cty::c_uint)>,
    pub commit_txn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu) -> ::aya_bpf_cty::c_int>,
    pub cancel_txn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub event_idx:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    pub sched_task:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event_context, arg2: bool_)>,
    pub task_ctx_cache: *mut kmem_cache,
    pub swap_task_ctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event_context, arg2: *mut perf_event_context),
    >,
    pub setup_aux: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: *mut *mut ::aya_bpf_cty::c_void,
            arg3: ::aya_bpf_cty::c_int,
            arg4: bool_,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub free_aux: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub snapshot_aux: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: *mut perf_output_handle,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub addr_filters_validate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut list_head) -> ::aya_bpf_cty::c_int>,
    pub addr_filters_sync: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub aux_output_match:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    pub filter_match:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    pub check_period: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: u64_) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_regs {
    pub regs: pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::aya_bpf_cty::c_void,
    pub iov_len: __kernel_size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut ::aya_bpf_cty::c_void,
    pub iov_len: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_regs {
    pub abi: __u64,
    pub regs: *mut pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_cgroup_storage_key {
    pub cgroup_inode_id: __u64,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_array_item {
    pub prog: *mut bpf_prog,
    pub cgroup_storage: [*mut bpf_cgroup_storage; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage {
    pub __bindgen_anon_1: bpf_cgroup_storage__bindgen_ty_1,
    pub map: *mut bpf_cgroup_storage_map,
    pub key: bpf_cgroup_storage_key,
    pub list_map: list_head,
    pub list_cg: list_head,
    pub node: rb_node,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cgroup_storage__bindgen_ty_1 {
    pub buf: *mut bpf_storage_buffer,
    pub percpu_buf: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_prog_array {
    pub rcu: callback_head,
    pub items: __IncompleteArrayField<bpf_prog_array_item>,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_storage_buffer {
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psi_group_cpu {
    pub seq: seqcount_t,
    pub tasks: [::aya_bpf_cty::c_uint; 4usize],
    pub state_mask: u32_,
    pub times: [u32_; 6usize],
    pub state_start: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub times_prev: [u32_; 12usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl psi_group_cpu {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> ::aya_bpf_cty::c_int,
    >,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: ::aya_bpf_cty::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut cgroup_subsys_state,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub can_attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_taskset) -> ::aya_bpf_cty::c_int,
    >,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>,
    pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
    pub can_fork: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut css_set) -> ::aya_bpf_cty::c_int,
    >,
    pub cancel_fork:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut css_set)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub id: ::aya_bpf_cty::c_int,
    pub name: *const ::aya_bpf_cty::c_char,
    pub legacy_name: *const ::aya_bpf_cty::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: ::aya_bpf_cty::c_uint,
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_rstat_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub updated_children: *mut cgroup,
    pub updated_next: *mut cgroup,
}
#[repr(C)]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: ::aya_bpf_cty::c_uint,
    pub hierarchy_id: ::aya_bpf_cty::c_int,
    pub cgrp: cgroup,
    pub cgrp_ancestor_id_storage: u64_,
    pub nr_cgrps: atomic_t,
    pub root_list: list_head,
    pub flags: ::aya_bpf_cty::c_uint,
    pub release_agent_path: [::aya_bpf_cty::c_char; 4096usize],
    pub name: [::aya_bpf_cty::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cftype {
    pub name: [::aya_bpf_cty::c_char; 64usize],
    pub private: ::aya_bpf_cty::c_ulong,
    pub max_write_len: size_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub file_offset: ::aya_bpf_cty::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub seq_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cgroup_subsys_state,
            arg2: *mut cftype,
            arg3: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cgroup_subsys_state,
            arg2: *mut cftype,
            arg3: s64,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: loff_t,
        ) -> ssize_t,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct perf_callchain_entry {
    pub nr: __u64,
    pub ip: __IncompleteArrayField<__u64>,
}
pub type perf_copy_f = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf_cty::c_void,
        arg2: *const ::aya_bpf_cty::c_void,
        arg3: ::aya_bpf_cty::c_ulong,
        arg4: ::aya_bpf_cty::c_ulong,
    ) -> ::aya_bpf_cty::c_ulong,
>;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct perf_raw_frag {
    pub __bindgen_anon_1: perf_raw_frag__bindgen_ty_1,
    pub copy: perf_copy_f,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub size: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_raw_frag__bindgen_ty_1 {
    pub next: *mut perf_raw_frag,
    pub pad: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_raw_record {
    pub frag: perf_raw_frag,
    pub size: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct perf_branch_stack {
    pub nr: __u64,
    pub hw_idx: __u64,
    pub entries: __IncompleteArrayField<perf_branch_entry>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_cpu_context {
    pub ctx: perf_event_context,
    pub task_ctx: *mut perf_event_context,
    pub active_oncpu: ::aya_bpf_cty::c_int,
    pub exclusive: ::aya_bpf_cty::c_int,
    pub hrtimer_lock: raw_spinlock_t,
    pub hrtimer: hrtimer,
    pub hrtimer_interval: ktime_t,
    pub hrtimer_active: ::aya_bpf_cty::c_uint,
    pub cgrp: *mut perf_cgroup,
    pub cgrp_cpuctx_entry: list_head,
    pub sched_cb_entry: list_head,
    pub sched_cb_usage: ::aya_bpf_cty::c_int,
    pub online: ::aya_bpf_cty::c_int,
    pub heap_size: ::aya_bpf_cty::c_int,
    pub heap: *mut *mut perf_event,
    pub heap_default: [*mut perf_event; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_output_handle {
    pub event: *mut perf_event,
    pub rb: *mut perf_buffer,
    pub wakeup: ::aya_bpf_cty::c_ulong,
    pub size: ::aya_bpf_cty::c_ulong,
    pub aux_flags: u64_,
    pub __bindgen_anon_1: perf_output_handle__bindgen_ty_1,
    pub page: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_output_handle__bindgen_ty_1 {
    pub addr: *mut ::aya_bpf_cty::c_void,
    pub head: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_addr_filter_range {
    pub start: ::aya_bpf_cty::c_ulong,
    pub size: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_sample_data {
    pub addr: u64_,
    pub raw: *mut perf_raw_record,
    pub br_stack: *mut perf_branch_stack,
    pub period: u64_,
    pub weight: u64_,
    pub txn: u64_,
    pub data_src: perf_mem_data_src,
    pub type_: u64_,
    pub ip: u64_,
    pub tid_entry: perf_sample_data__bindgen_ty_1,
    pub time: u64_,
    pub id: u64_,
    pub stream_id: u64_,
    pub cpu_entry: perf_sample_data__bindgen_ty_2,
    pub callchain: *mut perf_callchain_entry,
    pub aux_size: u64_,
    pub regs_user: perf_regs,
    pub regs_intr: perf_regs,
    pub stack_user_size: u64_,
    pub phys_addr: u64_,
    pub cgroup: u64_,
    pub data_page_size: u64_,
    pub code_page_size: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_data__bindgen_ty_1 {
    pub pid: u32_,
    pub tid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_data__bindgen_ty_2 {
    pub cpu: u32_,
    pub reserved: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_cgroup {
    pub css: cgroup_subsys_state,
    pub info: *mut perf_cgroup_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_cgroup_info {
    pub time: u64_,
    pub timestamp: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_entry {
    pub type_: ::aya_bpf_cty::c_ushort,
    pub flags: ::aya_bpf_cty::c_uchar,
    pub preempt_count: ::aya_bpf_cty::c_uchar,
    pub pid: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_iterator {
    pub tr: *mut trace_array,
    pub trace: *mut tracer,
    pub array_buffer: *mut array_buffer,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub cpu_file: ::aya_bpf_cty::c_int,
    pub mutex: mutex,
    pub buffer_iter: *mut *mut ring_buffer_iter,
    pub iter_flags: ::aya_bpf_cty::c_ulong,
    pub temp: *mut ::aya_bpf_cty::c_void,
    pub temp_size: ::aya_bpf_cty::c_uint,
    pub tmp_seq: trace_seq,
    pub started: cpumask_var_t,
    pub snapshot: bool_,
    pub seq: trace_seq,
    pub ent: *mut trace_entry,
    pub lost_events: ::aya_bpf_cty::c_ulong,
    pub leftover: ::aya_bpf_cty::c_int,
    pub ent_size: ::aya_bpf_cty::c_int,
    pub cpu: ::aya_bpf_cty::c_int,
    pub ts: u64_,
    pub pos: loff_t,
    pub idx: ::aya_bpf_cty::c_long,
}
pub mod print_line_t {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TRACE_TYPE_PARTIAL_LINE: Type = 0;
    pub const TRACE_TYPE_HANDLED: Type = 1;
    pub const TRACE_TYPE_UNHANDLED: Type = 2;
    pub const TRACE_TYPE_NO_CONSUME: Type = 3;
}
pub type trace_print_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut trace_iterator,
        arg2: ::aya_bpf_cty::c_int,
        arg3: *mut trace_event,
    ) -> print_line_t::Type,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_functions {
    pub trace: trace_print_func,
    pub raw: trace_print_func,
    pub hex: trace_print_func,
    pub binary: trace_print_func,
}
pub mod trace_reg {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TRACE_REG_REGISTER: Type = 0;
    pub const TRACE_REG_UNREGISTER: Type = 1;
    pub const TRACE_REG_PERF_REGISTER: Type = 2;
    pub const TRACE_REG_PERF_UNREGISTER: Type = 3;
    pub const TRACE_REG_PERF_OPEN: Type = 4;
    pub const TRACE_REG_PERF_CLOSE: Type = 5;
    pub const TRACE_REG_PERF_ADD: Type = 6;
    pub const TRACE_REG_PERF_DEL: Type = 7;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_event_fields {
    pub type_: *const ::aya_bpf_cty::c_char,
    pub __bindgen_anon_1: trace_event_fields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union trace_event_fields__bindgen_ty_1 {
    pub __bindgen_anon_1: trace_event_fields__bindgen_ty_1__bindgen_ty_1,
    pub define_fields: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_fields__bindgen_ty_1__bindgen_ty_1 {
    pub name: *const ::aya_bpf_cty::c_char,
    pub size: ::aya_bpf_cty::c_int,
    pub align: ::aya_bpf_cty::c_int,
    pub is_signed: ::aya_bpf_cty::c_int,
    pub filter_type: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_class {
    pub system: *const ::aya_bpf_cty::c_char,
    pub probe: *mut ::aya_bpf_cty::c_void,
    pub perf_probe: *mut ::aya_bpf_cty::c_void,
    pub reg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_event_call,
            arg2: trace_reg::Type,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fields_array: *mut trace_event_fields,
    pub get_fields:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_event_call) -> *mut list_head>,
    pub fields: list_head,
    pub raw_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_file {
    pub list: list_head,
    pub event_call: *mut trace_event_call,
    pub filter: *mut event_filter,
    pub dir: *mut dentry,
    pub tr: *mut trace_array,
    pub system: *mut trace_subsystem_dir,
    pub triggers: list_head,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub sm_ref: atomic_t,
    pub tm_ref: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const device,
        ) -> *const ::aya_bpf_cty::c_void,
    >,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf_cty::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut ::aya_bpf_cty::c_void,
            arg5: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: *mut *const ::aya_bpf_cty::c_char,
            arg4: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf_cty::c_char,
    >,
    pub get_name_prefix: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf_cty::c_char,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf_cty::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: *const ::aya_bpf_cty::c_char,
            arg4: ::aya_bpf_cty::c_uint,
            arg5: ::aya_bpf_cty::c_uint,
            arg6: *mut fwnode_reference_args,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_endpoint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub add_links: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: ::aya_bpf_cty::c_uint,
    pub id: ::aya_bpf_cty::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: ::aya_bpf_cty::c_uint,
    pub args: [u64_; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct property {
    pub name: *mut ::aya_bpf_cty::c_char,
    pub length: ::aya_bpf_cty::c_int,
    pub value: *mut ::aya_bpf_cty::c_void,
    pub next: *mut property,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_fwspec {
    pub fwnode: *mut fwnode_handle,
    pub param_count: ::aya_bpf_cty::c_int,
    pub param: [u32_; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_domain_ops {
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device_node,
            arg3: irq_domain_bus_token::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub select: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_fwspec,
            arg3: irq_domain_bus_token::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: irq_hw_number_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub unmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_domain, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub xlate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device_node,
            arg3: *const u32_,
            arg4: ::aya_bpf_cty::c_uint,
            arg5: *mut ::aya_bpf_cty::c_ulong,
            arg6: *mut ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
        ),
    >,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_data,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub deactivate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_domain, arg2: *mut irq_data)>,
    pub translate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_fwspec,
            arg3: *mut ::aya_bpf_cty::c_ulong,
            arg4: *mut ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gendisk {
    pub major: ::aya_bpf_cty::c_int,
    pub first_minor: ::aya_bpf_cty::c_int,
    pub minors: ::aya_bpf_cty::c_int,
    pub disk_name: [::aya_bpf_cty::c_char; 32usize],
    pub events: ::aya_bpf_cty::c_ushort,
    pub event_flags: ::aya_bpf_cty::c_ushort,
    pub part_tbl: *mut disk_part_tbl,
    pub part0: *mut block_device,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut ::aya_bpf_cty::c_void,
    pub flags: ::aya_bpf_cty::c_int,
    pub state: ::aya_bpf_cty::c_ulong,
    pub slave_dir: *mut kobject,
    pub random: *mut timer_rand_state,
    pub sync_io: atomic_t,
    pub ev: *mut disk_events,
    pub integrity_kobj: kobject,
    pub cdi: *mut cdrom_device_info,
    pub node_id: ::aya_bpf_cty::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [::aya_bpf_cty::c_char; 37usize],
    pub volname: [u8_; 64usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_integrity_payload {
    pub bip_bio: *mut bio,
    pub bip_iter: bvec_iter,
    pub bip_slab: ::aya_bpf_cty::c_ushort,
    pub bip_vcnt: ::aya_bpf_cty::c_ushort,
    pub bip_max_vcnt: ::aya_bpf_cty::c_ushort,
    pub bip_flags: ::aya_bpf_cty::c_ushort,
    pub bio_iter: bvec_iter,
    pub bip_work: work_struct,
    pub bip_vec: *mut bio_vec,
    pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_iostat {
    pub bytes: [u64_; 3usize],
    pub ios: [u64_; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_iostat_set {
    pub sync: u64_stats_sync,
    pub cur: blkg_iostat,
    pub last: blkg_iostat,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg_gq {
    pub q: *mut request_queue,
    pub q_node: list_head,
    pub blkcg_node: hlist_node,
    pub blkcg: *mut blkcg,
    pub parent: *mut blkcg_gq,
    pub refcnt: percpu_ref,
    pub online: bool_,
    pub iostat_cpu: *mut blkg_iostat_set,
    pub iostat: blkg_iostat_set,
    pub pd: [*mut blkg_policy_data; 5usize],
    pub async_bio_lock: spinlock_t,
    pub async_bios: bio_list,
    pub async_bio_work: work_struct,
    pub use_delay: atomic_t,
    pub delay_nsec: atomic64_t,
    pub delay_start: atomic64_t,
    pub last_delay: u64_,
    pub last_use: ::aya_bpf_cty::c_int,
    pub callback_head: callback_head,
}
pub type blk_qc_t = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct disk_part_tbl {
    pub callback_head: callback_head,
    pub len: ::aya_bpf_cty::c_int,
    pub last_lookup: *mut block_device,
    pub part: __IncompleteArrayField<*mut block_device>,
}
pub type integrity_processing_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_integrity_iter) -> blk_status_t>;
pub type integrity_prepare_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>;
pub type integrity_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: ::aya_bpf_cty::c_uint)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_profile {
    pub generate_fn: integrity_processing_fn,
    pub verify_fn: integrity_processing_fn,
    pub prepare_fn: integrity_prepare_fn,
    pub complete_fn: integrity_complete_fn,
    pub name: *const ::aya_bpf_cty::c_char,
}
pub type report_zones_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut blk_zone,
        arg2: ::aya_bpf_cty::c_uint,
        arg3: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_operations {
    pub submit_bio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio) -> blk_qc_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: fmode_t) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk, arg2: fmode_t)>,
    pub rw_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: sector_t,
            arg3: *mut page,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_uint,
    >,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub revalidate_disk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> ::aya_bpf_cty::c_int>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: *mut hd_geometry,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_read_only: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub swap_slot_free_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: ::aya_bpf_cty::c_ulong),
    >,
    pub report_zones: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            arg2: sector_t,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: report_zones_cb,
            arg5: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gendisk, arg2: *mut umode_t) -> *mut ::aya_bpf_cty::c_char,
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_io_v4 {
    pub guard: __s32,
    pub protocol: __u32,
    pub subprotocol: __u32,
    pub request_len: __u32,
    pub request: __u64,
    pub request_tag: __u64,
    pub request_attr: __u32,
    pub request_priority: __u32,
    pub request_extra: __u32,
    pub max_response_len: __u32,
    pub response: __u64,
    pub dout_iovec_count: __u32,
    pub dout_xfer_len: __u32,
    pub din_iovec_count: __u32,
    pub din_xfer_len: __u32,
    pub dout_xferp: __u64,
    pub din_xferp: __u64,
    pub timeout: __u32,
    pub flags: __u32,
    pub usr_ptr: __u64,
    pub spare_in: __u32,
    pub driver_status: __u32,
    pub transport_status: __u32,
    pub device_status: __u32,
    pub retry_delay: __u32,
    pub info: __u32,
    pub duration: __u32,
    pub response_len: __u32,
    pub din_resid: __s32,
    pub dout_resid: __s32,
    pub generated_tag: __u64,
    pub spare_out: __u32,
    pub padding: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bsg_ops {
    pub check_proto:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sg_io_v4) -> ::aya_bpf_cty::c_int>,
    pub fill_hdr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request,
            arg2: *mut sg_io_v4,
            arg3: fmode_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub complete_rq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request, arg2: *mut sg_io_v4) -> ::aya_bpf_cty::c_int,
    >,
    pub free_rq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
}
pub type req_flags_t = __u32;
pub type rq_end_io_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: blk_status_t)>;
pub mod mq_rq_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MQ_RQ_IDLE: Type = 0;
    pub const MQ_RQ_IN_FLIGHT: Type = 1;
    pub const MQ_RQ_COMPLETE: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    pub q: *mut request_queue,
    pub mq_ctx: *mut blk_mq_ctx,
    pub mq_hctx: *mut blk_mq_hw_ctx,
    pub cmd_flags: ::aya_bpf_cty::c_uint,
    pub rq_flags: req_flags_t,
    pub tag: ::aya_bpf_cty::c_int,
    pub internal_tag: ::aya_bpf_cty::c_int,
    pub __data_len: ::aya_bpf_cty::c_uint,
    pub __sector: sector_t,
    pub bio: *mut bio,
    pub biotail: *mut bio,
    pub queuelist: list_head,
    pub __bindgen_anon_1: request__bindgen_ty_1,
    pub __bindgen_anon_2: request__bindgen_ty_2,
    pub __bindgen_anon_3: request__bindgen_ty_3,
    pub rq_disk: *mut gendisk,
    pub part: *mut block_device,
    pub alloc_time_ns: u64_,
    pub start_time_ns: u64_,
    pub io_start_time_ns: u64_,
    pub wbt_flags: ::aya_bpf_cty::c_ushort,
    pub stats_sectors: ::aya_bpf_cty::c_ushort,
    pub nr_phys_segments: ::aya_bpf_cty::c_ushort,
    pub nr_integrity_segments: ::aya_bpf_cty::c_ushort,
    pub crypt_ctx: *mut bio_crypt_ctx,
    pub crypt_keyslot: *mut blk_ksm_keyslot,
    pub write_hint: ::aya_bpf_cty::c_ushort,
    pub ioprio: ::aya_bpf_cty::c_ushort,
    pub state: mq_rq_state::Type,
    pub ref_: refcount_t,
    pub timeout: ::aya_bpf_cty::c_uint,
    pub deadline: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_4: request__bindgen_ty_4,
    pub end_io: rq_end_io_fn,
    pub end_io_data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_1 {
    pub hash: hlist_node,
    pub ipi_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_2 {
    pub rb_node: rb_node,
    pub special_vec: bio_vec,
    pub completion_data: *mut ::aya_bpf_cty::c_void,
    pub error_count: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_3 {
    pub elv: request__bindgen_ty_3__bindgen_ty_1,
    pub flush: request__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_3__bindgen_ty_1 {
    pub icq: *mut io_cq,
    pub priv_: [*mut ::aya_bpf_cty::c_void; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_3__bindgen_ty_2 {
    pub seq: ::aya_bpf_cty::c_uint,
    pub list: list_head,
    pub saved_end_io: rq_end_io_fn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_4 {
    pub csd: __call_single_data,
    pub fifo_time: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_zone {
    pub start: __u64,
    pub len: __u64,
    pub wp: __u64,
    pub type_: __u8,
    pub cond: __u8,
    pub non_seq: __u8,
    pub reset: __u8,
    pub resv: [__u8; 4usize],
    pub capacity: __u64,
    pub reserved: [__u8; 24usize],
}
pub mod elv_merge {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ELEVATOR_NO_MERGE: Type = 0;
    pub const ELEVATOR_FRONT_MERGE: Type = 1;
    pub const ELEVATOR_BACK_MERGE: Type = 2;
    pub const ELEVATOR_DISCARD_MERGE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elevator_mq_ops {
    pub init_sched: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request_queue,
            arg2: *mut elevator_type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub exit_sched: ::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub depth_updated: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub allow_merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut bio) -> bool_,
    >,
    pub bio_merge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut bio,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> bool_,
    >,
    pub request_merge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request_queue,
            arg2: *mut *mut request,
            arg3: *mut bio,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub request_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: elv_merge::Type),
    >,
    pub requests_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
    >,
    pub limit_depth: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_uint, arg2: *mut blk_mq_alloc_data),
    >,
    pub prepare_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub finish_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub insert_requests: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut list_head, arg3: bool_),
    >,
    pub dispatch_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> *mut request>,
    pub has_work: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>,
    pub completed_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: u64_)>,
    pub requeue_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub former_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub next_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub init_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
    pub exit_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elevator_type {
    pub icq_cache: *mut kmem_cache,
    pub ops: elevator_mq_ops,
    pub icq_size: size_t,
    pub icq_align: size_t,
    pub elevator_attrs: *mut elv_fs_entry,
    pub elevator_name: *const ::aya_bpf_cty::c_char,
    pub elevator_alias: *const ::aya_bpf_cty::c_char,
    pub elevator_features: ::aya_bpf_cty::c_uint,
    pub elevator_owner: *mut module,
    pub queue_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub hctx_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub icq_cache_name: [::aya_bpf_cty::c_char; 22usize],
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    pub type_: *mut elevator_type,
    pub elevator_data: *mut ::aya_bpf_cty::c_void,
    pub kobj: kobject,
    pub sysfs_lock: mutex,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub hash: [hlist_head; 64usize],
}
impl elevator_queue {
    #[inline]
    pub fn registered(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        registered: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let registered: u32 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elv_fs_entry {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut elevator_queue,
            arg2: *mut ::aya_bpf_cty::c_char,
        ) -> ssize_t,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut elevator_queue,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: size_t,
        ) -> ssize_t,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_debugfs_attr {
    pub name: *const ::aya_bpf_cty::c_char,
    pub mode: umode_t,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_void,
            arg2: *mut seq_file,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_void,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub seq_ops: *const seq_operations,
}
pub mod blk_eh_timer_return {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BLK_EH_DONE: Type = 0;
    pub const BLK_EH_RESET_TIMER: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_ops {
    pub queue_rq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *const blk_mq_queue_data,
        ) -> blk_status_t,
    >,
    pub commit_rqs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub get_budget: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>,
    pub put_budget: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue)>,
    pub timeout: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request, arg2: bool_) -> blk_eh_timer_return::Type,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> ::aya_bpf_cty::c_int,
    >,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub init_request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_tag_set,
            arg2: *mut request,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub exit_request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_tag_set,
            arg2: *mut request,
            arg3: ::aya_bpf_cty::c_uint,
        ),
    >,
    pub initialize_rq_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub cleanup_rq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub busy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>,
    pub map_queues: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_tag_set) -> ::aya_bpf_cty::c_int,
    >,
    pub show_rq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut request)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_iter {
    pub prot_buf: *mut ::aya_bpf_cty::c_void,
    pub data_buf: *mut ::aya_bpf_cty::c_void,
    pub seed: sector_t,
    pub data_size: ::aya_bpf_cty::c_uint,
    pub interval: ::aya_bpf_cty::c_ushort,
    pub disk_name: *const ::aya_bpf_cty::c_char,
}
pub mod pr_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PR_WRITE_EXCLUSIVE: Type = 1;
    pub const PR_EXCLUSIVE_ACCESS: Type = 2;
    pub const PR_WRITE_EXCLUSIVE_REG_ONLY: Type = 3;
    pub const PR_EXCLUSIVE_ACCESS_REG_ONLY: Type = 4;
    pub const PR_WRITE_EXCLUSIVE_ALL_REGS: Type = 5;
    pub const PR_EXCLUSIVE_ACCESS_ALL_REGS: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pr_ops {
    pub pr_register: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: u64_,
            arg4: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pr_reserve: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: pr_type::Type,
            arg4: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pr_release: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: pr_type::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pr_preempt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: u64_,
            arg4: pr_type::Type,
            arg5: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pr_clear: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: u64_) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg {
    pub css: cgroup_subsys_state,
    pub lock: spinlock_t,
    pub online_pin: refcount_t,
    pub blkg_tree: xarray,
    pub blkg_hint: *mut blkcg_gq,
    pub blkg_list: hlist_head,
    pub cpd: [*mut blkcg_policy_data; 5usize],
    pub all_blkcgs_node: list_head,
    pub cgwb_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkcg_policy_data {
    pub blkcg: *mut blkcg,
    pub plid: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_policy_data {
    pub blkg: *mut blkcg_gq,
    pub plid: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats_percpu {
    pub stat: [::aya_bpf_cty::c_long; 41usize],
    pub events: [::aya_bpf_cty::c_ulong; 96usize],
    pub nr_page_events: ::aya_bpf_cty::c_ulong,
    pub targets: [::aya_bpf_cty::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_reclaim_iter {
    pub position: *mut mem_cgroup,
    pub generation: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec_stat {
    pub count: [::aya_bpf_cty::c_long; 38usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct memcg_shrinker_map {
    pub rcu: callback_head,
    pub map: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_per_node {
    pub lruvec: lruvec,
    pub lruvec_stat_local: *mut lruvec_stat,
    pub lruvec_stat_cpu: *mut lruvec_stat,
    pub lruvec_stat: [atomic_long_t; 38usize],
    pub lru_zone_size: [::aya_bpf_cty::c_ulong; 25usize],
    pub iter: mem_cgroup_reclaim_iter,
    pub shrinker_map: *mut memcg_shrinker_map,
    pub tree_node: rb_node,
    pub usage_in_excess: ::aya_bpf_cty::c_ulong,
    pub on_tree: bool_,
    pub memcg: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventfd_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_threshold {
    pub eventfd: *mut eventfd_ctx,
    pub threshold: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct mem_cgroup_threshold_ary {
    pub current_threshold: ::aya_bpf_cty::c_int,
    pub size: ::aya_bpf_cty::c_uint,
    pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obj_cgroup {
    pub refcnt: percpu_ref,
    pub memcg: *mut mem_cgroup,
    pub nr_charged_bytes: atomic_t,
    pub __bindgen_anon_1: obj_cgroup__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obj_cgroup__bindgen_ty_1 {
    pub list: list_head,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_cluster {
    pub index: swap_cluster_info,
    pub next: ::aya_bpf_cty::c_uint,
}
pub mod fs_value_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const fs_value_is_undefined: Type = 0;
    pub const fs_value_is_flag: Type = 1;
    pub const fs_value_is_string: Type = 2;
    pub const fs_value_is_blob: Type = 3;
    pub const fs_value_is_filename: Type = 4;
    pub const fs_value_is_file: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    pub key: *const ::aya_bpf_cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: fs_parameter__bindgen_ty_1,
    pub size: size_t,
    pub dirfd: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parameter__bindgen_ty_1 {
    pub string: *mut ::aya_bpf_cty::c_char,
    pub blob: *mut ::aya_bpf_cty::c_void,
    pub name: *mut filename,
    pub file: *mut file,
}
impl fs_parameter {
    #[inline]
    pub fn type_(&self) -> fs_value_type::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: fs_value_type::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: fs_value_type::Type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fc_log {
    pub usage: refcount_t,
    pub head: u8_,
    pub tail: u8_,
    pub need_free: u8_,
    pub owner: *mut module,
    pub buffer: [*mut ::aya_bpf_cty::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_context_operations {
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context)>,
    pub dup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context, arg2: *mut fs_context) -> ::aya_bpf_cty::c_int,
    >,
    pub parse_param: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fs_context,
            arg2: *mut fs_parameter,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub parse_monolithic: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fs_context,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_tree:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
    pub reconfigure:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parse_result {
    pub negated: bool_,
    pub __bindgen_anon_1: fs_parse_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parse_result__bindgen_ty_1 {
    pub boolean: bool_,
    pub int_32: ::aya_bpf_cty::c_int,
    pub uint_32: ::aya_bpf_cty::c_uint,
    pub uint_64: u64_,
}
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub type __wsum = __u32;
pub type slab_flags_t = ::aya_bpf_cty::c_uint;
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut notifier_block,
        arg2: ::aya_bpf_cty::c_ulong,
        arg3: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
pub type __addrpair = __u64;
pub type __portpair = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct possible_net_t {
    pub net: *mut net,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
#[repr(C)]
pub struct sock_common {
    pub __bindgen_anon_1: sock_common__bindgen_ty_1,
    pub __bindgen_anon_2: sock_common__bindgen_ty_2,
    pub __bindgen_anon_3: sock_common__bindgen_ty_3,
    pub skc_family: ::aya_bpf_cty::c_ushort,
    pub skc_state: ::aya_bpf_cty::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub skc_bound_dev_if: ::aya_bpf_cty::c_int,
    pub __bindgen_anon_4: sock_common__bindgen_ty_4,
    pub skc_prot: *mut proto,
    pub skc_net: possible_net_t,
    pub skc_v6_daddr: in6_addr,
    pub skc_v6_rcv_saddr: in6_addr,
    pub skc_cookie: atomic64_t,
    pub __bindgen_anon_5: sock_common__bindgen_ty_5,
    pub skc_dontcopy_begin: __IncompleteArrayField<::aya_bpf_cty::c_int>,
    pub __bindgen_anon_6: sock_common__bindgen_ty_6,
    pub skc_tx_queue_mapping: ::aya_bpf_cty::c_ushort,
    pub skc_rx_queue_mapping: ::aya_bpf_cty::c_ushort,
    pub __bindgen_anon_7: sock_common__bindgen_ty_7,
    pub skc_refcnt: refcount_t,
    pub skc_dontcopy_end: __IncompleteArrayField<::aya_bpf_cty::c_int>,
    pub __bindgen_anon_8: sock_common__bindgen_ty_8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_1 {
    pub skc_addrpair: __addrpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_common__bindgen_ty_1__bindgen_ty_1 {
    pub skc_daddr: __be32,
    pub skc_rcv_saddr: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_2 {
    pub skc_hash: ::aya_bpf_cty::c_uint,
    pub skc_u16hashes: [__u16; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_3 {
    pub skc_portpair: __portpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_common__bindgen_ty_3__bindgen_ty_1 {
    pub skc_dport: __be16,
    pub skc_num: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_4 {
    pub skc_bind_node: hlist_node,
    pub skc_portaddr_node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_5 {
    pub skc_flags: ::aya_bpf_cty::c_ulong,
    pub skc_listener: *mut sock,
    pub skc_tw_dr: *mut inet_timewait_death_row,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_6 {
    pub skc_node: hlist_node,
    pub skc_nulls_node: hlist_nulls_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_7 {
    pub skc_incoming_cpu: ::aya_bpf_cty::c_int,
    pub skc_rcv_wnd: u32_,
    pub skc_tw_rcv_nxt: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_8 {
    pub skc_rxhash: u32_,
    pub skc_window_clamp: u32_,
    pub skc_tw_snd_nxt: u32_,
}
impl sock_common {
    #[inline]
    pub fn skc_reuse(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuse(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_reuseport(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuseport(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_ipv6only(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_ipv6only(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_net_refcnt(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_net_refcnt(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        skc_reuse: ::aya_bpf_cty::c_uchar,
        skc_reuseport: ::aya_bpf_cty::c_uchar,
        skc_ipv6only: ::aya_bpf_cty::c_uchar,
        skc_net_refcnt: ::aya_bpf_cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let skc_reuse: u8 = unsafe { ::core::mem::transmute(skc_reuse) };
            skc_reuse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skc_reuseport: u8 = unsafe { ::core::mem::transmute(skc_reuseport) };
            skc_reuseport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skc_ipv6only: u8 = unsafe { ::core::mem::transmute(skc_ipv6only) };
            skc_ipv6only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let skc_net_refcnt: u8 = unsafe { ::core::mem::transmute(skc_net_refcnt) };
            skc_net_refcnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_lock_t {
    pub slock: spinlock_t,
    pub owned: ::aya_bpf_cty::c_int,
    pub wq: wait_queue_head_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
pub type netdev_features_t = u64_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_cgroup_data {
    pub __bindgen_anon_1: sock_cgroup_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_cgroup_data__bindgen_ty_1 {
    pub __bindgen_anon_1: sock_cgroup_data__bindgen_ty_1__bindgen_ty_1,
    pub val: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_cgroup_data__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub padding: u8_,
    pub prioidx: u16_,
    pub classid: u32_,
}
impl sock_cgroup_data__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn is_data(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_data(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_refcnt(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_refcnt(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_data: u8_,
        no_refcnt: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_data: u8 = unsafe { ::core::mem::transmute(is_data) };
            is_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_refcnt: u8 = unsafe { ::core::mem::transmute(no_refcnt) };
            no_refcnt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sock {
    pub __sk_common: sock_common,
    pub sk_lock: socket_lock_t,
    pub sk_drops: atomic_t,
    pub sk_rcvlowat: ::aya_bpf_cty::c_int,
    pub sk_error_queue: sk_buff_head,
    pub sk_rx_skb_cache: *mut sk_buff,
    pub sk_receive_queue: sk_buff_head,
    pub sk_backlog: sock__bindgen_ty_1,
    pub sk_forward_alloc: ::aya_bpf_cty::c_int,
    pub sk_ll_usec: ::aya_bpf_cty::c_uint,
    pub sk_napi_id: ::aya_bpf_cty::c_uint,
    pub sk_rcvbuf: ::aya_bpf_cty::c_int,
    pub sk_filter: *mut sk_filter,
    pub __bindgen_anon_1: sock__bindgen_ty_2,
    pub sk_policy: [*mut xfrm_policy; 2usize],
    pub sk_rx_dst: *mut dst_entry,
    pub sk_dst_cache: *mut dst_entry,
    pub sk_omem_alloc: atomic_t,
    pub sk_sndbuf: ::aya_bpf_cty::c_int,
    pub sk_wmem_queued: ::aya_bpf_cty::c_int,
    pub sk_wmem_alloc: refcount_t,
    pub sk_tsq_flags: ::aya_bpf_cty::c_ulong,
    pub __bindgen_anon_2: sock__bindgen_ty_3,
    pub sk_tx_skb_cache: *mut sk_buff,
    pub sk_write_queue: sk_buff_head,
    pub sk_peek_off: __s32,
    pub sk_write_pending: ::aya_bpf_cty::c_int,
    pub sk_dst_pending_confirm: __u32,
    pub sk_pacing_status: u32_,
    pub sk_sndtimeo: ::aya_bpf_cty::c_long,
    pub sk_timer: timer_list,
    pub sk_priority: __u32,
    pub sk_mark: __u32,
    pub sk_pacing_rate: ::aya_bpf_cty::c_ulong,
    pub sk_max_pacing_rate: ::aya_bpf_cty::c_ulong,
    pub sk_frag: page_frag,
    pub sk_route_caps: netdev_features_t,
    pub sk_route_nocaps: netdev_features_t,
    pub sk_route_forced_caps: netdev_features_t,
    pub sk_gso_type: ::aya_bpf_cty::c_int,
    pub sk_gso_max_size: ::aya_bpf_cty::c_uint,
    pub sk_allocation: gfp_t,
    pub sk_txhash: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub sk_pacing_shift: u8_,
    pub sk_type: u16_,
    pub sk_protocol: u16_,
    pub sk_gso_max_segs: u16_,
    pub sk_lingertime: ::aya_bpf_cty::c_ulong,
    pub sk_prot_creator: *mut proto,
    pub sk_callback_lock: rwlock_t,
    pub sk_err: ::aya_bpf_cty::c_int,
    pub sk_err_soft: ::aya_bpf_cty::c_int,
    pub sk_ack_backlog: u32_,
    pub sk_max_ack_backlog: u32_,
    pub sk_uid: kuid_t,
    pub sk_prefer_busy_poll: u8_,
    pub sk_busy_poll_budget: u16_,
    pub sk_peer_pid: *mut pid,
    pub sk_peer_cred: *const cred,
    pub sk_rcvtimeo: ::aya_bpf_cty::c_long,
    pub sk_stamp: ktime_t,
    pub sk_tsflags: u16_,
    pub sk_shutdown: u8_,
    pub sk_tskey: u32_,
    pub sk_zckey: atomic_t,
    pub sk_clockid: u8_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub sk_socket: *mut socket,
    pub sk_user_data: *mut ::aya_bpf_cty::c_void,
    pub sk_security: *mut ::aya_bpf_cty::c_void,
    pub sk_cgrp_data: sock_cgroup_data,
    pub sk_memcg: *mut mem_cgroup,
    pub sk_state_change: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_data_ready: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_error_report: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub sk_validate_xmit_skb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut net_device,
            arg3: *mut sk_buff,
        ) -> *mut sk_buff,
    >,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_reuseport_cb: *mut sock_reuseport,
    pub sk_bpf_storage: *mut bpf_local_storage,
    pub sk_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock__bindgen_ty_1 {
    pub rmem_alloc: atomic_t,
    pub len: ::aya_bpf_cty::c_int,
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_2 {
    pub sk_wq: *mut socket_wq,
    pub sk_wq_raw: *mut socket_wq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_3 {
    pub sk_send_head: *mut sk_buff,
    pub tcp_rtx_queue: rb_root,
}
impl sock {
    #[inline]
    pub fn sk_padding(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_padding(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_kern_sock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_kern_sock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_tx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_tx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_rx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_rx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_userlocks(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sk_userlocks(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sk_padding: u8_,
        sk_kern_sock: u8_,
        sk_no_check_tx: u8_,
        sk_no_check_rx: u8_,
        sk_userlocks: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_padding: u8 = unsafe { ::core::mem::transmute(sk_padding) };
            sk_padding as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_kern_sock: u8 = unsafe { ::core::mem::transmute(sk_kern_sock) };
            sk_kern_sock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sk_no_check_tx: u8 = unsafe { ::core::mem::transmute(sk_no_check_tx) };
            sk_no_check_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sk_no_check_rx: u8 = unsafe { ::core::mem::transmute(sk_no_check_rx) };
            sk_no_check_rx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sk_userlocks: u8 = unsafe { ::core::mem::transmute(sk_userlocks) };
            sk_userlocks as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sk_txtime_deadline_mode(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_deadline_mode(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_report_errors(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_report_errors(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sk_txtime_deadline_mode: u8_,
        sk_txtime_report_errors: u8_,
        sk_txtime_unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_txtime_deadline_mode: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_deadline_mode) };
            sk_txtime_deadline_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_txtime_report_errors: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_report_errors) };
            sk_txtime_report_errors as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let sk_txtime_unused: u8 = unsafe { ::core::mem::transmute(sk_txtime_unused) };
            sk_txtime_unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const ::aya_bpf_cty::c_void,
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_void, arg2: u32_, arg3: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_void, arg2: u32_, arg3: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rhashtable_compare_arg,
        arg2: *const ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: ::aya_bpf_cty::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: ::aya_bpf_cty::c_uint,
    pub max_elems: ::aya_bpf_cty::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_struct {
    pub users: ::aya_bpf_cty::c_int,
    pub lock: spinlock_t,
    pub seq: seqcount_spinlock_t,
    pub umask: ::aya_bpf_cty::c_int,
    pub in_exec: ::aya_bpf_cty::c_int,
    pub root: path,
    pub pwd: path,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    pub mutex: mutex,
    pub rd_wait: wait_queue_head_t,
    pub wr_wait: wait_queue_head_t,
    pub head: ::aya_bpf_cty::c_uint,
    pub tail: ::aya_bpf_cty::c_uint,
    pub max_usage: ::aya_bpf_cty::c_uint,
    pub ring_size: ::aya_bpf_cty::c_uint,
    pub note_loss: bool_,
    pub nr_accounted: ::aya_bpf_cty::c_uint,
    pub readers: ::aya_bpf_cty::c_uint,
    pub writers: ::aya_bpf_cty::c_uint,
    pub files: ::aya_bpf_cty::c_uint,
    pub r_counter: ::aya_bpf_cty::c_uint,
    pub w_counter: ::aya_bpf_cty::c_uint,
    pub tmp_page: *mut page,
    pub fasync_readers: *mut fasync_struct,
    pub fasync_writers: *mut fasync_struct,
    pub bufs: *mut pipe_buffer,
    pub user: *mut user_struct,
    pub watch_queue: *mut watch_queue,
}
pub type __kernel_sa_family_t = ::aya_bpf_cty::c_ushort;
pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::aya_bpf_cty::c_char; 14usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::aya_bpf_cty::c_void,
    pub msg_namelen: ::aya_bpf_cty::c_int,
    pub msg_iter: iov_iter,
    pub __bindgen_anon_1: msghdr__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub msg_controllen: __kernel_size_t,
    pub msg_flags: ::aya_bpf_cty::c_uint,
    pub msg_iocb: *mut kiocb,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msghdr__bindgen_ty_1 {
    pub msg_control: *mut ::aya_bpf_cty::c_void,
    pub msg_control_user: *mut ::aya_bpf_cty::c_void,
}
impl msghdr {
    #[inline]
    pub fn msg_control_is_user(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_control_is_user(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(msg_control_is_user: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_control_is_user: u8 = unsafe { ::core::mem::transmute(msg_control_is_user) };
            msg_control_is_user as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: ::aya_bpf_cty::c_uint,
    pub clock_type: ::aya_bpf_cty::c_uint,
    pub loopback: ::aya_bpf_cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: ::aya_bpf_cty::c_uint,
    pub clock_type: ::aya_bpf_cty::c_uint,
    pub loopback: ::aya_bpf_cty::c_ushort,
    pub slot_map: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: ::aya_bpf_cty::c_ushort,
    pub parity: ::aya_bpf_cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto {
    pub t391: ::aya_bpf_cty::c_uint,
    pub t392: ::aya_bpf_cty::c_uint,
    pub n391: ::aya_bpf_cty::c_uint,
    pub n392: ::aya_bpf_cty::c_uint,
    pub n393: ::aya_bpf_cty::c_uint,
    pub lmi: ::aya_bpf_cty::c_ushort,
    pub dce: ::aya_bpf_cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: ::aya_bpf_cty::c_uint,
    pub master: [::aya_bpf_cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cisco_proto {
    pub interval: ::aya_bpf_cty::c_uint,
    pub timeout: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: ::aya_bpf_cty::c_ushort,
    pub modulo: ::aya_bpf_cty::c_uint,
    pub window: ::aya_bpf_cty::c_uint,
    pub t1: ::aya_bpf_cty::c_uint,
    pub t2: ::aya_bpf_cty::c_uint,
    pub n2: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifmap {
    pub mem_start: ::aya_bpf_cty::c_ulong,
    pub mem_end: ::aya_bpf_cty::c_ulong,
    pub base_addr: ::aya_bpf_cty::c_ushort,
    pub irq: ::aya_bpf_cty::c_uchar,
    pub dma: ::aya_bpf_cty::c_uchar,
    pub port: ::aya_bpf_cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: ::aya_bpf_cty::c_uint,
    pub size: ::aya_bpf_cty::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [::aya_bpf_cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: ::aya_bpf_cty::c_short,
    pub ifru_ivalue: ::aya_bpf_cty::c_int,
    pub ifru_mtu: ::aya_bpf_cty::c_int,
    pub ifru_map: ifmap,
    pub ifru_slave: [::aya_bpf_cty::c_char; 16usize],
    pub ifru_newname: [::aya_bpf_cty::c_char; 16usize],
    pub ifru_data: *mut ::aya_bpf_cty::c_void,
    pub ifru_settings: if_settings,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ld_semaphore {
    pub count: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub wait_readers: ::aya_bpf_cty::c_uint,
    pub read_wait: list_head,
    pub write_wait: list_head,
}
pub type tcflag_t = ::aya_bpf_cty::c_uint;
pub type cc_t = ::aya_bpf_cty::c_uchar;
pub type speed_t = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktermios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 19usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::aya_bpf_cty::c_ushort,
    pub ws_col: ::aya_bpf_cty::c_ushort,
    pub ws_xpixel: ::aya_bpf_cty::c_ushort,
    pub ws_ypixel: ::aya_bpf_cty::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tty_struct {
    pub magic: ::aya_bpf_cty::c_int,
    pub kref: kref,
    pub dev: *mut device,
    pub driver: *mut tty_driver,
    pub ops: *const tty_operations,
    pub index: ::aya_bpf_cty::c_int,
    pub ldisc_sem: ld_semaphore,
    pub ldisc: *mut tty_ldisc,
    pub atomic_write_lock: mutex,
    pub legacy_mutex: mutex,
    pub throttle_mutex: mutex,
    pub termios_rwsem: rw_semaphore,
    pub winsize_mutex: mutex,
    pub ctrl_lock: spinlock_t,
    pub flow_lock: spinlock_t,
    pub termios: ktermios,
    pub termios_locked: ktermios,
    pub name: [::aya_bpf_cty::c_char; 64usize],
    pub pgrp: *mut pid,
    pub session: *mut pid,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub count: ::aya_bpf_cty::c_int,
    pub winsize: winsize,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub hw_stopped: ::aya_bpf_cty::c_int,
    pub _bitfield_align_2: [u64; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 15usize]>,
    pub receive_room: ::aya_bpf_cty::c_uint,
    pub flow_change: ::aya_bpf_cty::c_int,
    pub link: *mut tty_struct,
    pub fasync: *mut fasync_struct,
    pub write_wait: wait_queue_head_t,
    pub read_wait: wait_queue_head_t,
    pub hangup_work: work_struct,
    pub disc_data: *mut ::aya_bpf_cty::c_void,
    pub driver_data: *mut ::aya_bpf_cty::c_void,
    pub files_lock: spinlock_t,
    pub tty_files: list_head,
    pub closing: ::aya_bpf_cty::c_int,
    pub write_buf: *mut ::aya_bpf_cty::c_uchar,
    pub write_cnt: ::aya_bpf_cty::c_int,
    pub SAK_work: work_struct,
    pub port: *mut tty_port,
}
impl tty_struct {
    #[inline]
    pub fn stopped(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_stopped(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_stopped(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_flow_stopped(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        stopped: ::aya_bpf_cty::c_ulong,
        flow_stopped: ::aya_bpf_cty::c_ulong,
        unused: ::aya_bpf_cty::c_ulong,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let stopped: u64 = unsafe { ::core::mem::transmute(stopped) };
            stopped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_stopped: u64 = unsafe { ::core::mem::transmute(flow_stopped) };
            flow_stopped as u64
        });
        __bindgen_bitfield_unit.set(64usize, 62u8, {
            let unused: u64 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn ctrl_status(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ctrl_status(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn packet(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_packet(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused_ctrl(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(64usize, 55u8) as u64) }
    }
    #[inline]
    pub fn set_unused_ctrl(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(64usize, 55u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        ctrl_status: ::aya_bpf_cty::c_ulong,
        packet: ::aya_bpf_cty::c_ulong,
        unused_ctrl: ::aya_bpf_cty::c_ulong,
    ) -> __BindgenBitfieldUnit<[u8; 15usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 15usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ctrl_status: u64 = unsafe { ::core::mem::transmute(ctrl_status) };
            ctrl_status as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let packet: u64 = unsafe { ::core::mem::transmute(packet) };
            packet as u64
        });
        __bindgen_bitfield_unit.set(64usize, 55u8, {
            let unused_ctrl: u64 = unsafe { ::core::mem::transmute(unused_ctrl) };
            unused_ctrl as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: size_t,
    pub count: size_t,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut ::aya_bpf_cty::c_char,
    pub data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl_entry {
    pub e_tag: ::aya_bpf_cty::c_short,
    pub e_perm: ::aya_bpf_cty::c_ushort,
    pub __bindgen_anon_1: posix_acl_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union posix_acl_entry__bindgen_ty_1 {
    pub e_uid: kuid_t,
    pub e_gid: kgid_t,
}
#[repr(C)]
pub struct posix_acl {
    pub a_refcount: refcount_t,
    pub a_rcu: callback_head,
    pub a_count: ::aya_bpf_cty::c_uint,
    pub a_entries: __IncompleteArrayField<posix_acl_entry>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: *mut file,
            arg3: ::aya_bpf_cty::c_int,
        ) -> *mut tty_struct,
    >,
    pub install: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_driver, arg2: *mut tty_struct) -> ::aya_bpf_cty::c_int,
    >,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_driver, arg2: *mut tty_struct)>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file) -> ::aya_bpf_cty::c_int,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf_cty::c_uchar,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub put_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf_cty::c_uchar,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flush_chars: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub write_room:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    pub chars_in_buffer:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub set_termios:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut ktermios)>,
    pub throttle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub unthrottle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub hangup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub break_ctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flush_buffer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub set_ldisc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub wait_until_sent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_int),
    >,
    pub send_xchar: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_char),
    >,
    pub tiocmget:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    pub tiocmset: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub resize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut winsize) -> ::aya_bpf_cty::c_int,
    >,
    pub get_icount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_icounter_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_serial: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_serial: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut seq_file)>,
    pub poll_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_char,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub poll_get_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub poll_put_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_char,
        ),
    >,
    pub proc_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_driver {
    pub magic: ::aya_bpf_cty::c_int,
    pub kref: kref,
    pub cdevs: *mut *mut cdev,
    pub owner: *mut module,
    pub driver_name: *const ::aya_bpf_cty::c_char,
    pub name: *const ::aya_bpf_cty::c_char,
    pub name_base: ::aya_bpf_cty::c_int,
    pub major: ::aya_bpf_cty::c_int,
    pub minor_start: ::aya_bpf_cty::c_int,
    pub num: ::aya_bpf_cty::c_uint,
    pub type_: ::aya_bpf_cty::c_short,
    pub subtype: ::aya_bpf_cty::c_short,
    pub init_termios: ktermios,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub proc_entry: *mut proc_dir_entry,
    pub other: *mut tty_driver,
    pub ttys: *mut *mut tty_struct,
    pub ports: *mut *mut tty_port,
    pub termios: *mut *mut ktermios,
    pub driver_state: *mut ::aya_bpf_cty::c_void,
    pub ops: *const tty_operations,
    pub tty_drivers: list_head,
}
#[repr(C)]
pub struct tty_buffer {
    pub __bindgen_anon_1: tty_buffer__bindgen_ty_1,
    pub used: ::aya_bpf_cty::c_int,
    pub size: ::aya_bpf_cty::c_int,
    pub commit: ::aya_bpf_cty::c_int,
    pub read: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub data: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tty_buffer__bindgen_ty_1 {
    pub next: *mut tty_buffer,
    pub free: llist_node,
}
#[repr(C)]
pub struct tty_bufhead {
    pub head: *mut tty_buffer,
    pub work: work_struct,
    pub lock: mutex,
    pub priority: atomic_t,
    pub sentinel: tty_buffer,
    pub free: llist_head,
    pub mem_used: atomic_t,
    pub mem_limit: ::aya_bpf_cty::c_int,
    pub tail: *mut tty_buffer,
}
#[repr(C)]
pub struct tty_port {
    pub buf: tty_bufhead,
    pub tty: *mut tty_struct,
    pub itty: *mut tty_struct,
    pub ops: *const tty_port_operations,
    pub client_ops: *const tty_port_client_operations,
    pub lock: spinlock_t,
    pub blocked_open: ::aya_bpf_cty::c_int,
    pub count: ::aya_bpf_cty::c_int,
    pub open_wait: wait_queue_head_t,
    pub delta_msr_wait: wait_queue_head_t,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub iflags: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mutex: mutex,
    pub buf_mutex: mutex,
    pub xmit_buf: *mut ::aya_bpf_cty::c_uchar,
    pub close_delay: ::aya_bpf_cty::c_uint,
    pub closing_wait: ::aya_bpf_cty::c_uint,
    pub drain_delay: ::aya_bpf_cty::c_int,
    pub kref: kref,
    pub client_data: *mut ::aya_bpf_cty::c_void,
}
impl tty_port {
    #[inline]
    pub fn console(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_console(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn low_latency(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_low_latency(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        console: ::aya_bpf_cty::c_uchar,
        low_latency: ::aya_bpf_cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let console: u8 = unsafe { ::core::mem::transmute(console) };
            console as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let low_latency: u8 = unsafe { ::core::mem::transmute(low_latency) };
            low_latency as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_ldisc_ops {
    pub magic: ::aya_bpf_cty::c_int,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub num: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub open:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub flush_buffer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *mut ::aya_bpf_cty::c_uchar,
            arg4: size_t,
            arg5: *mut *mut ::aya_bpf_cty::c_void,
            arg6: ::aya_bpf_cty::c_ulong,
        ) -> ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *const ::aya_bpf_cty::c_uchar,
            arg4: size_t,
        ) -> ssize_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_termios:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut ktermios)>,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub hangup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    pub receive_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf_cty::c_uchar,
            arg3: *mut ::aya_bpf_cty::c_char,
            arg4: ::aya_bpf_cty::c_int,
        ),
    >,
    pub write_wakeup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub dcd_change: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub receive_buf2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf_cty::c_uchar,
            arg3: *mut ::aya_bpf_cty::c_char,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub owner: *mut module,
    pub refcount: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_ldisc {
    pub ops: *mut tty_ldisc_ops,
    pub tty: *mut tty_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_port_operations {
    pub carrier_raised:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port) -> ::aya_bpf_cty::c_int>,
    pub dtr_rts: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_port, arg2: ::aya_bpf_cty::c_int),
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_port, arg2: *mut tty_struct) -> ::aya_bpf_cty::c_int,
    >,
    pub destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_port_client_operations {
    pub receive_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_port,
            arg2: *const ::aya_bpf_cty::c_uchar,
            arg3: *const ::aya_bpf_cty::c_uchar,
            arg4: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write_wakeup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_core {
    pub sysctl_hdr: *mut ctl_table_header,
    pub sysctl_somaxconn: ::aya_bpf_cty::c_int,
    pub sock_inuse: *mut ::aya_bpf_cty::c_int,
    pub prot_inuse: *mut prot_inuse,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mib {
    pub tcp_statistics: *mut tcp_mib,
    pub ip_statistics: *mut ipstats_mib,
    pub net_statistics: *mut linux_mib,
    pub udp_statistics: *mut udp_mib,
    pub udplite_statistics: *mut udp_mib,
    pub icmp_statistics: *mut icmp_mib,
    pub icmpmsg_statistics: *mut icmpmsg_mib,
    pub proc_net_devsnmp6: *mut proc_dir_entry,
    pub udp_stats_in6: *mut udp_mib,
    pub udplite_stats_in6: *mut udp_mib,
    pub ipv6_statistics: *mut ipstats_mib,
    pub icmpv6_statistics: *mut icmpv6_mib,
    pub icmpv6msg_statistics: *mut icmpv6msg_mib,
    pub xfrm_statistics: *mut linux_xfrm_mib,
    pub tls_statistics: *mut linux_tls_mib,
    pub mptcp_statistics: *mut mptcp_mib,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_packet {
    pub sklist_lock: mutex,
    pub sklist: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_unix {
    pub sysctl_max_dgram_qlen: ::aya_bpf_cty::c_int,
    pub ctl: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nexthop {
    pub rb_root: rb_root,
    pub devhash: *mut hlist_head,
    pub seq: ::aya_bpf_cty::c_uint,
    pub last_id_allocated: u32_,
    pub notifier_chain: blocking_notifier_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_ports {
    pub lock: seqlock_t,
    pub range: [::aya_bpf_cty::c_int; 2usize],
    pub warned: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_timewait_death_row {
    pub tw_count: atomic_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 64usize]>,
    pub hashinfo: *mut inet_hashinfo,
    pub sysctl_max_tw_buckets: ::aya_bpf_cty::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ping_group_range {
    pub lock: seqlock_t,
    pub range: [kgid_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv4 {
    pub forw_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub ipv4_hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub xfrm4_hdr: *mut ctl_table_header,
    pub devconf_all: *mut ipv4_devconf,
    pub devconf_dflt: *mut ipv4_devconf,
    pub ra_chain: *mut ip_ra_chain,
    pub ra_mutex: mutex,
    pub rules_ops: *mut fib_rules_ops,
    pub fib_has_custom_rules: bool_,
    pub fib_rules_require_fldissect: ::aya_bpf_cty::c_uint,
    pub fib_main: *mut fib_table,
    pub fib_default: *mut fib_table,
    pub fib_has_custom_local_routes: bool_,
    pub fib_num_tclassid_users: ::aya_bpf_cty::c_int,
    pub fib_table_hash: *mut hlist_head,
    pub fib_offload_disabled: bool_,
    pub fibnl: *mut sock,
    pub icmp_sk: *mut *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub peers: *mut inet_peer_base,
    pub tcp_sk: *mut *mut sock,
    pub fqdir: *mut fqdir,
    pub iptable_filter: *mut xt_table,
    pub iptable_mangle: *mut xt_table,
    pub iptable_raw: *mut xt_table,
    pub arptable_filter: *mut xt_table,
    pub iptable_security: *mut xt_table,
    pub nat_table: *mut xt_table,
    pub sysctl_icmp_echo_ignore_all: ::aya_bpf_cty::c_int,
    pub sysctl_icmp_echo_ignore_broadcasts: ::aya_bpf_cty::c_int,
    pub sysctl_icmp_ignore_bogus_error_responses: ::aya_bpf_cty::c_int,
    pub sysctl_icmp_ratelimit: ::aya_bpf_cty::c_int,
    pub sysctl_icmp_ratemask: ::aya_bpf_cty::c_int,
    pub sysctl_icmp_errors_use_inbound_ifaddr: ::aya_bpf_cty::c_int,
    pub ip_local_ports: local_ports,
    pub sysctl_tcp_ecn: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_ecn_fallback: ::aya_bpf_cty::c_int,
    pub sysctl_ip_default_ttl: ::aya_bpf_cty::c_int,
    pub sysctl_ip_no_pmtu_disc: ::aya_bpf_cty::c_int,
    pub sysctl_ip_fwd_use_pmtu: ::aya_bpf_cty::c_int,
    pub sysctl_ip_fwd_update_priority: ::aya_bpf_cty::c_int,
    pub sysctl_ip_nonlocal_bind: ::aya_bpf_cty::c_int,
    pub sysctl_ip_autobind_reuse: ::aya_bpf_cty::c_int,
    pub sysctl_ip_dynaddr: ::aya_bpf_cty::c_int,
    pub sysctl_ip_early_demux: ::aya_bpf_cty::c_int,
    pub sysctl_raw_l3mdev_accept: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_early_demux: ::aya_bpf_cty::c_int,
    pub sysctl_udp_early_demux: ::aya_bpf_cty::c_int,
    pub sysctl_nexthop_compat_mode: ::aya_bpf_cty::c_int,
    pub sysctl_fwmark_reflect: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_fwmark_accept: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_l3mdev_accept: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_mtu_probing: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_mtu_probe_floor: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_base_mss: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_min_snd_mss: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_probe_threshold: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_probe_interval: u32_,
    pub sysctl_tcp_keepalive_time: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_keepalive_probes: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_keepalive_intvl: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_syn_retries: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_synack_retries: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_syncookies: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_reordering: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_retries1: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_retries2: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_orphan_retries: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_fin_timeout: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_notsent_lowat: ::aya_bpf_cty::c_uint,
    pub sysctl_tcp_tw_reuse: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_sack: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_window_scaling: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_timestamps: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_early_retrans: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_recovery: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_thin_linear_timeouts: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_slow_start_after_idle: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_retrans_collapse: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_stdurg: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_rfc1337: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_abort_on_overflow: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_fack: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_max_reordering: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_dsack: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_app_win: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_adv_win_scale: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_frto: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_nometrics_save: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_no_ssthresh_metrics_save: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_moderate_rcvbuf: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_tso_win_divisor: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_workaround_signed_windows: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_limit_output_bytes: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_challenge_ack_limit: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_min_tso_segs: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_min_rtt_wlen: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_autocorking: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_invalid_ratelimit: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_pacing_ss_ratio: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_pacing_ca_ratio: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_wmem: [::aya_bpf_cty::c_int; 3usize],
    pub sysctl_tcp_rmem: [::aya_bpf_cty::c_int; 3usize],
    pub sysctl_tcp_comp_sack_nr: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_comp_sack_delay_ns: ::aya_bpf_cty::c_ulong,
    pub sysctl_tcp_comp_sack_slack_ns: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub tcp_death_row: inet_timewait_death_row,
    pub sysctl_max_syn_backlog: ::aya_bpf_cty::c_int,
    pub sysctl_tcp_fastopen: ::aya_bpf_cty::c_int,
    pub tcp_congestion_control: *const tcp_congestion_ops,
    pub tcp_fastopen_ctx: *mut tcp_fastopen_context,
    pub tcp_fastopen_ctx_lock: spinlock_t,
    pub sysctl_tcp_fastopen_blackhole_timeout: ::aya_bpf_cty::c_uint,
    pub tfo_active_disable_times: atomic_t,
    pub tfo_active_disable_stamp: ::aya_bpf_cty::c_ulong,
    pub sysctl_tcp_reflect_tos: ::aya_bpf_cty::c_int,
    pub sysctl_udp_wmem_min: ::aya_bpf_cty::c_int,
    pub sysctl_udp_rmem_min: ::aya_bpf_cty::c_int,
    pub sysctl_udp_l3mdev_accept: ::aya_bpf_cty::c_int,
    pub sysctl_igmp_max_memberships: ::aya_bpf_cty::c_int,
    pub sysctl_igmp_max_msf: ::aya_bpf_cty::c_int,
    pub sysctl_igmp_llm_reports: ::aya_bpf_cty::c_int,
    pub sysctl_igmp_qrv: ::aya_bpf_cty::c_int,
    pub ping_group_range: ping_group_range,
    pub dev_addr_genid: atomic_t,
    pub sysctl_local_reserved_ports: *mut ::aya_bpf_cty::c_ulong,
    pub sysctl_ip_prot_sock: ::aya_bpf_cty::c_int,
    pub mr_tables: list_head,
    pub mr_rules_ops: *mut fib_rules_ops,
    pub sysctl_fib_multipath_use_neigh: ::aya_bpf_cty::c_int,
    pub sysctl_fib_multipath_hash_policy: ::aya_bpf_cty::c_int,
    pub notifier_ops: *mut fib_notifier_ops,
    pub fib_seq: ::aya_bpf_cty::c_uint,
    pub ipmr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: ::aya_bpf_cty::c_uint,
    pub rt_genid: atomic_t,
    pub ip_id_key: siphash_key_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_ipv6 {
    pub hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub icmp_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub xfrm6_hdr: *mut ctl_table_header,
    pub bindv6only: ::aya_bpf_cty::c_int,
    pub flush_delay: ::aya_bpf_cty::c_int,
    pub ip6_rt_max_size: ::aya_bpf_cty::c_int,
    pub ip6_rt_gc_min_interval: ::aya_bpf_cty::c_int,
    pub ip6_rt_gc_timeout: ::aya_bpf_cty::c_int,
    pub ip6_rt_gc_interval: ::aya_bpf_cty::c_int,
    pub ip6_rt_gc_elasticity: ::aya_bpf_cty::c_int,
    pub ip6_rt_mtu_expires: ::aya_bpf_cty::c_int,
    pub ip6_rt_min_advmss: ::aya_bpf_cty::c_int,
    pub multipath_hash_policy: ::aya_bpf_cty::c_int,
    pub flowlabel_consistency: ::aya_bpf_cty::c_int,
    pub auto_flowlabels: ::aya_bpf_cty::c_int,
    pub icmpv6_time: ::aya_bpf_cty::c_int,
    pub icmpv6_echo_ignore_all: ::aya_bpf_cty::c_int,
    pub icmpv6_echo_ignore_multicast: ::aya_bpf_cty::c_int,
    pub icmpv6_echo_ignore_anycast: ::aya_bpf_cty::c_int,
    pub icmpv6_ratemask: [::aya_bpf_cty::c_ulong; 4usize],
    pub icmpv6_ratemask_ptr: *mut ::aya_bpf_cty::c_ulong,
    pub anycast_src_echo_reply: ::aya_bpf_cty::c_int,
    pub ip_nonlocal_bind: ::aya_bpf_cty::c_int,
    pub fwmark_reflect: ::aya_bpf_cty::c_int,
    pub idgen_retries: ::aya_bpf_cty::c_int,
    pub idgen_delay: ::aya_bpf_cty::c_int,
    pub flowlabel_state_ranges: ::aya_bpf_cty::c_int,
    pub flowlabel_reflect: ::aya_bpf_cty::c_int,
    pub max_dst_opts_cnt: ::aya_bpf_cty::c_int,
    pub max_hbh_opts_cnt: ::aya_bpf_cty::c_int,
    pub max_dst_opts_len: ::aya_bpf_cty::c_int,
    pub max_hbh_opts_len: ::aya_bpf_cty::c_int,
    pub seg6_flowlabel: ::aya_bpf_cty::c_int,
    pub skip_notify_on_dev_down: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_ops {
    pub family: ::aya_bpf_cty::c_ushort,
    pub gc_thresh: ::aya_bpf_cty::c_uint,
    pub gc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_ops) -> ::aya_bpf_cty::c_int>,
    pub check: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: __u32) -> *mut dst_entry,
    >,
    pub default_advmss: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf_cty::c_uint,
    >,
    pub mtu: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf_cty::c_uint,
    >,
    pub cow_metrics: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: ::aya_bpf_cty::c_ulong) -> *mut u32_,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>,
    pub ifdown: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dst_entry,
            arg2: *mut net_device,
            arg3: ::aya_bpf_cty::c_int,
        ),
    >,
    pub negative_advice:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>,
    pub link_failure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub update_pmtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dst_entry,
            arg2: *mut sock,
            arg3: *mut sk_buff,
            arg4: u32_,
            arg5: bool_,
        ),
    >,
    pub redirect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: *mut sock, arg3: *mut sk_buff),
    >,
    pub local_out: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub neigh_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dst_entry,
            arg2: *mut sk_buff,
            arg3: *const ::aya_bpf_cty::c_void,
        ) -> *mut neighbour,
    >,
    pub confirm_neigh: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry, arg2: *const ::aya_bpf_cty::c_void),
    >,
    pub kmem_cachep: *mut kmem_cache,
    pub pcpuc_entries: percpu_counter,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl dst_ops {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6 {
    pub sysctl: netns_sysctl_ipv6,
    pub devconf_all: *mut ipv6_devconf,
    pub devconf_dflt: *mut ipv6_devconf,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub ip6table_filter: *mut xt_table,
    pub ip6table_mangle: *mut xt_table,
    pub ip6table_raw: *mut xt_table,
    pub ip6table_security: *mut xt_table,
    pub ip6table_nat: *mut xt_table,
    pub fib6_null_entry: *mut fib6_info,
    pub ip6_null_entry: *mut rt6_info,
    pub rt6_stats: *mut rt6_statistics,
    pub ip6_fib_timer: timer_list,
    pub fib_table_hash: *mut hlist_head,
    pub fib6_main_tbl: *mut fib6_table,
    pub fib6_walkers: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub ip6_dst_ops: dst_ops,
    pub fib6_walker_lock: rwlock_t,
    pub fib6_gc_lock: spinlock_t,
    pub ip6_rt_gc_expire: ::aya_bpf_cty::c_uint,
    pub ip6_rt_last_gc: ::aya_bpf_cty::c_ulong,
    pub fib6_rules_require_fldissect: ::aya_bpf_cty::c_uint,
    pub fib6_has_custom_rules: bool_,
    pub fib6_routes_require_src: ::aya_bpf_cty::c_uint,
    pub ip6_prohibit_entry: *mut rt6_info,
    pub ip6_blk_hole_entry: *mut rt6_info,
    pub fib6_local_tbl: *mut fib6_table,
    pub fib6_rules_ops: *mut fib_rules_ops,
    pub icmp_sk: *mut *mut sock,
    pub ndisc_sk: *mut sock,
    pub tcp_sk: *mut sock,
    pub igmp_sk: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub mr6_tables: list_head,
    pub mr6_rules_ops: *mut fib_rules_ops,
    pub dev_addr_genid: atomic_t,
    pub fib6_sernum: atomic_t,
    pub seg6_data: *mut seg6_pernet_data,
    pub notifier_ops: *mut fib_notifier_ops,
    pub ip6mr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: ::aya_bpf_cty::c_uint,
    pub ip6addrlbl_table: netns_ipv6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6__bindgen_ty_1 {
    pub head: hlist_head,
    pub lock: spinlock_t,
    pub seq: u32_,
}
impl netns_ipv6 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_lowpan {
    pub frags_hdr: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ieee802154_lowpan {
    pub sysctl: netns_sysctl_lowpan,
    pub fqdir: *mut fqdir,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sctp_mib {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sctp {
    pub sctp_statistics: *mut sctp_mib,
    pub proc_net_sctp: *mut proc_dir_entry,
    pub sysctl_header: *mut ctl_table_header,
    pub ctl_sock: *mut sock,
    pub udp4_sock: *mut sock,
    pub udp6_sock: *mut sock,
    pub udp_port: ::aya_bpf_cty::c_int,
    pub encap_port: ::aya_bpf_cty::c_int,
    pub local_addr_list: list_head,
    pub addr_waitq: list_head,
    pub addr_wq_timer: timer_list,
    pub auto_asconf_splist: list_head,
    pub addr_wq_lock: spinlock_t,
    pub local_addr_lock: spinlock_t,
    pub rto_initial: ::aya_bpf_cty::c_uint,
    pub rto_min: ::aya_bpf_cty::c_uint,
    pub rto_max: ::aya_bpf_cty::c_uint,
    pub rto_alpha: ::aya_bpf_cty::c_int,
    pub rto_beta: ::aya_bpf_cty::c_int,
    pub max_burst: ::aya_bpf_cty::c_int,
    pub cookie_preserve_enable: ::aya_bpf_cty::c_int,
    pub sctp_hmac_alg: *mut ::aya_bpf_cty::c_char,
    pub valid_cookie_life: ::aya_bpf_cty::c_uint,
    pub sack_timeout: ::aya_bpf_cty::c_uint,
    pub hb_interval: ::aya_bpf_cty::c_uint,
    pub max_retrans_association: ::aya_bpf_cty::c_int,
    pub max_retrans_path: ::aya_bpf_cty::c_int,
    pub max_retrans_init: ::aya_bpf_cty::c_int,
    pub pf_retrans: ::aya_bpf_cty::c_int,
    pub ps_retrans: ::aya_bpf_cty::c_int,
    pub pf_enable: ::aya_bpf_cty::c_int,
    pub pf_expose: ::aya_bpf_cty::c_int,
    pub sndbuf_policy: ::aya_bpf_cty::c_int,
    pub rcvbuf_policy: ::aya_bpf_cty::c_int,
    pub default_auto_asconf: ::aya_bpf_cty::c_int,
    pub addip_enable: ::aya_bpf_cty::c_int,
    pub addip_noauth: ::aya_bpf_cty::c_int,
    pub prsctp_enable: ::aya_bpf_cty::c_int,
    pub reconf_enable: ::aya_bpf_cty::c_int,
    pub auth_enable: ::aya_bpf_cty::c_int,
    pub intl_enable: ::aya_bpf_cty::c_int,
    pub ecn_enable: ::aya_bpf_cty::c_int,
    pub scope_policy: ::aya_bpf_cty::c_int,
    pub rwnd_upd_shift: ::aya_bpf_cty::c_int,
    pub max_autoclose: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_dccp {
    pub v4_ctl_sk: *mut sock,
    pub v6_ctl_sk: *mut sock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nf {
    pub proc_netfilter: *mut proc_dir_entry,
    pub queue_handler: *const nf_queue_handler,
    pub nf_loggers: [*const nf_logger; 13usize],
    pub nf_log_dir_header: *mut ctl_table_header,
    pub hooks_ipv4: [*mut nf_hook_entries; 5usize],
    pub hooks_ipv6: [*mut nf_hook_entries; 5usize],
    pub hooks_arp: [*mut nf_hook_entries; 3usize],
    pub hooks_bridge: [*mut nf_hook_entries; 5usize],
    pub hooks_decnet: [*mut nf_hook_entries; 7usize],
    pub defrag_ipv4: bool_,
    pub defrag_ipv6: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ebt_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_xt {
    pub tables: [list_head; 13usize],
    pub notrack_deprecated_warning: bool_,
    pub clusterip_deprecated_warning: bool_,
    pub broute_table: *mut ebt_table,
    pub frame_filter: *mut ebt_table,
    pub frame_nat: *mut ebt_table,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_generic_net {
    pub timeout: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_tcp_net {
    pub timeouts: [::aya_bpf_cty::c_uint; 14usize],
    pub tcp_loose: ::aya_bpf_cty::c_int,
    pub tcp_be_liberal: ::aya_bpf_cty::c_int,
    pub tcp_max_retrans: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_udp_net {
    pub timeouts: [::aya_bpf_cty::c_uint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_icmp_net {
    pub timeout: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_dccp_net {
    pub dccp_loose: ::aya_bpf_cty::c_int,
    pub dccp_timeout: [::aya_bpf_cty::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_sctp_net {
    pub timeouts: [::aya_bpf_cty::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_gre_net {
    pub keymap_list: list_head,
    pub timeouts: [::aya_bpf_cty::c_uint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ip_net {
    pub generic: nf_generic_net,
    pub tcp: nf_tcp_net,
    pub udp: nf_udp_net,
    pub icmp: nf_icmp_net,
    pub icmpv6: nf_icmp_net,
    pub dccp: nf_dccp_net,
    pub sctp: nf_sctp_net,
    pub gre: nf_gre_net,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ct {
    pub count: atomic_t,
    pub expect_count: ::aya_bpf_cty::c_uint,
    pub ecache_dwork: delayed_work,
    pub ecache_dwork_pending: bool_,
    pub auto_assign_helper_warned: bool_,
    pub sysctl_header: *mut ctl_table_header,
    pub sysctl_log_invalid: ::aya_bpf_cty::c_uint,
    pub sysctl_events: ::aya_bpf_cty::c_int,
    pub sysctl_acct: ::aya_bpf_cty::c_int,
    pub sysctl_auto_assign_helper: ::aya_bpf_cty::c_int,
    pub sysctl_tstamp: ::aya_bpf_cty::c_int,
    pub sysctl_checksum: ::aya_bpf_cty::c_int,
    pub pcpu_lists: *mut ct_pcpu,
    pub stat: *mut ip_conntrack_stat,
    pub nf_conntrack_event_cb: *mut nf_ct_event_notifier,
    pub nf_expect_event_cb: *mut nf_exp_event_notifier,
    pub nf_ct_proto: nf_ip_net,
    pub labels_used: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nftables {
    pub tables: list_head,
    pub commit_list: list_head,
    pub module_list: list_head,
    pub notify_list: list_head,
    pub commit_mutex: mutex,
    pub base_seq: ::aya_bpf_cty::c_uint,
    pub gencursor: u8_,
    pub validate_state: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nf_frag {
    pub fqdir: *mut fqdir,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_bpf {
    pub run_array: [*mut bpf_prog_array; 2usize],
    pub progs: [*mut bpf_prog; 2usize],
    pub links: [list_head; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy_hash {
    pub table: *mut hlist_head,
    pub hmask: ::aya_bpf_cty::c_uint,
    pub dbits4: u8_,
    pub sbits4: u8_,
    pub dbits6: u8_,
    pub sbits6: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_hthresh {
    pub work: work_struct,
    pub lock: seqlock_t,
    pub lbits4: u8_,
    pub rbits4: u8_,
    pub lbits6: u8_,
    pub rbits6: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xfrm {
    pub state_all: list_head,
    pub state_bydst: *mut hlist_head,
    pub state_bysrc: *mut hlist_head,
    pub state_byspi: *mut hlist_head,
    pub state_hmask: ::aya_bpf_cty::c_uint,
    pub state_num: ::aya_bpf_cty::c_uint,
    pub state_hash_work: work_struct,
    pub policy_all: list_head,
    pub policy_byidx: *mut hlist_head,
    pub policy_idx_hmask: ::aya_bpf_cty::c_uint,
    pub policy_inexact: [hlist_head; 3usize],
    pub policy_bydst: [xfrm_policy_hash; 3usize],
    pub policy_count: [::aya_bpf_cty::c_uint; 6usize],
    pub policy_hash_work: work_struct,
    pub policy_hthresh: xfrm_policy_hthresh,
    pub inexact_bins: list_head,
    pub nlsk: *mut sock,
    pub nlsk_stash: *mut sock,
    pub sysctl_aevent_etime: u32_,
    pub sysctl_aevent_rseqth: u32_,
    pub sysctl_larval_drop: ::aya_bpf_cty::c_int,
    pub sysctl_acq_expires: u32_,
    pub sysctl_hdr: *mut ctl_table_header,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub xfrm4_dst_ops: dst_ops,
    pub xfrm6_dst_ops: dst_ops,
    pub xfrm_state_lock: spinlock_t,
    pub xfrm_state_hash_generation: seqcount_t,
    pub xfrm_policy_lock: spinlock_t,
    pub xfrm_cfg_mutex: mutex,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl netns_xfrm {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ipvs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mpls {
    pub ip_ttl_propagate: ::aya_bpf_cty::c_int,
    pub default_ttl: ::aya_bpf_cty::c_int,
    pub platform_labels: size_t,
    pub platform_label: *mut *mut mpls_route,
    pub ctl: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_dev_rcv_lists {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_pkg_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_rcv_lists_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_can {
    pub proc_dir: *mut proc_dir_entry,
    pub pde_stats: *mut proc_dir_entry,
    pub pde_reset_stats: *mut proc_dir_entry,
    pub pde_rcvlist_all: *mut proc_dir_entry,
    pub pde_rcvlist_fil: *mut proc_dir_entry,
    pub pde_rcvlist_inv: *mut proc_dir_entry,
    pub pde_rcvlist_sff: *mut proc_dir_entry,
    pub pde_rcvlist_eff: *mut proc_dir_entry,
    pub pde_rcvlist_err: *mut proc_dir_entry,
    pub bcmproc_dir: *mut proc_dir_entry,
    pub rx_alldev_list: *mut can_dev_rcv_lists,
    pub rcvlists_lock: spinlock_t,
    pub stattimer: timer_list,
    pub pkg_stats: *mut can_pkg_stats,
    pub rcv_lists_stats: *mut can_rcv_lists_stats,
    pub cgw_list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xdp {
    pub lock: mutex,
    pub list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net {
    pub passive: refcount_t,
    pub rules_mod_lock: spinlock_t,
    pub dev_unreg_count: ::aya_bpf_cty::c_uint,
    pub dev_base_seq: ::aya_bpf_cty::c_uint,
    pub ifindex: ::aya_bpf_cty::c_int,
    pub nsid_lock: spinlock_t,
    pub fnhe_genid: atomic_t,
    pub list: list_head,
    pub exit_list: list_head,
    pub cleanup_list: llist_node,
    pub key_domain: *mut key_tag,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub netns_ids: idr,
    pub ns: ns_common,
    pub dev_base_head: list_head,
    pub proc_net: *mut proc_dir_entry,
    pub proc_net_stat: *mut proc_dir_entry,
    pub sysctls: ctl_table_set,
    pub rtnl: *mut sock,
    pub genl_sock: *mut sock,
    pub uevent_sock: *mut uevent_sock,
    pub dev_name_head: *mut hlist_head,
    pub dev_index_head: *mut hlist_head,
    pub netdev_chain: raw_notifier_head,
    pub hash_mix: u32_,
    pub loopback_dev: *mut net_device,
    pub rules_ops: list_head,
    pub core: netns_core,
    pub mib: netns_mib,
    pub packet: netns_packet,
    pub unx: netns_unix,
    pub nexthop: netns_nexthop,
    pub ipv4: netns_ipv4,
    pub ipv6: netns_ipv6,
    pub ieee802154_lowpan: netns_ieee802154_lowpan,
    pub sctp: netns_sctp,
    pub dccp: netns_dccp,
    pub nf: netns_nf,
    pub xt: netns_xt,
    pub ct: netns_ct,
    pub nft: netns_nftables,
    pub nf_frag: netns_nf_frag,
    pub nf_frag_frags_hdr: *mut ctl_table_header,
    pub nfnl: *mut sock,
    pub nfnl_stash: *mut sock,
    pub nfct_timeout_list: list_head,
    pub wext_nlevents: sk_buff_head,
    pub gen: *mut net_generic,
    pub bpf: netns_bpf,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub xfrm: netns_xfrm,
    pub net_cookie: atomic64_t,
    pub ipvs: *mut netns_ipvs,
    pub mpls: netns_mpls,
    pub can: netns_can,
    pub xdp: netns_xdp,
    pub crypto_nlsk: *mut sock,
    pub diag_nlsk: *mut sock,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
impl net {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u64_stats_t {
    pub v: local64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub off: __s16,
    pub imm: __s32,
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod bpf_map_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_MAP_TYPE_UNSPEC: Type = 0;
    pub const BPF_MAP_TYPE_HASH: Type = 1;
    pub const BPF_MAP_TYPE_ARRAY: Type = 2;
    pub const BPF_MAP_TYPE_PROG_ARRAY: Type = 3;
    pub const BPF_MAP_TYPE_PERF_EVENT_ARRAY: Type = 4;
    pub const BPF_MAP_TYPE_PERCPU_HASH: Type = 5;
    pub const BPF_MAP_TYPE_PERCPU_ARRAY: Type = 6;
    pub const BPF_MAP_TYPE_STACK_TRACE: Type = 7;
    pub const BPF_MAP_TYPE_CGROUP_ARRAY: Type = 8;
    pub const BPF_MAP_TYPE_LRU_HASH: Type = 9;
    pub const BPF_MAP_TYPE_LRU_PERCPU_HASH: Type = 10;
    pub const BPF_MAP_TYPE_LPM_TRIE: Type = 11;
    pub const BPF_MAP_TYPE_ARRAY_OF_MAPS: Type = 12;
    pub const BPF_MAP_TYPE_HASH_OF_MAPS: Type = 13;
    pub const BPF_MAP_TYPE_DEVMAP: Type = 14;
    pub const BPF_MAP_TYPE_SOCKMAP: Type = 15;
    pub const BPF_MAP_TYPE_CPUMAP: Type = 16;
    pub const BPF_MAP_TYPE_XSKMAP: Type = 17;
    pub const BPF_MAP_TYPE_SOCKHASH: Type = 18;
    pub const BPF_MAP_TYPE_CGROUP_STORAGE: Type = 19;
    pub const BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: Type = 20;
    pub const BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: Type = 21;
    pub const BPF_MAP_TYPE_QUEUE: Type = 22;
    pub const BPF_MAP_TYPE_STACK: Type = 23;
    pub const BPF_MAP_TYPE_SK_STORAGE: Type = 24;
    pub const BPF_MAP_TYPE_DEVMAP_HASH: Type = 25;
    pub const BPF_MAP_TYPE_STRUCT_OPS: Type = 26;
    pub const BPF_MAP_TYPE_RINGBUF: Type = 27;
    pub const BPF_MAP_TYPE_INODE_STORAGE: Type = 28;
    pub const BPF_MAP_TYPE_TASK_STORAGE: Type = 29;
}
pub mod bpf_prog_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_PROG_TYPE_UNSPEC: Type = 0;
    pub const BPF_PROG_TYPE_SOCKET_FILTER: Type = 1;
    pub const BPF_PROG_TYPE_KPROBE: Type = 2;
    pub const BPF_PROG_TYPE_SCHED_CLS: Type = 3;
    pub const BPF_PROG_TYPE_SCHED_ACT: Type = 4;
    pub const BPF_PROG_TYPE_TRACEPOINT: Type = 5;
    pub const BPF_PROG_TYPE_XDP: Type = 6;
    pub const BPF_PROG_TYPE_PERF_EVENT: Type = 7;
    pub const BPF_PROG_TYPE_CGROUP_SKB: Type = 8;
    pub const BPF_PROG_TYPE_CGROUP_SOCK: Type = 9;
    pub const BPF_PROG_TYPE_LWT_IN: Type = 10;
    pub const BPF_PROG_TYPE_LWT_OUT: Type = 11;
    pub const BPF_PROG_TYPE_LWT_XMIT: Type = 12;
    pub const BPF_PROG_TYPE_SOCK_OPS: Type = 13;
    pub const BPF_PROG_TYPE_SK_SKB: Type = 14;
    pub const BPF_PROG_TYPE_CGROUP_DEVICE: Type = 15;
    pub const BPF_PROG_TYPE_SK_MSG: Type = 16;
    pub const BPF_PROG_TYPE_RAW_TRACEPOINT: Type = 17;
    pub const BPF_PROG_TYPE_CGROUP_SOCK_ADDR: Type = 18;
    pub const BPF_PROG_TYPE_LWT_SEG6LOCAL: Type = 19;
    pub const BPF_PROG_TYPE_LIRC_MODE2: Type = 20;
    pub const BPF_PROG_TYPE_SK_REUSEPORT: Type = 21;
    pub const BPF_PROG_TYPE_FLOW_DISSECTOR: Type = 22;
    pub const BPF_PROG_TYPE_CGROUP_SYSCTL: Type = 23;
    pub const BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: Type = 24;
    pub const BPF_PROG_TYPE_CGROUP_SOCKOPT: Type = 25;
    pub const BPF_PROG_TYPE_TRACING: Type = 26;
    pub const BPF_PROG_TYPE_STRUCT_OPS: Type = 27;
    pub const BPF_PROG_TYPE_EXT: Type = 28;
    pub const BPF_PROG_TYPE_LSM: Type = 29;
    pub const BPF_PROG_TYPE_SK_LOOKUP: Type = 30;
}
pub mod bpf_attach_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_CGROUP_INET_INGRESS: Type = 0;
    pub const BPF_CGROUP_INET_EGRESS: Type = 1;
    pub const BPF_CGROUP_INET_SOCK_CREATE: Type = 2;
    pub const BPF_CGROUP_SOCK_OPS: Type = 3;
    pub const BPF_SK_SKB_STREAM_PARSER: Type = 4;
    pub const BPF_SK_SKB_STREAM_VERDICT: Type = 5;
    pub const BPF_CGROUP_DEVICE: Type = 6;
    pub const BPF_SK_MSG_VERDICT: Type = 7;
    pub const BPF_CGROUP_INET4_BIND: Type = 8;
    pub const BPF_CGROUP_INET6_BIND: Type = 9;
    pub const BPF_CGROUP_INET4_CONNECT: Type = 10;
    pub const BPF_CGROUP_INET6_CONNECT: Type = 11;
    pub const BPF_CGROUP_INET4_POST_BIND: Type = 12;
    pub const BPF_CGROUP_INET6_POST_BIND: Type = 13;
    pub const BPF_CGROUP_UDP4_SENDMSG: Type = 14;
    pub const BPF_CGROUP_UDP6_SENDMSG: Type = 15;
    pub const BPF_LIRC_MODE2: Type = 16;
    pub const BPF_FLOW_DISSECTOR: Type = 17;
    pub const BPF_CGROUP_SYSCTL: Type = 18;
    pub const BPF_CGROUP_UDP4_RECVMSG: Type = 19;
    pub const BPF_CGROUP_UDP6_RECVMSG: Type = 20;
    pub const BPF_CGROUP_GETSOCKOPT: Type = 21;
    pub const BPF_CGROUP_SETSOCKOPT: Type = 22;
    pub const BPF_TRACE_RAW_TP: Type = 23;
    pub const BPF_TRACE_FENTRY: Type = 24;
    pub const BPF_TRACE_FEXIT: Type = 25;
    pub const BPF_MODIFY_RETURN: Type = 26;
    pub const BPF_LSM_MAC: Type = 27;
    pub const BPF_TRACE_ITER: Type = 28;
    pub const BPF_CGROUP_INET4_GETPEERNAME: Type = 29;
    pub const BPF_CGROUP_INET6_GETPEERNAME: Type = 30;
    pub const BPF_CGROUP_INET4_GETSOCKNAME: Type = 31;
    pub const BPF_CGROUP_INET6_GETSOCKNAME: Type = 32;
    pub const BPF_XDP_DEVMAP: Type = 33;
    pub const BPF_CGROUP_INET_SOCK_RELEASE: Type = 34;
    pub const BPF_XDP_CPUMAP: Type = 35;
    pub const BPF_SK_LOOKUP: Type = 36;
    pub const BPF_XDP: Type = 37;
    pub const __MAX_BPF_ATTACH_TYPE: Type = 38;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub batch: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_5,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_6,
    pub test: bpf_attr__bindgen_ty_7,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_8,
    pub info: bpf_attr__bindgen_ty_9,
    pub query: bpf_attr__bindgen_ty_10,
    pub raw_tracepoint: bpf_attr__bindgen_ty_11,
    pub __bindgen_anon_7: bpf_attr__bindgen_ty_12,
    pub task_fd_query: bpf_attr__bindgen_ty_13,
    pub link_create: bpf_attr__bindgen_ty_14,
    pub link_update: bpf_attr__bindgen_ty_15,
    pub link_detach: bpf_attr__bindgen_ty_16,
    pub enable_stats: bpf_attr__bindgen_ty_17,
    pub iter_create: bpf_attr__bindgen_ty_18,
    pub prog_bind_map: bpf_attr__bindgen_ty_19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [::aya_bpf_cty::c_char; 16usize],
    pub map_ifindex: __u32,
    pub btf_fd: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub btf_vmlinux_value_type_id: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_3 {
    pub in_batch: __u64,
    pub out_batch: __u64,
    pub keys: __u64,
    pub values: __u64,
    pub count: __u32,
    pub map_fd: __u32,
    pub elem_flags: __u64,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_4 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [::aya_bpf_cty::c_char; 16usize],
    pub prog_ifindex: __u32,
    pub expected_attach_type: __u32,
    pub prog_btf_fd: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub func_info_cnt: __u32,
    pub line_info_rec_size: __u32,
    pub line_info: __u64,
    pub line_info_cnt: __u32,
    pub attach_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    pub attach_prog_fd: __u32,
    pub attach_btf_obj_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_5 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
    pub file_flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_6 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
    pub replace_bpf_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_7 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
    pub ctx_size_in: __u32,
    pub ctx_size_out: __u32,
    pub ctx_in: __u64,
    pub ctx_out: __u64,
    pub flags: __u32,
    pub cpu: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_8 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_8__bindgen_ty_1,
    pub next_id: __u32,
    pub open_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    pub btf_id: __u32,
    pub link_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_9 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_10 {
    pub target_fd: __u32,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub prog_cnt: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_11 {
    pub name: __u64,
    pub prog_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_12 {
    pub btf: __u64,
    pub btf_log_buf: __u64,
    pub btf_size: __u32,
    pub btf_log_size: __u32,
    pub btf_log_level: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_13 {
    pub pid: __u32,
    pub fd: __u32,
    pub flags: __u32,
    pub buf_len: __u32,
    pub buf: __u64,
    pub prog_id: __u32,
    pub fd_type: __u32,
    pub probe_offset: __u64,
    pub probe_addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14 {
    pub prog_fd: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_1,
    pub attach_type: __u32,
    pub flags: __u32,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_14__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub target_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1 {
    pub iter_info: __u64,
    pub iter_info_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_15 {
    pub link_fd: __u32,
    pub new_prog_fd: __u32,
    pub flags: __u32,
    pub old_prog_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_16 {
    pub link_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_17 {
    pub type_: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_18 {
    pub link_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_19 {
    pub prog_fd: __u32,
    pub map_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_info {
    pub insn_off: __u32,
    pub type_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_line_info {
    pub insn_off: __u32,
    pub file_name_off: __u32,
    pub line_off: __u32,
    pub line_col: __u32,
}
pub type bpf_iter_init_seq_priv_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf_cty::c_void,
        arg2: *mut bpf_iter_aux_info,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_aux_info {
    pub map: *mut bpf_map,
}
pub type bpf_iter_fini_seq_priv_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_seq_info {
    pub seq_ops: *const seq_operations,
    pub init_seq_private: bpf_iter_init_seq_priv_t,
    pub fini_seq_private: bpf_iter_fini_seq_priv_t,
    pub seq_priv_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_ops {
    pub map_alloc_check:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> ::aya_bpf_cty::c_int>,
    pub map_alloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> *mut bpf_map>,
    pub map_release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut file)>,
    pub map_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>,
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_release_uref: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>,
    pub map_lookup_elem_sys_only: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub map_lookup_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_lookup_and_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_update_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_push_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_pop_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_peek_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_fd_get_ptr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut file,
            arg3: ::aya_bpf_cty::c_int,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub map_fd_put_ptr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub map_gen_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_insn) -> ::aya_bpf_cty::c_int,
    >,
    pub map_fd_sys_lookup_elem:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> u32_>,
    pub map_seq_show_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut seq_file,
        ),
    >,
    pub map_check_btf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: *const btf,
            arg3: *const btf_type,
            arg4: *const btf_type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_poke_track: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_prog_aux) -> ::aya_bpf_cty::c_int,
    >,
    pub map_poke_untrack:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_prog_aux)>,
    pub map_poke_run: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: u32_,
            arg3: *mut bpf_prog,
            arg4: *mut bpf_prog,
        ),
    >,
    pub map_direct_value_addr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: *mut u64_,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_direct_value_meta: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: u64_,
            arg3: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut vm_area_struct) -> ::aya_bpf_cty::c_int,
    >,
    pub map_poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut file,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub map_local_storage_charge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_local_storage_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_local_storage_uncharge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_local_storage_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: u32_,
        ),
    >,
    pub map_owner_storage_ptr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> *mut *mut bpf_local_storage,
    >,
    pub map_meta_equal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const bpf_map, arg2: *const bpf_map) -> bool_,
    >,
    pub map_btf_name: *const ::aya_bpf_cty::c_char,
    pub map_btf_id: *mut ::aya_bpf_cty::c_int,
    pub iter_seq_info: *const bpf_iter_seq_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map {
    pub ops: *const bpf_map_ops,
    pub inner_map_meta: *mut bpf_map,
    pub security: *mut ::aya_bpf_cty::c_void,
    pub map_type: bpf_map_type::Type,
    pub key_size: u32_,
    pub value_size: u32_,
    pub max_entries: u32_,
    pub map_flags: u32_,
    pub spin_lock_off: ::aya_bpf_cty::c_int,
    pub id: u32_,
    pub numa_node: ::aya_bpf_cty::c_int,
    pub btf_key_type_id: u32_,
    pub btf_value_type_id: u32_,
    pub btf: *mut btf,
    pub memcg: *mut mem_cgroup,
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub btf_vmlinux_value_type_id: u32_,
    pub bypass_spec_v1: bool_,
    pub frozen: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub refcnt: atomic64_t,
    pub usercnt: atomic64_t,
    pub work: work_struct,
    pub freeze_mutex: mutex,
    pub writecnt: u64_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 40usize]>,
}
impl bpf_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_header {
    pub magic: __u16,
    pub version: __u8,
    pub flags: __u8,
    pub hdr_len: __u32,
    pub type_off: __u32,
    pub type_len: __u32,
    pub str_off: __u32,
    pub str_len: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf {
    pub data: *mut ::aya_bpf_cty::c_void,
    pub types: *mut *mut btf_type,
    pub resolved_ids: *mut u32_,
    pub resolved_sizes: *mut u32_,
    pub strings: *const ::aya_bpf_cty::c_char,
    pub nohdr_data: *mut ::aya_bpf_cty::c_void,
    pub hdr: btf_header,
    pub nr_types: u32_,
    pub types_size: u32_,
    pub data_size: u32_,
    pub refcnt: refcount_t,
    pub id: u32_,
    pub rcu: callback_head,
    pub base_btf: *mut btf,
    pub start_id: u32_,
    pub start_str_off: u32_,
    pub name: [::aya_bpf_cty::c_char; 56usize],
    pub kernel_btf: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_type {
    pub name_off: __u32,
    pub info: __u32,
    pub __bindgen_anon_1: btf_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_type__bindgen_ty_1 {
    pub size: __u32,
    pub type_: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_ksym {
    pub start: ::aya_bpf_cty::c_ulong,
    pub end: ::aya_bpf_cty::c_ulong,
    pub name: [::aya_bpf_cty::c_char; 128usize],
    pub lnode: list_head,
    pub tnode: latch_tree_node,
    pub prog: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    pub refcnt: atomic64_t,
    pub used_map_cnt: u32_,
    pub max_ctx_offset: u32_,
    pub max_pkt_offset: u32_,
    pub max_tp_access: u32_,
    pub stack_depth: u32_,
    pub id: u32_,
    pub func_cnt: u32_,
    pub func_idx: u32_,
    pub attach_btf_id: u32_,
    pub ctx_arg_info_size: u32_,
    pub max_rdonly_access: u32_,
    pub max_rdwr_access: u32_,
    pub attach_btf: *mut btf,
    pub ctx_arg_info: *const bpf_ctx_arg_aux,
    pub dst_mutex: mutex,
    pub dst_prog: *mut bpf_prog,
    pub dst_trampoline: *mut bpf_trampoline,
    pub saved_dst_prog_type: bpf_prog_type::Type,
    pub saved_dst_attach_type: bpf_attach_type::Type,
    pub verifier_zext: bool_,
    pub offload_requested: bool_,
    pub attach_btf_trace: bool_,
    pub func_proto_unreliable: bool_,
    pub sleepable: bool_,
    pub tail_call_reachable: bool_,
    pub tramp_hlist: hlist_node,
    pub attach_func_proto: *const btf_type,
    pub attach_func_name: *const ::aya_bpf_cty::c_char,
    pub func: *mut *mut bpf_prog,
    pub jit_data: *mut ::aya_bpf_cty::c_void,
    pub poke_tab: *mut bpf_jit_poke_descriptor,
    pub size_poke_tab: u32_,
    pub ksym: bpf_ksym,
    pub ops: *const bpf_prog_ops,
    pub used_maps: *mut *mut bpf_map,
    pub used_maps_mutex: mutex,
    pub prog: *mut bpf_prog,
    pub user: *mut user_struct,
    pub load_time: u64_,
    pub cgroup_storage: [*mut bpf_map; 2usize],
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub security: *mut ::aya_bpf_cty::c_void,
    pub offload: *mut bpf_prog_offload,
    pub btf: *mut btf,
    pub func_info: *mut bpf_func_info,
    pub func_info_aux: *mut bpf_func_info_aux,
    pub linfo: *mut bpf_line_info,
    pub jited_linfo: *mut *mut ::aya_bpf_cty::c_void,
    pub func_info_cnt: u32_,
    pub nr_linfo: u32_,
    pub linfo_idx: u32_,
    pub num_exentries: u32_,
    pub extable: *mut exception_table_entry,
    pub stats: *mut bpf_prog_stats,
    pub __bindgen_anon_1: bpf_prog_aux__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_aux__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_filter {
    pub code: __u16,
    pub jt: __u8,
    pub jf: __u8,
    pub k: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_prog {
    pub pages: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub type_: bpf_prog_type::Type,
    pub expected_attach_type: bpf_attach_type::Type,
    pub len: u32_,
    pub jited_len: u32_,
    pub tag: [u8_; 8usize],
    pub aux: *mut bpf_prog_aux,
    pub orig_prog: *mut sock_fprog_kern,
    pub bpf_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf_cty::c_void,
            arg2: *const bpf_insn,
        ) -> ::aya_bpf_cty::c_uint,
    >,
    pub insns: __IncompleteArrayField<sock_filter>,
    pub insnsi: __IncompleteArrayField<bpf_insn>,
}
impl bpf_prog {
    #[inline]
    pub fn jited(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jited(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jit_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jit_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpl_compatible(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cb_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cb_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_needed(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dst_needed(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinded(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinded(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_func(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_func(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kprobe_override(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kprobe_override(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_callchain_buf(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_has_callchain_buf(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enforce_expected_attach_type(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enforce_expected_attach_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn call_get_stack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_stack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        jited: u16_,
        jit_requested: u16_,
        gpl_compatible: u16_,
        cb_access: u16_,
        dst_needed: u16_,
        blinded: u16_,
        is_func: u16_,
        kprobe_override: u16_,
        has_callchain_buf: u16_,
        enforce_expected_attach_type: u16_,
        call_get_stack: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let jited: u16 = unsafe { ::core::mem::transmute(jited) };
            jited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jit_requested: u16 = unsafe { ::core::mem::transmute(jit_requested) };
            jit_requested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gpl_compatible: u16 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cb_access: u16 = unsafe { ::core::mem::transmute(cb_access) };
            cb_access as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_needed: u16 = unsafe { ::core::mem::transmute(dst_needed) };
            dst_needed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blinded: u16 = unsafe { ::core::mem::transmute(blinded) };
            blinded as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_func: u16 = unsafe { ::core::mem::transmute(is_func) };
            is_func as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let kprobe_override: u16 = unsafe { ::core::mem::transmute(kprobe_override) };
            kprobe_override as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_callchain_buf: u16 = unsafe { ::core::mem::transmute(has_callchain_buf) };
            has_callchain_buf as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enforce_expected_attach_type: u16 =
                unsafe { ::core::mem::transmute(enforce_expected_attach_type) };
            enforce_expected_attach_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let call_get_stack: u16 = unsafe { ::core::mem::transmute(call_get_stack) };
            call_get_stack as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_dev_ops {
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_offloaded_map {
    pub map: bpf_map,
    pub netdev: *mut net_device,
    pub dev_ops: *const bpf_map_dev_ops,
    pub dev_priv: *mut ::aya_bpf_cty::c_void,
    pub offloads: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl bpf_offloaded_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_stats {
    pub rx_packets: ::aya_bpf_cty::c_ulong,
    pub tx_packets: ::aya_bpf_cty::c_ulong,
    pub rx_bytes: ::aya_bpf_cty::c_ulong,
    pub tx_bytes: ::aya_bpf_cty::c_ulong,
    pub rx_errors: ::aya_bpf_cty::c_ulong,
    pub tx_errors: ::aya_bpf_cty::c_ulong,
    pub rx_dropped: ::aya_bpf_cty::c_ulong,
    pub tx_dropped: ::aya_bpf_cty::c_ulong,
    pub multicast: ::aya_bpf_cty::c_ulong,
    pub collisions: ::aya_bpf_cty::c_ulong,
    pub rx_length_errors: ::aya_bpf_cty::c_ulong,
    pub rx_over_errors: ::aya_bpf_cty::c_ulong,
    pub rx_crc_errors: ::aya_bpf_cty::c_ulong,
    pub rx_frame_errors: ::aya_bpf_cty::c_ulong,
    pub rx_fifo_errors: ::aya_bpf_cty::c_ulong,
    pub rx_missed_errors: ::aya_bpf_cty::c_ulong,
    pub tx_aborted_errors: ::aya_bpf_cty::c_ulong,
    pub tx_carrier_errors: ::aya_bpf_cty::c_ulong,
    pub tx_fifo_errors: ::aya_bpf_cty::c_ulong,
    pub tx_heartbeat_errors: ::aya_bpf_cty::c_ulong,
    pub tx_window_errors: ::aya_bpf_cty::c_ulong,
    pub rx_compressed: ::aya_bpf_cty::c_ulong,
    pub tx_compressed: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_hw_addr_list {
    pub list: list_head,
    pub count: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tipc_bearer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dn_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_dev {
    _unused: [u8; 0],
}
pub mod rx_handler_result {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RX_HANDLER_CONSUMED: Type = 0;
    pub const RX_HANDLER_ANOTHER: Type = 1;
    pub const RX_HANDLER_EXACT: Type = 2;
    pub const RX_HANDLER_PASS: Type = 3;
}
pub use self::rx_handler_result::Type as rx_handler_result_t;
pub type rx_handler_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut *mut sk_buff) -> rx_handler_result_t>;
pub mod netdev_ml_priv_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ML_PRIV_NONE: Type = 0;
    pub const ML_PRIV_CAN: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_dstats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct garp_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrp_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_tc_txq {
    pub count: u16_,
    pub offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_xdp_entity {
    pub prog: *mut bpf_prog,
    pub link: *mut bpf_xdp_link,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device {
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub name_node: *mut netdev_name_node,
    pub ifalias: *mut dev_ifalias,
    pub mem_end: ::aya_bpf_cty::c_ulong,
    pub mem_start: ::aya_bpf_cty::c_ulong,
    pub base_addr: ::aya_bpf_cty::c_ulong,
    pub irq: ::aya_bpf_cty::c_int,
    pub state: ::aya_bpf_cty::c_ulong,
    pub dev_list: list_head,
    pub napi_list: list_head,
    pub unreg_list: list_head,
    pub close_list: list_head,
    pub ptype_all: list_head,
    pub ptype_specific: list_head,
    pub adj_list: net_device__bindgen_ty_1,
    pub features: netdev_features_t,
    pub hw_features: netdev_features_t,
    pub wanted_features: netdev_features_t,
    pub vlan_features: netdev_features_t,
    pub hw_enc_features: netdev_features_t,
    pub mpls_features: netdev_features_t,
    pub gso_partial_features: netdev_features_t,
    pub ifindex: ::aya_bpf_cty::c_int,
    pub group: ::aya_bpf_cty::c_int,
    pub stats: net_device_stats,
    pub rx_dropped: atomic_long_t,
    pub tx_dropped: atomic_long_t,
    pub rx_nohandler: atomic_long_t,
    pub carrier_up_count: atomic_t,
    pub carrier_down_count: atomic_t,
    pub wireless_handlers: *const iw_handler_def,
    pub wireless_data: *mut iw_public_data,
    pub netdev_ops: *const net_device_ops,
    pub ethtool_ops: *const ethtool_ops,
    pub l3mdev_ops: *const l3mdev_ops,
    pub ndisc_ops: *const ndisc_ops,
    pub xfrmdev_ops: *const xfrmdev_ops,
    pub tlsdev_ops: *const tlsdev_ops,
    pub header_ops: *const header_ops,
    pub flags: ::aya_bpf_cty::c_uint,
    pub priv_flags: ::aya_bpf_cty::c_uint,
    pub gflags: ::aya_bpf_cty::c_ushort,
    pub padded: ::aya_bpf_cty::c_ushort,
    pub operstate: ::aya_bpf_cty::c_uchar,
    pub link_mode: ::aya_bpf_cty::c_uchar,
    pub if_port: ::aya_bpf_cty::c_uchar,
    pub dma: ::aya_bpf_cty::c_uchar,
    pub mtu: ::aya_bpf_cty::c_uint,
    pub min_mtu: ::aya_bpf_cty::c_uint,
    pub max_mtu: ::aya_bpf_cty::c_uint,
    pub type_: ::aya_bpf_cty::c_ushort,
    pub hard_header_len: ::aya_bpf_cty::c_ushort,
    pub min_header_len: ::aya_bpf_cty::c_uchar,
    pub name_assign_type: ::aya_bpf_cty::c_uchar,
    pub needed_headroom: ::aya_bpf_cty::c_ushort,
    pub needed_tailroom: ::aya_bpf_cty::c_ushort,
    pub perm_addr: [::aya_bpf_cty::c_uchar; 32usize],
    pub addr_assign_type: ::aya_bpf_cty::c_uchar,
    pub addr_len: ::aya_bpf_cty::c_uchar,
    pub upper_level: ::aya_bpf_cty::c_uchar,
    pub lower_level: ::aya_bpf_cty::c_uchar,
    pub neigh_priv_len: ::aya_bpf_cty::c_ushort,
    pub dev_id: ::aya_bpf_cty::c_ushort,
    pub dev_port: ::aya_bpf_cty::c_ushort,
    pub addr_list_lock: spinlock_t,
    pub uc: netdev_hw_addr_list,
    pub mc: netdev_hw_addr_list,
    pub dev_addrs: netdev_hw_addr_list,
    pub queues_kset: *mut kset,
    pub promiscuity: ::aya_bpf_cty::c_uint,
    pub allmulti: ::aya_bpf_cty::c_uint,
    pub uc_promisc: bool_,
    pub vlan_info: *mut vlan_info,
    pub dsa_ptr: *mut dsa_port,
    pub tipc_ptr: *mut tipc_bearer,
    pub atalk_ptr: *mut ::aya_bpf_cty::c_void,
    pub ip_ptr: *mut in_device,
    pub dn_ptr: *mut dn_dev,
    pub ip6_ptr: *mut inet6_dev,
    pub ax25_ptr: *mut ::aya_bpf_cty::c_void,
    pub ieee80211_ptr: *mut wireless_dev,
    pub ieee802154_ptr: *mut wpan_dev,
    pub mpls_ptr: *mut mpls_dev,
    pub dev_addr: *mut ::aya_bpf_cty::c_uchar,
    pub _rx: *mut netdev_rx_queue,
    pub num_rx_queues: ::aya_bpf_cty::c_uint,
    pub real_num_rx_queues: ::aya_bpf_cty::c_uint,
    pub xdp_prog: *mut bpf_prog,
    pub gro_flush_timeout: ::aya_bpf_cty::c_ulong,
    pub napi_defer_hard_irqs: ::aya_bpf_cty::c_int,
    pub rx_handler: rx_handler_func_t,
    pub rx_handler_data: *mut ::aya_bpf_cty::c_void,
    pub miniq_ingress: *mut mini_Qdisc,
    pub ingress_queue: *mut netdev_queue,
    pub nf_hooks_ingress: *mut nf_hook_entries,
    pub broadcast: [::aya_bpf_cty::c_uchar; 32usize],
    pub rx_cpu_rmap: *mut cpu_rmap,
    pub index_hlist: hlist_node,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub _tx: *mut netdev_queue,
    pub num_tx_queues: ::aya_bpf_cty::c_uint,
    pub real_num_tx_queues: ::aya_bpf_cty::c_uint,
    pub qdisc: *mut Qdisc,
    pub tx_queue_len: ::aya_bpf_cty::c_uint,
    pub tx_global_lock: spinlock_t,
    pub xdp_bulkq: *mut xdp_dev_bulk_queue,
    pub xps_cpus_map: *mut xps_dev_maps,
    pub xps_rxqs_map: *mut xps_dev_maps,
    pub miniq_egress: *mut mini_Qdisc,
    pub qdisc_hash: [hlist_head; 16usize],
    pub watchdog_timer: timer_list,
    pub watchdog_timeo: ::aya_bpf_cty::c_int,
    pub proto_down_reason: u32_,
    pub todo_list: list_head,
    pub pcpu_refcnt: *mut ::aya_bpf_cty::c_int,
    pub link_watch_list: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dismantle: bool_,
    pub _bitfield_align_3: [u16; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub needs_free_netdev: bool_,
    pub priv_destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub npinfo: *mut netpoll_info,
    pub nd_net: possible_net_t,
    pub ml_priv: *mut ::aya_bpf_cty::c_void,
    pub ml_priv_type: netdev_ml_priv_type::Type,
    pub __bindgen_anon_1: net_device__bindgen_ty_4,
    pub garp_port: *mut garp_port,
    pub mrp_port: *mut mrp_port,
    pub dev: device,
    pub sysfs_groups: [*const attribute_group; 4usize],
    pub sysfs_rx_queue_group: *const attribute_group,
    pub rtnl_link_ops: *const rtnl_link_ops,
    pub gso_max_size: ::aya_bpf_cty::c_uint,
    pub gso_max_segs: u16_,
    pub dcbnl_ops: *const dcbnl_rtnl_ops,
    pub num_tc: s16,
    pub tc_to_txq: [netdev_tc_txq; 16usize],
    pub prio_tc_map: [u8_; 16usize],
    pub fcoe_ddp_xid: ::aya_bpf_cty::c_uint,
    pub priomap: *mut netprio_map,
    pub phydev: *mut phy_device,
    pub sfp_bus: *mut sfp_bus,
    pub qdisc_tx_busylock: *mut lock_class_key,
    pub qdisc_running_key: *mut lock_class_key,
    pub proto_down: bool_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub net_notifier_list: list_head,
    pub macsec_ops: *const macsec_ops,
    pub udp_tunnel_nic_info: *const udp_tunnel_nic_info,
    pub udp_tunnel_nic: *mut udp_tunnel_nic,
    pub xdp_state: [bpf_xdp_entity; 3usize],
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device__bindgen_ty_1 {
    pub upper: list_head,
    pub lower: list_head,
}
pub mod net_device__bindgen_ty_2 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NETREG_UNINITIALIZED: Type = 0;
    pub const NETREG_REGISTERED: Type = 1;
    pub const NETREG_UNREGISTERING: Type = 2;
    pub const NETREG_UNREGISTERED: Type = 3;
    pub const NETREG_RELEASED: Type = 4;
    pub const NETREG_DUMMY: Type = 5;
}
pub mod net_device__bindgen_ty_3 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RTNL_LINK_INITIALIZED: Type = 0;
    pub const RTNL_LINK_INITIALIZING: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device__bindgen_ty_4 {
    pub lstats: *mut pcpu_lstats,
    pub tstats: *mut pcpu_sw_netstats,
    pub dstats: *mut pcpu_dstats,
}
impl net_device {
    #[inline]
    pub fn reg_state(&self) -> net_device__bindgen_ty_2::Type {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reg_state(&mut self, val: net_device__bindgen_ty_2::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reg_state: net_device__bindgen_ty_2::Type,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reg_state: u32 = unsafe { ::core::mem::transmute(reg_state) };
            reg_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rtnl_link_state(&self) -> net_device__bindgen_ty_3::Type {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtnl_link_state(&mut self, val: net_device__bindgen_ty_3::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        rtnl_link_state: net_device__bindgen_ty_3::Type,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtnl_link_state: u32 = unsafe { ::core::mem::transmute(rtnl_link_state) };
            rtnl_link_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wol_enabled(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        wol_enabled: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod bpf_reg_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NOT_INIT: Type = 0;
    pub const SCALAR_VALUE: Type = 1;
    pub const PTR_TO_CTX: Type = 2;
    pub const CONST_PTR_TO_MAP: Type = 3;
    pub const PTR_TO_MAP_VALUE: Type = 4;
    pub const PTR_TO_MAP_VALUE_OR_NULL: Type = 5;
    pub const PTR_TO_STACK: Type = 6;
    pub const PTR_TO_PACKET_META: Type = 7;
    pub const PTR_TO_PACKET: Type = 8;
    pub const PTR_TO_PACKET_END: Type = 9;
    pub const PTR_TO_FLOW_KEYS: Type = 10;
    pub const PTR_TO_SOCKET: Type = 11;
    pub const PTR_TO_SOCKET_OR_NULL: Type = 12;
    pub const PTR_TO_SOCK_COMMON: Type = 13;
    pub const PTR_TO_SOCK_COMMON_OR_NULL: Type = 14;
    pub const PTR_TO_TCP_SOCK: Type = 15;
    pub const PTR_TO_TCP_SOCK_OR_NULL: Type = 16;
    pub const PTR_TO_TP_BUFFER: Type = 17;
    pub const PTR_TO_XDP_SOCK: Type = 18;
    pub const PTR_TO_BTF_ID: Type = 19;
    pub const PTR_TO_BTF_ID_OR_NULL: Type = 20;
    pub const PTR_TO_MEM: Type = 21;
    pub const PTR_TO_MEM_OR_NULL: Type = 22;
    pub const PTR_TO_RDONLY_BUF: Type = 23;
    pub const PTR_TO_RDONLY_BUF_OR_NULL: Type = 24;
    pub const PTR_TO_RDWR_BUF: Type = 25;
    pub const PTR_TO_RDWR_BUF_OR_NULL: Type = 26;
    pub const PTR_TO_PERCPU_BTF_ID: Type = 27;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_ops {
    pub test_run: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_prog,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_offload {
    pub prog: *mut bpf_prog,
    pub netdev: *mut net_device,
    pub offdev: *mut bpf_offload_dev,
    pub dev_priv: *mut ::aya_bpf_cty::c_void,
    pub offloads: list_head,
    pub dev_state: bool_,
    pub opt_failed: bool_,
    pub jited_image: *mut ::aya_bpf_cty::c_void,
    pub jited_len: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_stats {
    pub cnt: u64_,
    pub nsecs: u64_,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_func_model {
    pub ret_size: u8_,
    pub nr_args: u8_,
    pub arg_size: [u8_; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_image {
    pub image: *mut ::aya_bpf_cty::c_void,
    pub ksym: bpf_ksym,
    pub pcref: percpu_ref,
    pub ip_after_call: *mut ::aya_bpf_cty::c_void,
    pub ip_epilogue: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: bpf_tramp_image__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tramp_image__bindgen_ty_1 {
    pub rcu: callback_head,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline {
    pub hlist: hlist_node,
    pub mutex: mutex,
    pub refcnt: refcount_t,
    pub key: u64_,
    pub func: bpf_trampoline__bindgen_ty_1,
    pub extension_prog: *mut bpf_prog,
    pub progs_hlist: [hlist_head; 3usize],
    pub progs_cnt: [::aya_bpf_cty::c_int; 3usize],
    pub cur_image: *mut bpf_tramp_image,
    pub selector: u64_,
    pub mod_: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_trampoline__bindgen_ty_1 {
    pub model: btf_func_model,
    pub addr: *mut ::aya_bpf_cty::c_void,
    pub ftrace_managed: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_info_aux {
    pub linkage: u16_,
    pub unreliable: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor {
    pub tailcall_target: *mut ::aya_bpf_cty::c_void,
    pub tailcall_bypass: *mut ::aya_bpf_cty::c_void,
    pub bypass_addr: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: bpf_jit_poke_descriptor__bindgen_ty_1,
    pub tailcall_target_stable: bool_,
    pub adj_off: u8_,
    pub reason: u16_,
    pub insn_idx: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_jit_poke_descriptor__bindgen_ty_1 {
    pub tail_call: bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub map: *mut bpf_map,
    pub key: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_ctx_arg_aux {
    pub offset: u32_,
    pub reg_type: bpf_reg_type::Type,
    pub btf_id: u32_,
}
pub type sk_buff_data_t = ::aya_bpf_cty::c_uint;
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub cb: [::aya_bpf_cty::c_char; 48usize],
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub _nfct: ::aya_bpf_cty::c_ulong,
    pub len: ::aya_bpf_cty::c_uint,
    pub data_len: ::aya_bpf_cty::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub active_extensions: __u8,
    pub headers_start: __IncompleteArrayField<__u32>,
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub tc_index: __u16,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub priority: __u32,
    pub skb_iif: ::aya_bpf_cty::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_6: sk_buff__bindgen_ty_6,
    pub secmark: __u32,
    pub __bindgen_anon_7: sk_buff__bindgen_ty_7,
    pub __bindgen_anon_8: sk_buff__bindgen_ty_8,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
    pub headers_end: __IncompleteArrayField<__u32>,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut ::aya_bpf_cty::c_uchar,
    pub data: *mut ::aya_bpf_cty::c_uchar,
    pub truesize: ::aya_bpf_cty::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub sk: *mut sock,
    pub ip_defrag_offset: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub _skb_refdst: ::aya_bpf_cty::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_6 {
    pub napi_id: ::aya_bpf_cty::c_uint,
    pub sender_cpu: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_7 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_8 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn vlan_present(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_present(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        vlan_present: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        csum_not_inet: __u8,
        dst_pending_confirm: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        redirected: __u8,
        from_ingress: __u8,
        decrypted: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_present: u8 = unsafe { ::core::mem::transmute(vlan_present) };
            vlan_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scatterlist {
    pub page_link: ::aya_bpf_cty::c_ulong,
    pub offset: ::aya_bpf_cty::c_uint,
    pub length: ::aya_bpf_cty::c_uint,
    pub dma_address: dma_addr_t,
    pub dma_length: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: ::aya_bpf_cty::c_int,
    pub flowic_iif: ::aya_bpf_cty::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_tun_key: flowi_tunnel,
    pub flowic_multipath_hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub dnports: flowi_uli__bindgen_ty_3,
    pub spi: __be32,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub dport: __le16,
    pub sport: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_4 {
    pub type_: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowidn {
    pub __fl_common: flowi_common,
    pub daddr: __le16,
    pub saddr: __le16,
    pub uli: flowi_uli,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
    pub dn: flowidn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipstats_mib {
    pub mibs: [u64_; 37usize],
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 28usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpmsg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6_mib_device {
    pub mibs: [atomic_long_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpv6msg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpv6msg_mib_device {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 124usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_xfrm_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 29usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_tls_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fqdir {
    pub high_thresh: ::aya_bpf_cty::c_long,
    pub low_thresh: ::aya_bpf_cty::c_long,
    pub timeout: ::aya_bpf_cty::c_int,
    pub max_dist: ::aya_bpf_cty::c_int,
    pub f: *mut inet_frags,
    pub net: *mut net,
    pub dead: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub rhashtable: rhashtable,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub mem: atomic_long_t,
    pub destroy_work: work_struct,
    pub free_list: llist_node,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl fqdir {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frags {
    pub qsize: ::aya_bpf_cty::c_uint,
    pub constructor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inet_frag_queue, arg2: *const ::aya_bpf_cty::c_void),
    >,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>,
    pub frag_expire: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub frags_cachep: *mut kmem_cache,
    pub frags_cache_name: *const ::aya_bpf_cty::c_char,
    pub rhash_params: rhashtable_params,
    pub refcnt: refcount_t,
    pub completion: completion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frag_v4_compare_key {
    pub saddr: __be32,
    pub daddr: __be32,
    pub user: u32_,
    pub vif: u32_,
    pub id: __be16,
    pub protocol: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct frag_v6_compare_key {
    pub saddr: in6_addr,
    pub daddr: in6_addr,
    pub user: u32_,
    pub id: __be32,
    pub iif: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frag_queue {
    pub node: rhash_head,
    pub key: inet_frag_queue__bindgen_ty_1,
    pub timer: timer_list,
    pub lock: spinlock_t,
    pub refcnt: refcount_t,
    pub rb_fragments: rb_root,
    pub fragments_tail: *mut sk_buff,
    pub last_run_head: *mut sk_buff,
    pub stamp: ktime_t,
    pub len: ::aya_bpf_cty::c_int,
    pub meat: ::aya_bpf_cty::c_int,
    pub flags: __u8,
    pub max_size: u16_,
    pub fqdir: *mut fqdir,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_frag_queue__bindgen_ty_1 {
    pub v4: frag_v4_compare_key,
    pub v6: frag_v6_compare_key,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rules_ops {
    pub family: ::aya_bpf_cty::c_int,
    pub list: list_head,
    pub rule_size: ::aya_bpf_cty::c_int,
    pub addr_size: ::aya_bpf_cty::c_int,
    pub unresolved_rules: ::aya_bpf_cty::c_int,
    pub nr_goto_rules: ::aya_bpf_cty::c_int,
    pub fib_rules_seq: ::aya_bpf_cty::c_uint,
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *mut fib_lookup_arg,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub suppress: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fib_rule, arg2: *mut fib_lookup_arg) -> bool_,
    >,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> ::aya_bpf_cty::c_int>,
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut fib_rule_hdr,
            arg3: *mut *mut nlattr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fill: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub nlmsg_payload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> size_t>,
    pub flush_cache: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rules_ops)>,
    pub nlgroup: ::aya_bpf_cty::c_int,
    pub policy: *const nla_policy,
    pub rules_list: list_head,
    pub owner: *mut module,
    pub fro_net: *mut net,
    pub rcu: callback_head,
}
pub mod tcp_ca_event {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const CA_EVENT_TX_START: Type = 0;
    pub const CA_EVENT_CWND_RESTART: Type = 1;
    pub const CA_EVENT_COMPLETE_CWR: Type = 2;
    pub const CA_EVENT_LOSS: Type = 3;
    pub const CA_EVENT_ECN_NO_CE: Type = 4;
    pub const CA_EVENT_ECN_IS_CE: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_congestion_ops {
    pub list: list_head,
    pub key: u32_,
    pub flags: u32_,
    pub init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub ssthresh: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub cong_avoid:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_, arg3: u32_)>,
    pub set_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u8_)>,
    pub cwnd_event:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: tcp_ca_event::Type)>,
    pub in_ack_event: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_)>,
    pub undo_cwnd: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub pkts_acked:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const ack_sample)>,
    pub min_tso_segs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub sndbuf_expand: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub cong_control:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const rate_sample)>,
    pub get_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: u32_,
            arg3: *mut ::aya_bpf_cty::c_int,
            arg4: *mut tcp_cc_info,
        ) -> size_t,
    >,
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_notifier_ops {
    pub family: ::aya_bpf_cty::c_int,
    pub list: list_head,
    pub fib_seq_read:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net) -> ::aya_bpf_cty::c_uint>,
    pub fib_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut notifier_block,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub owner: *mut module,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_entry {
    pub dev: *mut net_device,
    pub ops: *mut dst_ops,
    pub _metrics: ::aya_bpf_cty::c_ulong,
    pub expires: ::aya_bpf_cty::c_ulong,
    pub xfrm: *mut xfrm_state,
    pub input:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf_cty::c_int>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub obsolete: ::aya_bpf_cty::c_short,
    pub header_len: ::aya_bpf_cty::c_ushort,
    pub trailer_len: ::aya_bpf_cty::c_ushort,
    pub __refcnt: atomic_t,
    pub __use: ::aya_bpf_cty::c_int,
    pub lastuse: ::aya_bpf_cty::c_ulong,
    pub lwtstate: *mut lwtunnel_state,
    pub callback_head: callback_head,
    pub error: ::aya_bpf_cty::c_short,
    pub __pad: ::aya_bpf_cty::c_short,
    pub tclassid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hh_cache {
    pub hh_len: ::aya_bpf_cty::c_uint,
    pub hh_lock: seqlock_t,
    pub hh_data: [::aya_bpf_cty::c_ulong; 16usize],
}
#[repr(C)]
pub struct neighbour {
    pub next: *mut neighbour,
    pub tbl: *mut neigh_table,
    pub parms: *mut neigh_parms,
    pub confirmed: ::aya_bpf_cty::c_ulong,
    pub updated: ::aya_bpf_cty::c_ulong,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub arp_queue_len_bytes: ::aya_bpf_cty::c_uint,
    pub arp_queue: sk_buff_head,
    pub timer: timer_list,
    pub used: ::aya_bpf_cty::c_ulong,
    pub probes: atomic_t,
    pub flags: __u8,
    pub nud_state: __u8,
    pub type_: __u8,
    pub dead: __u8,
    pub protocol: u8_,
    pub ha_lock: seqlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ha: [::aya_bpf_cty::c_uchar; 32usize],
    pub hh: hh_cache,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub ops: *const neigh_ops,
    pub gc_list: list_head,
    pub rcu: callback_head,
    pub dev: *mut net_device,
    pub primary_key: __IncompleteArrayField<u8_>,
}
impl neighbour {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_stable_secret {
    pub initialized: bool_,
    pub secret: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_devconf {
    pub forwarding: __s32,
    pub hop_limit: __s32,
    pub mtu6: __s32,
    pub accept_ra: __s32,
    pub accept_redirects: __s32,
    pub autoconf: __s32,
    pub dad_transmits: __s32,
    pub rtr_solicits: __s32,
    pub rtr_solicit_interval: __s32,
    pub rtr_solicit_max_interval: __s32,
    pub rtr_solicit_delay: __s32,
    pub force_mld_version: __s32,
    pub mldv1_unsolicited_report_interval: __s32,
    pub mldv2_unsolicited_report_interval: __s32,
    pub use_tempaddr: __s32,
    pub temp_valid_lft: __s32,
    pub temp_prefered_lft: __s32,
    pub regen_max_retry: __s32,
    pub max_desync_factor: __s32,
    pub max_addresses: __s32,
    pub accept_ra_defrtr: __s32,
    pub accept_ra_min_hop_limit: __s32,
    pub accept_ra_pinfo: __s32,
    pub ignore_routes_with_linkdown: __s32,
    pub accept_ra_rtr_pref: __s32,
    pub rtr_probe_interval: __s32,
    pub accept_ra_rt_info_min_plen: __s32,
    pub accept_ra_rt_info_max_plen: __s32,
    pub proxy_ndp: __s32,
    pub accept_source_route: __s32,
    pub accept_ra_from_local: __s32,
    pub mc_forwarding: __s32,
    pub disable_ipv6: __s32,
    pub drop_unicast_in_l2_multicast: __s32,
    pub accept_dad: __s32,
    pub force_tllao: __s32,
    pub ndisc_notify: __s32,
    pub suppress_frag_ndisc: __s32,
    pub accept_ra_mtu: __s32,
    pub drop_unsolicited_na: __s32,
    pub stable_secret: ipv6_stable_secret,
    pub use_oif_addrs_only: __s32,
    pub keep_addr_on_down: __s32,
    pub seg6_enabled: __s32,
    pub seg6_require_hmac: __s32,
    pub enhanced_dad: __u32,
    pub addr_gen_mode: __u32,
    pub disable_policy: __s32,
    pub ndisc_tclass: __s32,
    pub rpl_seg_enabled: __s32,
    pub sysctl_header: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_queue_handler {
    pub outfn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nf_queue_entry,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub nf_hook_drop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net)>,
}
pub mod nf_log_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NF_LOG_TYPE_LOG: Type = 0;
    pub const NF_LOG_TYPE_ULOG: Type = 1;
    pub const NF_LOG_TYPE_MAX: Type = 2;
}
pub type u_int8_t = u8_;
pub type nf_logfn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut net,
        arg2: u_int8_t,
        arg3: ::aya_bpf_cty::c_uint,
        arg4: *const sk_buff,
        arg5: *const net_device,
        arg6: *const net_device,
        arg7: *const nf_loginfo,
        arg8: *const ::aya_bpf_cty::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_logger {
    pub name: *mut ::aya_bpf_cty::c_char,
    pub type_: nf_log_type::Type,
    pub logfn: nf_logfn,
    pub me: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: ::aya_bpf_cty::c_uint,
    pub invalid: ::aya_bpf_cty::c_uint,
    pub insert: ::aya_bpf_cty::c_uint,
    pub insert_failed: ::aya_bpf_cty::c_uint,
    pub clash_resolve: ::aya_bpf_cty::c_uint,
    pub drop: ::aya_bpf_cty::c_uint,
    pub early_drop: ::aya_bpf_cty::c_uint,
    pub error: ::aya_bpf_cty::c_uint,
    pub expect_new: ::aya_bpf_cty::c_uint,
    pub expect_create: ::aya_bpf_cty::c_uint,
    pub expect_delete: ::aya_bpf_cty::c_uint,
    pub search_restart: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ct_pcpu {
    pub lock: spinlock_t,
    pub unconfirmed: hlist_nulls_head,
    pub dying: hlist_nulls_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockptr_t {
    pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockptr_t__bindgen_ty_1 {
    pub kernel: *mut ::aya_bpf_cty::c_void,
    pub user: *mut ::aya_bpf_cty::c_void,
}
impl sockptr_t {
    #[inline]
    pub fn is_kernel(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_kernel(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
            is_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod socket_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const SS_FREE: Type = 0;
    pub const SS_UNCONNECTED: Type = 1;
    pub const SS_CONNECTING: Type = 2;
    pub const SS_CONNECTED: Type = 3;
    pub const SS_DISCONNECTING: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl socket_wq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state::Type,
    pub type_: ::aya_bpf_cty::c_short,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub wq: socket_wq,
}
impl socket {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: ::aya_bpf_cty::c_uint,
        arg4: size_t,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_ops {
    pub family: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_uint,
    pub owner: *mut module,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf_cty::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut socket, arg2: *mut socket) -> ::aya_bpf_cty::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut socket,
            arg3: ::aya_bpf_cty::c_int,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut socket,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: bool_,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut socket, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut socket, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: sockptr_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *mut ::aya_bpf_cty::c_char,
            arg5: *mut ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut socket)>,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut msghdr,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut msghdr,
            arg3: size_t,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut socket,
            arg3: *mut vm_area_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut page,
            arg3: ::aya_bpf_cty::c_int,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_int,
        ) -> ssize_t,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ssize_t,
    >,
    pub set_peek_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub peek_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf_cty::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut read_descriptor_t,
            arg3: sk_read_actor_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendpage_locked: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut page,
            arg3: ::aya_bpf_cty::c_int,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_rcvlowat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buffer {
    pub page: *mut page,
    pub offset: ::aya_bpf_cty::c_uint,
    pub len: ::aya_bpf_cty::c_uint,
    pub ops: *const pipe_buf_operations,
    pub flags: ::aya_bpf_cty::c_uint,
    pub private: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buf_operations {
    pub confirm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut pipe_buffer,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
    >,
    pub try_steal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 4usize],
    pub chunks: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub data: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
impl skb_ext {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dql {
    pub num_queued: ::aya_bpf_cty::c_uint,
    pub adj_limit: ::aya_bpf_cty::c_uint,
    pub last_obj_cnt: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub limit: ::aya_bpf_cty::c_uint,
    pub num_completed: ::aya_bpf_cty::c_uint,
    pub prev_ovlimit: ::aya_bpf_cty::c_uint,
    pub prev_num_queued: ::aya_bpf_cty::c_uint,
    pub prev_last_obj_cnt: ::aya_bpf_cty::c_uint,
    pub lowest_slack: ::aya_bpf_cty::c_uint,
    pub slack_start_time: ::aya_bpf_cty::c_ulong,
    pub max_limit: ::aya_bpf_cty::c_uint,
    pub min_limit: ::aya_bpf_cty::c_uint,
    pub slack_hold_time: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl dql {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_ets {
    pub willing: __u8,
    pub ets_cap: __u8,
    pub cbs: __u8,
    pub tc_tx_bw: [__u8; 8usize],
    pub tc_rx_bw: [__u8; 8usize],
    pub tc_tsa: [__u8; 8usize],
    pub prio_tc: [__u8; 8usize],
    pub tc_reco_bw: [__u8; 8usize],
    pub tc_reco_tsa: [__u8; 8usize],
    pub reco_prio_tc: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_maxrate {
    pub tc_maxrate: [__u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_qcn {
    pub rpg_enable: [__u8; 8usize],
    pub rppp_max_rps: [__u32; 8usize],
    pub rpg_time_reset: [__u32; 8usize],
    pub rpg_byte_reset: [__u32; 8usize],
    pub rpg_threshold: [__u32; 8usize],
    pub rpg_max_rate: [__u32; 8usize],
    pub rpg_ai_rate: [__u32; 8usize],
    pub rpg_hai_rate: [__u32; 8usize],
    pub rpg_gd: [__u32; 8usize],
    pub rpg_min_dec_fac: [__u32; 8usize],
    pub rpg_min_rate: [__u32; 8usize],
    pub cndd_state_machine: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_qcn_stats {
    pub rppp_rp_centiseconds: [__u64; 8usize],
    pub rppp_created_rps: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_pfc {
    pub pfc_cap: __u8,
    pub pfc_en: __u8,
    pub mbc: __u8,
    pub delay: __u16,
    pub requests: [__u64; 8usize],
    pub indications: [__u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcbnl_buffer {
    pub prio2buffer: [__u8; 8usize],
    pub buffer_size: [__u32; 8usize],
    pub total_size: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cee_pg {
    pub willing: __u8,
    pub error: __u8,
    pub pg_en: __u8,
    pub tcs_supported: __u8,
    pub pg_bw: [__u8; 8usize],
    pub prio_pg: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cee_pfc {
    pub willing: __u8,
    pub error: __u8,
    pub pfc_en: __u8,
    pub tcs_supported: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb_app {
    pub selector: __u8,
    pub priority: __u8,
    pub protocol: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb_peer_app_info {
    pub willing: __u8,
    pub error: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcbnl_rtnl_ops {
    pub ieee_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_setets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_getmaxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_maxrate,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_setmaxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_maxrate,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_getqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_setqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_getqcnstats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_qcn_stats,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_setpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_setapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_delapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_peer_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf_cty::c_int,
    >,
    pub ieee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf_cty::c_int,
    >,
    pub getstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setstate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub getpermhwaddr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u8_)>,
    pub setpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
    >,
    pub setpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
    >,
    pub getpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
    >,
    pub getpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
    >,
    pub setpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
    >,
    pub getpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
    >,
    pub setall: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub getcap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
        ) -> u8_,
    >,
    pub getnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub setnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_)>,
    pub getbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u32_),
    >,
    pub setbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u32_),
    >,
    pub getbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
    >,
    pub setbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
    >,
    pub setapp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u8_,
            arg3: u16_,
            arg4: u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_, arg3: u16_) -> ::aya_bpf_cty::c_int,
    >,
    pub getfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
        ) -> u8_,
    >,
    pub setfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_) -> u8_,
    >,
    pub getdcbx: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setdcbx:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub peer_getappinfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcb_peer_app_info,
            arg3: *mut u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub peer_getapptable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
    >,
    pub cee_peer_getpg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pg) -> ::aya_bpf_cty::c_int,
    >,
    pub cee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pfc) -> ::aya_bpf_cty::c_int,
    >,
    pub dcbnl_getbuffer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcbnl_buffer,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dcbnl_setbuffer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcbnl_buffer,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct netprio_map {
    pub rcu: callback_head,
    pub priomap_len: u32_,
    pub priomap: __IncompleteArrayField<u32_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_mem_info {
    pub type_: u32_,
    pub id: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_rxq_info {
    pub dev: *mut net_device,
    pub queue_index: u32_,
    pub reg_state: u32_,
    pub mem: xdp_mem_info,
    pub napi_id: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_frame {
    pub data: *mut ::aya_bpf_cty::c_void,
    pub len: u16_,
    pub headroom: u16_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub mem: xdp_mem_info,
    pub dev_rx: *mut net_device,
}
impl xdp_frame {
    #[inline]
    pub fn metasize(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_metasize(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_sz(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_frame_sz(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(metasize: u32_, frame_sz: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let metasize: u32 = unsafe { ::core::mem::transmute(metasize) };
            metasize as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let frame_sz: u32 = unsafe { ::core::mem::transmute(frame_sz) };
            frame_sz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const ::aya_bpf_cty::c_char,
    pub bad_attr: *const nlattr,
    pub policy: *const nla_policy,
    pub cookie: [u8_; 20usize],
    pub cookie_len: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nla_policy {
    pub type_: u8_,
    pub validation_type: u8_,
    pub len: u16_,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nla_policy__bindgen_ty_1 {
    pub bitfield32_valid: u32_,
    pub mask: u32_,
    pub reject_message: *const ::aya_bpf_cty::c_char,
    pub nested_policy: *const nla_policy,
    pub range: *mut netlink_range_validation,
    pub range_signed: *mut netlink_range_validation_signed,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1__bindgen_ty_1,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const nlattr,
            arg2: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub strict_start_type: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_policy__bindgen_ty_1__bindgen_ty_1 {
    pub min: s16,
    pub max: s16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut netlink_callback,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> ::aya_bpf_cty::c_int,
    >,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub answer_flags: u16_,
    pub min_dump_alloc: u32_,
    pub prev_seq: ::aya_bpf_cty::c_uint,
    pub seq: ::aya_bpf_cty::c_uint,
    pub strict_check: bool_,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [::aya_bpf_cty::c_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndmsg {
    pub ndm_family: __u8,
    pub ndm_pad1: __u8,
    pub ndm_pad2: __u16,
    pub ndm_ifindex: __s32,
    pub ndm_state: __u16,
    pub ndm_flags: __u8,
    pub ndm_type: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_guid {
    pub vf: __u32,
    pub guid: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_stats {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub broadcast: __u64,
    pub multicast: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_info {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
    pub vlan: __u32,
    pub qos: __u32,
    pub spoofchk: __u32,
    pub linkstate: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
    pub rss_query_en: __u32,
    pub trusted: __u32,
    pub vlan_proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tc_stats {
    pub bytes: __u64,
    pub packets: __u32,
    pub drops: __u32,
    pub overlimits: __u32,
    pub bps: __u32,
    pub pps: __u32,
    pub qlen: __u32,
    pub backlog: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tc_sizespec {
    pub cell_log: ::aya_bpf_cty::c_uchar,
    pub size_log: ::aya_bpf_cty::c_uchar,
    pub cell_align: ::aya_bpf_cty::c_short,
    pub overhead: ::aya_bpf_cty::c_int,
    pub linklayer: ::aya_bpf_cty::c_uint,
    pub mpu: ::aya_bpf_cty::c_uint,
    pub mtu: ::aya_bpf_cty::c_uint,
    pub tsize: ::aya_bpf_cty::c_uint,
}
pub mod netdev_tx {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const __NETDEV_TX_MIN: Type = 2147483648;
    pub const NETDEV_TX_OK: Type = 0;
    pub const NETDEV_TX_BUSY: Type = 16;
}
pub use self::netdev_tx::Type as netdev_tx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: ::aya_bpf_cty::c_ushort,
            arg4: *const ::aya_bpf_cty::c_void,
            arg5: *const ::aya_bpf_cty::c_void,
            arg6: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sk_buff,
            arg2: *mut ::aya_bpf_cty::c_uchar,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const neighbour,
            arg2: *mut hh_cache,
            arg3: __be16,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cache_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut hh_cache,
            arg2: *const net_device,
            arg3: *const ::aya_bpf_cty::c_uchar,
        ),
    >,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf_cty::c_char,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> bool_,
    >,
    pub parse_protocol:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sk_buff) -> __be16>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_queue {
    pub dev: *mut net_device,
    pub qdisc: *mut Qdisc,
    pub qdisc_sleeping: *mut Qdisc,
    pub kobj: kobject,
    pub numa_node: ::aya_bpf_cty::c_int,
    pub tx_maxrate: ::aya_bpf_cty::c_ulong,
    pub trans_timeout: ::aya_bpf_cty::c_ulong,
    pub sb_dev: *mut net_device,
    pub pool: *mut xsk_buff_pool,
    pub _xmit_lock: spinlock_t,
    pub xmit_lock_owner: ::aya_bpf_cty::c_int,
    pub trans_start: ::aya_bpf_cty::c_ulong,
    pub state: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub dql: dql,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_skb_head {
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_stats_basic_packed {
    pub bytes: __u64,
    pub packets: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_stats_queue {
    pub qlen: __u32,
    pub backlog: __u32,
    pub drops: __u32,
    pub requeues: __u32,
    pub overlimits: __u32,
}
#[repr(C)]
pub struct Qdisc {
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut Qdisc,
            arg3: *mut *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub flags: ::aya_bpf_cty::c_uint,
    pub limit: u32_,
    pub ops: *const Qdisc_ops,
    pub stab: *mut qdisc_size_table,
    pub hash: hlist_node,
    pub handle: u32_,
    pub parent: u32_,
    pub dev_queue: *mut netdev_queue,
    pub rate_est: *mut net_rate_estimator,
    pub cpu_bstats: *mut gnet_stats_basic_cpu,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub pad: ::aya_bpf_cty::c_int,
    pub refcnt: refcount_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub gso_skb: sk_buff_head,
    pub q: qdisc_skb_head,
    pub bstats: gnet_stats_basic_packed,
    pub running: seqcount_t,
    pub qstats: gnet_stats_queue,
    pub state: ::aya_bpf_cty::c_ulong,
    pub next_sched: *mut Qdisc,
    pub skb_bad_txq: sk_buff_head,
    pub busylock: spinlock_t,
    pub seqlock: spinlock_t,
    pub empty: bool_,
    pub rcu: callback_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub privdata: __IncompleteArrayField<::aya_bpf_cty::c_long>,
}
impl Qdisc {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_map {
    pub len: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
    pub cpus: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_dev_flow {
    pub cpu: u16_,
    pub filter: u16_,
    pub last_qtail: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_dev_flow_table {
    pub mask: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
    pub flows: __IncompleteArrayField<rps_dev_flow>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_rx_queue {
    pub rps_map: *mut rps_map,
    pub rps_flow_table: *mut rps_dev_flow_table,
    pub kobj: kobject,
    pub dev: *mut net_device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub xdp_rxq: xdp_rxq_info,
    pub pool: *mut xsk_buff_pool,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_map {
    pub len: ::aya_bpf_cty::c_uint,
    pub alloc_len: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
    pub queues: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_dev_maps {
    pub rcu: callback_head,
    pub attr_map: __IncompleteArrayField<*mut xps_map>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_fcoe_hbainfo {
    pub manufacturer: [::aya_bpf_cty::c_char; 64usize],
    pub serial_number: [::aya_bpf_cty::c_char; 64usize],
    pub hardware_version: [::aya_bpf_cty::c_char; 64usize],
    pub driver_version: [::aya_bpf_cty::c_char; 64usize],
    pub optionrom_version: [::aya_bpf_cty::c_char; 64usize],
    pub firmware_version: [::aya_bpf_cty::c_char; 64usize],
    pub model: [::aya_bpf_cty::c_char; 256usize],
    pub model_description: [::aya_bpf_cty::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_phys_item_id {
    pub id: [::aya_bpf_cty::c_uchar; 32usize],
    pub id_len: ::aya_bpf_cty::c_uchar,
}
pub mod tc_setup_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TC_SETUP_QDISC_MQPRIO: Type = 0;
    pub const TC_SETUP_CLSU32: Type = 1;
    pub const TC_SETUP_CLSFLOWER: Type = 2;
    pub const TC_SETUP_CLSMATCHALL: Type = 3;
    pub const TC_SETUP_CLSBPF: Type = 4;
    pub const TC_SETUP_BLOCK: Type = 5;
    pub const TC_SETUP_QDISC_CBS: Type = 6;
    pub const TC_SETUP_QDISC_RED: Type = 7;
    pub const TC_SETUP_QDISC_PRIO: Type = 8;
    pub const TC_SETUP_QDISC_MQ: Type = 9;
    pub const TC_SETUP_QDISC_ETF: Type = 10;
    pub const TC_SETUP_ROOT_QDISC: Type = 11;
    pub const TC_SETUP_QDISC_GRED: Type = 12;
    pub const TC_SETUP_QDISC_TAPRIO: Type = 13;
    pub const TC_SETUP_FT: Type = 14;
    pub const TC_SETUP_QDISC_ETS: Type = 15;
    pub const TC_SETUP_QDISC_TBF: Type = 16;
    pub const TC_SETUP_QDISC_FIFO: Type = 17;
}
pub mod bpf_netdev_command {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const XDP_SETUP_PROG: Type = 0;
    pub const XDP_SETUP_PROG_HW: Type = 1;
    pub const BPF_OFFLOAD_MAP_ALLOC: Type = 2;
    pub const BPF_OFFLOAD_MAP_FREE: Type = 3;
    pub const XDP_SETUP_XSK_POOL: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf {
    pub command: bpf_netdev_command::Type,
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_bpf__bindgen_ty_1 {
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: netdev_bpf__bindgen_ty_1__bindgen_ty_2,
    pub xsk: netdev_bpf__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    pub flags: u32_,
    pub prog: *mut bpf_prog,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    pub offmap: *mut bpf_offloaded_map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    pub pool: *mut xsk_buff_pool,
    pub queue_id: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrmdev_ops {
    pub xdo_dev_state_add:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state) -> ::aya_bpf_cty::c_int>,
    pub xdo_dev_state_delete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_state_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_offload_ok: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut xfrm_state) -> bool_,
    >,
    pub xdo_dev_state_advance_esn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
}
#[repr(C)]
#[derive(Debug)]
pub struct dev_ifalias {
    pub rcuhead: callback_head,
    pub ifalias: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_name_node {
    pub hlist: hlist_node,
    pub list: list_head,
    pub dev: *mut net_device,
    pub name: *const ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_ops {
    pub ndo_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_uninit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_open:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_stop:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_start_xmit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> netdev_tx_t,
    >,
    pub ndo_features_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_select_queue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sk_buff,
            arg3: *mut net_device,
        ) -> u16_,
    >,
    pub ndo_change_rx_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int),
    >,
    pub ndo_set_rx_mode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_set_mac_address: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_validate_addr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_do_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_config: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ifmap) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_neigh_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neigh_parms) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_tx_timeout: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub ndo_get_stats64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut rtnl_link_stats64),
    >,
    pub ndo_has_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf_cty::c_int) -> bool_,
    >,
    pub ndo_get_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf_cty::c_int,
            arg2: *const net_device,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device_stats,
    >,
    pub ndo_vlan_rx_add_vid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: __be16,
            arg3: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_vlan_rx_kill_vid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: __be16,
            arg3: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_poll_controller: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_netpoll_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netpoll_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_netpoll_cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_set_vf_mac: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_vlan: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u16_,
            arg4: u8_,
            arg5: __be16,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_rate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_spoofchk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_trust: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_vf_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ifla_vf_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_vf_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ifla_vf_stats,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut *mut nlattr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ifla_vf_guid,
            arg4: *mut ifla_vf_guid,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u64_,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_vf_rss_query_en: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: tc_setup_type::Type,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fcoe_enable:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_fcoe_disable:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub ndo_fcoe_ddp_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u16_,
            arg3: *mut scatterlist,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fcoe_ddp_done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u16_) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fcoe_ddp_target: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u16_,
            arg3: *mut scatterlist,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fcoe_get_hbainfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_fcoe_hbainfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fcoe_get_wwn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u64_,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_rx_flow_steer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const sk_buff,
            arg3: u16_,
            arg4: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_add_slave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_del_slave: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut net_device) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_xmit_slave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sk_buff,
            arg3: bool_,
        ) -> *mut net_device,
    >,
    pub ndo_sk_get_lower_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sock) -> *mut net_device,
    >,
    pub ndo_fix_features: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: netdev_features_t) -> netdev_features_t,
    >,
    pub ndo_set_features: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: netdev_features_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_neigh_construct: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neighbour) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_neigh_destroy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neighbour)>,
    pub ndo_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndmsg,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf_cty::c_uchar,
            arg5: u16_,
            arg6: u16_,
            arg7: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndmsg,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf_cty::c_uchar,
            arg5: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut netlink_callback,
            arg3: *mut net_device,
            arg4: *mut net_device,
            arg5: *mut ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fdb_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf_cty::c_uchar,
            arg5: u16_,
            arg6: u32_,
            arg7: u32_,
            arg8: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_bridge_setlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut nlmsghdr,
            arg3: u16_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_bridge_getlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut net_device,
            arg5: u32_,
            arg6: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_bridge_dellink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut nlmsghdr,
            arg3: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_change_carrier: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_phys_port_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_phys_item_id,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_port_parent_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_phys_item_id,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_phys_port_name: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_udp_tunnel_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut udp_tunnel_info),
    >,
    pub ndo_udp_tunnel_del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut udp_tunnel_info),
    >,
    pub ndo_dfwd_add_station: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub ndo_dfwd_del_station: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub ndo_set_tx_maxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_iflink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_change_proto_down: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_fill_metadata_dst: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_set_rx_headroom: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int),
    >,
    pub ndo_bpf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut netdev_bpf) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_xdp_xmit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut *mut xdp_frame,
            arg4: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_xsk_wakeup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_, arg3: u32_) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_devlink_port:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut devlink_port>,
    pub ndo_tunnel_ctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ip_tunnel_parm,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ndo_get_peer_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_parms {
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub list: list_head,
    pub neigh_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf_cty::c_int>,
    pub tbl: *mut neigh_table,
    pub sysctl_table: *mut ::aya_bpf_cty::c_void,
    pub dead: ::aya_bpf_cty::c_int,
    pub refcnt: refcount_t,
    pub callback_head: callback_head,
    pub reachable_time: ::aya_bpf_cty::c_int,
    pub data: [::aya_bpf_cty::c_int; 13usize],
    pub data_state: [::aya_bpf_cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_lstats {
    pub packets: u64_stats_t,
    pub bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_sw_netstats {
    pub rx_packets: u64_,
    pub rx_bytes: u64_,
    pub tx_packets: u64_,
    pub tx_bytes: u64_,
    pub syncp: u64_stats_sync,
}
pub type iw_handler = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut net_device,
        arg2: *mut iw_request_info,
        arg3: *mut iwreq_data,
        arg4: *mut ::aya_bpf_cty::c_char,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_handler_def {
    pub standard: *const iw_handler,
    pub num_standard: __u16,
    pub num_private: __u16,
    pub num_private_args: __u16,
    pub private: *const iw_handler,
    pub private_args: *const iw_priv_args,
    pub get_wireless_stats:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut iw_statistics>,
}
pub mod ethtool_phys_id_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_ID_INACTIVE: Type = 0;
    pub const ETHTOOL_ID_ACTIVE: Type = 1;
    pub const ETHTOOL_ID_ON: Type = 2;
    pub const ETHTOOL_ID_OFF: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ops {
    pub supported_coalesce_params: u32_,
    pub get_drvinfo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
    >,
    pub get_regs_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_regs,
            arg3: *mut ::aya_bpf_cty::c_void,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_wolinfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_msglevel: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_msglevel:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>,
    pub nway_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub get_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_link_ext_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ext_state_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_eeprom_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ringparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ringparam),
    >,
    pub set_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_pause_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pause_stats),
    >,
    pub get_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
    >,
    pub set_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_pauseparam,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_, arg3: *mut u8_),
    >,
    pub set_phys_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ethtool_phys_id_state::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub begin:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub get_priv_flags: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_priv_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> ::aya_bpf_cty::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
            arg3: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flash_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_flash,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> ::aya_bpf_cty::c_int,
    >,
    pub get_rxfh_key_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh_indir_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u32_,
            arg3: *mut u8_,
            arg4: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const u32_,
            arg3: *const u8_,
            arg4: u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u32_,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const u32_,
            arg3: *const u8_,
            arg4: u8_,
            arg5: *mut u32_,
            arg6: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
    >,
    pub set_channels: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_channels,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_dump_flag: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_dump_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ts_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_module_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_modinfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> ::aya_bpf_cty::c_int,
    >,
    pub set_eee: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eee) -> ::aya_bpf_cty::c_int,
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ksettings,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_link_ksettings,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l3mdev_ops {
    pub l3mdev_fib_table:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> u32_>,
    pub l3mdev_l3_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sk_buff, arg3: u16_) -> *mut sk_buff,
    >,
    pub l3mdev_l3_out: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: *mut sk_buff,
            arg4: u16_,
        ) -> *mut sk_buff,
    >,
    pub l3mdev_link_scope_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *mut flowi6) -> *mut dst_entry,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndisc_ops {
    pub is_useropt: ::core::option::Option<unsafe extern "C" fn(arg1: u8_) -> ::aya_bpf_cty::c_int>,
    pub parse_options: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut nd_opt_hdr,
            arg3: *mut ndisc_options,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut neighbour,
            arg3: u32_,
            arg4: u8_,
            arg5: *const ndisc_options,
        ),
    >,
    pub opt_addr_space: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: u8_,
            arg3: *mut neighbour,
            arg4: *mut u8_,
            arg5: *mut *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub fill_addr_option: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut sk_buff,
            arg3: u8_,
            arg4: *const u8_,
        ),
    >,
    pub prefix_rcv_add_addr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut net_device,
            arg3: *const prefix_info,
            arg4: *mut inet6_dev,
            arg5: *mut in6_addr,
            arg6: ::aya_bpf_cty::c_int,
            arg7: u32_,
            arg8: bool_,
            arg9: bool_,
            arg10: __u32,
            arg11: u32_,
            arg12: bool_,
        ),
    >,
}
pub mod tls_offload_ctx_dir {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TLS_OFFLOAD_CTX_DIR_RX: Type = 0;
    pub const TLS_OFFLOAD_CTX_DIR_TX: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlsdev_ops {
    pub tls_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: tls_offload_ctx_dir::Type,
            arg4: *mut tls_crypto_info,
            arg5: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub tls_dev_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut tls_context,
            arg3: tls_offload_ctx_dir::Type,
        ),
    >,
    pub tls_dev_resync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: u32_,
            arg4: *mut u8_,
            arg5: tls_offload_ctx_dir::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_devstat {
    pub proc_dir_entry: *mut proc_dir_entry,
    pub ipv6: *mut ipstats_mib,
    pub icmpv6dev: *mut icmpv6_mib_device,
    pub icmpv6msgdev: *mut icmpv6msg_mib_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet6_dev {
    pub dev: *mut net_device,
    pub addr_list: list_head,
    pub mc_list: *mut ifmcaddr6,
    pub mc_tomb: *mut ifmcaddr6,
    pub mc_lock: spinlock_t,
    pub mc_qrv: ::aya_bpf_cty::c_uchar,
    pub mc_gq_running: ::aya_bpf_cty::c_uchar,
    pub mc_ifc_count: ::aya_bpf_cty::c_uchar,
    pub mc_dad_count: ::aya_bpf_cty::c_uchar,
    pub mc_v1_seen: ::aya_bpf_cty::c_ulong,
    pub mc_qi: ::aya_bpf_cty::c_ulong,
    pub mc_qri: ::aya_bpf_cty::c_ulong,
    pub mc_maxdelay: ::aya_bpf_cty::c_ulong,
    pub mc_gq_timer: timer_list,
    pub mc_ifc_timer: timer_list,
    pub mc_dad_timer: timer_list,
    pub ac_list: *mut ifacaddr6,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub if_flags: __u32,
    pub dead: ::aya_bpf_cty::c_int,
    pub desync_factor: u32_,
    pub tempaddr_list: list_head,
    pub token: in6_addr,
    pub nd_parms: *mut neigh_parms,
    pub cnf: ipv6_devconf,
    pub stats: ipv6_devstat,
    pub rs_timer: timer_list,
    pub rs_interval: __s32,
    pub rs_probes: __u8,
    pub tstamp: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mini_Qdisc {
    pub filter_list: *mut tcf_proto,
    pub block: *mut tcf_block,
    pub cpu_bstats: *mut gnet_stats_basic_cpu,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_link_ops {
    pub list: list_head,
    pub kind: *const ::aya_bpf_cty::c_char,
    pub priv_size: size_t,
    pub setup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub netns_refund: bool_,
    pub maxtype: ::aya_bpf_cty::c_uint,
    pub policy: *const nla_policy,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut nlattr,
            arg2: *mut *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub newlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut net_device,
            arg3: *mut *mut nlattr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub changelink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut *mut nlattr,
            arg3: *mut *mut nlattr,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dellink:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut list_head)>,
    pub get_size: ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> size_t>,
    pub fill_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *const net_device) -> ::aya_bpf_cty::c_int,
    >,
    pub get_xstats_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> size_t>,
    pub fill_xstats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *const net_device) -> ::aya_bpf_cty::c_int,
    >,
    pub get_num_tx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_uint>,
    pub get_num_rx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_uint>,
    pub slave_maxtype: ::aya_bpf_cty::c_uint,
    pub slave_policy: *const nla_policy,
    pub slave_changelink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
            arg3: *mut *mut nlattr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_slave_size: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *const net_device) -> size_t,
    >,
    pub fill_slave_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const net_device,
            arg3: *const net_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_link_net:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> *mut net>,
    pub get_linkxstats_size: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf_cty::c_int) -> size_t,
    >,
    pub fill_linkxstats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const net_device,
            arg3: *mut ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_table_info {
    pub n_entries: ::aya_bpf_cty::c_uint,
    pub tunnel_types: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_info {
    pub set_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut udp_tunnel_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub unset_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut udp_tunnel_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sync_table: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub shared: *mut udp_tunnel_nic_shared,
    pub flags: ::aya_bpf_cty::c_uint,
    pub tables: [udp_tunnel_nic_table_info; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcmsg {
    pub tcm_family: ::aya_bpf_cty::c_uchar,
    pub tcm__pad1: ::aya_bpf_cty::c_uchar,
    pub tcm__pad2: ::aya_bpf_cty::c_ushort,
    pub tcm_ifindex: ::aya_bpf_cty::c_int,
    pub tcm_handle: __u32,
    pub tcm_parent: __u32,
    pub tcm_info: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_stats_basic_cpu {
    pub bstats: gnet_stats_basic_packed,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_dump {
    pub lock: *mut spinlock_t,
    pub skb: *mut sk_buff,
    pub tail: *mut nlattr,
    pub compat_tc_stats: ::aya_bpf_cty::c_int,
    pub compat_xstats: ::aya_bpf_cty::c_int,
    pub padattr: ::aya_bpf_cty::c_int,
    pub xstats: *mut ::aya_bpf_cty::c_void,
    pub xstats_len: ::aya_bpf_cty::c_int,
    pub tc_stats: tc_stats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_range_validation {
    pub min: u64_,
    pub max: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_range_validation_signed {
    pub min: s64,
    pub max: s64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_block {
    pub cb_list: list_head,
}
pub type flow_setup_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: tc_setup_type::Type,
        arg2: *mut ::aya_bpf_cty::c_void,
        arg3: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct qdisc_size_table {
    pub rcu: callback_head,
    pub list: list_head,
    pub szopts: tc_sizespec,
    pub refcnt: ::aya_bpf_cty::c_int,
    pub data: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qdisc_ops {
    pub next: *mut Qdisc_ops,
    pub cl_ops: *const Qdisc_class_ops,
    pub id: [::aya_bpf_cty::c_char; 16usize],
    pub priv_size: ::aya_bpf_cty::c_int,
    pub static_flags: ::aya_bpf_cty::c_uint,
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut Qdisc,
            arg3: *mut *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub peek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change_tx_queue_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_uint) -> ::aya_bpf_cty::c_int,
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut gnet_dump) -> ::aya_bpf_cty::c_int,
    >,
    pub ingress_block_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>,
    pub egress_block_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>,
    pub ingress_block_get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>,
    pub egress_block_get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>,
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qdisc_class_ops {
    pub flags: ::aya_bpf_cty::c_uint,
    pub select_queue: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut tcmsg) -> *mut netdev_queue,
    >,
    pub graft: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut Qdisc,
            arg4: *mut *mut Qdisc,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub leaf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong) -> *mut Qdisc,
    >,
    pub qlen_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong),
    >,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_) -> ::aya_bpf_cty::c_ulong,
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut ::aya_bpf_cty::c_ulong,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub walk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut qdisc_walker)>,
    pub tcf_block: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut netlink_ext_ack,
        ) -> *mut tcf_block,
    >,
    pub bind_tcf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
    pub unbind_tcf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong),
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut sk_buff,
            arg4: *mut tcmsg,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut gnet_dump,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_block {
    pub lock: mutex,
    pub chain_list: list_head,
    pub index: u32_,
    pub classid: u32_,
    pub refcnt: refcount_t,
    pub net: *mut net,
    pub q: *mut Qdisc,
    pub cb_lock: rw_semaphore,
    pub flow_block: flow_block,
    pub owner_list: list_head,
    pub keep_dst: bool_,
    pub offloadcnt: atomic_t,
    pub nooffloaddevcnt: ::aya_bpf_cty::c_uint,
    pub lockeddevcnt: ::aya_bpf_cty::c_uint,
    pub chain0: tcf_block__bindgen_ty_1,
    pub rcu: callback_head,
    pub proto_destroy_ht: [hlist_head; 128usize],
    pub proto_destroy_lock: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_block__bindgen_ty_1 {
    pub chain: *mut tcf_chain,
    pub filter_chain_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_proto {
    pub next: *mut tcf_proto,
    pub root: *mut ::aya_bpf_cty::c_void,
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub protocol: __be16,
    pub prio: u32_,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub ops: *const tcf_proto_ops,
    pub chain: *mut tcf_chain,
    pub lock: spinlock_t,
    pub deleting: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub destroy_ht_node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_result {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcf_result__bindgen_ty_1 {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1__bindgen_ty_1,
    pub goto_tp: *const tcf_proto,
    pub __bindgen_anon_2: tcf_result__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_1 {
    pub class: ::aya_bpf_cty::c_ulong,
    pub classid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_2 {
    pub ingress: bool_,
    pub qstats: *mut gnet_stats_queue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_proto_ops {
    pub head: list_head,
    pub kind: [::aya_bpf_cty::c_char; 16usize],
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> ::aya_bpf_cty::c_int>,
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: bool_, arg3: *mut netlink_ext_ack),
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: u32_) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sk_buff,
            arg3: *mut tcf_proto,
            arg4: ::aya_bpf_cty::c_ulong,
            arg5: u32_,
            arg6: *mut *mut nlattr,
            arg7: *mut *mut ::aya_bpf_cty::c_void,
            arg8: bool_,
            arg9: bool_,
            arg10: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut bool_,
            arg4: bool_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub delete_empty: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> bool_>,
    pub walk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut tcf_walker, arg3: bool_),
    >,
    pub reoffload: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: bool_,
            arg3: flow_setup_cb_t,
            arg4: *mut ::aya_bpf_cty::c_void,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub hw_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub hw_del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub bind_class: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_void,
            arg2: u32_,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: *mut ::aya_bpf_cty::c_void,
            arg5: ::aya_bpf_cty::c_ulong,
        ),
    >,
    pub tmplt_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_chain,
            arg3: *mut *mut nlattr,
            arg4: *mut netlink_ext_ack,
        ) -> *mut ::aya_bpf_cty::c_void,
    >,
    pub tmplt_destroy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: *mut sk_buff,
            arg5: *mut tcmsg,
            arg6: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub terse_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: *mut sk_buff,
            arg5: *mut tcmsg,
            arg6: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub tmplt_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub owner: *mut module,
    pub flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_chain {
    pub filter_chain_lock: mutex,
    pub filter_chain: *mut tcf_proto,
    pub list: list_head,
    pub block: *mut tcf_block,
    pub index: u32_,
    pub refcnt: ::aya_bpf_cty::c_uint,
    pub action_refcnt: ::aya_bpf_cty::c_uint,
    pub explicitly_created: bool_,
    pub flushing: bool_,
    pub tmplt_ops: *const tcf_proto_ops,
    pub tmplt_priv: *mut ::aya_bpf_cty::c_void,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_fprog_kern {
    pub len: u16_,
    pub filter: *mut sock_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_filter {
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub prog: *mut bpf_prog,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_table {
    pub family: ::aya_bpf_cty::c_int,
    pub entry_size: ::aya_bpf_cty::c_uint,
    pub key_len: ::aya_bpf_cty::c_uint,
    pub protocol: __be16,
    pub hash: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf_cty::c_void,
            arg2: *const net_device,
            arg3: *mut __u32,
        ) -> __u32,
    >,
    pub key_eq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const neighbour, arg2: *const ::aya_bpf_cty::c_void) -> bool_,
    >,
    pub constructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf_cty::c_int>,
    pub pconstructor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pneigh_entry) -> ::aya_bpf_cty::c_int,
    >,
    pub pdestructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
    pub proxy_redo: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub is_multicast: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
    >,
    pub allow_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *mut netlink_ext_ack) -> bool_,
    >,
    pub id: *mut ::aya_bpf_cty::c_char,
    pub parms: neigh_parms,
    pub parms_list: list_head,
    pub gc_interval: ::aya_bpf_cty::c_int,
    pub gc_thresh1: ::aya_bpf_cty::c_int,
    pub gc_thresh2: ::aya_bpf_cty::c_int,
    pub gc_thresh3: ::aya_bpf_cty::c_int,
    pub last_flush: ::aya_bpf_cty::c_ulong,
    pub gc_work: delayed_work,
    pub proxy_timer: timer_list,
    pub proxy_queue: sk_buff_head,
    pub entries: atomic_t,
    pub gc_entries: atomic_t,
    pub gc_list: list_head,
    pub lock: rwlock_t,
    pub last_rand: ::aya_bpf_cty::c_ulong,
    pub stats: *mut neigh_statistics,
    pub nht: *mut neigh_hash_table,
    pub phash_buckets: *mut *mut pneigh_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_statistics {
    pub allocs: ::aya_bpf_cty::c_ulong,
    pub destroys: ::aya_bpf_cty::c_ulong,
    pub hash_grows: ::aya_bpf_cty::c_ulong,
    pub res_failed: ::aya_bpf_cty::c_ulong,
    pub lookups: ::aya_bpf_cty::c_ulong,
    pub hits: ::aya_bpf_cty::c_ulong,
    pub rcv_probes_mcast: ::aya_bpf_cty::c_ulong,
    pub rcv_probes_ucast: ::aya_bpf_cty::c_ulong,
    pub periodic_gc_runs: ::aya_bpf_cty::c_ulong,
    pub forced_gc_runs: ::aya_bpf_cty::c_ulong,
    pub unres_discards: ::aya_bpf_cty::c_ulong,
    pub table_fulls: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_ops {
    pub family: ::aya_bpf_cty::c_int,
    pub solicit:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub error_report:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub connected_output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct pneigh_entry {
    pub next: *mut pneigh_entry,
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub flags: u8_,
    pub protocol: u8_,
    pub key: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_hash_table {
    pub hash_buckets: *mut *mut neighbour,
    pub hash_shift: ::aya_bpf_cty::c_uint,
    pub hash_rnd: [__u32; 4usize],
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule_hdr {
    pub family: __u8,
    pub dst_len: __u8,
    pub src_len: __u8,
    pub tos: __u8,
    pub table: __u8,
    pub res1: __u8,
    pub res2: __u8,
    pub action: __u8,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule_port_range {
    pub start: __u16,
    pub end: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_kuid_range {
    pub start: kuid_t,
    pub end: kuid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule {
    pub list: list_head,
    pub iifindex: ::aya_bpf_cty::c_int,
    pub oifindex: ::aya_bpf_cty::c_int,
    pub mark: u32_,
    pub mark_mask: u32_,
    pub flags: u32_,
    pub table: u32_,
    pub action: u8_,
    pub l3mdev: u8_,
    pub proto: u8_,
    pub ip_proto: u8_,
    pub target: u32_,
    pub tun_id: __be64,
    pub ctarget: *mut fib_rule,
    pub fr_net: *mut net,
    pub refcnt: refcount_t,
    pub pref: u32_,
    pub suppress_ifgroup: ::aya_bpf_cty::c_int,
    pub suppress_prefixlen: ::aya_bpf_cty::c_int,
    pub iifname: [::aya_bpf_cty::c_char; 16usize],
    pub oifname: [::aya_bpf_cty::c_char; 16usize],
    pub uid_range: fib_kuid_range,
    pub sport_range: fib_rule_port_range,
    pub dport_range: fib_rule_port_range,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_lookup_arg {
    pub lookup_ptr: *mut ::aya_bpf_cty::c_void,
    pub lookup_data: *const ::aya_bpf_cty::c_void,
    pub result: *mut ::aya_bpf_cty::c_void,
    pub rule: *mut fib_rule,
    pub table: u32_,
    pub flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smc_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto {
    pub close:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_long)>,
    pub pre_connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_int,
            arg4: bool_,
        ) -> *mut sock,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub shutdown:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int)>,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: sockptr_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *mut ::aya_bpf_cty::c_char,
            arg5: *mut ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub keepalive:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int)>,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: size_t,
            arg4: ::aya_bpf_cty::c_int,
            arg5: ::aya_bpf_cty::c_int,
            arg6: *mut ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut page,
            arg3: ::aya_bpf_cty::c_int,
            arg4: size_t,
            arg5: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub bind_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub release_cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub hash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>,
    pub unhash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub rehash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub get_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_ushort,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub inuse_idx: ::aya_bpf_cty::c_uint,
    pub stream_memory_free: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: ::aya_bpf_cty::c_int) -> bool_,
    >,
    pub stream_memory_read:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sock) -> bool_>,
    pub enter_memory_pressure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub leave_memory_pressure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub memory_allocated: *mut atomic_long_t,
    pub sockets_allocated: *mut percpu_counter,
    pub memory_pressure: *mut ::aya_bpf_cty::c_ulong,
    pub sysctl_mem: *mut ::aya_bpf_cty::c_long,
    pub sysctl_wmem: *mut ::aya_bpf_cty::c_int,
    pub sysctl_rmem: *mut ::aya_bpf_cty::c_int,
    pub sysctl_wmem_offset: u32_,
    pub sysctl_rmem_offset: u32_,
    pub max_header: ::aya_bpf_cty::c_int,
    pub no_autobind: bool_,
    pub slab: *mut kmem_cache,
    pub obj_size: ::aya_bpf_cty::c_uint,
    pub slab_flags: slab_flags_t,
    pub useroffset: ::aya_bpf_cty::c_uint,
    pub usersize: ::aya_bpf_cty::c_uint,
    pub orphan_count: *mut percpu_counter,
    pub rsk_prot: *mut request_sock_ops,
    pub twsk_prot: *mut timewait_sock_ops,
    pub h: proto__bindgen_ty_1,
    pub owner: *mut module,
    pub name: [::aya_bpf_cty::c_char; 32usize],
    pub node: list_head,
    pub diag_destroy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proto__bindgen_ty_1 {
    pub hashinfo: *mut inet_hashinfo,
    pub udp_table: *mut udp_table,
    pub raw_hash: *mut raw_hashinfo,
    pub smc_hash: *mut smc_hashinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_sock_ops {
    pub family: ::aya_bpf_cty::c_int,
    pub obj_size: ::aya_bpf_cty::c_uint,
    pub slab: *mut kmem_cache,
    pub slab_name: *mut ::aya_bpf_cty::c_char,
    pub rtx_syn_ack: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *mut request_sock) -> ::aya_bpf_cty::c_int,
    >,
    pub send_ack: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff, arg3: *mut request_sock),
    >,
    pub send_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff)>,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_sock)>,
    pub syn_ack_timeout: ::core::option::Option<unsafe extern "C" fn(arg1: *const request_sock)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timewait_sock_ops {
    pub twsk_slab: *mut kmem_cache,
    pub twsk_slab_name: *mut ::aya_bpf_cty::c_char,
    pub twsk_obj_size: ::aya_bpf_cty::c_uint,
    pub twsk_unique: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sock,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub twsk_destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
}
#[repr(C)]
pub struct request_sock {
    pub __req_common: sock_common,
    pub dl_next: *mut request_sock,
    pub mss: u16_,
    pub num_retrans: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ts_recent: u32_,
    pub rsk_timer: timer_list,
    pub rsk_ops: *const request_sock_ops,
    pub sk: *mut sock,
    pub saved_syn: *mut saved_syn,
    pub secid: u32_,
    pub peer_secid: u32_,
}
impl request_sock {
    #[inline]
    pub fn syncookie(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syncookie(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_timeout(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_num_timeout(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(syncookie: u8_, num_timeout: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let syncookie: u8 = unsafe { ::core::mem::transmute(syncookie) };
            syncookie as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let num_timeout: u8 = unsafe { ::core::mem::transmute(num_timeout) };
            num_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct saved_syn {
    pub mac_hdrlen: u32_,
    pub network_hdrlen: u32_,
    pub tcp_hdrlen: u32_,
    pub data: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_sf_list {
    pub sf_next: *mut ip6_sf_list,
    pub sf_addr: in6_addr,
    pub sf_count: [::aya_bpf_cty::c_ulong; 2usize],
    pub sf_gsresp: ::aya_bpf_cty::c_uchar,
    pub sf_oldin: ::aya_bpf_cty::c_uchar,
    pub sf_crcount: ::aya_bpf_cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifmcaddr6 {
    pub mca_addr: in6_addr,
    pub idev: *mut inet6_dev,
    pub next: *mut ifmcaddr6,
    pub mca_sources: *mut ip6_sf_list,
    pub mca_tomb: *mut ip6_sf_list,
    pub mca_sfmode: ::aya_bpf_cty::c_uint,
    pub mca_crcount: ::aya_bpf_cty::c_uchar,
    pub mca_sfcount: [::aya_bpf_cty::c_ulong; 2usize],
    pub mca_timer: timer_list,
    pub mca_flags: ::aya_bpf_cty::c_uint,
    pub mca_users: ::aya_bpf_cty::c_int,
    pub mca_refcnt: refcount_t,
    pub mca_lock: spinlock_t,
    pub mca_cstamp: ::aya_bpf_cty::c_ulong,
    pub mca_tstamp: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifacaddr6 {
    pub aca_addr: in6_addr,
    pub aca_rt: *mut fib6_info,
    pub aca_next: *mut ifacaddr6,
    pub aca_addr_lst: hlist_node,
    pub aca_users: ::aya_bpf_cty::c_int,
    pub aca_refcnt: refcount_t,
    pub aca_cstamp: ::aya_bpf_cty::c_ulong,
    pub aca_tstamp: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_hdr {
    pub nd_opt_type: __u8,
    pub nd_opt_len: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndisc_options {
    pub nd_opt_array: [*mut nd_opt_hdr; 15usize],
    pub nd_opts_ri: *mut nd_opt_hdr,
    pub nd_opts_ri_end: *mut nd_opt_hdr,
    pub nd_useropts: *mut nd_opt_hdr,
    pub nd_useropts_end: *mut nd_opt_hdr,
    pub nd_802154_opt_array: [*mut nd_opt_hdr; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prefix_info {
    pub type_: __u8,
    pub length: __u8,
    pub prefix_len: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub valid: __be32,
    pub prefered: __be32,
    pub reserved2: __be32,
    pub prefix: in6_addr,
}
impl prefix_info {
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn autoconf(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autoconf(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onlink(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onlink(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u8,
        autoconf: __u8,
        onlink: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoconf: u8 = unsafe { ::core::mem::transmute(autoconf) };
            autoconf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let onlink: u8 = unsafe { ::core::mem::transmute(onlink) };
            onlink as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_bitmap {
    pub sequence: u64_,
    pub refcnt: refcount_t,
    pub max: ::aya_bpf_cty::c_uint,
    pub bitmap: [::aya_bpf_cty::c_ulong; 1024usize],
}
pub mod irqreturn {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IRQ_NONE: Type = 0;
    pub const IRQ_HANDLED: Type = 1;
    pub const IRQ_WAKE_THREAD: Type = 2;
}
pub use self::irqreturn::Type as irqreturn_t;
pub type irq_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::aya_bpf_cty::c_int,
        arg2: *mut ::aya_bpf_cty::c_void,
    ) -> irqreturn_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irqaction {
    pub handler: irq_handler_t,
    pub dev_id: *mut ::aya_bpf_cty::c_void,
    pub percpu_dev_id: *mut ::aya_bpf_cty::c_void,
    pub next: *mut irqaction,
    pub thread_fn: irq_handler_t,
    pub thread: *mut task_struct,
    pub secondary: *mut irqaction,
    pub irq: ::aya_bpf_cty::c_uint,
    pub flags: ::aya_bpf_cty::c_uint,
    pub thread_flags: ::aya_bpf_cty::c_ulong,
    pub thread_mask: ::aya_bpf_cty::c_ulong,
    pub name: *const ::aya_bpf_cty::c_char,
    pub dir: *mut proc_dir_entry,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl irqaction {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_affinity_notify {
    pub irq: ::aya_bpf_cty::c_uint,
    pub kref: kref,
    pub work: work_struct,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_affinity_notify, arg2: *const cpumask_t),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kref)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_affinity_desc {
    pub mask: cpumask,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl irq_affinity_desc {
    #[inline]
    pub fn is_managed(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_managed(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_managed: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_managed: u32 = unsafe { ::core::mem::transmute(is_managed) };
            is_managed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod irqchip_irq_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IRQCHIP_STATE_PENDING: Type = 0;
    pub const IRQCHIP_STATE_ACTIVE: Type = 1;
    pub const IRQCHIP_STATE_MASKED: Type = 2;
    pub const IRQCHIP_STATE_LINE_LEVEL: Type = 3;
}
pub type irq_flow_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_desc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_common_data {
    pub state_use_accessors: ::aya_bpf_cty::c_uint,
    pub node: ::aya_bpf_cty::c_uint,
    pub handler_data: *mut ::aya_bpf_cty::c_void,
    pub msi_desc: *mut msi_desc,
    pub affinity: cpumask_var_t,
    pub effective_affinity: cpumask_var_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub mask: u32_,
    pub irq: ::aya_bpf_cty::c_uint,
    pub hwirq: ::aya_bpf_cty::c_ulong,
    pub common: *mut irq_common_data,
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub parent_data: *mut irq_data,
    pub chip_data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_desc {
    pub irq_common_data: irq_common_data,
    pub irq_data: irq_data,
    pub kstat_irqs: *mut ::aya_bpf_cty::c_uint,
    pub handle_irq: irq_flow_handler_t,
    pub action: *mut irqaction,
    pub status_use_accessors: ::aya_bpf_cty::c_uint,
    pub core_internal_state__do_not_mess_with_it: ::aya_bpf_cty::c_uint,
    pub depth: ::aya_bpf_cty::c_uint,
    pub wake_depth: ::aya_bpf_cty::c_uint,
    pub tot_count: ::aya_bpf_cty::c_uint,
    pub irq_count: ::aya_bpf_cty::c_uint,
    pub last_unhandled: ::aya_bpf_cty::c_ulong,
    pub irqs_unhandled: ::aya_bpf_cty::c_uint,
    pub threads_handled: atomic_t,
    pub threads_handled_last: ::aya_bpf_cty::c_int,
    pub lock: raw_spinlock_t,
    pub percpu_enabled: *mut cpumask,
    pub percpu_affinity: *const cpumask,
    pub affinity_hint: *const cpumask,
    pub affinity_notify: *mut irq_affinity_notify,
    pub pending_mask: cpumask_var_t,
    pub threads_oneshot: ::aya_bpf_cty::c_ulong,
    pub threads_active: atomic_t,
    pub wait_for_threads: wait_queue_head_t,
    pub nr_actions: ::aya_bpf_cty::c_uint,
    pub no_suspend_depth: ::aya_bpf_cty::c_uint,
    pub cond_suspend_depth: ::aya_bpf_cty::c_uint,
    pub force_resume_depth: ::aya_bpf_cty::c_uint,
    pub dir: *mut proc_dir_entry,
    pub rcu: callback_head,
    pub kobj: kobject,
    pub request_mutex: mutex,
    pub parent_irq: ::aya_bpf_cty::c_int,
    pub owner: *mut module,
    pub name: *const ::aya_bpf_cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_msi_addr_lo {
    pub __bindgen_anon_1: x86_msi_addr_lo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x86_msi_addr_lo__bindgen_ty_1 {
    pub __bindgen_anon_1: x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode_logical(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_mode_logical(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect_hint(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect_hint(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_destid_8_14(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_virt_destid_8_14(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn destid_0_7(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_destid_0_7(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn base_address(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_base_address(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32_,
        dest_mode_logical: u32_,
        redirect_hint: u32_,
        reserved_1: u32_,
        virt_destid_8_14: u32_,
        destid_0_7: u32_,
        base_address: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dest_mode_logical: u32 = unsafe { ::core::mem::transmute(dest_mode_logical) };
            dest_mode_logical as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let redirect_hint: u32 = unsafe { ::core::mem::transmute(redirect_hint) };
            redirect_hint as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved_1: u32 = unsafe { ::core::mem::transmute(reserved_1) };
            reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let virt_destid_8_14: u32 = unsafe { ::core::mem::transmute(virt_destid_8_14) };
            virt_destid_8_14 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let destid_0_7: u32 = unsafe { ::core::mem::transmute(destid_0_7) };
            destid_0_7 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let base_address: u32 = unsafe { ::core::mem::transmute(base_address) };
            base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn dmar_reserved_0(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_reserved_0(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_index_15(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_index_15(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_subhandle_valid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_subhandle_valid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_format(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_format(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_index_0_14(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_index_0_14(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_base_address(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_base_address(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dmar_reserved_0: u32_,
        dmar_index_15: u32_,
        dmar_subhandle_valid: u32_,
        dmar_format: u32_,
        dmar_index_0_14: u32_,
        dmar_base_address: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dmar_reserved_0: u32 = unsafe { ::core::mem::transmute(dmar_reserved_0) };
            dmar_reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dmar_index_15: u32 = unsafe { ::core::mem::transmute(dmar_index_15) };
            dmar_index_15 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dmar_subhandle_valid: u32 = unsafe { ::core::mem::transmute(dmar_subhandle_valid) };
            dmar_subhandle_valid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dmar_format: u32 = unsafe { ::core::mem::transmute(dmar_format) };
            dmar_format as u64
        });
        __bindgen_bitfield_unit.set(5usize, 15u8, {
            let dmar_index_0_14: u32 = unsafe { ::core::mem::transmute(dmar_index_0_14) };
            dmar_index_0_14 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let dmar_base_address: u32 = unsafe { ::core::mem::transmute(dmar_base_address) };
            dmar_base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_addr_lo_t = x86_msi_addr_lo;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_hi {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_hi {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn destid_8_31(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_destid_8_31(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        destid_8_31: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let destid_8_31: u32 = unsafe { ::core::mem::transmute(destid_8_31) };
            destid_8_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_addr_hi_t = x86_msi_addr_hi;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_data {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub dmar_subhandle: u32_,
}
impl x86_msi_data {
    #[inline]
    pub fn vector(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode_logical(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_mode_logical(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn active_low(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_level(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_level(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: u32_,
        delivery_mode: u32_,
        dest_mode_logical: u32_,
        reserved: u32_,
        active_low: u32_,
        is_level: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::core::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::core::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dest_mode_logical: u32 = unsafe { ::core::mem::transmute(dest_mode_logical) };
            dest_mode_logical as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is_level: u32 = unsafe { ::core::mem::transmute(is_level) };
            is_level as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_data_t = x86_msi_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_msg {
    pub __bindgen_anon_1: msi_msg__bindgen_ty_1,
    pub __bindgen_anon_2: msi_msg__bindgen_ty_2,
    pub __bindgen_anon_3: msi_msg__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_1 {
    pub address_lo: u32_,
    pub arch_addr_lo: arch_msi_msg_addr_lo_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_2 {
    pub address_hi: u32_,
    pub arch_addr_hi: arch_msi_msg_addr_hi_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_3 {
    pub data: u32_,
    pub arch_data: arch_msi_msg_data_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct platform_msi_desc {
    pub msi_priv_data: *mut platform_msi_priv_data,
    pub msi_index: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsl_mc_msi_desc {
    pub msi_index: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ti_sci_inta_msi_desc {
    pub dev_index: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc {
    pub list: list_head,
    pub irq: ::aya_bpf_cty::c_uint,
    pub nvec_used: ::aya_bpf_cty::c_uint,
    pub dev: *mut device,
    pub msg: msi_msg,
    pub affinity: *mut irq_affinity_desc,
    pub iommu_cookie: *const ::aya_bpf_cty::c_void,
    pub write_msi_msg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut msi_desc, arg2: *mut ::aya_bpf_cty::c_void),
    >,
    pub write_msi_msg_data: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: msi_desc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_desc__bindgen_ty_1 {
    pub __bindgen_anon_1: msi_desc__bindgen_ty_1__bindgen_ty_1,
    pub platform: platform_msi_desc,
    pub fsl_mc: fsl_mc_msi_desc,
    pub inta: ti_sci_inta_msi_desc,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc__bindgen_ty_1__bindgen_ty_1 {
    pub masked: u32_,
    pub msi_attrib: msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub entry_nr: u16_,
    pub default_irq: ::aya_bpf_cty::c_uint,
}
impl msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn is_msix(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_msix(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multiple(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_cap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_multi_cap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn maskbit(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_maskbit(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_64(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_64(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_virtual(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_virtual(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_msix: u8_,
        multiple: u8_,
        multi_cap: u8_,
        maskbit: u8_,
        is_64: u8_,
        is_virtual: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_msix: u8 = unsafe { ::core::mem::transmute(is_msix) };
            is_msix as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let multiple: u8 = unsafe { ::core::mem::transmute(multiple) };
            multiple as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let multi_cap: u8 = unsafe { ::core::mem::transmute(multi_cap) };
            multi_cap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let maskbit: u8 = unsafe { ::core::mem::transmute(maskbit) };
            maskbit as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_64: u8 = unsafe { ::core::mem::transmute(is_64) };
            is_64 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_virtual: u8 = unsafe { ::core::mem::transmute(is_virtual) };
            is_virtual as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub mask_pos: u8_,
    pub mask_base: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip {
    pub parent_device: *mut device,
    pub name: *const ::aya_bpf_cty::c_char,
    pub irq_startup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_uint>,
    pub irq_shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_ack: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_mask_ack: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_eoi: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_set_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: *const cpumask,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub irq_retrigger:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    pub irq_set_type: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub irq_set_wake: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub irq_bus_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_bus_sync_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_cpu_online: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_cpu_offline: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_suspend: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_resume: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_pm_shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_calc_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_print_chip:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut seq_file)>,
    pub irq_request_resources:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    pub irq_release_resources: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_compose_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>,
    pub irq_write_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>,
    pub irq_get_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: irqchip_irq_state::Type,
            arg3: *mut bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub irq_set_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: irqchip_irq_state::Type,
            arg3: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub irq_set_vcpu_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ipi_send_single: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_data, arg2: ::aya_bpf_cty::c_uint),
    >,
    pub ipi_send_mask:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *const cpumask)>,
    pub irq_nmi_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    pub irq_nmi_teardown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub flags: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip_regs {
    pub enable: ::aya_bpf_cty::c_ulong,
    pub disable: ::aya_bpf_cty::c_ulong,
    pub mask: ::aya_bpf_cty::c_ulong,
    pub ack: ::aya_bpf_cty::c_ulong,
    pub eoi: ::aya_bpf_cty::c_ulong,
    pub type_: ::aya_bpf_cty::c_ulong,
    pub polarity: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip_type {
    pub chip: irq_chip,
    pub regs: irq_chip_regs,
    pub handler: irq_flow_handler_t,
    pub type_: u32_,
    pub mask_cache_priv: u32_,
    pub mask_cache: *mut u32_,
}
#[repr(C)]
pub struct irq_chip_generic {
    pub lock: raw_spinlock_t,
    pub reg_base: *mut ::aya_bpf_cty::c_void,
    pub reg_readl:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> u32_>,
    pub reg_writel:
        ::core::option::Option<unsafe extern "C" fn(arg1: u32_, arg2: *mut ::aya_bpf_cty::c_void)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>,
    pub irq_base: ::aya_bpf_cty::c_uint,
    pub irq_cnt: ::aya_bpf_cty::c_uint,
    pub mask_cache: u32_,
    pub type_cache: u32_,
    pub polarity_cache: u32_,
    pub wake_enabled: u32_,
    pub wake_active: u32_,
    pub num_ct: ::aya_bpf_cty::c_uint,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub installed: ::aya_bpf_cty::c_ulong,
    pub unused: ::aya_bpf_cty::c_ulong,
    pub domain: *mut irq_domain,
    pub list: list_head,
    pub chip_types: __IncompleteArrayField<irq_chip_type>,
}
pub mod irq_gc_flags {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IRQ_GC_INIT_MASK_CACHE: Type = 1;
    pub const IRQ_GC_INIT_NESTED_LOCK: Type = 2;
    pub const IRQ_GC_MASK_CACHE_PER_TYPE: Type = 4;
    pub const IRQ_GC_NO_MASK: Type = 8;
    pub const IRQ_GC_BE_IO: Type = 16;
}
#[repr(C)]
#[derive(Debug)]
pub struct irq_domain_chip_generic {
    pub irqs_per_chip: ::aya_bpf_cty::c_uint,
    pub num_chips: ::aya_bpf_cty::c_uint,
    pub irq_flags_to_clear: ::aya_bpf_cty::c_uint,
    pub irq_flags_to_set: ::aya_bpf_cty::c_uint,
    pub gc_flags: irq_gc_flags::Type,
    pub gc: __IncompleteArrayField<*mut irq_chip_generic>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const ::aya_bpf_cty::c_char,
    pub pages: *mut *mut page,
    pub fault: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const vm_special_mapping,
            arg2: *mut vm_area_struct,
            arg3: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const vm_special_mapping,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timens_offsets {
    pub monotonic: timespec64,
    pub boottime: timespec64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_namespace {
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub ns: ns_common,
    pub offsets: timens_offsets,
    pub vvar_page: *mut page,
    pub frozen_offsets: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_mmap_page {
    pub version: __u32,
    pub compat_version: __u32,
    pub lock: __u32,
    pub index: __u32,
    pub offset: __s64,
    pub time_enabled: __u64,
    pub time_running: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1,
    pub pmc_width: __u16,
    pub time_shift: __u16,
    pub time_mult: __u32,
    pub time_offset: __u64,
    pub time_zero: __u64,
    pub size: __u32,
    pub __reserved_1: __u32,
    pub time_cycles: __u64,
    pub time_mask: __u64,
    pub __reserved: [__u8; 928usize],
    pub data_head: __u64,
    pub data_tail: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
    pub aux_head: __u64,
    pub aux_tail: __u64,
    pub aux_offset: __u64,
    pub aux_size: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_mmap_page__bindgen_ty_1 {
    pub capabilities: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cap_bit0(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_bit0_is_deprecated(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0_is_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_rdpmc(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_rdpmc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_zero(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_zero(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_short(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_short(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_____res(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_cap_____res(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cap_bit0: __u64,
        cap_bit0_is_deprecated: __u64,
        cap_user_rdpmc: __u64,
        cap_user_time: __u64,
        cap_user_time_zero: __u64,
        cap_user_time_short: __u64,
        cap_____res: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cap_bit0: u64 = unsafe { ::core::mem::transmute(cap_bit0) };
            cap_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cap_bit0_is_deprecated: u64 =
                unsafe { ::core::mem::transmute(cap_bit0_is_deprecated) };
            cap_bit0_is_deprecated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cap_user_rdpmc: u64 = unsafe { ::core::mem::transmute(cap_user_rdpmc) };
            cap_user_rdpmc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cap_user_time: u64 = unsafe { ::core::mem::transmute(cap_user_time) };
            cap_user_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cap_user_time_zero: u64 = unsafe { ::core::mem::transmute(cap_user_time_zero) };
            cap_user_time_zero as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cap_user_time_short: u64 = unsafe { ::core::mem::transmute(cap_user_time_short) };
            cap_user_time_short as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let cap_____res: u64 = unsafe { ::core::mem::transmute(cap_____res) };
            cap_____res as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldt_struct {
    pub entries: *mut desc_struct,
    pub nr_entries: ::aya_bpf_cty::c_uint,
    pub slot: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
pub mod pm_qos_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PM_QOS_UNITIALIZED: Type = 0;
    pub const PM_QOS_MAX: Type = 1;
    pub const PM_QOS_MIN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_constraints {
    pub list: plist_head,
    pub target_value: s32,
    pub default_value: s32,
    pub no_constraint_value: s32,
    pub type_: pm_qos_type::Type,
    pub notifiers: *mut blocking_notifier_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct freq_constraints {
    pub min_freq: pm_qos_constraints,
    pub min_freq_notifiers: blocking_notifier_head,
    pub max_freq: pm_qos_constraints,
    pub max_freq_notifiers: blocking_notifier_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_flags {
    pub list: list_head,
    pub effective_flags: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos {
    pub resume_latency: pm_qos_constraints,
    pub latency_tolerance: pm_qos_constraints,
    pub freq: freq_constraints,
    pub flags: pm_qos_flags,
    pub resume_latency_req: *mut dev_pm_qos_request,
    pub latency_tolerance_req: *mut dev_pm_qos_request,
    pub flags_req: *mut dev_pm_qos_request,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_flags_request {
    pub node: list_head,
    pub flags: s32,
}
pub mod freq_qos_req_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FREQ_QOS_MIN: Type = 1;
    pub const FREQ_QOS_MAX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct freq_qos_request {
    pub type_: freq_qos_req_type::Type,
    pub pnode: plist_node,
    pub qos: *mut freq_constraints,
}
pub mod dev_pm_qos_req_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEV_PM_QOS_RESUME_LATENCY: Type = 1;
    pub const DEV_PM_QOS_LATENCY_TOLERANCE: Type = 2;
    pub const DEV_PM_QOS_MIN_FREQUENCY: Type = 3;
    pub const DEV_PM_QOS_MAX_FREQUENCY: Type = 4;
    pub const DEV_PM_QOS_FLAGS: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos_request {
    pub type_: dev_pm_qos_req_type::Type,
    pub data: dev_pm_qos_request__bindgen_ty_1,
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dev_pm_qos_request__bindgen_ty_1 {
    pub pnode: plist_node,
    pub flr: pm_qos_flags_request,
    pub freq: freq_qos_request,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: ::aya_bpf_cty::c_uint,
    pub orig_nents: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::aya_bpf_cty::c_int; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    pub f_type: ::aya_bpf_cty::c_long,
    pub f_bsize: ::aya_bpf_cty::c_long,
    pub f_blocks: u64_,
    pub f_bfree: u64_,
    pub f_bavail: u64_,
    pub f_files: u64_,
    pub f_ffree: u64_,
    pub f_fsid: __kernel_fsid_t,
    pub f_namelen: ::aya_bpf_cty::c_long,
    pub f_frsize: ::aya_bpf_cty::c_long,
    pub f_flags: ::aya_bpf_cty::c_long,
    pub f_spare: [::aya_bpf_cty::c_long; 4usize],
}
pub mod ip_conntrack_dir {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IP_CT_DIR_ORIGINAL: Type = 0;
    pub const IP_CT_DIR_REPLY: Type = 1;
    pub const IP_CT_DIR_MAX: Type = 2;
}
pub mod sctp_conntrack {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const SCTP_CONNTRACK_NONE: Type = 0;
    pub const SCTP_CONNTRACK_CLOSED: Type = 1;
    pub const SCTP_CONNTRACK_COOKIE_WAIT: Type = 2;
    pub const SCTP_CONNTRACK_COOKIE_ECHOED: Type = 3;
    pub const SCTP_CONNTRACK_ESTABLISHED: Type = 4;
    pub const SCTP_CONNTRACK_SHUTDOWN_SENT: Type = 5;
    pub const SCTP_CONNTRACK_SHUTDOWN_RECD: Type = 6;
    pub const SCTP_CONNTRACK_SHUTDOWN_ACK_SENT: Type = 7;
    pub const SCTP_CONNTRACK_HEARTBEAT_SENT: Type = 8;
    pub const SCTP_CONNTRACK_HEARTBEAT_ACKED: Type = 9;
    pub const SCTP_CONNTRACK_MAX: Type = 10;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    pub lock: mutex,
    pub fault_param: *mut iommu_fault_param,
    pub fwspec: *mut iommu_fwspec,
    pub iommu_dev: *mut iommu_device,
    pub priv_: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct of_phandle_args {
    pub np: *mut device_node,
    pub args_count: ::aya_bpf_cty::c_int,
    pub args: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fault_unrecoverable {
    pub reason: __u32,
    pub flags: __u32,
    pub pasid: __u32,
    pub perm: __u32,
    pub addr: __u64,
    pub fetch_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fault_page_request {
    pub flags: __u32,
    pub pasid: __u32,
    pub grpid: __u32,
    pub perm: __u32,
    pub addr: __u64,
    pub private_data: [__u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault {
    pub type_: __u32,
    pub padding: __u32,
    pub __bindgen_anon_1: iommu_fault__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_fault__bindgen_ty_1 {
    pub event: iommu_fault_unrecoverable,
    pub prm: iommu_fault_page_request,
    pub padding2: [__u8; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_page_response {
    pub argsz: __u32,
    pub version: __u32,
    pub flags: __u32,
    pub pasid: __u32,
    pub grpid: __u32,
    pub code: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_inv_addr_info {
    pub flags: __u32,
    pub archid: __u32,
    pub pasid: __u64,
    pub addr: __u64,
    pub granule_size: __u64,
    pub nb_granules: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_inv_pasid_info {
    pub flags: __u32,
    pub archid: __u32,
    pub pasid: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_cache_invalidate_info {
    pub argsz: __u32,
    pub version: __u32,
    pub cache: __u8,
    pub granularity: __u8,
    pub padding: [__u8; 6usize],
    pub granu: iommu_cache_invalidate_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_cache_invalidate_info__bindgen_ty_1 {
    pub pasid_info: iommu_inv_pasid_info,
    pub addr_info: iommu_inv_addr_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_gpasid_bind_data_vtd {
    pub flags: __u64,
    pub pat: __u32,
    pub emt: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_gpasid_bind_data {
    pub argsz: __u32,
    pub version: __u32,
    pub format: __u32,
    pub addr_width: __u32,
    pub flags: __u64,
    pub gpgd: __u64,
    pub hpasid: __u64,
    pub gpasid: __u64,
    pub padding: [__u8; 8usize],
    pub vendor: iommu_gpasid_bind_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_gpasid_bind_data__bindgen_ty_1 {
    pub vtd: iommu_gpasid_bind_data_vtd,
}
pub type iommu_fault_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut iommu_domain,
        arg2: *mut device,
        arg3: ::aya_bpf_cty::c_ulong,
        arg4: ::aya_bpf_cty::c_int,
        arg5: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain_geometry {
    pub aperture_start: dma_addr_t,
    pub aperture_end: dma_addr_t,
    pub force_aperture: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain {
    pub type_: ::aya_bpf_cty::c_uint,
    pub ops: *const iommu_ops,
    pub pgsize_bitmap: ::aya_bpf_cty::c_ulong,
    pub handler: iommu_fault_handler_t,
    pub handler_token: *mut ::aya_bpf_cty::c_void,
    pub geometry: iommu_domain_geometry,
    pub iova_cookie: *mut ::aya_bpf_cty::c_void,
}
pub type iommu_dev_fault_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut iommu_fault,
        arg2: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
pub mod iommu_resv_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IOMMU_RESV_DIRECT: Type = 0;
    pub const IOMMU_RESV_DIRECT_RELAXABLE: Type = 1;
    pub const IOMMU_RESV_RESERVED: Type = 2;
    pub const IOMMU_RESV_MSI: Type = 3;
    pub const IOMMU_RESV_SW_MSI: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_resv_region {
    pub list: list_head,
    pub start: phys_addr_t,
    pub length: size_t,
    pub prot: ::aya_bpf_cty::c_int,
    pub type_: iommu_resv_type::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_iotlb_gather {
    pub start: ::aya_bpf_cty::c_ulong,
    pub end: ::aya_bpf_cty::c_ulong,
    pub pgsize: size_t,
    pub freelist: *mut page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_device {
    pub list: list_head,
    pub ops: *const iommu_ops,
    pub fwnode: *mut fwnode_handle,
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_sva {
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault_event {
    pub fault: iommu_fault,
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault_param {
    pub handler: iommu_dev_fault_handler_t,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub faults: list_head,
    pub lock: mutex,
}
#[repr(C)]
#[derive(Debug)]
pub struct iommu_fwspec {
    pub ops: *const iommu_ops,
    pub iommu_fwnode: *mut fwnode_handle,
    pub flags: u32_,
    pub num_pasid_bits: u32_,
    pub num_ids: ::aya_bpf_cty::c_uint,
    pub ids: __IncompleteArrayField<u32_>,
}
pub type cycles_t = ::aya_bpf_cty::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ops {
    pub proc_flags: ::aya_bpf_cty::c_uint,
    pub proc_open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
    >,
    pub proc_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub proc_read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub proc_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf_cty::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub proc_lseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::aya_bpf_cty::c_int) -> loff_t,
    >,
    pub proc_release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
    >,
    pub proc_poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub proc_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub proc_compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_long,
    >,
    pub proc_mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::aya_bpf_cty::c_int,
    >,
    pub proc_get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: ::aya_bpf_cty::c_ulong,
            arg4: ::aya_bpf_cty::c_ulong,
            arg5: ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_ulong,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct firmware {
    pub size: size_t,
    pub data: *const u8_,
    pub priv_: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_tfm {
    pub crt_flags: u32_,
    pub node: ::aya_bpf_cty::c_int,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>,
    pub __crt_alg: *mut crypto_alg,
    pub __crt_ctx: __IncompleteArrayField<*mut ::aya_bpf_cty::c_void>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_alg {
    pub cia_min_keysize: ::aya_bpf_cty::c_uint,
    pub cia_max_keysize: ::aya_bpf_cty::c_uint,
    pub cia_setkey: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cia_encrypt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
    >,
    pub cia_decrypt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compress_alg {
    pub coa_compress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut u8_,
            arg5: *mut ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub coa_decompress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut u8_,
            arg5: *mut ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_aead {
    pub encrypt_cnt: atomic64_t,
    pub encrypt_tlen: atomic64_t,
    pub decrypt_cnt: atomic64_t,
    pub decrypt_tlen: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_akcipher {
    pub encrypt_cnt: atomic64_t,
    pub encrypt_tlen: atomic64_t,
    pub decrypt_cnt: atomic64_t,
    pub decrypt_tlen: atomic64_t,
    pub verify_cnt: atomic64_t,
    pub sign_cnt: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_cipher {
    pub encrypt_cnt: atomic64_t,
    pub encrypt_tlen: atomic64_t,
    pub decrypt_cnt: atomic64_t,
    pub decrypt_tlen: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_compress {
    pub compress_cnt: atomic64_t,
    pub compress_tlen: atomic64_t,
    pub decompress_cnt: atomic64_t,
    pub decompress_tlen: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_hash {
    pub hash_cnt: atomic64_t,
    pub hash_tlen: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_kpp {
    pub setsecret_cnt: atomic64_t,
    pub generate_public_key_cnt: atomic64_t,
    pub compute_shared_secret_cnt: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_istat_rng {
    pub generate_cnt: atomic64_t,
    pub generate_tlen: atomic64_t,
    pub seed_cnt: atomic64_t,
    pub err_cnt: atomic64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_alg {
    pub cra_list: list_head,
    pub cra_users: list_head,
    pub cra_flags: u32_,
    pub cra_blocksize: ::aya_bpf_cty::c_uint,
    pub cra_ctxsize: ::aya_bpf_cty::c_uint,
    pub cra_alignmask: ::aya_bpf_cty::c_uint,
    pub cra_priority: ::aya_bpf_cty::c_int,
    pub cra_refcnt: refcount_t,
    pub cra_name: [::aya_bpf_cty::c_char; 128usize],
    pub cra_driver_name: [::aya_bpf_cty::c_char; 128usize],
    pub cra_type: *const crypto_type,
    pub cra_u: crypto_alg__bindgen_ty_1,
    pub cra_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf_cty::c_int>,
    pub cra_exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>,
    pub cra_destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_alg)>,
    pub cra_module: *mut module,
    pub stats: crypto_alg__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_alg__bindgen_ty_1 {
    pub cipher: cipher_alg,
    pub compress: compress_alg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_alg__bindgen_ty_2 {
    pub aead: crypto_istat_aead,
    pub akcipher: crypto_istat_akcipher,
    pub cipher: crypto_istat_cipher,
    pub compress: crypto_istat_compress,
    pub hash: crypto_istat_hash,
    pub rng: crypto_istat_rng,
    pub kpp: crypto_istat_kpp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_type {
    pub ctxsize: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_alg,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_uint,
    >,
    pub extsize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_alg) -> ::aya_bpf_cty::c_uint,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: u32_, arg3: u32_) -> ::aya_bpf_cty::c_int,
    >,
    pub init_tfm:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf_cty::c_int>,
    pub show:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut crypto_alg)>,
    pub report: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut crypto_alg) -> ::aya_bpf_cty::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_instance)>,
    pub type_: ::aya_bpf_cty::c_uint,
    pub maskclear: ::aya_bpf_cty::c_uint,
    pub maskset: ::aya_bpf_cty::c_uint,
    pub tfmsize: ::aya_bpf_cty::c_uint,
}
pub mod irq_alloc_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const X86_IRQ_ALLOC_TYPE_IOAPIC: Type = 1;
    pub const X86_IRQ_ALLOC_TYPE_HPET: Type = 2;
    pub const X86_IRQ_ALLOC_TYPE_PCI_MSI: Type = 3;
    pub const X86_IRQ_ALLOC_TYPE_PCI_MSIX: Type = 4;
    pub const X86_IRQ_ALLOC_TYPE_DMAR: Type = 5;
    pub const X86_IRQ_ALLOC_TYPE_AMDVI: Type = 6;
    pub const X86_IRQ_ALLOC_TYPE_UV: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioapic_alloc_info {
    pub pin: ::aya_bpf_cty::c_int,
    pub node: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ioapic_alloc_info {
    #[inline]
    pub fn is_level(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_level(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active_low(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_level: u32_,
        active_low: u32_,
        valid: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_level: u32 = unsafe { ::core::mem::transmute(is_level) };
            is_level as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_alloc_info {
    pub limit: ::aya_bpf_cty::c_int,
    pub blade: ::aya_bpf_cty::c_int,
    pub offset: ::aya_bpf_cty::c_ulong,
    pub name: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_alloc_info {
    pub type_: irq_alloc_type::Type,
    pub flags: u32_,
    pub devid: u32_,
    pub hwirq: irq_hw_number_t,
    pub mask: *const cpumask,
    pub desc: *mut msi_desc,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: irq_alloc_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union irq_alloc_info__bindgen_ty_1 {
    pub ioapic: ioapic_alloc_info,
    pub uv: uv_alloc_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_icounter_struct {
    pub cts: ::aya_bpf_cty::c_int,
    pub dsr: ::aya_bpf_cty::c_int,
    pub rng: ::aya_bpf_cty::c_int,
    pub dcd: ::aya_bpf_cty::c_int,
    pub rx: ::aya_bpf_cty::c_int,
    pub tx: ::aya_bpf_cty::c_int,
    pub frame: ::aya_bpf_cty::c_int,
    pub overrun: ::aya_bpf_cty::c_int,
    pub parity: ::aya_bpf_cty::c_int,
    pub brk: ::aya_bpf_cty::c_int,
    pub buf_overrun: ::aya_bpf_cty::c_int,
    pub reserved: [::aya_bpf_cty::c_int; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_struct {
    pub type_: ::aya_bpf_cty::c_int,
    pub line: ::aya_bpf_cty::c_int,
    pub port: ::aya_bpf_cty::c_uint,
    pub irq: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub xmit_fifo_size: ::aya_bpf_cty::c_int,
    pub custom_divisor: ::aya_bpf_cty::c_int,
    pub baud_base: ::aya_bpf_cty::c_int,
    pub close_delay: ::aya_bpf_cty::c_ushort,
    pub io_type: ::aya_bpf_cty::c_char,
    pub reserved_char: [::aya_bpf_cty::c_char; 1usize],
    pub hub6: ::aya_bpf_cty::c_int,
    pub closing_wait: ::aya_bpf_cty::c_ushort,
    pub closing_wait2: ::aya_bpf_cty::c_ushort,
    pub iomem_base: *mut ::aya_bpf_cty::c_uchar,
    pub iomem_reg_shift: ::aya_bpf_cty::c_ushort,
    pub port_high: ::aya_bpf_cty::c_uint,
    pub iomap_base: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_domain_shared {
    pub ref_: atomic_t,
    pub nr_busy_cpus: atomic_t,
    pub has_idle_cores: ::aya_bpf_cty::c_int,
}
#[repr(C)]
pub struct sched_domain {
    pub parent: *mut sched_domain,
    pub child: *mut sched_domain,
    pub groups: *mut sched_group,
    pub min_interval: ::aya_bpf_cty::c_ulong,
    pub max_interval: ::aya_bpf_cty::c_ulong,
    pub busy_factor: ::aya_bpf_cty::c_uint,
    pub imbalance_pct: ::aya_bpf_cty::c_uint,
    pub cache_nice_tries: ::aya_bpf_cty::c_uint,
    pub nohz_idle: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub level: ::aya_bpf_cty::c_int,
    pub last_balance: ::aya_bpf_cty::c_ulong,
    pub balance_interval: ::aya_bpf_cty::c_uint,
    pub nr_balance_failed: ::aya_bpf_cty::c_uint,
    pub max_newidle_lb_cost: u64_,
    pub next_decay_max_lb_cost: ::aya_bpf_cty::c_ulong,
    pub avg_scan_cost: u64_,
    pub lb_count: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_failed: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_balanced: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_imbalance: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_gained: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_hot_gained: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_nobusyg: [::aya_bpf_cty::c_uint; 3usize],
    pub lb_nobusyq: [::aya_bpf_cty::c_uint; 3usize],
    pub alb_count: ::aya_bpf_cty::c_uint,
    pub alb_failed: ::aya_bpf_cty::c_uint,
    pub alb_pushed: ::aya_bpf_cty::c_uint,
    pub sbe_count: ::aya_bpf_cty::c_uint,
    pub sbe_balanced: ::aya_bpf_cty::c_uint,
    pub sbe_pushed: ::aya_bpf_cty::c_uint,
    pub sbf_count: ::aya_bpf_cty::c_uint,
    pub sbf_balanced: ::aya_bpf_cty::c_uint,
    pub sbf_pushed: ::aya_bpf_cty::c_uint,
    pub ttwu_wake_remote: ::aya_bpf_cty::c_uint,
    pub ttwu_move_affine: ::aya_bpf_cty::c_uint,
    pub ttwu_move_balance: ::aya_bpf_cty::c_uint,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub __bindgen_anon_1: sched_domain__bindgen_ty_1,
    pub shared: *mut sched_domain_shared,
    pub span_weight: ::aya_bpf_cty::c_uint,
    pub span: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_domain__bindgen_ty_1 {
    pub private: *mut ::aya_bpf_cty::c_void,
    pub rcu: callback_head,
}
pub type msi_alloc_info_t = irq_alloc_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub ops: *const uprobe_xol_ops,
    pub __bindgen_anon_2: arch_uprobe__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 16usize],
    pub ixol: [u8_; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_2 {
    pub branch: arch_uprobe__bindgen_ty_2__bindgen_ty_1,
    pub defparam: arch_uprobe__bindgen_ty_2__bindgen_ty_2,
    pub push: arch_uprobe__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub offs: s32,
    pub ilen: u8_,
    pub opc1: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fixups: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub reg_offset: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_xol_ops {
    pub emulate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> bool_,
    >,
    pub pre_xol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> ::aya_bpf_cty::c_int,
    >,
    pub post_xol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> ::aya_bpf_cty::c_int,
    >,
    pub abort:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs)>,
}
#[repr(C)]
pub struct crypto_instance {
    pub alg: crypto_alg,
    pub tmpl: *mut crypto_template,
    pub __bindgen_anon_1: crypto_instance__bindgen_ty_1,
    pub __ctx: __IncompleteArrayField<*mut ::aya_bpf_cty::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_instance__bindgen_ty_1 {
    pub list: hlist_node,
    pub spawns: *mut crypto_spawn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_spawn {
    pub list: list_head,
    pub alg: *mut crypto_alg,
    pub __bindgen_anon_1: crypto_spawn__bindgen_ty_1,
    pub frontend: *const crypto_type,
    pub mask: u32_,
    pub dead: bool_,
    pub registered: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_spawn__bindgen_ty_1 {
    pub inst: *mut crypto_instance,
    pub next: *mut crypto_spawn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_template {
    pub list: list_head,
    pub instances: hlist_head,
    pub module: *mut module,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_template,
            arg2: *mut *mut rtattr,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub name: [::aya_bpf_cty::c_char; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: ::aya_bpf_cty::c_uint,
    pub wait_list: list_head,
}
pub const BPF_REG_0: ::aya_bpf_cty::c_uint = 0;
pub const BPF_REG_1: ::aya_bpf_cty::c_uint = 1;
pub const BPF_REG_2: ::aya_bpf_cty::c_uint = 2;
pub const BPF_REG_3: ::aya_bpf_cty::c_uint = 3;
pub const BPF_REG_4: ::aya_bpf_cty::c_uint = 4;
pub const BPF_REG_5: ::aya_bpf_cty::c_uint = 5;
pub const BPF_REG_6: ::aya_bpf_cty::c_uint = 6;
pub const BPF_REG_7: ::aya_bpf_cty::c_uint = 7;
pub const BPF_REG_8: ::aya_bpf_cty::c_uint = 8;
pub const BPF_REG_9: ::aya_bpf_cty::c_uint = 9;
pub const BPF_REG_10: ::aya_bpf_cty::c_uint = 10;
pub const __MAX_BPF_REG: ::aya_bpf_cty::c_uint = 11;
pub type _bindgen_ty_102 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdtable {
    pub max_fds: ::aya_bpf_cty::c_uint,
    pub fd: *mut *mut file,
    pub close_on_exec: *mut ::aya_bpf_cty::c_ulong,
    pub open_fds: *mut ::aya_bpf_cty::c_ulong,
    pub full_fds_bits: *mut ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct files_struct {
    pub count: atomic_t,
    pub resize_in_progress: bool_,
    pub resize_wait: wait_queue_head_t,
    pub fdt: *mut fdtable,
    pub fdtab: fdtable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub file_lock: spinlock_t,
    pub next_fd: ::aya_bpf_cty::c_uint,
    pub close_on_exec_init: [::aya_bpf_cty::c_ulong; 1usize],
    pub open_fds_init: [::aya_bpf_cty::c_ulong; 1usize],
    pub full_fds_bits_init: [::aya_bpf_cty::c_ulong; 1usize],
    pub fd_array: [*mut file; 64usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl files_struct {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_identity {
    pub files: *mut files_struct,
    pub mm: *mut mm_struct,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub creds: *const cred,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub fsize: ::aya_bpf_cty::c_ulong,
    pub loginuid: kuid_t,
    pub sessionid: ::aya_bpf_cty::c_uint,
    pub count: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_task {
    pub xa: xarray,
    pub wait: wait_queue_head,
    pub last: *mut file,
    pub inflight: percpu_counter,
    pub __identity: io_identity,
    pub identity: *mut io_identity,
    pub in_idle: atomic_t,
    pub sqpoll: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list {
    pub next: *mut robust_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    pub list: robust_list,
    pub futex_offset: ::aya_bpf_cty::c_long,
    pub list_op_pending: *mut robust_list,
}
#[repr(C)]
pub struct workqueue_struct {
    pub pwqs: list_head,
    pub list: list_head,
    pub mutex: mutex,
    pub work_color: ::aya_bpf_cty::c_int,
    pub flush_color: ::aya_bpf_cty::c_int,
    pub nr_pwqs_to_flush: atomic_t,
    pub first_flusher: *mut wq_flusher,
    pub flusher_queue: list_head,
    pub flusher_overflow: list_head,
    pub maydays: list_head,
    pub rescuer: *mut worker,
    pub nr_drainers: ::aya_bpf_cty::c_int,
    pub saved_max_active: ::aya_bpf_cty::c_int,
    pub unbound_attrs: *mut workqueue_attrs,
    pub dfl_pwq: *mut pool_workqueue,
    pub wq_dev: *mut wq_device,
    pub name: [::aya_bpf_cty::c_char; 24usize],
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub flags: ::aya_bpf_cty::c_uint,
    pub cpu_pwqs: *mut pool_workqueue,
    pub numa_pwq_tbl: __IncompleteArrayField<*mut pool_workqueue>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_attrs {
    pub nice: ::aya_bpf_cty::c_int,
    pub cpumask: cpumask_var_t,
    pub no_numa: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ida {
    pub xa: xarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker {
    pub __bindgen_anon_1: worker__bindgen_ty_1,
    pub current_work: *mut work_struct,
    pub current_func: work_func_t,
    pub current_pwq: *mut pool_workqueue,
    pub scheduled: list_head,
    pub task: *mut task_struct,
    pub pool: *mut worker_pool,
    pub node: list_head,
    pub last_active: ::aya_bpf_cty::c_ulong,
    pub flags: ::aya_bpf_cty::c_uint,
    pub id: ::aya_bpf_cty::c_int,
    pub sleeping: ::aya_bpf_cty::c_int,
    pub desc: [::aya_bpf_cty::c_char; 24usize],
    pub rescue_wq: *mut workqueue_struct,
    pub last_func: work_func_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union worker__bindgen_ty_1 {
    pub entry: list_head,
    pub hentry: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pool_workqueue {
    pub pool: *mut worker_pool,
    pub wq: *mut workqueue_struct,
    pub work_color: ::aya_bpf_cty::c_int,
    pub flush_color: ::aya_bpf_cty::c_int,
    pub refcnt: ::aya_bpf_cty::c_int,
    pub nr_in_flight: [::aya_bpf_cty::c_int; 15usize],
    pub nr_active: ::aya_bpf_cty::c_int,
    pub max_active: ::aya_bpf_cty::c_int,
    pub delayed_works: list_head,
    pub pwqs_node: list_head,
    pub mayday_node: list_head,
    pub unbound_release_work: work_struct,
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 64usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker_pool {
    pub lock: raw_spinlock_t,
    pub cpu: ::aya_bpf_cty::c_int,
    pub node: ::aya_bpf_cty::c_int,
    pub id: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_uint,
    pub watchdog_ts: ::aya_bpf_cty::c_ulong,
    pub worklist: list_head,
    pub nr_workers: ::aya_bpf_cty::c_int,
    pub nr_idle: ::aya_bpf_cty::c_int,
    pub idle_list: list_head,
    pub idle_timer: timer_list,
    pub mayday_timer: timer_list,
    pub busy_hash: [hlist_head; 64usize],
    pub manager: *mut worker,
    pub workers: list_head,
    pub detach_completion: *mut completion,
    pub worker_ida: ida,
    pub attrs: *mut workqueue_attrs,
    pub hash_node: hlist_node,
    pub refcnt: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub nr_running: atomic_t,
    pub rcu: callback_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 40usize]>,
}
impl worker_pool {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wq_flusher {
    pub list: list_head,
    pub flush_color: ::aya_bpf_cty::c_int,
    pub done: completion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wq_device {
    pub wq: *mut workqueue_struct,
    pub dev: device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct param_attribute {
    pub mattr: module_attribute,
    pub param: *const kernel_param,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_param_attrs {
    pub num: ::aya_bpf_cty::c_uint,
    pub grp: attribute_group,
    pub attrs: __IncompleteArrayField<param_attribute>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_ids {
    pub in_use: ::aya_bpf_cty::c_int,
    pub seq: ::aya_bpf_cty::c_ushort,
    pub rwsem: rw_semaphore,
    pub ipcs_idr: idr,
    pub max_idx: ::aya_bpf_cty::c_int,
    pub last_idx: ::aya_bpf_cty::c_int,
    pub next_id: ::aya_bpf_cty::c_int,
    pub key_ht: rhashtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_namespace {
    pub ids: [ipc_ids; 3usize],
    pub sem_ctls: [::aya_bpf_cty::c_int; 4usize],
    pub used_sems: ::aya_bpf_cty::c_int,
    pub msg_ctlmax: ::aya_bpf_cty::c_uint,
    pub msg_ctlmnb: ::aya_bpf_cty::c_uint,
    pub msg_ctlmni: ::aya_bpf_cty::c_uint,
    pub msg_bytes: atomic_t,
    pub msg_hdrs: atomic_t,
    pub shm_ctlmax: size_t,
    pub shm_ctlall: size_t,
    pub shm_tot: ::aya_bpf_cty::c_ulong,
    pub shm_ctlmni: ::aya_bpf_cty::c_int,
    pub shm_rmid_forced: ::aya_bpf_cty::c_int,
    pub ipcns_nb: notifier_block,
    pub mq_mnt: *mut vfsmount,
    pub mq_queues_count: ::aya_bpf_cty::c_uint,
    pub mq_queues_max: ::aya_bpf_cty::c_uint,
    pub mq_msg_max: ::aya_bpf_cty::c_uint,
    pub mq_msgsize_max: ::aya_bpf_cty::c_uint,
    pub mq_msg_default: ::aya_bpf_cty::c_uint,
    pub mq_msgsize_default: ::aya_bpf_cty::c_uint,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub mnt_llist: llist_node,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsmblob {
    pub secid: [u32_; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pin_cookie {}
pub type call_single_data_t = __call_single_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dl_bw {
    pub lock: raw_spinlock_t,
    pub bw: u64_,
    pub total_bw: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpudl {
    pub lock: raw_spinlock_t,
    pub size: ::aya_bpf_cty::c_int,
    pub free_cpus: cpumask_var_t,
    pub elements: *mut cpudl_item,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpupri_vec {
    pub count: atomic_t,
    pub mask: cpumask_var_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpupri {
    pub pri_to_cpu: [cpupri_vec; 101usize],
    pub cpu_to_pri: *mut ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct root_domain {
    pub refcount: atomic_t,
    pub rto_count: atomic_t,
    pub rcu: callback_head,
    pub span: cpumask_var_t,
    pub online: cpumask_var_t,
    pub overload: ::aya_bpf_cty::c_int,
    pub overutilized: ::aya_bpf_cty::c_int,
    pub dlo_mask: cpumask_var_t,
    pub dlo_count: atomic_t,
    pub dl_bw: dl_bw,
    pub cpudl: cpudl,
    pub visit_gen: u64_,
    pub rto_push_work: irq_work,
    pub rto_lock: raw_spinlock_t,
    pub rto_loop: ::aya_bpf_cty::c_int,
    pub rto_cpu: ::aya_bpf_cty::c_int,
    pub rto_loop_next: atomic_t,
    pub rto_loop_start: atomic_t,
    pub rto_mask: cpumask_var_t,
    pub cpupri: cpupri,
    pub max_cpu_capacity: ::aya_bpf_cty::c_ulong,
    pub pd: *mut perf_domain,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq {
    pub load: load_weight,
    pub nr_running: ::aya_bpf_cty::c_uint,
    pub h_nr_running: ::aya_bpf_cty::c_uint,
    pub idle_h_nr_running: ::aya_bpf_cty::c_uint,
    pub exec_clock: u64_,
    pub min_vruntime: u64_,
    pub tasks_timeline: rb_root_cached,
    pub curr: *mut sched_entity,
    pub next: *mut sched_entity,
    pub last: *mut sched_entity,
    pub skip: *mut sched_entity,
    pub nr_spread_over: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub avg: sched_avg,
    pub removed: cfs_rq__bindgen_ty_1,
    pub tg_load_avg_contrib: ::aya_bpf_cty::c_ulong,
    pub propagate: ::aya_bpf_cty::c_long,
    pub prop_runnable_sum: ::aya_bpf_cty::c_long,
    pub h_load: ::aya_bpf_cty::c_ulong,
    pub last_h_load_update: u64_,
    pub h_load_next: *mut sched_entity,
    pub rq: *mut rq,
    pub on_list: ::aya_bpf_cty::c_int,
    pub leaf_cfs_rq_list: list_head,
    pub tg: *mut task_group,
    pub runtime_enabled: ::aya_bpf_cty::c_int,
    pub runtime_remaining: s64,
    pub throttled_clock: u64_,
    pub throttled_clock_task: u64_,
    pub throttled_clock_task_time: u64_,
    pub throttled: ::aya_bpf_cty::c_int,
    pub throttle_count: ::aya_bpf_cty::c_int,
    pub throttled_list: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq__bindgen_ty_1 {
    pub lock: raw_spinlock_t,
    pub nr: ::aya_bpf_cty::c_int,
    pub load_avg: ::aya_bpf_cty::c_ulong,
    pub util_avg: ::aya_bpf_cty::c_ulong,
    pub runnable_avg: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl cfs_rq__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl cfs_rq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_bandwidth {
    pub lock: raw_spinlock_t,
    pub period: ktime_t,
    pub quota: u64_,
    pub runtime: u64_,
    pub hierarchical_quota: s64,
    pub idle: u8_,
    pub period_active: u8_,
    pub slack_started: u8_,
    pub period_timer: hrtimer,
    pub slack_timer: hrtimer,
    pub throttled_cfs_rq: list_head,
    pub nr_periods: ::aya_bpf_cty::c_int,
    pub nr_throttled: ::aya_bpf_cty::c_int,
    pub throttled_time: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_group {
    pub css: cgroup_subsys_state,
    pub se: *mut *mut sched_entity,
    pub cfs_rq: *mut *mut cfs_rq,
    pub shares: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub load_avg: atomic_long_t,
    pub rcu: callback_head,
    pub list: list_head,
    pub parent: *mut task_group,
    pub siblings: list_head,
    pub children: list_head,
    pub autogroup: *mut autogroup,
    pub cfs_bandwidth: cfs_bandwidth,
    pub uclamp_pct: [::aya_bpf_cty::c_uint; 2usize],
    pub uclamp_req: [uclamp_se; 2usize],
    pub uclamp: [uclamp_se; 2usize],
}
impl task_group {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sched_group {
    pub next: *mut sched_group,
    pub ref_: atomic_t,
    pub group_weight: ::aya_bpf_cty::c_uint,
    pub sgc: *mut sched_group_capacity,
    pub asym_prefer_cpu: ::aya_bpf_cty::c_int,
    pub cpumask: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug)]
pub struct sched_group_capacity {
    pub ref_: atomic_t,
    pub capacity: ::aya_bpf_cty::c_ulong,
    pub min_capacity: ::aya_bpf_cty::c_ulong,
    pub max_capacity: ::aya_bpf_cty::c_ulong,
    pub next_update: ::aya_bpf_cty::c_ulong,
    pub imbalance: ::aya_bpf_cty::c_int,
    pub id: ::aya_bpf_cty::c_int,
    pub cpumask: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct autogroup {
    pub kref: kref,
    pub tg: *mut task_group,
    pub lock: rw_semaphore,
    pub id: ::aya_bpf_cty::c_ulong,
    pub nice: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_state_usage {
    pub disable: ::aya_bpf_cty::c_ulonglong,
    pub usage: ::aya_bpf_cty::c_ulonglong,
    pub time_ns: u64_,
    pub above: ::aya_bpf_cty::c_ulonglong,
    pub below: ::aya_bpf_cty::c_ulonglong,
    pub rejected: ::aya_bpf_cty::c_ulonglong,
    pub s2idle_usage: ::aya_bpf_cty::c_ulonglong,
    pub s2idle_time: ::aya_bpf_cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_state {
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub desc: [::aya_bpf_cty::c_char; 32usize],
    pub exit_latency_ns: u64_,
    pub target_residency_ns: u64_,
    pub flags: ::aya_bpf_cty::c_uint,
    pub exit_latency: ::aya_bpf_cty::c_uint,
    pub power_usage: ::aya_bpf_cty::c_int,
    pub target_residency: ::aya_bpf_cty::c_uint,
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: *mut cpuidle_driver,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub enter_dead: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub enter_s2idle: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: *mut cpuidle_driver,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_driver_kobj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_device {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cpu: ::aya_bpf_cty::c_uint,
    pub next_hrtimer: ktime_t,
    pub last_state_idx: ::aya_bpf_cty::c_int,
    pub last_residency_ns: u64_,
    pub poll_limit_ns: u64_,
    pub forced_idle_latency_limit_ns: u64_,
    pub states_usage: [cpuidle_state_usage; 10usize],
    pub kobjs: [*mut cpuidle_state_kobj; 10usize],
    pub kobj_driver: *mut cpuidle_driver_kobj,
    pub kobj_dev: *mut cpuidle_device_kobj,
    pub device_list: list_head,
}
impl cpuidle_device {
    #[inline]
    pub fn registered(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn poll_time_limit(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_poll_time_limit(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        registered: ::aya_bpf_cty::c_uint,
        enabled: ::aya_bpf_cty::c_uint,
        poll_time_limit: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let registered: u32 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let poll_time_limit: u32 = unsafe { ::core::mem::transmute(poll_time_limit) };
            poll_time_limit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_driver {
    pub name: *const ::aya_bpf_cty::c_char,
    pub owner: *mut module,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub states: [cpuidle_state; 10usize],
    pub state_count: ::aya_bpf_cty::c_int,
    pub safe_state_index: ::aya_bpf_cty::c_int,
    pub cpumask: *mut cpumask,
    pub governor: *const ::aya_bpf_cty::c_char,
}
impl cpuidle_driver {
    #[inline]
    pub fn bctimer(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bctimer(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bctimer: ::aya_bpf_cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bctimer: u32 = unsafe { ::core::mem::transmute(bctimer) };
            bctimer as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type cpu_stop_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_stop_work {
    pub list: list_head,
    pub fn_: cpu_stop_fn_t,
    pub caller: ::aya_bpf_cty::c_ulong,
    pub arg: *mut ::aya_bpf_cty::c_void,
    pub done: *mut cpu_stop_done,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpudl_item {
    pub dl: u64_,
    pub cpu: ::aya_bpf_cty::c_int,
    pub idx: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_prio_array {
    pub bitmap: [::aya_bpf_cty::c_ulong; 2usize],
    pub queue: [list_head; 100usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct uclamp_bucket {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl uclamp_bucket {
    #[inline]
    pub fn value(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u64) }
    }
    #[inline]
    pub fn set_value(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn tasks(&self) -> ::aya_bpf_cty::c_ulong {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 53u8) as u64) }
    }
    #[inline]
    pub fn set_tasks(&mut self, val: ::aya_bpf_cty::c_ulong) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 53u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value: ::aya_bpf_cty::c_ulong,
        tasks: ::aya_bpf_cty::c_ulong,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let value: u64 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(11usize, 53u8, {
            let tasks: u64 = unsafe { ::core::mem::transmute(tasks) };
            tasks as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uclamp_rq {
    pub value: ::aya_bpf_cty::c_uint,
    pub bucket: [uclamp_bucket; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_rq {
    pub active: rt_prio_array,
    pub rt_nr_running: ::aya_bpf_cty::c_uint,
    pub rr_nr_running: ::aya_bpf_cty::c_uint,
    pub highest_prio: rt_rq__bindgen_ty_1,
    pub rt_nr_migratory: ::aya_bpf_cty::c_ulong,
    pub rt_nr_total: ::aya_bpf_cty::c_ulong,
    pub overloaded: ::aya_bpf_cty::c_int,
    pub pushable_tasks: plist_head,
    pub rt_queued: ::aya_bpf_cty::c_int,
    pub rt_throttled: ::aya_bpf_cty::c_int,
    pub rt_time: u64_,
    pub rt_runtime: u64_,
    pub rt_runtime_lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rq__bindgen_ty_1 {
    pub curr: ::aya_bpf_cty::c_int,
    pub next: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_rq {
    pub root: rb_root_cached,
    pub dl_nr_running: ::aya_bpf_cty::c_ulong,
    pub earliest_dl: dl_rq__bindgen_ty_1,
    pub dl_nr_migratory: ::aya_bpf_cty::c_ulong,
    pub overloaded: ::aya_bpf_cty::c_int,
    pub pushable_dl_tasks_root: rb_root_cached,
    pub running_bw: u64_,
    pub this_bw: u64_,
    pub extra_bw: u64_,
    pub bw_ratio: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_rq__bindgen_ty_1 {
    pub curr: u64_,
    pub next: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq {
    pub lock: raw_spinlock_t,
    pub nr_running: ::aya_bpf_cty::c_uint,
    pub nr_numa_running: ::aya_bpf_cty::c_uint,
    pub nr_preferred_running: ::aya_bpf_cty::c_uint,
    pub numa_migrate_on: ::aya_bpf_cty::c_uint,
    pub last_blocked_load_update_tick: ::aya_bpf_cty::c_ulong,
    pub has_blocked_load: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub nohz_csd: call_single_data_t,
    pub nohz_tick_stopped: ::aya_bpf_cty::c_uint,
    pub nohz_flags: atomic_t,
    pub ttwu_pending: ::aya_bpf_cty::c_uint,
    pub nr_switches: u64_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub uclamp: [uclamp_rq; 2usize],
    pub uclamp_flags: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub cfs: cfs_rq,
    pub rt: rt_rq,
    pub dl: dl_rq,
    pub leaf_cfs_rq_list: list_head,
    pub tmp_alone_branch: *mut list_head,
    pub nr_uninterruptible: ::aya_bpf_cty::c_ulong,
    pub curr: *mut task_struct,
    pub idle: *mut task_struct,
    pub stop: *mut task_struct,
    pub next_balance: ::aya_bpf_cty::c_ulong,
    pub prev_mm: *mut mm_struct,
    pub clock_update_flags: ::aya_bpf_cty::c_uint,
    pub clock: u64_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub clock_task: u64_,
    pub clock_pelt: u64_,
    pub lost_idle_time: ::aya_bpf_cty::c_ulong,
    pub nr_iowait: atomic_t,
    pub membarrier_state: ::aya_bpf_cty::c_int,
    pub rd: *mut root_domain,
    pub sd: *mut sched_domain,
    pub cpu_capacity: ::aya_bpf_cty::c_ulong,
    pub cpu_capacity_orig: ::aya_bpf_cty::c_ulong,
    pub balance_callback: *mut callback_head,
    pub balance_push: ::aya_bpf_cty::c_uchar,
    pub nohz_idle_balance: ::aya_bpf_cty::c_uchar,
    pub idle_balance: ::aya_bpf_cty::c_uchar,
    pub misfit_task_load: ::aya_bpf_cty::c_ulong,
    pub active_balance: ::aya_bpf_cty::c_int,
    pub push_cpu: ::aya_bpf_cty::c_int,
    pub active_balance_work: cpu_stop_work,
    pub cpu: ::aya_bpf_cty::c_int,
    pub online: ::aya_bpf_cty::c_int,
    pub cfs_tasks: list_head,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub avg_rt: sched_avg,
    pub avg_dl: sched_avg,
    pub idle_stamp: u64_,
    pub avg_idle: u64_,
    pub max_idle_balance_cost: u64_,
    pub hotplug_wait: rcuwait,
    pub prev_steal_time: u64_,
    pub calc_load_update: ::aya_bpf_cty::c_ulong,
    pub calc_load_active: ::aya_bpf_cty::c_long,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub hrtick_csd: call_single_data_t,
    pub hrtick_timer: hrtimer,
    pub hrtick_time: ktime_t,
    pub rq_sched_info: sched_info,
    pub rq_cpu_time: ::aya_bpf_cty::c_ulonglong,
    pub yld_count: ::aya_bpf_cty::c_uint,
    pub sched_count: ::aya_bpf_cty::c_uint,
    pub sched_goidle: ::aya_bpf_cty::c_uint,
    pub ttwu_count: ::aya_bpf_cty::c_uint,
    pub ttwu_local: ::aya_bpf_cty::c_uint,
    pub idle_state: *mut cpuidle_state,
    pub nr_pinned: ::aya_bpf_cty::c_uint,
    pub push_busy: ::aya_bpf_cty::c_uint,
    pub push_work: cpu_stop_work,
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl rq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_4() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_5() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_6() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_7() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_domain {
    pub em_pd: *mut em_perf_domain,
    pub next: *mut perf_domain,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_flags {
    pub flags: ::aya_bpf_cty::c_ulong,
    pub cookie: pin_cookie,
    pub clock_update_flags: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
pub struct numa_group {
    pub refcount: refcount_t,
    pub lock: spinlock_t,
    pub nr_tasks: ::aya_bpf_cty::c_int,
    pub gid: pid_t,
    pub active_nodes: ::aya_bpf_cty::c_int,
    pub rcu: callback_head,
    pub total_faults: ::aya_bpf_cty::c_ulong,
    pub max_faults_cpu: ::aya_bpf_cty::c_ulong,
    pub faults_cpu: *mut ::aya_bpf_cty::c_ulong,
    pub faults: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub tree_entry: rb_node,
    pub pi_tree_entry: rb_node,
    pub task: *mut task_struct,
    pub lock: *mut rt_mutex,
    pub prio: ::aya_bpf_cty::c_int,
    pub deadline: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex {
    pub wait_lock: raw_spinlock_t,
    pub waiters: rb_root_cached,
    pub owner: *mut task_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union futex_key {
    pub shared: futex_key__bindgen_ty_1,
    pub private: futex_key__bindgen_ty_2,
    pub both: futex_key__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_key__bindgen_ty_1 {
    pub i_seq: u64_,
    pub pgoff: ::aya_bpf_cty::c_ulong,
    pub offset: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_key__bindgen_ty_2 {
    pub __bindgen_anon_1: futex_key__bindgen_ty_2__bindgen_ty_1,
    pub address: ::aya_bpf_cty::c_ulong,
    pub offset: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union futex_key__bindgen_ty_2__bindgen_ty_1 {
    pub mm: *mut mm_struct,
    pub __tmp: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_key__bindgen_ty_3 {
    pub ptr: u64_,
    pub word: ::aya_bpf_cty::c_ulong,
    pub offset: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_pi_state {
    pub list: list_head,
    pub pi_mutex: rt_mutex,
    pub owner: *mut task_struct,
    pub refcount: refcount_t,
    pub key: futex_key,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_sect_attr {
    pub battr: bin_attribute,
    pub address: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_sect_attrs {
    pub grp: attribute_group,
    pub nsections: ::aya_bpf_cty::c_uint,
    pub attrs: __IncompleteArrayField<module_sect_attr>,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_notes_attrs {
    pub dir: *mut kobject,
    pub notes: ::aya_bpf_cty::c_uint,
    pub attrs: __IncompleteArrayField<bin_attribute>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_pin {
    pub wait: wait_queue_head_t,
    pub done: ::aya_bpf_cty::c_int,
    pub s_list: hlist_node,
    pub m_list: hlist_node,
    pub kill: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_pin)>,
}
pub mod bpf_link_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_LINK_TYPE_UNSPEC: Type = 0;
    pub const BPF_LINK_TYPE_RAW_TRACEPOINT: Type = 1;
    pub const BPF_LINK_TYPE_TRACING: Type = 2;
    pub const BPF_LINK_TYPE_CGROUP: Type = 3;
    pub const BPF_LINK_TYPE_ITER: Type = 4;
    pub const BPF_LINK_TYPE_NETNS: Type = 5;
    pub const BPF_LINK_TYPE_XDP: Type = 6;
    pub const MAX_BPF_LINK_TYPE: Type = 7;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info {
    pub type_: __u32,
    pub id: __u32,
    pub prog_id: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1 {
    pub raw_tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_1,
    pub tracing: bpf_link_info__bindgen_ty_1__bindgen_ty_2,
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_3,
    pub iter: bpf_link_info__bindgen_ty_1__bindgen_ty_4,
    pub netns: bpf_link_info__bindgen_ty_1__bindgen_ty_5,
    pub xdp: bpf_link_info__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub tp_name: __u64,
    pub tp_name_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub cgroup_id: __u64,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_name: __u64,
    pub target_name_len: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub map: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub map_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub netns_ino: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub ifindex: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link {
    pub refcnt: atomic64_t,
    pub id: u32_,
    pub type_: bpf_link_type::Type,
    pub ops: *const bpf_link_ops,
    pub prog: *mut bpf_prog,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_ops {
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>,
    pub dealloc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>,
    pub detach:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link) -> ::aya_bpf_cty::c_int>,
    pub update_prog: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_link,
            arg2: *mut bpf_prog,
            arg3: *mut bpf_prog,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_link, arg2: *mut seq_file)>,
    pub fill_link_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_link,
            arg2: *mut bpf_link_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_taskset {
    pub src_csets: list_head,
    pub dst_csets: list_head,
    pub nr_tasks: ::aya_bpf_cty::c_int,
    pub ssid: ::aya_bpf_cty::c_int,
    pub csets: *mut list_head,
    pub cur_cset: *mut css_set,
    pub cur_task: *mut task_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_pkey_query {
    pub supported_ops: __u32,
    pub key_size: __u32,
    pub max_data_size: __u16,
    pub max_sig_size: __u16,
    pub max_enc_size: __u16,
    pub max_dec_size: __u16,
}
pub mod kernel_pkey_operation {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const kernel_pkey_encrypt: Type = 0;
    pub const kernel_pkey_decrypt: Type = 1;
    pub const kernel_pkey_sign: Type = 2;
    pub const kernel_pkey_verify: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_pkey_params {
    pub key: *mut key,
    pub encoding: *const ::aya_bpf_cty::c_char,
    pub hash_algo: *const ::aya_bpf_cty::c_char,
    pub info: *mut ::aya_bpf_cty::c_char,
    pub in_len: __u32,
    pub __bindgen_anon_1: kernel_pkey_params__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_pkey_params__bindgen_ty_1 {
    pub out_len: __u32,
    pub in2_len: __u32,
}
impl kernel_pkey_params {
    #[inline]
    pub fn op(&self) -> kernel_pkey_operation::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_op(&mut self, val: kernel_pkey_operation::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(op: kernel_pkey_operation::Type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let op: u32 = unsafe { ::core::mem::transmute(op) };
            op as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_preparsed_payload {
    pub orig_description: *const ::aya_bpf_cty::c_char,
    pub description: *mut ::aya_bpf_cty::c_char,
    pub payload: key_payload,
    pub data: *const ::aya_bpf_cty::c_void,
    pub datalen: size_t,
    pub quotalen: size_t,
    pub expiry: time64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_match_data {
    pub cmp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const key, arg2: *const key_match_data) -> bool_,
    >,
    pub raw_data: *const ::aya_bpf_cty::c_void,
    pub preparsed: *mut ::aya_bpf_cty::c_void,
    pub lookup_type: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_stop_done {
    pub nr_todo: atomic_t,
    pub ret: ::aya_bpf_cty::c_int,
    pub completion: completion,
}
pub type __kernel_mqd_t = ::aya_bpf_cty::c_int;
pub type mqd_t = __kernel_mqd_t;
pub mod audit_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const AUDIT_DISABLED: Type = 0;
    pub const AUDIT_BUILD_CONTEXT: Type = 1;
    pub const AUDIT_RECORD_CONTEXT: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_cap_data {
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
    pub __bindgen_anon_1: audit_cap_data__bindgen_ty_1,
    pub ambient: kernel_cap_t,
    pub rootid: kuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union audit_cap_data__bindgen_ty_1 {
    pub fE: ::aya_bpf_cty::c_uint,
    pub effective: kernel_cap_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_names {
    pub list: list_head,
    pub name: *mut filename,
    pub name_len: ::aya_bpf_cty::c_int,
    pub hidden: bool_,
    pub ino: ::aya_bpf_cty::c_ulong,
    pub dev: dev_t,
    pub mode: umode_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub rdev: dev_t,
    pub oblob: lsmblob,
    pub fcap: audit_cap_data,
    pub fcap_ver: ::aya_bpf_cty::c_uint,
    pub type_: ::aya_bpf_cty::c_uchar,
    pub should_free: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mq_attr {
    pub mq_flags: __kernel_long_t,
    pub mq_maxmsg: __kernel_long_t,
    pub mq_msgsize: __kernel_long_t,
    pub mq_curmsgs: __kernel_long_t,
    pub __reserved: [__kernel_long_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_proctitle {
    pub len: ::aya_bpf_cty::c_int,
    pub value: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context {
    pub dummy: ::aya_bpf_cty::c_int,
    pub in_syscall: ::aya_bpf_cty::c_int,
    pub state: audit_state::Type,
    pub current_state: audit_state::Type,
    pub serial: ::aya_bpf_cty::c_uint,
    pub major: ::aya_bpf_cty::c_int,
    pub ctime: timespec64,
    pub argv: [::aya_bpf_cty::c_ulong; 4usize],
    pub return_code: ::aya_bpf_cty::c_long,
    pub prio: u64_,
    pub return_valid: ::aya_bpf_cty::c_int,
    pub preallocated_names: [audit_names; 5usize],
    pub name_count: ::aya_bpf_cty::c_int,
    pub names_list: list_head,
    pub filterkey: *mut ::aya_bpf_cty::c_char,
    pub pwd: path,
    pub aux: *mut audit_aux_data,
    pub aux_pids: *mut audit_aux_data,
    pub sockaddr: *mut __kernel_sockaddr_storage,
    pub sockaddr_len: size_t,
    pub pid: pid_t,
    pub ppid: pid_t,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub suid: kuid_t,
    pub fsuid: kuid_t,
    pub gid: kgid_t,
    pub egid: kgid_t,
    pub sgid: kgid_t,
    pub fsgid: kgid_t,
    pub personality: ::aya_bpf_cty::c_ulong,
    pub arch: ::aya_bpf_cty::c_int,
    pub target_pid: pid_t,
    pub target_auid: kuid_t,
    pub target_uid: kuid_t,
    pub target_sessionid: ::aya_bpf_cty::c_uint,
    pub target_lsm: lsmblob,
    pub target_comm: [::aya_bpf_cty::c_char; 16usize],
    pub trees: *mut audit_tree_refs,
    pub first_trees: *mut audit_tree_refs,
    pub killed_trees: list_head,
    pub tree_count: ::aya_bpf_cty::c_int,
    pub type_: ::aya_bpf_cty::c_int,
    pub __bindgen_anon_1: audit_context__bindgen_ty_1,
    pub fds: [::aya_bpf_cty::c_int; 2usize],
    pub proctitle: audit_proctitle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union audit_context__bindgen_ty_1 {
    pub socketcall: audit_context__bindgen_ty_1__bindgen_ty_1,
    pub ipc: audit_context__bindgen_ty_1__bindgen_ty_2,
    pub mq_getsetattr: audit_context__bindgen_ty_1__bindgen_ty_3,
    pub mq_notify: audit_context__bindgen_ty_1__bindgen_ty_4,
    pub mq_sendrecv: audit_context__bindgen_ty_1__bindgen_ty_5,
    pub mq_open: audit_context__bindgen_ty_1__bindgen_ty_6,
    pub capset: audit_context__bindgen_ty_1__bindgen_ty_7,
    pub mmap: audit_context__bindgen_ty_1__bindgen_ty_8,
    pub execve: audit_context__bindgen_ty_1__bindgen_ty_9,
    pub module: audit_context__bindgen_ty_1__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_1 {
    pub nargs: ::aya_bpf_cty::c_int,
    pub args: [::aya_bpf_cty::c_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_2 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub mode: umode_t,
    pub oblob: lsmblob,
    pub has_perm: ::aya_bpf_cty::c_int,
    pub perm_uid: uid_t,
    pub perm_gid: gid_t,
    pub perm_mode: umode_t,
    pub qbytes: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_3 {
    pub mqdes: mqd_t,
    pub mqstat: mq_attr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_4 {
    pub mqdes: mqd_t,
    pub sigev_signo: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_5 {
    pub mqdes: mqd_t,
    pub msg_len: size_t,
    pub msg_prio: ::aya_bpf_cty::c_uint,
    pub abs_timeout: timespec64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_6 {
    pub oflag: ::aya_bpf_cty::c_int,
    pub mode: umode_t,
    pub attr: mq_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_7 {
    pub pid: pid_t,
    pub cap: audit_cap_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_8 {
    pub fd: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_9 {
    pub argc: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_1__bindgen_ty_10 {
    pub name: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::aya_bpf_cty::c_char; 126usize],
}
#[repr(C)]
pub struct net_generic {
    pub __bindgen_anon_1: net_generic__bindgen_ty_1,
}
#[repr(C)]
pub struct net_generic__bindgen_ty_1 {
    pub s: __BindgenUnionField<net_generic__bindgen_ty_1__bindgen_ty_1>,
    pub ptr: __BindgenUnionField<[*mut ::aya_bpf_cty::c_void; 0usize]>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_generic__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
}
pub type fsnotify_connp_t = *mut fsnotify_mark_connector;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    pub lock: spinlock_t,
    pub type_: ::aya_bpf_cty::c_ushort,
    pub flags: ::aya_bpf_cty::c_ushort,
    pub fsid: __kernel_fsid_t,
    pub __bindgen_anon_1: fsnotify_mark_connector__bindgen_ty_1,
    pub list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fsnotify_mark_connector__bindgen_ty_1 {
    pub obj: *mut fsnotify_connp_t,
    pub destroy_next: *mut fsnotify_mark_connector,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_aux_data {
    pub next: *mut audit_aux_data,
    pub type_: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_chunk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_tree_refs {
    pub next: *mut audit_tree_refs,
    pub c: [*mut audit_chunk; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_cache {
    pub allow_native: [::aya_bpf_cty::c_ulong; 7usize],
    pub allow_compat: [::aya_bpf_cty::c_ulong; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp_filter {
    pub refs: refcount_t,
    pub users: refcount_t,
    pub log: bool_,
    pub cache: action_cache,
    pub prev: *mut seccomp_filter,
    pub prog: *mut bpf_prog,
    pub notif: *mut notification,
    pub notify_lock: mutex,
    pub wqh: wait_queue_head_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notification {
    pub request: semaphore,
    pub next_id: u64_,
    pub notifications: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rchan_buf {
    pub start: *mut ::aya_bpf_cty::c_void,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub offset: size_t,
    pub subbufs_produced: size_t,
    pub subbufs_consumed: size_t,
    pub chan: *mut rchan,
    pub read_wait: wait_queue_head_t,
    pub wakeup_work: irq_work,
    pub dentry: *mut dentry,
    pub kref: kref,
    pub page_array: *mut *mut page,
    pub page_count: ::aya_bpf_cty::c_uint,
    pub finalized: ::aya_bpf_cty::c_uint,
    pub padding: *mut size_t,
    pub prev_padding: size_t,
    pub bytes_consumed: size_t,
    pub early_bytes: size_t,
    pub cpu: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl rchan_buf {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rchan {
    pub version: u32_,
    pub subbuf_size: size_t,
    pub n_subbufs: size_t,
    pub alloc_size: size_t,
    pub cb: *const rchan_callbacks,
    pub kref: kref,
    pub private_data: *mut ::aya_bpf_cty::c_void,
    pub last_toobig: size_t,
    pub buf: *mut *mut rchan_buf,
    pub is_global: ::aya_bpf_cty::c_int,
    pub list: list_head,
    pub parent: *mut dentry,
    pub has_base_filename: ::aya_bpf_cty::c_int,
    pub base_filename: [::aya_bpf_cty::c_char; 255usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rchan_callbacks {
    pub subbuf_start: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rchan_buf,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut ::aya_bpf_cty::c_void,
            arg4: size_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub create_buf_file: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf_cty::c_char,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: *mut rchan_buf,
            arg5: *mut ::aya_bpf_cty::c_int,
        ) -> *mut dentry,
    >,
    pub remove_buf_file:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf_cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_hash {
    pub size_bits: ::aya_bpf_cty::c_ulong,
    pub buckets: *mut hlist_head,
    pub count: ::aya_bpf_cty::c_ulong,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_filter {
    pub prog: *mut prog_entry,
    pub filter_string: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct array_buffer {
    pub tr: *mut trace_array,
    pub buffer: *mut trace_buffer,
    pub data: *mut trace_array_cpu,
    pub time_start: u64_,
    pub cpu: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_array {
    pub list: list_head,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub array_buffer: array_buffer,
    pub max_buffer: array_buffer,
    pub allocated_snapshot: bool_,
    pub max_latency: ::aya_bpf_cty::c_ulong,
    pub d_max_latency: *mut dentry,
    pub fsnotify_work: work_struct,
    pub fsnotify_irqwork: irq_work,
    pub filtered_pids: *mut trace_pid_list,
    pub filtered_no_pids: *mut trace_pid_list,
    pub max_lock: arch_spinlock_t,
    pub buffer_disabled: ::aya_bpf_cty::c_int,
    pub sys_refcount_enter: ::aya_bpf_cty::c_int,
    pub sys_refcount_exit: ::aya_bpf_cty::c_int,
    pub enter_syscall_files: [*mut trace_event_file; 442usize],
    pub exit_syscall_files: [*mut trace_event_file; 442usize],
    pub stop_count: ::aya_bpf_cty::c_int,
    pub clock_id: ::aya_bpf_cty::c_int,
    pub nr_topts: ::aya_bpf_cty::c_int,
    pub clear_trace: bool_,
    pub buffer_percent: ::aya_bpf_cty::c_int,
    pub n_err_log_entries: ::aya_bpf_cty::c_uint,
    pub current_trace: *mut tracer,
    pub trace_flags: ::aya_bpf_cty::c_uint,
    pub trace_flags_index: [::aya_bpf_cty::c_uchar; 32usize],
    pub flags: ::aya_bpf_cty::c_uint,
    pub start_lock: raw_spinlock_t,
    pub err_log: list_head,
    pub dir: *mut dentry,
    pub options: *mut dentry,
    pub percpu_dir: *mut dentry,
    pub event_dir: *mut dentry,
    pub topts: *mut trace_options,
    pub systems: list_head,
    pub events: list_head,
    pub trace_marker_file: *mut trace_event_file,
    pub tracing_cpumask: cpumask_var_t,
    pub ref_: ::aya_bpf_cty::c_int,
    pub trace_ref: ::aya_bpf_cty::c_int,
    pub ops: *mut ftrace_ops,
    pub function_pids: *mut trace_pid_list,
    pub function_no_pids: *mut trace_pid_list,
    pub func_probes: list_head,
    pub mod_trace: list_head,
    pub mod_notrace: list_head,
    pub function_enabled: ::aya_bpf_cty::c_int,
    pub time_stamp_abs_ref: ::aya_bpf_cty::c_int,
    pub hist_vars: list_head,
    pub cond_snapshot: *mut cond_snapshot,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer {
    pub name: *const ::aya_bpf_cty::c_char,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf_cty::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub update_thresh: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf_cty::c_int,
    >,
    pub open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub pipe_open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub pipe_close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_iterator,
            arg2: *mut file,
            arg3: *mut ::aya_bpf_cty::c_char,
            arg4: size_t,
            arg5: *mut loff_t,
        ) -> ssize_t,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_iterator,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: *mut pipe_inode_info,
            arg5: size_t,
            arg6: ::aya_bpf_cty::c_uint,
        ) -> ssize_t,
    >,
    pub print_header: ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file)>,
    pub print_line: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_iterator) -> print_line_t::Type,
    >,
    pub set_flag: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_array,
            arg2: u32_,
            arg3: u32_,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flag_changed: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_array,
            arg2: u32_,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub next: *mut tracer,
    pub flags: *mut tracer_flags,
    pub enabled: ::aya_bpf_cty::c_int,
    pub print_max: bool_,
    pub allow_instances: bool_,
    pub use_max_tr: bool_,
    pub noboot: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_subsystem_dir {
    pub list: list_head,
    pub subsystem: *mut event_subsystem,
    pub tr: *mut trace_array,
    pub entry: *mut dentry,
    pub ref_count: ::aya_bpf_cty::c_int,
    pub nr_events: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_array_cpu {
    pub disabled: atomic_t,
    pub buffer_page: *mut ::aya_bpf_cty::c_void,
    pub entries: ::aya_bpf_cty::c_ulong,
    pub saved_latency: ::aya_bpf_cty::c_ulong,
    pub critical_start: ::aya_bpf_cty::c_ulong,
    pub critical_end: ::aya_bpf_cty::c_ulong,
    pub critical_sequence: ::aya_bpf_cty::c_ulong,
    pub nice: ::aya_bpf_cty::c_ulong,
    pub policy: ::aya_bpf_cty::c_ulong,
    pub rt_priority: ::aya_bpf_cty::c_ulong,
    pub skipped_entries: ::aya_bpf_cty::c_ulong,
    pub preempt_timestamp: u64_,
    pub pid: pid_t,
    pub uid: kuid_t,
    pub comm: [::aya_bpf_cty::c_char; 16usize],
    pub ftrace_ignore_pid: ::aya_bpf_cty::c_int,
    pub ignore_pid: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_options {
    pub tracer: *mut tracer,
    pub topts: *mut trace_option_dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_option_dentry {
    pub opt: *mut tracer_opt,
    pub flags: *mut tracer_flags,
    pub tr: *mut trace_array,
    pub entry: *mut dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_pid_list {
    pub pid_max: ::aya_bpf_cty::c_int,
    pub pids: *mut ::aya_bpf_cty::c_ulong,
}
pub type cond_update_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut trace_array, arg2: *mut ::aya_bpf_cty::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cond_snapshot {
    pub cond_data: *mut ::aya_bpf_cty::c_void,
    pub update: cond_update_fn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer_opt {
    pub name: *const ::aya_bpf_cty::c_char,
    pub bit: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer_flags {
    pub val: u32_,
    pub opts: *mut tracer_opt,
    pub trace: *mut tracer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_subsystem {
    pub list: list_head,
    pub name: *const ::aya_bpf_cty::c_char,
    pub filter: *mut event_filter,
    pub ref_count: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ring_buffer_iter {
    pub cpu_buffer: *mut ring_buffer_per_cpu,
    pub head: ::aya_bpf_cty::c_ulong,
    pub next_event: ::aya_bpf_cty::c_ulong,
    pub head_page: *mut buffer_page,
    pub cache_reader_page: *mut buffer_page,
    pub cache_read: ::aya_bpf_cty::c_ulong,
    pub read_stamp: u64_,
    pub page_stamp: u64_,
    pub event: *mut ring_buffer_event,
    pub missed_events: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_irq_work {
    pub work: irq_work,
    pub waiters: wait_queue_head_t,
    pub full_waiters: wait_queue_head_t,
    pub waiters_pending: bool_,
    pub full_waiters_pending: bool_,
    pub wakeup_full: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_buffer___2 {
    pub flags: ::aya_bpf_cty::c_uint,
    pub cpus: ::aya_bpf_cty::c_int,
    pub record_disabled: atomic_t,
    pub cpumask: cpumask_var_t,
    pub reader_lock_key: *mut lock_class_key,
    pub mutex: mutex,
    pub buffers: *mut *mut ring_buffer_per_cpu,
    pub node: hlist_node,
    pub clock: ::core::option::Option<unsafe extern "C" fn() -> u64_>,
    pub irq_work: rb_irq_work,
    pub time_stamp_abs: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct buffer_data_page {
    pub time_stamp: u64_,
    pub commit: local_t,
    pub data: __IncompleteArrayField<::aya_bpf_cty::c_uchar>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffer_page {
    pub list: list_head,
    pub write: local_t,
    pub read: ::aya_bpf_cty::c_uint,
    pub entries: local_t,
    pub real_end: ::aya_bpf_cty::c_ulong,
    pub page: *mut buffer_data_page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_time_struct {
    pub time: local64_t,
}
pub type rb_time_t = rb_time_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ring_buffer_per_cpu {
    pub cpu: ::aya_bpf_cty::c_int,
    pub record_disabled: atomic_t,
    pub resize_disabled: atomic_t,
    pub buffer: *mut trace_buffer___2,
    pub reader_lock: raw_spinlock_t,
    pub lock: arch_spinlock_t,
    pub lock_key: lock_class_key,
    pub free_page: *mut buffer_data_page,
    pub nr_pages: ::aya_bpf_cty::c_ulong,
    pub current_context: ::aya_bpf_cty::c_uint,
    pub pages: *mut list_head,
    pub head_page: *mut buffer_page,
    pub tail_page: *mut buffer_page,
    pub commit_page: *mut buffer_page,
    pub reader_page: *mut buffer_page,
    pub lost_events: ::aya_bpf_cty::c_ulong,
    pub last_overrun: ::aya_bpf_cty::c_ulong,
    pub nest: ::aya_bpf_cty::c_ulong,
    pub entries_bytes: local_t,
    pub entries: local_t,
    pub overrun: local_t,
    pub commit_overrun: local_t,
    pub dropped_events: local_t,
    pub committing: local_t,
    pub commits: local_t,
    pub pages_touched: local_t,
    pub pages_read: local_t,
    pub last_pages_touch: ::aya_bpf_cty::c_long,
    pub shortest_full: size_t,
    pub read: ::aya_bpf_cty::c_ulong,
    pub read_bytes: ::aya_bpf_cty::c_ulong,
    pub write_stamp: rb_time_t,
    pub before_stamp: rb_time_t,
    pub read_stamp: u64_,
    pub nr_pages_to_update: ::aya_bpf_cty::c_long,
    pub new_pages: list_head,
    pub update_pages_work: work_struct,
    pub update_done: completion,
    pub irq_work: rb_irq_work,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disk_stats {
    pub nsecs: [u64_; 4usize],
    pub sectors: [::aya_bpf_cty::c_ulong; 4usize],
    pub ios: [::aya_bpf_cty::c_ulong; 4usize],
    pub merges: [::aya_bpf_cty::c_ulong; 4usize],
    pub io_ticks: ::aya_bpf_cty::c_ulong,
    pub in_flight: [local_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_crypt_ctx {
    pub bc_key: *const blk_crypto_key,
    pub bc_dun: [u64_; 4usize],
}
pub type blk_mq_req_flags_t = __u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_ctx {
    pub __bindgen_anon_1: blk_mq_ctx__bindgen_ty_1,
    pub cpu: ::aya_bpf_cty::c_uint,
    pub index_hw: [::aya_bpf_cty::c_ushort; 3usize],
    pub hctxs: [*mut blk_mq_hw_ctx; 3usize],
    pub rq_dispatched: [::aya_bpf_cty::c_ulong; 2usize],
    pub rq_merged: ::aya_bpf_cty::c_ulong,
    pub rq_completed: [::aya_bpf_cty::c_ulong; 2usize],
    pub queue: *mut request_queue,
    pub ctxs: *mut blk_mq_ctxs,
    pub kobj: kobject,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub rq_lists: [list_head; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl blk_mq_ctx__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl blk_mq_ctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap {
    pub depth: ::aya_bpf_cty::c_uint,
    pub shift: ::aya_bpf_cty::c_uint,
    pub map_nr: ::aya_bpf_cty::c_uint,
    pub map: *mut sbitmap_word,
}
#[repr(C)]
pub struct blk_mq_hw_ctx {
    pub __bindgen_anon_1: blk_mq_hw_ctx__bindgen_ty_1,
    pub run_work: delayed_work,
    pub cpumask: cpumask_var_t,
    pub next_cpu: ::aya_bpf_cty::c_int,
    pub next_cpu_batch: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub sched_data: *mut ::aya_bpf_cty::c_void,
    pub queue: *mut request_queue,
    pub fq: *mut blk_flush_queue,
    pub driver_data: *mut ::aya_bpf_cty::c_void,
    pub ctx_map: sbitmap,
    pub dispatch_from: *mut blk_mq_ctx,
    pub dispatch_busy: ::aya_bpf_cty::c_uint,
    pub type_: ::aya_bpf_cty::c_ushort,
    pub nr_ctx: ::aya_bpf_cty::c_ushort,
    pub ctxs: *mut *mut blk_mq_ctx,
    pub dispatch_wait_lock: spinlock_t,
    pub dispatch_wait: wait_queue_entry_t,
    pub wait_index: atomic_t,
    pub tags: *mut blk_mq_tags,
    pub sched_tags: *mut blk_mq_tags,
    pub queued: ::aya_bpf_cty::c_ulong,
    pub run: ::aya_bpf_cty::c_ulong,
    pub dispatched: [::aya_bpf_cty::c_ulong; 7usize],
    pub numa_node: ::aya_bpf_cty::c_uint,
    pub queue_num: ::aya_bpf_cty::c_uint,
    pub nr_active: atomic_t,
    pub elevator_queued: atomic_t,
    pub cpuhp_online: hlist_node,
    pub cpuhp_dead: hlist_node,
    pub kobj: kobject,
    pub poll_considered: ::aya_bpf_cty::c_ulong,
    pub poll_invoked: ::aya_bpf_cty::c_ulong,
    pub poll_success: ::aya_bpf_cty::c_ulong,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub hctx_list: list_head,
    pub srcu: __IncompleteArrayField<srcu_struct>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub dispatch: list_head,
    pub state: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl blk_mq_hw_ctx__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl blk_mq_hw_ctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_alloc_data {
    pub q: *mut request_queue,
    pub flags: blk_mq_req_flags_t,
    pub shallow_depth: ::aya_bpf_cty::c_uint,
    pub cmd_flags: ::aya_bpf_cty::c_uint,
    pub ctx: *mut blk_mq_ctx,
    pub hctx: *mut blk_mq_hw_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_stat_callback {
    pub list: list_head,
    pub timer: timer_list,
    pub cpu_stat: *mut blk_rq_stat,
    pub bucket_fn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const request) -> ::aya_bpf_cty::c_int>,
    pub buckets: ::aya_bpf_cty::c_uint,
    pub stat: *mut blk_rq_stat,
    pub timer_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_stat_callback)>,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_trace {
    pub trace_state: ::aya_bpf_cty::c_int,
    pub rchan: *mut rchan,
    pub sequence: *mut ::aya_bpf_cty::c_ulong,
    pub msg_data: *mut ::aya_bpf_cty::c_uchar,
    pub act_mask: u16_,
    pub start_lba: u64_,
    pub end_lba: u64_,
    pub pid: u32_,
    pub dev: u32_,
    pub dir: *mut dentry,
    pub dropped_file: *mut dentry,
    pub msg_file: *mut dentry,
    pub running_list: list_head,
    pub dropped: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_flush_queue {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rq_status: blk_status_t,
    pub flush_pending_since: ::aya_bpf_cty::c_ulong,
    pub flush_queue: [list_head; 2usize],
    pub flush_data_in_flight: list_head,
    pub flush_rq: *mut request,
    pub mq_flush_lock: spinlock_t,
}
impl blk_flush_queue {
    #[inline]
    pub fn flush_pending_idx(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_pending_idx(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush_running_idx(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_running_idx(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flush_pending_idx: ::aya_bpf_cty::c_uint,
        flush_running_idx: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flush_pending_idx: u32 = unsafe { ::core::mem::transmute(flush_pending_idx) };
            flush_pending_idx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flush_running_idx: u32 = unsafe { ::core::mem::transmute(flush_running_idx) };
            flush_running_idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_queue_map {
    pub mq_map: *mut ::aya_bpf_cty::c_uint,
    pub nr_queues: ::aya_bpf_cty::c_uint,
    pub queue_offset: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap_queue {
    pub sb: sbitmap,
    pub alloc_hint: *mut ::aya_bpf_cty::c_uint,
    pub wake_batch: ::aya_bpf_cty::c_uint,
    pub wake_index: atomic_t,
    pub ws: *mut sbq_wait_state,
    pub ws_active: atomic_t,
    pub round_robin: bool_,
    pub min_shallow_depth: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tag_set {
    pub map: [blk_mq_queue_map; 3usize],
    pub nr_maps: ::aya_bpf_cty::c_uint,
    pub ops: *const blk_mq_ops,
    pub nr_hw_queues: ::aya_bpf_cty::c_uint,
    pub queue_depth: ::aya_bpf_cty::c_uint,
    pub reserved_tags: ::aya_bpf_cty::c_uint,
    pub cmd_size: ::aya_bpf_cty::c_uint,
    pub numa_node: ::aya_bpf_cty::c_int,
    pub timeout: ::aya_bpf_cty::c_uint,
    pub flags: ::aya_bpf_cty::c_uint,
    pub driver_data: *mut ::aya_bpf_cty::c_void,
    pub active_queues_shared_sbitmap: atomic_t,
    pub __bitmap_tags: sbitmap_queue,
    pub __breserved_tags: sbitmap_queue,
    pub tags: *mut *mut blk_mq_tags,
    pub tag_list_lock: mutex,
    pub tag_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbitmap_word {
    pub depth: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub word: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub cleared: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbq_wait_state {
    pub wait_cnt: atomic_t,
    pub wait: wait_queue_head_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl sbq_wait_state {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_tags {
    pub nr_tags: ::aya_bpf_cty::c_uint,
    pub nr_reserved_tags: ::aya_bpf_cty::c_uint,
    pub active_queues: atomic_t,
    pub bitmap_tags: *mut sbitmap_queue,
    pub breserved_tags: *mut sbitmap_queue,
    pub __bitmap_tags: sbitmap_queue,
    pub __breserved_tags: sbitmap_queue,
    pub rqs: *mut *mut request,
    pub static_rqs: *mut *mut request,
    pub page_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_queue_data {
    pub rq: *mut request,
    pub last: bool_,
}
pub mod blk_crypto_mode_num {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BLK_ENCRYPTION_MODE_INVALID: Type = 0;
    pub const BLK_ENCRYPTION_MODE_AES_256_XTS: Type = 1;
    pub const BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV: Type = 2;
    pub const BLK_ENCRYPTION_MODE_ADIANTUM: Type = 3;
    pub const BLK_ENCRYPTION_MODE_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_crypto_config {
    pub crypto_mode: blk_crypto_mode_num::Type,
    pub data_unit_size: ::aya_bpf_cty::c_uint,
    pub dun_bytes: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_crypto_key {
    pub crypto_cfg: blk_crypto_config,
    pub data_unit_size_bits: ::aya_bpf_cty::c_uint,
    pub size: ::aya_bpf_cty::c_uint,
    pub raw: [u8_; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_ctxs {
    pub kobj: kobject,
    pub queue_ctx: *mut blk_mq_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_event_field {
    pub link: list_head,
    pub name: *const ::aya_bpf_cty::c_char,
    pub type_: *const ::aya_bpf_cty::c_char,
    pub filter_type: ::aya_bpf_cty::c_int,
    pub offset: ::aya_bpf_cty::c_int,
    pub size: ::aya_bpf_cty::c_int,
    pub is_signed: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prog_entry {
    pub target: ::aya_bpf_cty::c_int,
    pub when_to_branch: ::aya_bpf_cty::c_int,
    pub pred: *mut filter_pred,
}
pub type filter_pred_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut filter_pred,
        arg2: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
pub type regex_match_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf_cty::c_char,
        arg2: *mut regex,
        arg3: ::aya_bpf_cty::c_int,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regex {
    pub pattern: [::aya_bpf_cty::c_char; 256usize],
    pub len: ::aya_bpf_cty::c_int,
    pub field_len: ::aya_bpf_cty::c_int,
    pub match_: regex_match_func,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct filter_pred {
    pub fn_: filter_pred_fn_t,
    pub val: u64_,
    pub regex: regex,
    pub ops: *mut ::aya_bpf_cty::c_ushort,
    pub field: *mut ftrace_event_field,
    pub offset: ::aya_bpf_cty::c_int,
    pub not: ::aya_bpf_cty::c_int,
    pub op: ::aya_bpf_cty::c_int,
}
pub mod bpf_func_id {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_FUNC_unspec: Type = 0;
    pub const BPF_FUNC_map_lookup_elem: Type = 1;
    pub const BPF_FUNC_map_update_elem: Type = 2;
    pub const BPF_FUNC_map_delete_elem: Type = 3;
    pub const BPF_FUNC_probe_read: Type = 4;
    pub const BPF_FUNC_ktime_get_ns: Type = 5;
    pub const BPF_FUNC_trace_printk: Type = 6;
    pub const BPF_FUNC_get_prandom_u32: Type = 7;
    pub const BPF_FUNC_get_smp_processor_id: Type = 8;
    pub const BPF_FUNC_skb_store_bytes: Type = 9;
    pub const BPF_FUNC_l3_csum_replace: Type = 10;
    pub const BPF_FUNC_l4_csum_replace: Type = 11;
    pub const BPF_FUNC_tail_call: Type = 12;
    pub const BPF_FUNC_clone_redirect: Type = 13;
    pub const BPF_FUNC_get_current_pid_tgid: Type = 14;
    pub const BPF_FUNC_get_current_uid_gid: Type = 15;
    pub const BPF_FUNC_get_current_comm: Type = 16;
    pub const BPF_FUNC_get_cgroup_classid: Type = 17;
    pub const BPF_FUNC_skb_vlan_push: Type = 18;
    pub const BPF_FUNC_skb_vlan_pop: Type = 19;
    pub const BPF_FUNC_skb_get_tunnel_key: Type = 20;
    pub const BPF_FUNC_skb_set_tunnel_key: Type = 21;
    pub const BPF_FUNC_perf_event_read: Type = 22;
    pub const BPF_FUNC_redirect: Type = 23;
    pub const BPF_FUNC_get_route_realm: Type = 24;
    pub const BPF_FUNC_perf_event_output: Type = 25;
    pub const BPF_FUNC_skb_load_bytes: Type = 26;
    pub const BPF_FUNC_get_stackid: Type = 27;
    pub const BPF_FUNC_csum_diff: Type = 28;
    pub const BPF_FUNC_skb_get_tunnel_opt: Type = 29;
    pub const BPF_FUNC_skb_set_tunnel_opt: Type = 30;
    pub const BPF_FUNC_skb_change_proto: Type = 31;
    pub const BPF_FUNC_skb_change_type: Type = 32;
    pub const BPF_FUNC_skb_under_cgroup: Type = 33;
    pub const BPF_FUNC_get_hash_recalc: Type = 34;
    pub const BPF_FUNC_get_current_task: Type = 35;
    pub const BPF_FUNC_probe_write_user: Type = 36;
    pub const BPF_FUNC_current_task_under_cgroup: Type = 37;
    pub const BPF_FUNC_skb_change_tail: Type = 38;
    pub const BPF_FUNC_skb_pull_data: Type = 39;
    pub const BPF_FUNC_csum_update: Type = 40;
    pub const BPF_FUNC_set_hash_invalid: Type = 41;
    pub const BPF_FUNC_get_numa_node_id: Type = 42;
    pub const BPF_FUNC_skb_change_head: Type = 43;
    pub const BPF_FUNC_xdp_adjust_head: Type = 44;
    pub const BPF_FUNC_probe_read_str: Type = 45;
    pub const BPF_FUNC_get_socket_cookie: Type = 46;
    pub const BPF_FUNC_get_socket_uid: Type = 47;
    pub const BPF_FUNC_set_hash: Type = 48;
    pub const BPF_FUNC_setsockopt: Type = 49;
    pub const BPF_FUNC_skb_adjust_room: Type = 50;
    pub const BPF_FUNC_redirect_map: Type = 51;
    pub const BPF_FUNC_sk_redirect_map: Type = 52;
    pub const BPF_FUNC_sock_map_update: Type = 53;
    pub const BPF_FUNC_xdp_adjust_meta: Type = 54;
    pub const BPF_FUNC_perf_event_read_value: Type = 55;
    pub const BPF_FUNC_perf_prog_read_value: Type = 56;
    pub const BPF_FUNC_getsockopt: Type = 57;
    pub const BPF_FUNC_override_return: Type = 58;
    pub const BPF_FUNC_sock_ops_cb_flags_set: Type = 59;
    pub const BPF_FUNC_msg_redirect_map: Type = 60;
    pub const BPF_FUNC_msg_apply_bytes: Type = 61;
    pub const BPF_FUNC_msg_cork_bytes: Type = 62;
    pub const BPF_FUNC_msg_pull_data: Type = 63;
    pub const BPF_FUNC_bind: Type = 64;
    pub const BPF_FUNC_xdp_adjust_tail: Type = 65;
    pub const BPF_FUNC_skb_get_xfrm_state: Type = 66;
    pub const BPF_FUNC_get_stack: Type = 67;
    pub const BPF_FUNC_skb_load_bytes_relative: Type = 68;
    pub const BPF_FUNC_fib_lookup: Type = 69;
    pub const BPF_FUNC_sock_hash_update: Type = 70;
    pub const BPF_FUNC_msg_redirect_hash: Type = 71;
    pub const BPF_FUNC_sk_redirect_hash: Type = 72;
    pub const BPF_FUNC_lwt_push_encap: Type = 73;
    pub const BPF_FUNC_lwt_seg6_store_bytes: Type = 74;
    pub const BPF_FUNC_lwt_seg6_adjust_srh: Type = 75;
    pub const BPF_FUNC_lwt_seg6_action: Type = 76;
    pub const BPF_FUNC_rc_repeat: Type = 77;
    pub const BPF_FUNC_rc_keydown: Type = 78;
    pub const BPF_FUNC_skb_cgroup_id: Type = 79;
    pub const BPF_FUNC_get_current_cgroup_id: Type = 80;
    pub const BPF_FUNC_get_local_storage: Type = 81;
    pub const BPF_FUNC_sk_select_reuseport: Type = 82;
    pub const BPF_FUNC_skb_ancestor_cgroup_id: Type = 83;
    pub const BPF_FUNC_sk_lookup_tcp: Type = 84;
    pub const BPF_FUNC_sk_lookup_udp: Type = 85;
    pub const BPF_FUNC_sk_release: Type = 86;
    pub const BPF_FUNC_map_push_elem: Type = 87;
    pub const BPF_FUNC_map_pop_elem: Type = 88;
    pub const BPF_FUNC_map_peek_elem: Type = 89;
    pub const BPF_FUNC_msg_push_data: Type = 90;
    pub const BPF_FUNC_msg_pop_data: Type = 91;
    pub const BPF_FUNC_rc_pointer_rel: Type = 92;
    pub const BPF_FUNC_spin_lock: Type = 93;
    pub const BPF_FUNC_spin_unlock: Type = 94;
    pub const BPF_FUNC_sk_fullsock: Type = 95;
    pub const BPF_FUNC_tcp_sock: Type = 96;
    pub const BPF_FUNC_skb_ecn_set_ce: Type = 97;
    pub const BPF_FUNC_get_listener_sock: Type = 98;
    pub const BPF_FUNC_skc_lookup_tcp: Type = 99;
    pub const BPF_FUNC_tcp_check_syncookie: Type = 100;
    pub const BPF_FUNC_sysctl_get_name: Type = 101;
    pub const BPF_FUNC_sysctl_get_current_value: Type = 102;
    pub const BPF_FUNC_sysctl_get_new_value: Type = 103;
    pub const BPF_FUNC_sysctl_set_new_value: Type = 104;
    pub const BPF_FUNC_strtol: Type = 105;
    pub const BPF_FUNC_strtoul: Type = 106;
    pub const BPF_FUNC_sk_storage_get: Type = 107;
    pub const BPF_FUNC_sk_storage_delete: Type = 108;
    pub const BPF_FUNC_send_signal: Type = 109;
    pub const BPF_FUNC_tcp_gen_syncookie: Type = 110;
    pub const BPF_FUNC_skb_output: Type = 111;
    pub const BPF_FUNC_probe_read_user: Type = 112;
    pub const BPF_FUNC_probe_read_kernel: Type = 113;
    pub const BPF_FUNC_probe_read_user_str: Type = 114;
    pub const BPF_FUNC_probe_read_kernel_str: Type = 115;
    pub const BPF_FUNC_tcp_send_ack: Type = 116;
    pub const BPF_FUNC_send_signal_thread: Type = 117;
    pub const BPF_FUNC_jiffies64: Type = 118;
    pub const BPF_FUNC_read_branch_records: Type = 119;
    pub const BPF_FUNC_get_ns_current_pid_tgid: Type = 120;
    pub const BPF_FUNC_xdp_output: Type = 121;
    pub const BPF_FUNC_get_netns_cookie: Type = 122;
    pub const BPF_FUNC_get_current_ancestor_cgroup_id: Type = 123;
    pub const BPF_FUNC_sk_assign: Type = 124;
    pub const BPF_FUNC_ktime_get_boot_ns: Type = 125;
    pub const BPF_FUNC_seq_printf: Type = 126;
    pub const BPF_FUNC_seq_write: Type = 127;
    pub const BPF_FUNC_sk_cgroup_id: Type = 128;
    pub const BPF_FUNC_sk_ancestor_cgroup_id: Type = 129;
    pub const BPF_FUNC_ringbuf_output: Type = 130;
    pub const BPF_FUNC_ringbuf_reserve: Type = 131;
    pub const BPF_FUNC_ringbuf_submit: Type = 132;
    pub const BPF_FUNC_ringbuf_discard: Type = 133;
    pub const BPF_FUNC_ringbuf_query: Type = 134;
    pub const BPF_FUNC_csum_level: Type = 135;
    pub const BPF_FUNC_skc_to_tcp6_sock: Type = 136;
    pub const BPF_FUNC_skc_to_tcp_sock: Type = 137;
    pub const BPF_FUNC_skc_to_tcp_timewait_sock: Type = 138;
    pub const BPF_FUNC_skc_to_tcp_request_sock: Type = 139;
    pub const BPF_FUNC_skc_to_udp6_sock: Type = 140;
    pub const BPF_FUNC_get_task_stack: Type = 141;
    pub const BPF_FUNC_load_hdr_opt: Type = 142;
    pub const BPF_FUNC_store_hdr_opt: Type = 143;
    pub const BPF_FUNC_reserve_hdr_opt: Type = 144;
    pub const BPF_FUNC_inode_storage_get: Type = 145;
    pub const BPF_FUNC_inode_storage_delete: Type = 146;
    pub const BPF_FUNC_d_path: Type = 147;
    pub const BPF_FUNC_copy_from_user: Type = 148;
    pub const BPF_FUNC_snprintf_btf: Type = 149;
    pub const BPF_FUNC_seq_printf_btf: Type = 150;
    pub const BPF_FUNC_skb_cgroup_classid: Type = 151;
    pub const BPF_FUNC_redirect_neigh: Type = 152;
    pub const BPF_FUNC_per_cpu_ptr: Type = 153;
    pub const BPF_FUNC_this_cpu_ptr: Type = 154;
    pub const BPF_FUNC_redirect_peer: Type = 155;
    pub const BPF_FUNC_task_storage_get: Type = 156;
    pub const BPF_FUNC_task_storage_delete: Type = 157;
    pub const BPF_FUNC_get_current_task_btf: Type = 158;
    pub const BPF_FUNC_bprm_opts_set: Type = 159;
    pub const BPF_FUNC_ktime_get_coarse_ns: Type = 160;
    pub const BPF_FUNC_ima_inode_hash: Type = 161;
    pub const BPF_FUNC_sock_from_file: Type = 162;
    pub const __BPF_FUNC_MAX_ID: Type = 163;
}
pub const BPF_F_INDEX_MASK: ::aya_bpf_cty::c_uint = 4294967295;
pub const BPF_F_CURRENT_CPU: ::aya_bpf_cty::c_uint = 4294967295;
pub const BPF_F_CTXLEN_MASK: ::aya_bpf_cty::c_uint = 0;
pub type _bindgen_ty_164 = ::aya_bpf_cty::c_uint;
pub const BPF_F_GET_BRANCH_RECORDS_SIZE: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_165 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_perf_event_value {
    pub counter: __u64,
    pub enabled: __u64,
    pub running: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_ptr {
    pub ptr: *mut ::aya_bpf_cty::c_void,
    pub type_id: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map {
    pub map: bpf_map,
    pub buckets: *mut bpf_local_storage_map_bucket,
    pub bucket_log: u32_,
    pub elem_size: u16_,
    pub cache_idx: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage {
    pub cache: [*mut bpf_local_storage_data; 16usize],
    pub list: hlist_head,
    pub owner: *mut ::aya_bpf_cty::c_void,
    pub rcu: callback_head,
    pub lock: raw_spinlock_t,
}
pub mod bpf_arg_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ARG_DONTCARE: Type = 0;
    pub const ARG_CONST_MAP_PTR: Type = 1;
    pub const ARG_PTR_TO_MAP_KEY: Type = 2;
    pub const ARG_PTR_TO_MAP_VALUE: Type = 3;
    pub const ARG_PTR_TO_UNINIT_MAP_VALUE: Type = 4;
    pub const ARG_PTR_TO_MAP_VALUE_OR_NULL: Type = 5;
    pub const ARG_PTR_TO_MEM: Type = 6;
    pub const ARG_PTR_TO_MEM_OR_NULL: Type = 7;
    pub const ARG_PTR_TO_UNINIT_MEM: Type = 8;
    pub const ARG_CONST_SIZE: Type = 9;
    pub const ARG_CONST_SIZE_OR_ZERO: Type = 10;
    pub const ARG_PTR_TO_CTX: Type = 11;
    pub const ARG_PTR_TO_CTX_OR_NULL: Type = 12;
    pub const ARG_ANYTHING: Type = 13;
    pub const ARG_PTR_TO_SPIN_LOCK: Type = 14;
    pub const ARG_PTR_TO_SOCK_COMMON: Type = 15;
    pub const ARG_PTR_TO_INT: Type = 16;
    pub const ARG_PTR_TO_LONG: Type = 17;
    pub const ARG_PTR_TO_SOCKET: Type = 18;
    pub const ARG_PTR_TO_SOCKET_OR_NULL: Type = 19;
    pub const ARG_PTR_TO_BTF_ID: Type = 20;
    pub const ARG_PTR_TO_ALLOC_MEM: Type = 21;
    pub const ARG_PTR_TO_ALLOC_MEM_OR_NULL: Type = 22;
    pub const ARG_CONST_ALLOC_SIZE_OR_ZERO: Type = 23;
    pub const ARG_PTR_TO_BTF_ID_SOCK_COMMON: Type = 24;
    pub const ARG_PTR_TO_PERCPU_BTF_ID: Type = 25;
    pub const __BPF_ARG_TYPE_MAX: Type = 26;
}
pub mod bpf_return_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RET_INTEGER: Type = 0;
    pub const RET_VOID: Type = 1;
    pub const RET_PTR_TO_MAP_VALUE: Type = 2;
    pub const RET_PTR_TO_MAP_VALUE_OR_NULL: Type = 3;
    pub const RET_PTR_TO_SOCKET_OR_NULL: Type = 4;
    pub const RET_PTR_TO_TCP_SOCK_OR_NULL: Type = 5;
    pub const RET_PTR_TO_SOCK_COMMON_OR_NULL: Type = 6;
    pub const RET_PTR_TO_ALLOC_MEM_OR_NULL: Type = 7;
    pub const RET_PTR_TO_BTF_ID_OR_NULL: Type = 8;
    pub const RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL: Type = 9;
    pub const RET_PTR_TO_MEM_OR_BTF_ID: Type = 10;
    pub const RET_PTR_TO_BTF_ID: Type = 11;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(arg1: u64_, arg2: u64_, arg3: u64_, arg4: u64_, arg5: u64_) -> u64_,
    >,
    pub gpl_only: bool_,
    pub pkt_access: bool_,
    pub ret_type: bpf_return_type::Type,
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2,
    pub ret_btf_id: *mut ::aya_bpf_cty::c_int,
    pub allowed: ::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_prog) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1__bindgen_ty_1,
    pub arg_type: [bpf_arg_type::Type; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    pub arg1_type: bpf_arg_type::Type,
    pub arg2_type: bpf_arg_type::Type,
    pub arg3_type: bpf_arg_type::Type,
    pub arg4_type: bpf_arg_type::Type,
    pub arg5_type: bpf_arg_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_2 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_2__bindgen_ty_1,
    pub arg_btf_id: [*mut u32_; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    pub arg1_btf_id: *mut u32_,
    pub arg2_btf_id: *mut u32_,
    pub arg3_btf_id: *mut u32_,
    pub arg4_btf_id: *mut u32_,
    pub arg5_btf_id: *mut u32_,
}
pub mod bpf_access_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_READ: Type = 1;
    pub const BPF_WRITE: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux {
    pub reg_type: bpf_reg_type::Type,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1,
    pub log: *mut bpf_verifier_log,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_access_aux__bindgen_ty_1 {
    pub ctx_field_size: ::aya_bpf_cty::c_int,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_ops {
    pub get_func_proto: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: bpf_func_id::Type,
            arg2: *const bpf_prog,
        ) -> *const bpf_func_proto,
    >,
    pub is_valid_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf_cty::c_int,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bpf_access_type::Type,
            arg4: *const bpf_prog,
            arg5: *mut bpf_insn_access_aux,
        ) -> bool_,
    >,
    pub gen_prologue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_insn,
            arg2: bool_,
            arg3: *const bpf_prog,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub gen_ld_abs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const bpf_insn, arg2: *mut bpf_insn) -> ::aya_bpf_cty::c_int,
    >,
    pub convert_ctx_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: bpf_access_type::Type,
            arg2: *const bpf_insn,
            arg3: *mut bpf_insn,
            arg4: *mut bpf_prog,
            arg5: *mut u32_,
        ) -> u32_,
    >,
    pub btf_struct_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_log,
            arg2: *const btf,
            arg3: *const btf_type,
            arg4: ::aya_bpf_cty::c_int,
            arg5: ::aya_bpf_cty::c_int,
            arg6: bpf_access_type::Type,
            arg7: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub type bpf_user_pt_regs_t = pt_regs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_perf_event_data {
    pub regs: bpf_user_pt_regs_t,
    pub sample_period: __u64,
    pub addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map_bucket {
    pub list: hlist_head,
    pub lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_local_storage_data {
    pub smap: *mut bpf_local_storage_map,
    pub data: __IncompleteArrayField<u8_>,
}
pub mod uprobe_filter_ctx {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const UPROBE_FILTER_REGISTER: Type = 0;
    pub const UPROBE_FILTER_UNREGISTER: Type = 1;
    pub const UPROBE_FILTER_MMAP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: *mut pt_regs,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub ret_handler: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut pt_regs,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: uprobe_filter_ctx::Type,
            arg3: *mut mm_struct,
        ) -> bool_,
    >,
    pub next: *mut uprobe_consumer,
}
#[repr(C)]
#[derive(Debug)]
pub struct bucket_table {
    pub size: ::aya_bpf_cty::c_uint,
    pub nest: ::aya_bpf_cty::c_uint,
    pub hash_rnd: u32_,
    pub walkers: list_head,
    pub rcu: callback_head,
    pub future_tbl: *mut bucket_table,
    pub dep_map: lockdep_map,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub buckets: __IncompleteArrayField<*mut rhash_lock_head>,
}
impl bucket_table {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub mod xdp_action {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const XDP_ABORTED: Type = 0;
    pub const XDP_DROP: Type = 1;
    pub const XDP_PASS: Type = 2;
    pub const XDP_TX: Type = 3;
    pub const XDP_REDIRECT: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_lock_head {}
pub const BPF_ANY: ::aya_bpf_cty::c_uint = 0;
pub const BPF_NOEXIST: ::aya_bpf_cty::c_uint = 1;
pub const BPF_EXIST: ::aya_bpf_cty::c_uint = 2;
pub const BPF_F_LOCK: ::aya_bpf_cty::c_uint = 4;
pub type _bindgen_ty_168 = ::aya_bpf_cty::c_uint;
pub const BPF_F_NO_PREALLOC: ::aya_bpf_cty::c_uint = 1;
pub const BPF_F_NO_COMMON_LRU: ::aya_bpf_cty::c_uint = 2;
pub const BPF_F_NUMA_NODE: ::aya_bpf_cty::c_uint = 4;
pub const BPF_F_RDONLY: ::aya_bpf_cty::c_uint = 8;
pub const BPF_F_WRONLY: ::aya_bpf_cty::c_uint = 16;
pub const BPF_F_STACK_BUILD_ID: ::aya_bpf_cty::c_uint = 32;
pub const BPF_F_ZERO_SEED: ::aya_bpf_cty::c_uint = 64;
pub const BPF_F_RDONLY_PROG: ::aya_bpf_cty::c_uint = 128;
pub const BPF_F_WRONLY_PROG: ::aya_bpf_cty::c_uint = 256;
pub const BPF_F_CLONE: ::aya_bpf_cty::c_uint = 512;
pub const BPF_F_MMAPABLE: ::aya_bpf_cty::c_uint = 1024;
pub const BPF_F_PRESERVE_ELEMS: ::aya_bpf_cty::c_uint = 2048;
pub const BPF_F_INNER_MAP: ::aya_bpf_cty::c_uint = 4096;
pub type _bindgen_ty_169 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_info {
    pub type_: __u32,
    pub id: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub ifindex: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub netns_dev: __u64,
    pub netns_ino: __u64,
    pub btf_id: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_spin_lock {
    pub val: __u32,
}
pub mod sk_action {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const SK_DROP: Type = 0;
    pub const SK_PASS: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_log {
    pub level: u32_,
    pub kbuf: [::aya_bpf_cty::c_char; 1024usize],
    pub ubuf: *mut ::aya_bpf_cty::c_char,
    pub len_used: u32_,
    pub len_total: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_subprog_info {
    pub start: u32_,
    pub linfo_idx: u32_,
    pub stack_depth: u16_,
    pub has_tail_call: bool_,
    pub tail_call_reachable: bool_,
    pub has_ld_abs: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_env {
    pub insn_idx: u32_,
    pub prev_insn_idx: u32_,
    pub prog: *mut bpf_prog,
    pub ops: *const bpf_verifier_ops,
    pub head: *mut bpf_verifier_stack_elem,
    pub stack_size: ::aya_bpf_cty::c_int,
    pub strict_alignment: bool_,
    pub test_state_freq: bool_,
    pub cur_state: *mut bpf_verifier_state,
    pub explored_states: *mut *mut bpf_verifier_state_list,
    pub free_list: *mut bpf_verifier_state_list,
    pub used_maps: [*mut bpf_map; 64usize],
    pub used_map_cnt: u32_,
    pub id_gen: u32_,
    pub allow_ptr_leaks: bool_,
    pub allow_uninit_stack: bool_,
    pub allow_ptr_to_map_access: bool_,
    pub bpf_capable: bool_,
    pub bypass_spec_v1: bool_,
    pub bypass_spec_v4: bool_,
    pub seen_direct_write: bool_,
    pub insn_aux_data: *mut bpf_insn_aux_data,
    pub prev_linfo: *const bpf_line_info,
    pub log: bpf_verifier_log,
    pub subprog_info: [bpf_subprog_info; 257usize],
    pub cfg: bpf_verifier_env__bindgen_ty_1,
    pub pass_cnt: u32_,
    pub subprog_cnt: u32_,
    pub prev_insn_processed: u32_,
    pub insn_processed: u32_,
    pub prev_jmps_processed: u32_,
    pub jmps_processed: u32_,
    pub verification_time: u64_,
    pub max_states_per_insn: u32_,
    pub total_states: u32_,
    pub peak_states: u32_,
    pub longest_mark_read_walk: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_env__bindgen_ty_1 {
    pub insn_state: *mut ::aya_bpf_cty::c_int,
    pub insn_stack: *mut ::aya_bpf_cty::c_int,
    pub cur_stack: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tnum {
    pub value: u64_,
    pub mask: u64_,
}
pub mod bpf_reg_liveness {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const REG_LIVE_NONE: Type = 0;
    pub const REG_LIVE_READ32: Type = 1;
    pub const REG_LIVE_READ64: Type = 2;
    pub const REG_LIVE_READ: Type = 3;
    pub const REG_LIVE_WRITTEN: Type = 4;
    pub const REG_LIVE_DONE: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_reg_state {
    pub type_: bpf_reg_type::Type,
    pub off: s32,
    pub __bindgen_anon_1: bpf_reg_state__bindgen_ty_1,
    pub id: u32_,
    pub ref_obj_id: u32_,
    pub var_off: tnum,
    pub smin_value: s64,
    pub smax_value: s64,
    pub umin_value: u64_,
    pub umax_value: u64_,
    pub s32_min_value: s32,
    pub s32_max_value: s32,
    pub u32_min_value: u32_,
    pub u32_max_value: u32_,
    pub parent: *mut bpf_reg_state,
    pub frameno: u32_,
    pub subreg_def: s32,
    pub live: bpf_reg_liveness::Type,
    pub precise: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_reg_state__bindgen_ty_1 {
    pub range: ::aya_bpf_cty::c_int,
    pub map_ptr: *mut bpf_map,
    pub __bindgen_anon_1: bpf_reg_state__bindgen_ty_1__bindgen_ty_1,
    pub mem_size: u32_,
    pub raw: bpf_reg_state__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_2 {
    pub raw1: ::aya_bpf_cty::c_ulong,
    pub raw2: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stack_state {
    pub spilled_ptr: bpf_reg_state,
    pub slot_type: [u8_; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reference_state {
    pub id: ::aya_bpf_cty::c_int,
    pub insn_idx: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_state {
    pub regs: [bpf_reg_state; 11usize],
    pub callsite: ::aya_bpf_cty::c_int,
    pub frameno: u32_,
    pub subprogno: u32_,
    pub acquired_refs: ::aya_bpf_cty::c_int,
    pub refs: *mut bpf_reference_state,
    pub allocated_stack: ::aya_bpf_cty::c_int,
    pub stack: *mut bpf_stack_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_idx_pair {
    pub prev_idx: u32_,
    pub idx: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_state {
    pub frame: [*mut bpf_func_state; 8usize],
    pub parent: *mut bpf_verifier_state,
    pub branches: u32_,
    pub insn_idx: u32_,
    pub curframe: u32_,
    pub active_spin_lock: u32_,
    pub speculative: bool_,
    pub first_insn_idx: u32_,
    pub last_insn_idx: u32_,
    pub jmp_history: *mut bpf_idx_pair,
    pub jmp_history_cnt: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_state_list {
    pub state: bpf_verifier_state,
    pub next: *mut bpf_verifier_state_list,
    pub miss_cnt: ::aya_bpf_cty::c_int,
    pub hit_cnt: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_aux_data {
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1,
    pub map_key_state: u64_,
    pub ctx_field_size: ::aya_bpf_cty::c_int,
    pub sanitize_stack_off: ::aya_bpf_cty::c_int,
    pub seen: u32_,
    pub zext_dst: bool_,
    pub alu_state: u8_,
    pub orig_idx: ::aya_bpf_cty::c_uint,
    pub prune_point: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_aux_data__bindgen_ty_1 {
    pub ptr_type: bpf_reg_type::Type,
    pub map_ptr_state: ::aya_bpf_cty::c_ulong,
    pub call_imm: s32,
    pub alu_limit: u32_,
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_1,
    pub btf_var: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_1 {
    pub map_index: u32_,
    pub map_off: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2 {
    pub reg_type: bpf_reg_type::Type,
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub mem_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_stack_elem {
    pub st: bpf_verifier_state,
    pub insn_idx: ::aya_bpf_cty::c_int,
    pub prev_insn_idx: ::aya_bpf_cty::c_int,
    pub next: *mut bpf_verifier_stack_elem,
    pub log_pos: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_pidns_info {
    pub pid: __u32,
    pub tgid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage_map {
    pub map: bpf_map,
    pub lock: spinlock_t,
    pub root: rb_root,
    pub list: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl bpf_cgroup_storage_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub const BPF_RB_NO_WAKEUP: ::aya_bpf_cty::c_uint = 1;
pub const BPF_RB_FORCE_WAKEUP: ::aya_bpf_cty::c_uint = 2;
pub type _bindgen_ty_176 = ::aya_bpf_cty::c_uint;
pub const BPF_RB_AVAIL_DATA: ::aya_bpf_cty::c_uint = 0;
pub const BPF_RB_RING_SIZE: ::aya_bpf_cty::c_uint = 1;
pub const BPF_RB_CONS_POS: ::aya_bpf_cty::c_uint = 2;
pub const BPF_RB_PROD_POS: ::aya_bpf_cty::c_uint = 3;
pub type _bindgen_ty_177 = ::aya_bpf_cty::c_uint;
pub const BPF_RINGBUF_BUSY_BIT: ::aya_bpf_cty::c_uint = 2147483648;
pub const BPF_RINGBUF_DISCARD_BIT: ::aya_bpf_cty::c_uint = 1073741824;
pub const BPF_RINGBUF_HDR_SZ: ::aya_bpf_cty::c_uint = 8;
pub type _bindgen_ty_178 = ::aya_bpf_cty::c_uint;
pub const BPF_LOCAL_STORAGE_GET_F_CREATE: ::aya_bpf_cty::c_uint = 1;
pub const BPF_SK_STORAGE_GET_F_CREATE: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_179 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_keys {
    pub nhoff: __u16,
    pub thoff: __u16,
    pub addr_proto: __u16,
    pub is_frag: __u8,
    pub is_first_frag: __u8,
    pub is_encap: __u8,
    pub ip_proto: __u8,
    pub n_proto: __be16,
    pub sport: __be16,
    pub dport: __be16,
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1,
    pub flags: __u32,
    pub flow_label: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_flow_keys__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_flow_keys__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
    pub ipv4_src: __be32,
    pub ipv4_dst: __be32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
    pub ipv6_src: [__u32; 4usize],
    pub ipv6_dst: [__u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_sock {
    pub bound_dev_if: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub mark: __u32,
    pub priority: __u32,
    pub src_ip4: __u32,
    pub src_ip6: [__u32; 4usize],
    pub src_port: __u32,
    pub dst_port: __u32,
    pub dst_ip4: __u32,
    pub dst_ip6: [__u32; 4usize],
    pub state: __u32,
    pub rx_queue_mapping: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sk_buff {
    pub len: __u32,
    pub pkt_type: __u32,
    pub mark: __u32,
    pub queue_mapping: __u32,
    pub protocol: __u32,
    pub vlan_present: __u32,
    pub vlan_tci: __u32,
    pub vlan_proto: __u32,
    pub priority: __u32,
    pub ingress_ifindex: __u32,
    pub ifindex: __u32,
    pub tc_index: __u32,
    pub cb: [__u32; 5usize],
    pub hash: __u32,
    pub tc_classid: __u32,
    pub data: __u32,
    pub data_end: __u32,
    pub napi_id: __u32,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub data_meta: __u32,
    pub __bindgen_anon_1: __sk_buff__bindgen_ty_1,
    pub tstamp: __u64,
    pub wire_len: __u32,
    pub gso_segs: __u32,
    pub __bindgen_anon_2: __sk_buff__bindgen_ty_2,
    pub gso_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_1 {
    pub flow_keys: *mut bpf_flow_keys,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_md {
    pub data: __u32,
    pub data_end: __u32,
    pub data_meta: __u32,
    pub ingress_ifindex: __u32,
    pub rx_queue_index: __u32,
    pub egress_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_msg_md {
    pub __bindgen_anon_1: sk_msg_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_msg_md__bindgen_ty_2,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub size: __u32,
    pub __bindgen_anon_3: sk_msg_md__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_1 {
    pub data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_2 {
    pub data_end: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_3 {
    pub sk: *mut bpf_sock,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_reuseport_md {
    pub __bindgen_anon_1: sk_reuseport_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_reuseport_md__bindgen_ty_2,
    pub len: __u32,
    pub eth_protocol: __u32,
    pub ip_protocol: __u32,
    pub bind_inany: __u32,
    pub hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_1 {
    pub data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_2 {
    pub data_end: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_addr {
    pub user_family: __u32,
    pub user_ip4: __u32,
    pub user_ip6: [__u32; 4usize],
    pub user_port: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub msg_src_ip4: __u32,
    pub msg_src_ip6: [__u32; 4usize],
    pub __bindgen_anon_1: bpf_sock_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_addr__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_ops {
    pub op: __u32,
    pub __bindgen_anon_1: bpf_sock_ops__bindgen_ty_1,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub is_fullsock: __u32,
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub bpf_sock_ops_cb_flags: __u32,
    pub state: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub sk_txhash: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub __bindgen_anon_2: bpf_sock_ops__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_sock_ops__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_sock_ops__bindgen_ty_4,
    pub skb_len: __u32,
    pub skb_tcp_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_1 {
    pub args: [__u32; 4usize],
    pub reply: __u32,
    pub replylong: [__u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_3 {
    pub skb_data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_4 {
    pub skb_data_end: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_sysctl {
    pub write: __u32,
    pub file_pos: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_listen_hashbucket {
    pub lock: spinlock_t,
    pub count: ::aya_bpf_cty::c_uint,
    pub __bindgen_anon_1: inet_listen_hashbucket__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_listen_hashbucket__bindgen_ty_1 {
    pub head: hlist_head,
    pub nulls_head: hlist_nulls_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_hashinfo {
    pub ehash: *mut inet_ehash_bucket,
    pub ehash_locks: *mut spinlock_t,
    pub ehash_mask: ::aya_bpf_cty::c_uint,
    pub ehash_locks_mask: ::aya_bpf_cty::c_uint,
    pub bind_bucket_cachep: *mut kmem_cache,
    pub bhash: *mut inet_bind_hashbucket,
    pub bhash_size: ::aya_bpf_cty::c_uint,
    pub lhash2_mask: ::aya_bpf_cty::c_uint,
    pub lhash2: *mut inet_listen_hashbucket,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub listening_hash: [inet_listen_hashbucket; 32usize],
}
impl inet_hashinfo {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_ra_chain {
    pub next: *mut ip_ra_chain,
    pub sk: *mut sock,
    pub __bindgen_anon_1: ip_ra_chain__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_ra_chain__bindgen_ty_1 {
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_sk: *mut sock,
}
#[repr(C)]
#[derive(Debug)]
pub struct fib_table {
    pub tb_hlist: hlist_node,
    pub tb_id: u32_,
    pub tb_num_default: ::aya_bpf_cty::c_int,
    pub rcu: callback_head,
    pub tb_data: *mut ::aya_bpf_cty::c_ulong,
    pub __data: __IncompleteArrayField<::aya_bpf_cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_peer_base {
    pub rb_root: rb_root,
    pub lock: seqlock_t,
    pub total: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_fastopen_context {
    pub key: [siphash_key_t; 2usize],
    pub num: ::aya_bpf_cty::c_int,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_txq_info {
    pub dev: *mut net_device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_buff {
    pub data: *mut ::aya_bpf_cty::c_void,
    pub data_end: *mut ::aya_bpf_cty::c_void,
    pub data_meta: *mut ::aya_bpf_cty::c_void,
    pub data_hard_start: *mut ::aya_bpf_cty::c_void,
    pub rxq: *mut xdp_rxq_info,
    pub txq: *mut xdp_txq_info,
    pub frame_sz: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct sock_reuseport {
    pub rcu: callback_head,
    pub max_socks: u16_,
    pub num_socks: u16_,
    pub synq_overflow_ts: ::aya_bpf_cty::c_uint,
    pub reuseport_id: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub prog: *mut bpf_prog,
    pub socks: __IncompleteArrayField<*mut sock>,
}
impl sock_reuseport {
    #[inline]
    pub fn bind_inany(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind_inany(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_conns(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_conns(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bind_inany: ::aya_bpf_cty::c_uint,
        has_conns: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bind_inany: u32 = unsafe { ::core::mem::transmute(bind_inany) };
            bind_inany as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_conns: u32 = unsafe { ::core::mem::transmute(has_conns) };
            has_conns as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_ehash_bucket {
    pub chain: hlist_nulls_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind_hashbucket {
    pub lock: spinlock_t,
    pub chain: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ack_sample {
    pub pkts_acked: u32_,
    pub rtt_us: s32,
    pub in_flight: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rate_sample {
    pub prior_mstamp: u64_,
    pub prior_delivered: u32_,
    pub delivered: s32,
    pub interval_us: ::aya_bpf_cty::c_long,
    pub snd_interval_us: u32_,
    pub rcv_interval_us: u32_,
    pub rtt_us: ::aya_bpf_cty::c_long,
    pub losses: ::aya_bpf_cty::c_int,
    pub acked_sacked: u32_,
    pub prior_in_flight: u32_,
    pub is_app_limited: bool_,
    pub is_retrans: bool_,
    pub is_ack_delayed: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_dev_bulk_queue {
    pub q: [*mut xdp_frame; 16usize],
    pub flush_node: list_head,
    pub dev: *mut net_device,
    pub dev_rx: *mut net_device,
    pub count: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_notifier_info {
    pub dev: *mut net_device,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_offload_ops {
    pub insn_hook: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub finalize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_verifier_env) -> ::aya_bpf_cty::c_int,
    >,
    pub replace_insn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: u32_,
            arg3: *mut bpf_insn,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub remove_insns: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf_cty::c_int>,
    pub translate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf_cty::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_offload_dev {
    pub ops: *const bpf_prog_offload_ops,
    pub netdevs: list_head,
    pub priv_: *mut ::aya_bpf_cty::c_void,
}
pub const BPF_F_SKIP_FIELD_MASK: ::aya_bpf_cty::c_uint = 255;
pub const BPF_F_USER_STACK: ::aya_bpf_cty::c_uint = 256;
pub const BPF_F_FAST_STACK_CMP: ::aya_bpf_cty::c_uint = 512;
pub const BPF_F_REUSE_STACKID: ::aya_bpf_cty::c_uint = 1024;
pub const BPF_F_USER_BUILD_ID: ::aya_bpf_cty::c_uint = 2048;
pub type _bindgen_ty_182 = ::aya_bpf_cty::c_uint;
pub const BPF_F_SYSCTL_BASE_NAME: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_183 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_sec_ctx {
    pub ctx_doi: __u8,
    pub ctx_alg: __u8,
    pub ctx_len: __u16,
    pub ctx_sid: __u32,
    pub ctx_str: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
pub const BPF_F_BPRM_SECUREEXEC: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_186 = ::aya_bpf_cty::c_uint;
#[repr(C)]
pub struct perf_buffer {
    pub refcount: refcount_t,
    pub callback_head: callback_head,
    pub nr_pages: ::aya_bpf_cty::c_int,
    pub overwrite: ::aya_bpf_cty::c_int,
    pub paused: ::aya_bpf_cty::c_int,
    pub poll: atomic_t,
    pub head: local_t,
    pub nest: ::aya_bpf_cty::c_uint,
    pub events: local_t,
    pub wakeup: local_t,
    pub lost: local_t,
    pub watermark: ::aya_bpf_cty::c_long,
    pub aux_watermark: ::aya_bpf_cty::c_long,
    pub event_lock: spinlock_t,
    pub event_list: list_head,
    pub mmap_count: atomic_t,
    pub mmap_locked: ::aya_bpf_cty::c_ulong,
    pub mmap_user: *mut user_struct,
    pub aux_head: ::aya_bpf_cty::c_long,
    pub aux_nest: ::aya_bpf_cty::c_uint,
    pub aux_wakeup: ::aya_bpf_cty::c_long,
    pub aux_pgoff: ::aya_bpf_cty::c_ulong,
    pub aux_nr_pages: ::aya_bpf_cty::c_int,
    pub aux_overwrite: ::aya_bpf_cty::c_int,
    pub aux_mmap_count: atomic_t,
    pub aux_mmap_locked: ::aya_bpf_cty::c_ulong,
    pub free_aux: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub aux_refcount: refcount_t,
    pub aux_in_sampling: ::aya_bpf_cty::c_int,
    pub aux_pages: *mut *mut ::aya_bpf_cty::c_void,
    pub aux_priv: *mut ::aya_bpf_cty::c_void,
    pub user_page: *mut perf_event_mmap_page,
    pub data_pages: __IncompleteArrayField<*mut ::aya_bpf_cty::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe {
    pub rb_node: rb_node,
    pub ref_: refcount_t,
    pub register_rwsem: rw_semaphore,
    pub consumer_rwsem: rw_semaphore,
    pub pending_list: list_head,
    pub consumers: *mut uprobe_consumer,
    pub inode: *mut inode,
    pub offset: loff_t,
    pub ref_ctr_offset: loff_t,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub arch: arch_uprobe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xol_area {
    pub wq: wait_queue_head_t,
    pub slot_count: atomic_t,
    pub bitmap: *mut ::aya_bpf_cty::c_ulong,
    pub xol_mapping: vm_special_mapping,
    pub pages: [*mut page; 2usize],
    pub vaddr: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capture_control {
    pub cc: *mut compact_control,
    pub page: *mut page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compact_control {
    pub freepages: list_head,
    pub migratepages: list_head,
    pub nr_freepages: ::aya_bpf_cty::c_uint,
    pub nr_migratepages: ::aya_bpf_cty::c_uint,
    pub free_pfn: ::aya_bpf_cty::c_ulong,
    pub migrate_pfn: ::aya_bpf_cty::c_ulong,
    pub fast_start_pfn: ::aya_bpf_cty::c_ulong,
    pub zone: *mut zone,
    pub total_migrate_scanned: ::aya_bpf_cty::c_ulong,
    pub total_free_scanned: ::aya_bpf_cty::c_ulong,
    pub fast_search_fail: ::aya_bpf_cty::c_ushort,
    pub search_order: ::aya_bpf_cty::c_short,
    pub gfp_mask: gfp_t,
    pub order: ::aya_bpf_cty::c_int,
    pub migratetype: ::aya_bpf_cty::c_int,
    pub alloc_flags: ::aya_bpf_cty::c_uint,
    pub highest_zoneidx: ::aya_bpf_cty::c_int,
    pub mode: migrate_mode::Type,
    pub ignore_skip_hint: bool_,
    pub no_set_skip_hint: bool_,
    pub ignore_block_suitable: bool_,
    pub direct_compaction: bool_,
    pub proactive_compaction: bool_,
    pub whole_zone: bool_,
    pub contended: bool_,
    pub rescan: bool_,
    pub alloc_contig: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_key_mod {
    pub next: *mut static_key_mod,
    pub entries: *mut jump_entry,
    pub mod_: *mut module,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_list {
    pub rcu: callback_head,
    pub watchers: hlist_head,
    pub release_watch: ::core::option::Option<unsafe extern "C" fn(arg1: *mut watch)>,
    pub lock: spinlock_t,
}
pub mod watch_notification_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const WATCH_TYPE_META: Type = 0;
    pub const WATCH_TYPE_KEY_NOTIFY: Type = 1;
    pub const WATCH_TYPE__NR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watch_type_filter {
    pub type_: watch_notification_type::Type,
    pub subtype_filter: [__u32; 1usize],
    pub info_filter: __u32,
    pub info_mask: __u32,
}
#[repr(C)]
pub struct watch_filter {
    pub __bindgen_anon_1: watch_filter__bindgen_ty_1,
    pub nr_filters: u32_,
    pub filters: __IncompleteArrayField<watch_type_filter>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union watch_filter__bindgen_ty_1 {
    pub rcu: callback_head,
    pub type_filter: [::aya_bpf_cty::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_queue {
    pub rcu: callback_head,
    pub filter: *mut watch_filter,
    pub pipe: *mut pipe_inode_info,
    pub watches: hlist_head,
    pub notes: *mut *mut page,
    pub notes_bitmap: *mut ::aya_bpf_cty::c_ulong,
    pub usage: kref,
    pub lock: spinlock_t,
    pub nr_notes: ::aya_bpf_cty::c_uint,
    pub nr_pages: ::aya_bpf_cty::c_uint,
    pub defunct: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch {
    pub __bindgen_anon_1: watch__bindgen_ty_1,
    pub queue: *mut watch_queue,
    pub queue_node: hlist_node,
    pub watch_list: *mut watch_list,
    pub list_node: hlist_node,
    pub cred: *const cred,
    pub private: *mut ::aya_bpf_cty::c_void,
    pub id: u64_,
    pub usage: kref,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union watch__bindgen_ty_1 {
    pub rcu: callback_head,
    pub info_id: u32_,
}
#[repr(C)]
pub struct fid {
    pub __bindgen_anon_1: fid__bindgen_ty_1,
}
#[repr(C)]
pub struct fid__bindgen_ty_1 {
    pub i32_: __BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_1>,
    pub udf: __BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_2>,
    pub raw: __BindgenUnionField<[__u32; 0usize]>,
    pub bindgen_union_field: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fid__bindgen_ty_1__bindgen_ty_1 {
    pub ino: u32_,
    pub gen: u32_,
    pub parent_ino: u32_,
    pub parent_gen: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fid__bindgen_ty_1__bindgen_ty_2 {
    pub block: u32_,
    pub partref: u16_,
    pub parent_partref: u16_,
    pub generation: u32_,
    pub parent_block: u32_,
    pub parent_generation: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reciprocal_value {
    pub m: u32_,
    pub sh1: u8_,
    pub sh2: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache_order_objects {
    pub x: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    pub cpu_slab: *mut kmem_cache_cpu,
    pub flags: slab_flags_t,
    pub min_partial: ::aya_bpf_cty::c_ulong,
    pub size: ::aya_bpf_cty::c_uint,
    pub object_size: ::aya_bpf_cty::c_uint,
    pub reciprocal_size: reciprocal_value,
    pub offset: ::aya_bpf_cty::c_uint,
    pub cpu_partial: ::aya_bpf_cty::c_uint,
    pub oo: kmem_cache_order_objects,
    pub max: kmem_cache_order_objects,
    pub min: kmem_cache_order_objects,
    pub allocflags: gfp_t,
    pub refcount: ::aya_bpf_cty::c_int,
    pub ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub inuse: ::aya_bpf_cty::c_uint,
    pub align: ::aya_bpf_cty::c_uint,
    pub red_left_pad: ::aya_bpf_cty::c_uint,
    pub name: *const ::aya_bpf_cty::c_char,
    pub list: list_head,
    pub kobj: kobject,
    pub random: ::aya_bpf_cty::c_ulong,
    pub remote_node_defrag_ratio: ::aya_bpf_cty::c_uint,
    pub random_seq: *mut ::aya_bpf_cty::c_uint,
    pub useroffset: ::aya_bpf_cty::c_uint,
    pub usersize: ::aya_bpf_cty::c_uint,
    pub node: [*mut kmem_cache_node; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache_cpu {
    pub freelist: *mut *mut ::aya_bpf_cty::c_void,
    pub tid: ::aya_bpf_cty::c_ulong,
    pub page: *mut page,
    pub partial: *mut page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache_node {
    pub list_lock: spinlock_t,
    pub nr_partial: ::aya_bpf_cty::c_ulong,
    pub partial: list_head,
    pub nr_slabs: atomic_long_t,
    pub total_objects: atomic_long_t,
    pub full: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct simple_xattrs {
    pub head: list_head,
    pub lock: spinlock_t,
}
pub type crypto_completion_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut crypto_async_request, arg2: ::aya_bpf_cty::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_async_request {
    pub list: list_head,
    pub complete: crypto_completion_t,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub tfm: *mut crypto_tfm,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    pub list: hlist_head,
    pub has_itree: bool_,
    pub lock: spinlock_t,
    pub invalidate_seq: ::aya_bpf_cty::c_ulong,
    pub active_invalidate_ranges: ::aya_bpf_cty::c_ulong,
    pub itree: rb_root_cached,
    pub wq: wait_queue_head_t,
    pub deferred_list: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v1 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub master_key_descriptor: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v2 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub __reserved: [__u8; 4usize],
    pub master_key_identifier: [__u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_policy {
    pub version: u8_,
    pub v1: fscrypt_policy_v1,
    pub v2: fscrypt_policy_v2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_namespace {
    pub ns: ns_common,
    pub root: *mut mount,
    pub list: list_head,
    pub ns_lock: spinlock_t,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub seq: u64_,
    pub poll: wait_queue_head_t,
    pub event: u64_,
    pub mounts: ::aya_bpf_cty::c_uint,
    pub pending_mounts: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mount {
    pub mnt_hash: hlist_node,
    pub mnt_parent: *mut mount,
    pub mnt_mountpoint: *mut dentry,
    pub mnt: vfsmount,
    pub __bindgen_anon_1: mount__bindgen_ty_1,
    pub mnt_pcp: *mut mnt_pcp,
    pub mnt_mounts: list_head,
    pub mnt_child: list_head,
    pub mnt_instance: list_head,
    pub mnt_devname: *const ::aya_bpf_cty::c_char,
    pub mnt_list: list_head,
    pub mnt_expire: list_head,
    pub mnt_share: list_head,
    pub mnt_slave_list: list_head,
    pub mnt_slave: list_head,
    pub mnt_master: *mut mount,
    pub mnt_ns: *mut mnt_namespace,
    pub mnt_mp: *mut mountpoint,
    pub __bindgen_anon_2: mount__bindgen_ty_2,
    pub mnt_umounting: list_head,
    pub mnt_fsnotify_marks: *mut fsnotify_mark_connector,
    pub mnt_fsnotify_mask: __u32,
    pub mnt_id: ::aya_bpf_cty::c_int,
    pub mnt_group_id: ::aya_bpf_cty::c_int,
    pub mnt_expiry_mark: ::aya_bpf_cty::c_int,
    pub mnt_pins: hlist_head,
    pub mnt_stuck_children: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mount__bindgen_ty_1 {
    pub mnt_rcu: callback_head,
    pub mnt_llist: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mount__bindgen_ty_2 {
    pub mnt_mp_list: hlist_node,
    pub mnt_umount: hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_pcp {
    pub mnt_count: ::aya_bpf_cty::c_int,
    pub mnt_writers: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mountpoint {
    pub m_hash: hlist_node,
    pub m_dentry: *mut dentry,
    pub m_list: hlist_head,
    pub m_count: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saved {
    pub link: path,
    pub done: delayed_call,
    pub name: *const ::aya_bpf_cty::c_char,
    pub seq: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameidata {
    pub path: path,
    pub last: qstr,
    pub root: path,
    pub inode: *mut inode,
    pub flags: ::aya_bpf_cty::c_uint,
    pub seq: ::aya_bpf_cty::c_uint,
    pub m_seq: ::aya_bpf_cty::c_uint,
    pub r_seq: ::aya_bpf_cty::c_uint,
    pub last_type: ::aya_bpf_cty::c_int,
    pub depth: ::aya_bpf_cty::c_uint,
    pub total_link_count: ::aya_bpf_cty::c_int,
    pub stack: *mut saved,
    pub internal: [saved; 2usize],
    pub name: *mut filename,
    pub saved: *mut nameidata,
    pub root_seq: ::aya_bpf_cty::c_uint,
    pub dfd: ::aya_bpf_cty::c_int,
    pub dir_uid: kuid_t,
    pub dir_mode: umode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    pub fi_flags: ::aya_bpf_cty::c_uint,
    pub fi_extents_mapped: ::aya_bpf_cty::c_uint,
    pub fi_extents_max: ::aya_bpf_cty::c_uint,
    pub fi_extents_start: *mut fiemap_extent,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent {
    pub fe_logical: __u64,
    pub fe_physical: __u64,
    pub fe_length: __u64,
    pub fe_reserved64: [__u64; 2usize],
    pub fe_flags: __u32,
    pub fe_reserved: [__u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unicode_map {
    pub charset: *const ::aya_bpf_cty::c_char,
    pub version: ::aya_bpf_cty::c_int,
}
pub type nlink_t = u32_;
pub type proc_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut ::aya_bpf_cty::c_char,
        arg3: size_t,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
pub struct proc_dir_entry {
    pub in_use: atomic_t,
    pub refcnt: refcount_t,
    pub pde_openers: list_head,
    pub pde_unload_lock: spinlock_t,
    pub pde_unload_completion: *mut completion,
    pub proc_iops: *const inode_operations,
    pub __bindgen_anon_1: proc_dir_entry__bindgen_ty_1,
    pub proc_dops: *const dentry_operations,
    pub __bindgen_anon_2: proc_dir_entry__bindgen_ty_2,
    pub write: proc_write_t,
    pub data: *mut ::aya_bpf_cty::c_void,
    pub state_size: ::aya_bpf_cty::c_uint,
    pub low_ino: ::aya_bpf_cty::c_uint,
    pub nlink: nlink_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub parent: *mut proc_dir_entry,
    pub subdir: rb_root,
    pub subdir_node: rb_node,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub mode: umode_t,
    pub flags: u8_,
    pub namelen: u8_,
    pub inline_name: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proc_dir_entry__bindgen_ty_1 {
    pub proc_ops: *const proc_ops,
    pub proc_dir_ops: *const file_operations,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proc_dir_entry__bindgen_ty_2 {
    pub seq_ops: *const seq_operations,
    pub single_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub mod userfaultfd_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const UFFD_STATE_WAIT_API: Type = 0;
    pub const UFFD_STATE_RUNNING: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct userfaultfd_ctx {
    pub fault_pending_wqh: wait_queue_head_t,
    pub fault_wqh: wait_queue_head_t,
    pub fd_wqh: wait_queue_head_t,
    pub event_wqh: wait_queue_head_t,
    pub refile_seq: seqcount_spinlock_t,
    pub refcount: refcount_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub features: ::aya_bpf_cty::c_uint,
    pub state: userfaultfd_state::Type,
    pub released: bool_,
    pub mmap_changing: bool_,
    pub mm: *mut mm_struct,
}
#[repr(C)]
#[derive(Debug)]
pub struct kioctx_table {
    pub rcu: callback_head,
    pub nr: ::aya_bpf_cty::c_uint,
    pub table: __IncompleteArrayField<*mut kioctx>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx {
    pub users: percpu_ref,
    pub dead: atomic_t,
    pub reqs: percpu_ref,
    pub user_id: ::aya_bpf_cty::c_ulong,
    pub cpu: *mut kioctx_cpu,
    pub req_batch: ::aya_bpf_cty::c_uint,
    pub max_reqs: ::aya_bpf_cty::c_uint,
    pub nr_events: ::aya_bpf_cty::c_uint,
    pub mmap_base: ::aya_bpf_cty::c_ulong,
    pub mmap_size: ::aya_bpf_cty::c_ulong,
    pub ring_pages: *mut *mut page,
    pub nr_pages: ::aya_bpf_cty::c_long,
    pub free_rwork: rcu_work,
    pub rq_wait: *mut ctx_rq_wait,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub __bindgen_anon_1: kioctx__bindgen_ty_1,
    pub __bindgen_anon_2: kioctx__bindgen_ty_2,
    pub __bindgen_anon_3: kioctx__bindgen_ty_3,
    pub __bindgen_anon_4: kioctx__bindgen_ty_4,
    pub internal_pages: [*mut page; 8usize],
    pub aio_ring_file: *mut file,
    pub id: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_1 {
    pub reqs_available: atomic_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 64usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_2 {
    pub ctx_lock: spinlock_t,
    pub active_reqs: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_3 {
    pub ring_lock: mutex,
    pub wait: wait_queue_head_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl kioctx__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_4 {
    pub tail: ::aya_bpf_cty::c_uint,
    pub completed_events: ::aya_bpf_cty::c_uint,
    pub completion_lock: spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
}
impl kioctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_cpu {
    pub reqs_available: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctx_rq_wait {
    pub comp: completion,
    pub count: atomic_t,
}
pub type __le64 = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_prepared_key {
    pub tfm: *mut crypto_skcipher,
    pub blk_key: *mut fscrypt_blk_crypto_key,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_info {
    pub ci_enc_key: fscrypt_prepared_key,
    pub ci_owns_key: bool_,
    pub ci_inlinecrypt: bool_,
    pub ci_mode: *mut fscrypt_mode,
    pub ci_inode: *mut inode,
    pub ci_master_key: *mut key,
    pub ci_master_key_link: list_head,
    pub ci_direct_key: *mut fscrypt_direct_key,
    pub ci_dirhash_key: siphash_key_t,
    pub ci_dirhash_key_initialized: bool_,
    pub ci_policy: fscrypt_policy,
    pub ci_nonce: [u8_; 16usize],
    pub ci_hashed_ino: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_skcipher {
    pub reqsize: ::aya_bpf_cty::c_uint,
    pub base: crypto_tfm,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_mode {
    pub friendly_name: *const ::aya_bpf_cty::c_char,
    pub cipher_str: *const ::aya_bpf_cty::c_char,
    pub keysize: ::aya_bpf_cty::c_int,
    pub ivsize: ::aya_bpf_cty::c_int,
    pub logged_impl_name: ::aya_bpf_cty::c_int,
    pub blk_crypto_mode: blk_crypto_mode_num::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_direct_key {
    pub dk_node: hlist_node,
    pub dk_refcount: refcount_t,
    pub dk_mode: *const fscrypt_mode,
    pub dk_key: fscrypt_prepared_key,
    pub dk_descriptor: [u8_; 8usize],
    pub dk_raw: [u8_; 64usize],
}
#[repr(C)]
pub struct fscrypt_blk_crypto_key {
    pub base: blk_crypto_key,
    pub num_devs: ::aya_bpf_cty::c_int,
    pub devs: __IncompleteArrayField<*mut request_queue>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct merkle_tree_params {
    pub hash_alg: *mut fsverity_hash_alg,
    pub hashstate: *const u8_,
    pub digest_size: ::aya_bpf_cty::c_uint,
    pub block_size: ::aya_bpf_cty::c_uint,
    pub hashes_per_block: ::aya_bpf_cty::c_uint,
    pub log_blocksize: ::aya_bpf_cty::c_uint,
    pub log_arity: ::aya_bpf_cty::c_uint,
    pub num_levels: ::aya_bpf_cty::c_uint,
    pub tree_size: u64_,
    pub level0_blocks: ::aya_bpf_cty::c_ulong,
    pub level_start: [u64_; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_info {
    pub tree_params: merkle_tree_params,
    pub root_hash: [u8_; 64usize],
    pub file_digest: [u8_; 64usize],
    pub inode: *const inode,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_hash_alg {
    pub tfm: *mut crypto_ahash,
    pub name: *const ::aya_bpf_cty::c_char,
    pub digest_size: ::aya_bpf_cty::c_uint,
    pub block_size: ::aya_bpf_cty::c_uint,
    pub req_pool: mempool_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_ahash {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
    >,
    pub final_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
    >,
    pub finup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
    >,
    pub digest: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
    >,
    pub export: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ahash_request,
            arg2: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub import: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ahash_request,
            arg2: *const ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub setkey: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_ahash,
            arg2: *const u8_,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reqsize: ::aya_bpf_cty::c_uint,
    pub base: crypto_tfm,
}
#[repr(C)]
#[derive(Debug)]
pub struct ahash_request {
    pub base: crypto_async_request,
    pub nbytes: ::aya_bpf_cty::c_uint,
    pub src: *mut scatterlist,
    pub result: *mut u8_,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub __ctx: __IncompleteArrayField<*mut ::aya_bpf_cty::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub xattrs: simple_xattrs,
    pub nr_user_xattrs: atomic_t,
    pub user_xattr_size: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    pub refcnt: atomic_t,
    pub event: atomic_t,
    pub poll: wait_queue_head_t,
    pub files: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sem_undo_list {
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub list_proc: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_user {
    pub node: rb_node,
    pub cons_lock: mutex,
    pub lock: spinlock_t,
    pub usage: refcount_t,
    pub nkeys: atomic_t,
    pub nikeys: atomic_t,
    pub uid: kuid_t,
    pub qnkeys: ::aya_bpf_cty::c_int,
    pub qnbytes: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [::aya_bpf_cty::c_uchar; 6usize],
    pub h_source: [::aya_bpf_cty::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [::aya_bpf_cty::c_char; 32usize],
    pub version: [::aya_bpf_cty::c_char; 32usize],
    pub fw_version: [::aya_bpf_cty::c_char; 32usize],
    pub bus_info: [::aya_bpf_cty::c_char; 32usize],
    pub erom_version: [::aya_bpf_cty::c_char; 32usize],
    pub reserved2: [::aya_bpf_cty::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut ::aya_bpf_cty::c_void>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
pub mod ethtool_link_ext_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_STATE_AUTONEG: Type = 0;
    pub const ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE: Type = 1;
    pub const ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH: Type = 2;
    pub const ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY: Type = 3;
    pub const ETHTOOL_LINK_EXT_STATE_NO_CABLE: Type = 4;
    pub const ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE: Type = 5;
    pub const ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE: Type = 6;
    pub const ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE: Type = 7;
    pub const ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED: Type = 8;
    pub const ETHTOOL_LINK_EXT_STATE_OVERHEAT: Type = 9;
}
pub mod ethtool_link_ext_substate_autoneg {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE: Type = 4;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE: Type = 5;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD: Type = 6;
}
pub mod ethtool_link_ext_substate_link_training {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT: Type = 4;
}
pub mod ethtool_link_ext_substate_link_logical_mismatch {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED: Type = 4;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED: Type = 5;
}
pub mod ethtool_link_ext_substate_bad_signal_integrity {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE: Type = 2;
}
pub mod ethtool_link_ext_substate_cable_issue {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE: Type = 2;
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [::aya_bpf_cty::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [::aya_bpf_cty::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub master_slave_cfg: __u8,
    pub master_slave_state: __u8,
    pub reserved1: [__u8; 1usize],
    pub reserved: [__u32; 7usize],
    pub link_mode_masks: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_link_ext_state_info {
    pub link_ext_state: ethtool_link_ext_state::Type,
    pub __bindgen_anon_1: ethtool_link_ext_state_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_link_ext_state_info__bindgen_ty_1 {
    pub autoneg: ethtool_link_ext_substate_autoneg::Type,
    pub link_training: ethtool_link_ext_substate_link_training::Type,
    pub link_logical_mismatch: ethtool_link_ext_substate_link_logical_mismatch::Type,
    pub bad_signal_integrity: ethtool_link_ext_substate_bad_signal_integrity::Type,
    pub cable_issue: ethtool_link_ext_substate_cable_issue::Type,
    pub __link_ext_substate: u8_,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_link_ksettings {
    pub base: ethtool_link_settings,
    pub link_modes: ethtool_link_ksettings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_link_ksettings__bindgen_ty_1 {
    pub supported: [::aya_bpf_cty::c_ulong; 2usize],
    pub advertising: [::aya_bpf_cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf_cty::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_pause_stats {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
pub type __sum16 = __u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: __be32,
}
pub type nf_hookfn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf_cty::c_void,
        arg2: *mut sk_buff,
        arg3: *const nf_hook_state,
    ) -> ::aya_bpf_cty::c_uint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_entry {
    pub hook: nf_hookfn,
    pub priv_: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct nf_hook_entries {
    pub num_hook_entries: u16_,
    pub hooks: __IncompleteArrayField<nf_hook_entry>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_state {
    pub hook: ::aya_bpf_cty::c_uint,
    pub pf: u_int8_t,
    pub in_: *mut net_device,
    pub out: *mut net_device,
    pub sk: *mut sock,
    pub net: *mut net,
    pub okfn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct ip_options {
    pub faddr: __be32,
    pub nexthop: __be32,
    pub optlen: ::aya_bpf_cty::c_uchar,
    pub srr: ::aya_bpf_cty::c_uchar,
    pub rr: ::aya_bpf_cty::c_uchar,
    pub ts: ::aya_bpf_cty::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub router_alert: ::aya_bpf_cty::c_uchar,
    pub cipso: ::aya_bpf_cty::c_uchar,
    pub __pad2: ::aya_bpf_cty::c_uchar,
    pub __data: __IncompleteArrayField<::aya_bpf_cty::c_uchar>,
}
impl ip_options {
    #[inline]
    pub fn is_strictroute(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_strictroute(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn srr_is_hit(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_srr_is_hit(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_changed(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_changed(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rr_needaddr(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rr_needaddr(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_needtime(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ts_needtime(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_needaddr(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ts_needaddr(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_strictroute: ::aya_bpf_cty::c_uchar,
        srr_is_hit: ::aya_bpf_cty::c_uchar,
        is_changed: ::aya_bpf_cty::c_uchar,
        rr_needaddr: ::aya_bpf_cty::c_uchar,
        ts_needtime: ::aya_bpf_cty::c_uchar,
        ts_needaddr: ::aya_bpf_cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_strictroute: u8 = unsafe { ::core::mem::transmute(is_strictroute) };
            is_strictroute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let srr_is_hit: u8 = unsafe { ::core::mem::transmute(srr_is_hit) };
            srr_is_hit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_changed: u8 = unsafe { ::core::mem::transmute(is_changed) };
            is_changed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rr_needaddr: u8 = unsafe { ::core::mem::transmute(rr_needaddr) };
            rr_needaddr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ts_needtime: u8 = unsafe { ::core::mem::transmute(ts_needtime) };
            ts_needtime as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ts_needaddr: u8 = unsafe { ::core::mem::transmute(ts_needaddr) };
            ts_needaddr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ip_options_rcu {
    pub rcu: callback_head,
    pub opt: ip_options,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_txoptions {
    pub refcnt: refcount_t,
    pub tot_len: ::aya_bpf_cty::c_int,
    pub opt_flen: __u16,
    pub opt_nflen: __u16,
    pub hopopt: *mut ipv6_opt_hdr,
    pub dst0opt: *mut ipv6_opt_hdr,
    pub srcrt: *mut ipv6_rt_hdr,
    pub dst1opt: *mut ipv6_opt_hdr,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_cork {
    pub flags: ::aya_bpf_cty::c_uint,
    pub addr: __be32,
    pub opt: *mut ip_options,
    pub fragsize: ::aya_bpf_cty::c_uint,
    pub length: ::aya_bpf_cty::c_int,
    pub dst: *mut dst_entry,
    pub tx_flags: u8_,
    pub ttl: __u8,
    pub tos: __s16,
    pub priority: ::aya_bpf_cty::c_char,
    pub gso_size: __u16,
    pub transmit_time: u64_,
    pub mark: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_cork_full {
    pub base: inet_cork,
    pub fl: flowi,
}
#[repr(C)]
pub struct inet_sock {
    pub sk: sock,
    pub pinet6: *mut ipv6_pinfo,
    pub inet_saddr: __be32,
    pub uc_ttl: __s16,
    pub cmsg_flags: __u16,
    pub inet_sport: __be16,
    pub inet_id: __u16,
    pub inet_opt: *mut ip_options_rcu,
    pub rx_dst_ifindex: ::aya_bpf_cty::c_int,
    pub tos: __u8,
    pub min_ttl: __u8,
    pub mc_ttl: __u8,
    pub pmtudisc: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub rcv_tos: __u8,
    pub convert_csum: __u8,
    pub uc_index: ::aya_bpf_cty::c_int,
    pub mc_index: ::aya_bpf_cty::c_int,
    pub mc_addr: __be32,
    pub mc_list: *mut ip_mc_socklist,
    pub cork: inet_cork_full,
}
impl inet_sock {
    #[inline]
    pub fn recverr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recverr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_icsk(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_icsk(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn freebind(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_freebind(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdrincl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hdrincl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_loop(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mc_loop(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_all(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mc_all(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nodefrag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nodefrag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bind_address_no_port(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bind_address_no_port(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recverr_rfc4884(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recverr_rfc4884(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defer_connect(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_defer_connect(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        recverr: __u8,
        is_icsk: __u8,
        freebind: __u8,
        hdrincl: __u8,
        mc_loop: __u8,
        transparent: __u8,
        mc_all: __u8,
        nodefrag: __u8,
        bind_address_no_port: __u8,
        recverr_rfc4884: __u8,
        defer_connect: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recverr: u8 = unsafe { ::core::mem::transmute(recverr) };
            recverr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_icsk: u8 = unsafe { ::core::mem::transmute(is_icsk) };
            is_icsk as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let freebind: u8 = unsafe { ::core::mem::transmute(freebind) };
            freebind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hdrincl: u8 = unsafe { ::core::mem::transmute(hdrincl) };
            hdrincl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mc_loop: u8 = unsafe { ::core::mem::transmute(mc_loop) };
            mc_loop as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transparent: u8 = unsafe { ::core::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mc_all: u8 = unsafe { ::core::mem::transmute(mc_all) };
            mc_all as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nodefrag: u8 = unsafe { ::core::mem::transmute(nodefrag) };
            nodefrag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bind_address_no_port: u8 = unsafe { ::core::mem::transmute(bind_address_no_port) };
            bind_address_no_port as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let recverr_rfc4884: u8 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
            recverr_rfc4884 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let defer_connect: u8 = unsafe { ::core::mem::transmute(defer_connect) };
            defer_connect as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet6_cork {
    pub opt: *mut ipv6_txoptions,
    pub hop_limit: u8_,
    pub tclass: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_pinfo {
    pub saddr: in6_addr,
    pub sticky_pktinfo: in6_pktinfo,
    pub daddr_cache: *const in6_addr,
    pub saddr_cache: *const in6_addr,
    pub flow_label: __be32,
    pub frag_size: __u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ucast_oif: ::aya_bpf_cty::c_int,
    pub mcast_oif: ::aya_bpf_cty::c_int,
    pub rxopt: ipv6_pinfo__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub min_hopcount: __u8,
    pub tclass: __u8,
    pub rcv_flowinfo: __be32,
    pub dst_cookie: __u32,
    pub rx_dst_cookie: __u32,
    pub ipv6_mc_list: *mut ipv6_mc_socklist,
    pub ipv6_ac_list: *mut ipv6_ac_socklist,
    pub ipv6_fl_list: *mut ipv6_fl_socklist,
    pub opt: *mut ipv6_txoptions,
    pub pktoptions: *mut sk_buff,
    pub rxpmtu: *mut sk_buff,
    pub cork: inet6_cork,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ipv6_pinfo__bindgen_ty_1 {
    pub bits: ipv6_pinfo__bindgen_ty_1__bindgen_ty_1,
    pub all: __u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn srcrt(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_srcrt(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn osrcrt(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_osrcrt(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxinfo(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxinfo(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxoinfo(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxoinfo(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxhlim(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxhlim(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxohlim(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxohlim(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hopopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hopopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ohopopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ohopopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dstopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dstopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn odstopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_odstopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxtclass(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxtclass(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxpmtu(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxpmtu(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxorigdstaddr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxorigdstaddr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recvfragsize(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recvfragsize(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        srcrt: __u16,
        osrcrt: __u16,
        rxinfo: __u16,
        rxoinfo: __u16,
        rxhlim: __u16,
        rxohlim: __u16,
        hopopts: __u16,
        ohopopts: __u16,
        dstopts: __u16,
        odstopts: __u16,
        rxflow: __u16,
        rxtclass: __u16,
        rxpmtu: __u16,
        rxorigdstaddr: __u16,
        recvfragsize: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let srcrt: u16 = unsafe { ::core::mem::transmute(srcrt) };
            srcrt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let osrcrt: u16 = unsafe { ::core::mem::transmute(osrcrt) };
            osrcrt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rxinfo: u16 = unsafe { ::core::mem::transmute(rxinfo) };
            rxinfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rxoinfo: u16 = unsafe { ::core::mem::transmute(rxoinfo) };
            rxoinfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxhlim: u16 = unsafe { ::core::mem::transmute(rxhlim) };
            rxhlim as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rxohlim: u16 = unsafe { ::core::mem::transmute(rxohlim) };
            rxohlim as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hopopts: u16 = unsafe { ::core::mem::transmute(hopopts) };
            hopopts as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ohopopts: u16 = unsafe { ::core::mem::transmute(ohopopts) };
            ohopopts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dstopts: u16 = unsafe { ::core::mem::transmute(dstopts) };
            dstopts as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let odstopts: u16 = unsafe { ::core::mem::transmute(odstopts) };
            odstopts as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rxflow: u16 = unsafe { ::core::mem::transmute(rxflow) };
            rxflow as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rxtclass: u16 = unsafe { ::core::mem::transmute(rxtclass) };
            rxtclass as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rxpmtu: u16 = unsafe { ::core::mem::transmute(rxpmtu) };
            rxpmtu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rxorigdstaddr: u16 = unsafe { ::core::mem::transmute(rxorigdstaddr) };
            rxorigdstaddr as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let recvfragsize: u16 = unsafe { ::core::mem::transmute(recvfragsize) };
            recvfragsize as u64
        });
        __bindgen_bitfield_unit
    }
}
impl ipv6_pinfo {
    #[inline]
    pub fn __unused_1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set___unused_1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn hop_limit(&self) -> __s16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_hop_limit(&mut self, val: __s16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_loop(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mc_loop(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __unused_2(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set___unused_2(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mcast_hops(&self) -> __s16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_mcast_hops(&mut self, val: __s16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __unused_1: __u16,
        hop_limit: __s16,
        mc_loop: __u16,
        __unused_2: __u16,
        mcast_hops: __s16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __unused_1: u16 = unsafe { ::core::mem::transmute(__unused_1) };
            __unused_1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let hop_limit: u16 = unsafe { ::core::mem::transmute(hop_limit) };
            hop_limit as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mc_loop: u16 = unsafe { ::core::mem::transmute(mc_loop) };
            mc_loop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let __unused_2: u16 = unsafe { ::core::mem::transmute(__unused_2) };
            __unused_2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let mcast_hops: u16 = unsafe { ::core::mem::transmute(mcast_hops) };
            mcast_hops as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn recverr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recverr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sndflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sndflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_repflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmtudisc(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_pmtudisc(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn srcprefs(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_srcprefs(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dontfrag(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dontfrag(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoflowlabel(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_autoflowlabel(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoflowlabel_set(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_autoflowlabel_set(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_all(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mc_all(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recverr_rfc4884(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recverr_rfc4884(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtalert_isolate(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rtalert_isolate(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        recverr: __u16,
        sndflow: __u16,
        repflow: __u16,
        pmtudisc: __u16,
        padding: __u16,
        srcprefs: __u16,
        dontfrag: __u16,
        autoflowlabel: __u16,
        autoflowlabel_set: __u16,
        mc_all: __u16,
        recverr_rfc4884: __u16,
        rtalert_isolate: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recverr: u16 = unsafe { ::core::mem::transmute(recverr) };
            recverr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sndflow: u16 = unsafe { ::core::mem::transmute(sndflow) };
            sndflow as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let repflow: u16 = unsafe { ::core::mem::transmute(repflow) };
            repflow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let pmtudisc: u16 = unsafe { ::core::mem::transmute(pmtudisc) };
            pmtudisc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let padding: u16 = unsafe { ::core::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let srcprefs: u16 = unsafe { ::core::mem::transmute(srcprefs) };
            srcprefs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dontfrag: u16 = unsafe { ::core::mem::transmute(dontfrag) };
            dontfrag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let autoflowlabel: u16 = unsafe { ::core::mem::transmute(autoflowlabel) };
            autoflowlabel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let autoflowlabel_set: u16 = unsafe { ::core::mem::transmute(autoflowlabel_set) };
            autoflowlabel_set as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mc_all: u16 = unsafe { ::core::mem::transmute(mc_all) };
            mc_all as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let recverr_rfc4884: u16 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
            recverr_rfc4884 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtalert_isolate: u16 = unsafe { ::core::mem::transmute(rtalert_isolate) };
            rtalert_isolate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr {
    pub source: __be16,
    pub dest: __be16,
    pub seq: __be32,
    pub ack_seq: __be32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: __be16,
    pub check: __sum16,
    pub urg_ptr: __be16,
}
impl tcphdr {
    #[inline]
    pub fn res1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ece(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cwr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: __u16,
        doff: __u16,
        fin: __u16,
        syn: __u16,
        rst: __u16,
        psh: __u16,
        ack: __u16,
        urg: __u16,
        ece: __u16,
        cwr: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::core::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: __u8,
    pub tot_len: __be16,
    pub id: __be16,
    pub frag_off: __be16,
    pub ttl: __u8,
    pub protocol: __u8,
    pub check: __sum16,
    pub saddr: __be32,
    pub daddr: __be32,
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_rt_hdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
    pub type_: __u8,
    pub segments_left: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_opt_hdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mc_socklist {
    pub addr: in6_addr,
    pub ifindex: ::aya_bpf_cty::c_int,
    pub sfmode: ::aya_bpf_cty::c_uint,
    pub next: *mut ipv6_mc_socklist,
    pub sflock: rwlock_t,
    pub sflist: *mut ip6_sf_socklist,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_ac_socklist {
    pub acl_addr: in6_addr,
    pub acl_ifindex: ::aya_bpf_cty::c_int,
    pub acl_next: *mut ipv6_ac_socklist,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_fl_socklist {
    pub next: *mut ipv6_fl_socklist,
    pub fl: *mut ip6_flowlabel,
    pub rcu: callback_head,
}
#[repr(C)]
pub struct ip6_sf_socklist {
    pub sl_max: ::aya_bpf_cty::c_uint,
    pub sl_count: ::aya_bpf_cty::c_uint,
    pub sl_addr: __IncompleteArrayField<in6_addr>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_flowlabel {
    pub next: *mut ip6_flowlabel,
    pub label: __be32,
    pub users: atomic_t,
    pub dst: in6_addr,
    pub opt: *mut ipv6_txoptions,
    pub linger: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
    pub share: u8_,
    pub owner: ip6_flowlabel__bindgen_ty_1,
    pub lastuse: ::aya_bpf_cty::c_ulong,
    pub expires: ::aya_bpf_cty::c_ulong,
    pub fl_net: *mut net,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip6_flowlabel__bindgen_ty_1 {
    pub pid: *mut pid,
    pub uid: kuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt6key {
    pub addr: in6_addr,
    pub plen: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh_common {
    pub nhc_dev: *mut net_device,
    pub nhc_oif: ::aya_bpf_cty::c_int,
    pub nhc_scope: ::aya_bpf_cty::c_uchar,
    pub nhc_family: u8_,
    pub nhc_gw_family: u8_,
    pub nhc_flags: ::aya_bpf_cty::c_uchar,
    pub nhc_lwtstate: *mut lwtunnel_state,
    pub nhc_gw: fib_nh_common__bindgen_ty_1,
    pub nhc_weight: ::aya_bpf_cty::c_int,
    pub nhc_upper_bound: atomic_t,
    pub nhc_pcpu_rth_output: *mut *mut rtable,
    pub nhc_rth_input: *mut rtable,
    pub nhc_exceptions: *mut fnhe_hash_bucket,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib_nh_common__bindgen_ty_1 {
    pub ipv4: __be32,
    pub ipv6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_nh {
    pub nh_common: fib_nh_common,
    pub last_probe: ::aya_bpf_cty::c_ulong,
    pub rt6i_pcpu: *mut *mut rt6_info,
    pub rt6i_exception_bucket: *mut rt6_exception_bucket,
}
#[repr(C)]
pub struct fib6_info {
    pub fib6_table: *mut fib6_table,
    pub fib6_next: *mut fib6_info,
    pub fib6_node: *mut fib6_node,
    pub __bindgen_anon_1: fib6_info__bindgen_ty_1,
    pub fib6_nsiblings: ::aya_bpf_cty::c_uint,
    pub fib6_ref: refcount_t,
    pub expires: ::aya_bpf_cty::c_ulong,
    pub fib6_metrics: *mut dst_metrics,
    pub fib6_dst: rt6key,
    pub fib6_flags: u32_,
    pub fib6_src: rt6key,
    pub fib6_prefsrc: rt6key,
    pub fib6_metric: u32_,
    pub fib6_protocol: u8_,
    pub fib6_type: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub nh: *mut nexthop,
    pub fib6_nh: __IncompleteArrayField<fib6_nh>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib6_info__bindgen_ty_1 {
    pub fib6_siblings: list_head,
    pub nh_list: list_head,
}
impl fib6_info {
    #[inline]
    pub fn should_flush(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_should_flush(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_nocount(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_nocount(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_nopolicy(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_nopolicy(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fib6_destroying(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fib6_destroying(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        should_flush: u8_,
        dst_nocount: u8_,
        dst_nopolicy: u8_,
        fib6_destroying: u8_,
        offload: u8_,
        trap: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let should_flush: u8 = unsafe { ::core::mem::transmute(should_flush) };
            should_flush as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dst_nocount: u8 = unsafe { ::core::mem::transmute(dst_nocount) };
            dst_nocount as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dst_nopolicy: u8 = unsafe { ::core::mem::transmute(dst_nopolicy) };
            dst_nopolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fib6_destroying: u8 = unsafe { ::core::mem::transmute(fib6_destroying) };
            fib6_destroying as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let offload: u8 = unsafe { ::core::mem::transmute(offload) };
            offload as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let trap: u8 = unsafe { ::core::mem::transmute(trap) };
            trap as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt6_info {
    pub dst: dst_entry,
    pub from: *mut fib6_info,
    pub sernum: ::aya_bpf_cty::c_int,
    pub rt6i_dst: rt6key,
    pub rt6i_src: rt6key,
    pub rt6i_gateway: in6_addr,
    pub rt6i_idev: *mut inet6_dev,
    pub rt6i_flags: u32_,
    pub rt6i_uncached: list_head,
    pub rt6i_uncached_list: *mut uncached_list,
    pub rt6i_nfheader_len: ::aya_bpf_cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt6_statistics {
    pub fib_nodes: __u32,
    pub fib_route_nodes: __u32,
    pub fib_rt_entries: __u32,
    pub fib_rt_cache: __u32,
    pub fib_discarded_routes: __u32,
    pub fib_rt_alloc: atomic_t,
    pub fib_rt_uncache: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib6_node {
    pub parent: *mut fib6_node,
    pub left: *mut fib6_node,
    pub right: *mut fib6_node,
    pub subtree: *mut fib6_node,
    pub leaf: *mut fib6_info,
    pub fn_bit: __u16,
    pub fn_flags: __u16,
    pub fn_sernum: ::aya_bpf_cty::c_int,
    pub rr_ptr: *mut fib6_info,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_table {
    pub tb6_hlist: hlist_node,
    pub tb6_id: u32_,
    pub tb6_lock: spinlock_t,
    pub tb6_root: fib6_node,
    pub tb6_peers: inet_peer_base,
    pub flags: ::aya_bpf_cty::c_uint,
    pub fib_seq: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xfrm_address_t {
    pub a4: __be32,
    pub a6: [__be32; 4usize],
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_id {
    pub daddr: xfrm_address_t,
    pub spi: __be32,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_selector {
    pub daddr: xfrm_address_t,
    pub saddr: xfrm_address_t,
    pub dport: __be16,
    pub dport_mask: __be16,
    pub sport: __be16,
    pub sport_mask: __be16,
    pub family: __u16,
    pub prefixlen_d: __u8,
    pub prefixlen_s: __u8,
    pub proto: __u8,
    pub ifindex: ::aya_bpf_cty::c_int,
    pub user: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_lifetime_cfg {
    pub soft_byte_limit: __u64,
    pub hard_byte_limit: __u64,
    pub soft_packet_limit: __u64,
    pub hard_packet_limit: __u64,
    pub soft_add_expires_seconds: __u64,
    pub hard_add_expires_seconds: __u64,
    pub soft_use_expires_seconds: __u64,
    pub hard_use_expires_seconds: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_lifetime_cur {
    pub bytes: __u64,
    pub packets: __u64,
    pub add_time: __u64,
    pub use_time: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_replay_state {
    pub oseq: __u32,
    pub seq: __u32,
    pub bitmap: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_replay_state_esn {
    pub bmp_len: ::aya_bpf_cty::c_uint,
    pub oseq: __u32,
    pub seq: __u32,
    pub oseq_hi: __u32,
    pub seq_hi: __u32,
    pub replay_window: __u32,
    pub bmp: __IncompleteArrayField<__u32>,
}
#[repr(C)]
pub struct xfrm_algo {
    pub alg_name: [::aya_bpf_cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf_cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
pub struct xfrm_algo_auth {
    pub alg_name: [::aya_bpf_cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf_cty::c_uint,
    pub alg_trunc_len: ::aya_bpf_cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
pub struct xfrm_algo_aead {
    pub alg_name: [::aya_bpf_cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf_cty::c_uint,
    pub alg_icv_len: ::aya_bpf_cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_stats {
    pub replay_window: __u32,
    pub replay: __u32,
    pub integrity_failed: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_encap_tmpl {
    pub encap_type: __u16,
    pub encap_sport: __be16,
    pub encap_dport: __be16,
    pub encap_oa: xfrm_address_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_mark {
    pub v: __u32,
    pub m: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_address_filter {
    pub saddr: xfrm_address_t,
    pub daddr: xfrm_address_t,
    pub family: __u16,
    pub splen: __u8,
    pub dplen: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_state_walk {
    pub all: list_head,
    pub state: u8_,
    pub dying: u8_,
    pub proto: u8_,
    pub seq: u32_,
    pub filter: *mut xfrm_address_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_state_offload {
    pub dev: *mut net_device,
    pub real_dev: *mut net_device,
    pub offload_handle: ::aya_bpf_cty::c_ulong,
    pub num_exthdrs: ::aya_bpf_cty::c_uint,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_mode {
    pub encap: u8_,
    pub family: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state {
    pub xs_net: possible_net_t,
    pub __bindgen_anon_1: xfrm_state__bindgen_ty_1,
    pub bysrc: hlist_node,
    pub byspi: hlist_node,
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub id: xfrm_id,
    pub sel: xfrm_selector,
    pub mark: xfrm_mark,
    pub if_id: u32_,
    pub tfcpad: u32_,
    pub genid: u32_,
    pub km: xfrm_state_walk,
    pub props: xfrm_state__bindgen_ty_2,
    pub lft: xfrm_lifetime_cfg,
    pub aalg: *mut xfrm_algo_auth,
    pub ealg: *mut xfrm_algo,
    pub calg: *mut xfrm_algo,
    pub aead: *mut xfrm_algo_aead,
    pub geniv: *const ::aya_bpf_cty::c_char,
    pub encap: *mut xfrm_encap_tmpl,
    pub encap_sk: *mut sock,
    pub coaddr: *mut xfrm_address_t,
    pub tunnel: *mut xfrm_state,
    pub tunnel_users: atomic_t,
    pub replay: xfrm_replay_state,
    pub replay_esn: *mut xfrm_replay_state_esn,
    pub preplay: xfrm_replay_state,
    pub preplay_esn: *mut xfrm_replay_state_esn,
    pub repl: *const xfrm_replay,
    pub xflags: u32_,
    pub replay_maxage: u32_,
    pub replay_maxdiff: u32_,
    pub rtimer: timer_list,
    pub stats: xfrm_stats,
    pub curlft: xfrm_lifetime_cur,
    pub mtimer: hrtimer,
    pub xso: xfrm_state_offload,
    pub saved_tmo: ::aya_bpf_cty::c_long,
    pub lastused: time64_t,
    pub xfrag: page_frag,
    pub type_: *const xfrm_type,
    pub inner_mode: xfrm_mode,
    pub inner_mode_iaf: xfrm_mode,
    pub outer_mode: xfrm_mode,
    pub type_offload: *const xfrm_type_offload,
    pub security: *mut xfrm_sec_ctx,
    pub data: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xfrm_state__bindgen_ty_1 {
    pub gclist: hlist_node,
    pub bydst: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state__bindgen_ty_2 {
    pub reqid: u32_,
    pub mode: u8_,
    pub replay_window: u8_,
    pub aalgo: u8_,
    pub ealgo: u8_,
    pub calgo: u8_,
    pub flags: u8_,
    pub family: u16_,
    pub saddr: xfrm_address_t,
    pub header_len: ::aya_bpf_cty::c_int,
    pub trailer_len: ::aya_bpf_cty::c_int,
    pub extra_flags: u32_,
    pub smark: xfrm_mark,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_metrics {
    pub metrics: [u32_; 17usize],
    pub refcnt: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy_walk_entry {
    pub all: list_head,
    pub dead: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_queue {
    pub hold_queue: sk_buff_head,
    pub hold_timer: timer_list,
    pub timeout: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_tmpl {
    pub id: xfrm_id,
    pub saddr: xfrm_address_t,
    pub encap_family: ::aya_bpf_cty::c_ushort,
    pub reqid: u32_,
    pub mode: u8_,
    pub share: u8_,
    pub optional: u8_,
    pub allalgs: u8_,
    pub aalgos: u32_,
    pub ealgos: u32_,
    pub calgos: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy {
    pub xp_net: possible_net_t,
    pub bydst: hlist_node,
    pub byidx: hlist_node,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub pos: u32_,
    pub timer: timer_list,
    pub genid: atomic_t,
    pub priority: u32_,
    pub index: u32_,
    pub if_id: u32_,
    pub mark: xfrm_mark,
    pub selector: xfrm_selector,
    pub lft: xfrm_lifetime_cfg,
    pub curlft: xfrm_lifetime_cur,
    pub walk: xfrm_policy_walk_entry,
    pub polq: xfrm_policy_queue,
    pub bydst_reinsert: bool_,
    pub type_: u8_,
    pub action: u8_,
    pub flags: u8_,
    pub xfrm_nr: u8_,
    pub family: u16_,
    pub security: *mut xfrm_sec_ctx,
    pub xfrm_vec: [xfrm_tmpl; 6usize],
    pub bydst_inexact_list: hlist_node,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_table {
    pub hash: *mut udp_hslot,
    pub hash2: *mut udp_hslot,
    pub mask: ::aya_bpf_cty::c_uint,
    pub log: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_nh_exception {
    pub fnhe_next: *mut fib_nh_exception,
    pub fnhe_genid: ::aya_bpf_cty::c_int,
    pub fnhe_daddr: __be32,
    pub fnhe_pmtu: u32_,
    pub fnhe_mtu_locked: bool_,
    pub fnhe_gw: __be32,
    pub fnhe_expires: ::aya_bpf_cty::c_ulong,
    pub fnhe_rth_input: *mut rtable,
    pub fnhe_rth_output: *mut rtable,
    pub fnhe_stamp: ::aya_bpf_cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtable {
    pub dst: dst_entry,
    pub rt_genid: ::aya_bpf_cty::c_int,
    pub rt_flags: ::aya_bpf_cty::c_uint,
    pub rt_type: __u16,
    pub rt_is_input: __u8,
    pub rt_uses_gateway: __u8,
    pub rt_iif: ::aya_bpf_cty::c_int,
    pub rt_gw_family: u8_,
    pub __bindgen_anon_1: rtable__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub rt_uncached: list_head,
    pub rt_uncached_list: *mut uncached_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtable__bindgen_ty_1 {
    pub rt_gw4: __be32,
    pub rt_gw6: in6_addr,
}
impl rtable {
    #[inline]
    pub fn rt_mtu_locked(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_mtu_locked(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rt_pmtu(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rt_pmtu(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rt_mtu_locked: u32_,
        rt_pmtu: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rt_mtu_locked: u32 = unsafe { ::core::mem::transmute(rt_mtu_locked) };
            rt_mtu_locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rt_pmtu: u32 = unsafe { ::core::mem::transmute(rt_pmtu) };
            rt_pmtu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fnhe_hash_bucket {
    pub chain: *mut fib_nh_exception,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt6_exception_bucket {
    pub chain: hlist_head,
    pub depth: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_replay {
    pub advance: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: __be32)>,
    pub check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: __be32,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub recheck: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: __be32,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: ::aya_bpf_cty::c_int),
    >,
    pub overflow: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_type {
    pub description: *mut ::aya_bpf_cty::c_char,
    pub owner: *mut module,
    pub proto: u8_,
    pub flags: u8_,
    pub init_state:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state) -> ::aya_bpf_cty::c_int>,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub input: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub reject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: *const flowi,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub hdr_offset: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: *mut *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_type_offload {
    pub description: *mut ::aya_bpf_cty::c_char,
    pub owner: *mut module,
    pub proto: u8_,
    pub encap:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff)>,
    pub input_tail: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub xmit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: netdev_features_t,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udp_hslot {
    pub head: hlist_head,
    pub count: ::aya_bpf_cty::c_int,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtattr {
    pub rta_len: ::aya_bpf_cty::c_ushort,
    pub rta_type: ::aya_bpf_cty::c_ushort,
}
pub mod rq_qos_id {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const RQ_QOS_WBT: Type = 0;
    pub const RQ_QOS_LATENCY: Type = 1;
    pub const RQ_QOS_COST: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_qos {
    pub ops: *mut rq_qos_ops,
    pub q: *mut request_queue,
    pub id: rq_qos_id::Type,
    pub next: *mut rq_qos,
    pub debugfs_dir: *mut dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_qos_ops {
    pub throttle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub track: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
    >,
    pub merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
    >,
    pub issue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub requeue:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub done: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub done_bio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub queue_depth_changed: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>,
    pub debugfs_attrs: *const blk_mq_debugfs_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_queue_stats {
    pub callbacks: list_head,
    pub lock: spinlock_t,
    pub enable_accounting: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hd_geometry {
    pub heads: ::aya_bpf_cty::c_uchar,
    pub sectors: ::aya_bpf_cty::c_uchar,
    pub cylinders: ::aya_bpf_cty::c_ushort,
    pub start: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist {
    pub k_lock: spinlock_t,
    pub k_list: list_head,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut ::aya_bpf_cty::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct disk_events {
    pub node: list_head,
    pub disk: *mut gendisk,
    pub lock: spinlock_t,
    pub block_mutex: mutex,
    pub block: ::aya_bpf_cty::c_int,
    pub pending: ::aya_bpf_cty::c_uint,
    pub clearing: ::aya_bpf_cty::c_uint,
    pub poll_msecs: ::aya_bpf_cty::c_long,
    pub dwork: delayed_work,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct badblocks {
    pub dev: *mut device,
    pub count: ::aya_bpf_cty::c_int,
    pub unacked_exist: ::aya_bpf_cty::c_int,
    pub shift: ::aya_bpf_cty::c_int,
    pub page: *mut u64_,
    pub changed: ::aya_bpf_cty::c_int,
    pub lock: seqlock_t,
    pub sector: sector_t,
    pub size: sector_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_device_info {
    pub ops: *const cdrom_device_ops,
    pub list: list_head,
    pub disk: *mut gendisk,
    pub handle: *mut ::aya_bpf_cty::c_void,
    pub mask: ::aya_bpf_cty::c_int,
    pub speed: ::aya_bpf_cty::c_int,
    pub capacity: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub vfs_events: ::aya_bpf_cty::c_uint,
    pub ioctl_events: ::aya_bpf_cty::c_uint,
    pub use_count: ::aya_bpf_cty::c_int,
    pub name: [::aya_bpf_cty::c_char; 20usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cdda_method: ::aya_bpf_cty::c_int,
    pub last_sense: __u8,
    pub media_written: __u8,
    pub mmc3_profile: ::aya_bpf_cty::c_ushort,
    pub for_data: ::aya_bpf_cty::c_int,
    pub exit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf_cty::c_int,
    >,
    pub mrw_mode_page: ::aya_bpf_cty::c_int,
}
impl cdrom_device_info {
    #[inline]
    pub fn options(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_options(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_flags(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mc_flags(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        options: ::aya_bpf_cty::c_uint,
        mc_flags: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let options: u32 = unsafe { ::core::mem::transmute(options) };
            options as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let mc_flags: u32 = unsafe { ::core::mem::transmute(mc_flags) };
            mc_flags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sanyo_slot(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sanyo_slot(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn keeplocked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keeplocked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sanyo_slot: __u8,
        keeplocked: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sanyo_slot: u8 = unsafe { ::core::mem::transmute(sanyo_slot) };
            sanyo_slot as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let keeplocked: u8 = unsafe { ::core::mem::transmute(keeplocked) };
            keeplocked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scsi_sense_hdr {
    pub response_code: u8_,
    pub sense_key: u8_,
    pub asc: u8_,
    pub ascq: u8_,
    pub byte4: u8_,
    pub byte5: u8_,
    pub byte6: u8_,
    pub additional_length: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_msf0 {
    pub minute: __u8,
    pub second: __u8,
    pub frame: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cdrom_addr {
    pub msf: cdrom_msf0,
    pub lba: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cdrom_multisession {
    pub addr: cdrom_addr,
    pub xa_flag: __u8,
    pub addr_format: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_mcn {
    pub medium_catalog_number: [__u8; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_command {
    pub cmd: [::aya_bpf_cty::c_uchar; 12usize],
    pub buffer: *mut ::aya_bpf_cty::c_uchar,
    pub buflen: ::aya_bpf_cty::c_uint,
    pub stat: ::aya_bpf_cty::c_int,
    pub sshdr: *mut scsi_sense_hdr,
    pub data_direction: ::aya_bpf_cty::c_uchar,
    pub quiet: ::aya_bpf_cty::c_int,
    pub timeout: ::aya_bpf_cty::c_int,
    pub reserved: [*mut ::aya_bpf_cty::c_void; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_device_ops {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cdrom_device_info)>,
    pub drive_status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_uint,
    >,
    pub tray_move: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub lock_door: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub select_speed: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub select_disc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_last_session: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut cdrom_multisession,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_mcn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut cdrom_mcn,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf_cty::c_int,
    >,
    pub audio_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub capability: ::aya_bpf_cty::c_int,
    pub generic_packet: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut packet_command,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct throtl_service_queue {
    pub parent_sq: *mut throtl_service_queue,
    pub queued: [list_head; 2usize],
    pub nr_queued: [::aya_bpf_cty::c_uint; 2usize],
    pub pending_tree: rb_root_cached,
    pub nr_pending: ::aya_bpf_cty::c_uint,
    pub first_pending_disptime: ::aya_bpf_cty::c_ulong,
    pub pending_timer: timer_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latency_bucket {
    pub total_latency: ::aya_bpf_cty::c_ulong,
    pub samples: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avg_latency_bucket {
    pub latency: ::aya_bpf_cty::c_ulong,
    pub valid: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct throtl_data {
    pub service_queue: throtl_service_queue,
    pub queue: *mut request_queue,
    pub nr_queued: [::aya_bpf_cty::c_uint; 2usize],
    pub throtl_slice: ::aya_bpf_cty::c_uint,
    pub dispatch_work: work_struct,
    pub limit_index: ::aya_bpf_cty::c_uint,
    pub limit_valid: [bool_; 2usize],
    pub low_upgrade_time: ::aya_bpf_cty::c_ulong,
    pub low_downgrade_time: ::aya_bpf_cty::c_ulong,
    pub scale: ::aya_bpf_cty::c_uint,
    pub tmp_buckets: [latency_bucket; 18usize],
    pub avg_buckets: [avg_latency_bucket; 18usize],
    pub latency_buckets: [*mut latency_bucket; 2usize],
    pub last_calculate_time: ::aya_bpf_cty::c_ulong,
    pub filtered_latency: ::aya_bpf_cty::c_ulong,
    pub track_bio_latency: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_ksm_keyslot {
    pub slot_refs: atomic_t,
    pub idle_slot_node: list_head,
    pub hash_node: hlist_node,
    pub key: *const blk_crypto_key,
    pub ksm: *mut blk_keyslot_manager,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_ksm_ll_ops {
    pub keyslot_program: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_keyslot_manager,
            arg2: *const blk_crypto_key,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub keyslot_evict: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_keyslot_manager,
            arg2: *const blk_crypto_key,
            arg3: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_keyslot_manager {
    pub ksm_ll_ops: blk_ksm_ll_ops,
    pub max_dun_bytes_supported: ::aya_bpf_cty::c_uint,
    pub crypto_modes_supported: [::aya_bpf_cty::c_uint; 4usize],
    pub dev: *mut device,
    pub num_slots: ::aya_bpf_cty::c_uint,
    pub lock: rw_semaphore,
    pub idle_slots_wait_queue: wait_queue_head_t,
    pub idle_slots: list_head,
    pub idle_slots_lock: spinlock_t,
    pub slot_hashtable: *mut hlist_head,
    pub log_slot_ht_size: ::aya_bpf_cty::c_uint,
    pub slots: *mut blk_ksm_keyslot,
}
#[repr(C)]
#[derive(Debug)]
pub struct cpu_rmap {
    pub refcount: kref,
    pub size: u16_,
    pub used: u16_,
    pub obj: *mut *mut ::aya_bpf_cty::c_void,
    pub near: __IncompleteArrayField<cpu_rmap__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_rmap__bindgen_ty_1 {
    pub index: u16_,
    pub dist: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uevent_sock {
    pub list: list_head,
    pub sk: *mut sock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct minmax_sample {
    pub t: u32_,
    pub v: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct minmax {
    pub s: [minmax_sample; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pin_info {
    pub p: *mut pinctrl,
    pub default_state: *mut pinctrl_state,
    pub init_state: *mut pinctrl_state,
    pub sleep_state: *mut pinctrl_state,
    pub idle_state: *mut pinctrl_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl {
    pub node: list_head,
    pub dev: *mut device,
    pub states: list_head,
    pub state: *mut pinctrl_state,
    pub dt_maps: list_head,
    pub users: kref,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl_state {
    pub node: list_head,
    pub name: *const ::aya_bpf_cty::c_char,
    pub settings: list_head,
}
pub type u_char = ::aya_bpf_cty::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_domain_data {
    pub list_node: list_head,
    pub dev: *mut device,
}
pub mod led_brightness {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const LED_OFF: Type = 0;
    pub const LED_ON: Type = 1;
    pub const LED_HALF: Type = 127;
    pub const LED_FULL: Type = 255;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct led_hw_trigger_type {
    pub dummy: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_classdev {
    pub name: *const ::aya_bpf_cty::c_char,
    pub brightness: led_brightness::Type,
    pub max_brightness: led_brightness::Type,
    pub flags: ::aya_bpf_cty::c_int,
    pub work_flags: ::aya_bpf_cty::c_ulong,
    pub brightness_set: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut led_classdev, arg2: led_brightness::Type),
    >,
    pub brightness_set_blocking: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut led_classdev,
            arg2: led_brightness::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub brightness_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut led_classdev) -> led_brightness::Type,
    >,
    pub blink_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut led_classdev,
            arg2: *mut ::aya_bpf_cty::c_ulong,
            arg3: *mut ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pattern_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut led_classdev,
            arg2: *mut led_pattern,
            arg3: u32_,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub pattern_clear: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut led_classdev) -> ::aya_bpf_cty::c_int,
    >,
    pub dev: *mut device,
    pub groups: *mut *const attribute_group,
    pub node: list_head,
    pub default_trigger: *const ::aya_bpf_cty::c_char,
    pub blink_delay_on: ::aya_bpf_cty::c_ulong,
    pub blink_delay_off: ::aya_bpf_cty::c_ulong,
    pub blink_timer: timer_list,
    pub blink_brightness: ::aya_bpf_cty::c_int,
    pub new_blink_brightness: ::aya_bpf_cty::c_int,
    pub flash_resume: ::core::option::Option<unsafe extern "C" fn(arg1: *mut led_classdev)>,
    pub set_brightness_work: work_struct,
    pub delayed_set_value: ::aya_bpf_cty::c_int,
    pub trigger_lock: rw_semaphore,
    pub trigger: *mut led_trigger,
    pub trig_list: list_head,
    pub trigger_data: *mut ::aya_bpf_cty::c_void,
    pub activated: bool_,
    pub trigger_type: *mut led_hw_trigger_type,
    pub brightness_hw_changed: ::aya_bpf_cty::c_int,
    pub brightness_hw_changed_kn: *mut kernfs_node,
    pub led_access: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct led_pattern {
    pub delta_t: u32_,
    pub brightness: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct led_trigger {
    pub name: *const ::aya_bpf_cty::c_char,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut led_classdev) -> ::aya_bpf_cty::c_int,
    >,
    pub deactivate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut led_classdev)>,
    pub trigger_type: *mut led_hw_trigger_type,
    pub leddev_list_lock: rwlock_t,
    pub led_cdevs: list_head,
    pub next_trig: list_head,
    pub groups: *mut *const attribute_group,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tty_audit_buf {
    pub mutex: mutex,
    pub dev: dev_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub valid: size_t,
    pub data: *mut ::aya_bpf_cty::c_uchar,
}
impl tty_audit_buf {
    #[inline]
    pub fn icanon(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icanon(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(icanon: ::aya_bpf_cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let icanon: u32 = unsafe { ::core::mem::transmute(icanon) };
            icanon as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_rand_state {
    pub last_time: cycles_t,
    pub last_delta: ::aya_bpf_cty::c_long,
    pub last_delta2: ::aya_bpf_cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    pub kobj: kobject,
    pub devices_kobj: *mut kobject,
    pub devices: list_head,
    pub mutex: mutex,
    pub notifier: blocking_notifier_head,
    pub iommu_data: *mut ::aya_bpf_cty::c_void,
    pub iommu_data_release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub id: ::aya_bpf_cty::c_int,
    pub default_domain: *mut iommu_domain,
    pub domain: *mut iommu_domain,
    pub entry: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    pub dev: *mut device,
    pub status: ::aya_bpf_cty::c_uint,
    pub irq: ::aya_bpf_cty::c_int,
    pub name: *const ::aya_bpf_cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_private {
    pub subsys: kset,
    pub devices_kset: *mut kset,
    pub interfaces: list_head,
    pub mutex: mutex,
    pub drivers_kset: *mut kset,
    pub klist_devices: klist,
    pub klist_drivers: klist,
    pub bus_notifier: blocking_notifier_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bus: *mut bus_type,
    pub glue_dirs: kset,
    pub class: *mut class,
}
impl subsys_private {
    #[inline]
    pub fn drivers_autoprobe(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drivers_autoprobe(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drivers_autoprobe: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drivers_autoprobe: u32 = unsafe { ::core::mem::transmute(drivers_autoprobe) };
            drivers_autoprobe as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    pub kobj: kobject,
    pub klist_devices: klist,
    pub knode_bus: klist_node,
    pub mkobj: *mut module_kobject,
    pub driver: *mut device_driver,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    pub klist_children: klist,
    pub knode_parent: klist_node,
    pub knode_driver: klist_node,
    pub knode_bus: klist_node,
    pub knode_class: klist_node,
    pub deferred_probe: list_head,
    pub async_driver: *mut device_driver,
    pub deferred_probe_reason: *mut ::aya_bpf_cty::c_char,
    pub device: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl device_private {
    #[inline]
    pub fn dead(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dead(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dead: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dead: u8 = unsafe { ::core::mem::transmute(dead) };
            dead as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reset_control___2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_device {
    pub dev: device,
    pub bus: *mut mii_bus,
    pub modalias: [::aya_bpf_cty::c_char; 32usize],
    pub bus_match: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut device_driver) -> ::aya_bpf_cty::c_int,
    >,
    pub device_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>,
    pub device_remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>,
    pub addr: ::aya_bpf_cty::c_int,
    pub flags: ::aya_bpf_cty::c_int,
    pub reset_gpio: *mut gpio_desc,
    pub reset_ctrl: *mut reset_control___2,
    pub reset_assert_delay: ::aya_bpf_cty::c_uint,
    pub reset_deassert_delay: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_c45_device_ids {
    pub devices_in_package: u32_,
    pub mmds_present: u32_,
    pub device_ids: [u32_; 32usize],
}
pub mod phy_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PHY_DOWN: Type = 0;
    pub const PHY_READY: Type = 1;
    pub const PHY_HALTED: Type = 2;
    pub const PHY_UP: Type = 3;
    pub const PHY_RUNNING: Type = 4;
    pub const PHY_NOLINK: Type = 5;
    pub const PHY_CABLETEST: Type = 6;
}
pub mod phy_interface_t {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PHY_INTERFACE_MODE_NA: Type = 0;
    pub const PHY_INTERFACE_MODE_INTERNAL: Type = 1;
    pub const PHY_INTERFACE_MODE_MII: Type = 2;
    pub const PHY_INTERFACE_MODE_GMII: Type = 3;
    pub const PHY_INTERFACE_MODE_SGMII: Type = 4;
    pub const PHY_INTERFACE_MODE_TBI: Type = 5;
    pub const PHY_INTERFACE_MODE_REVMII: Type = 6;
    pub const PHY_INTERFACE_MODE_RMII: Type = 7;
    pub const PHY_INTERFACE_MODE_RGMII: Type = 8;
    pub const PHY_INTERFACE_MODE_RGMII_ID: Type = 9;
    pub const PHY_INTERFACE_MODE_RGMII_RXID: Type = 10;
    pub const PHY_INTERFACE_MODE_RGMII_TXID: Type = 11;
    pub const PHY_INTERFACE_MODE_RTBI: Type = 12;
    pub const PHY_INTERFACE_MODE_SMII: Type = 13;
    pub const PHY_INTERFACE_MODE_XGMII: Type = 14;
    pub const PHY_INTERFACE_MODE_XLGMII: Type = 15;
    pub const PHY_INTERFACE_MODE_MOCA: Type = 16;
    pub const PHY_INTERFACE_MODE_QSGMII: Type = 17;
    pub const PHY_INTERFACE_MODE_TRGMII: Type = 18;
    pub const PHY_INTERFACE_MODE_1000BASEX: Type = 19;
    pub const PHY_INTERFACE_MODE_2500BASEX: Type = 20;
    pub const PHY_INTERFACE_MODE_RXAUI: Type = 21;
    pub const PHY_INTERFACE_MODE_XAUI: Type = 22;
    pub const PHY_INTERFACE_MODE_10GBASER: Type = 23;
    pub const PHY_INTERFACE_MODE_USXGMII: Type = 24;
    pub const PHY_INTERFACE_MODE_10GKR: Type = 25;
    pub const PHY_INTERFACE_MODE_MAX: Type = 26;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_device {
    pub mdio: mdio_device,
    pub drv: *mut phy_driver,
    pub phy_id: u32_,
    pub c45_ids: phy_c45_device_ids,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub state: phy_state::Type,
    pub dev_flags: u32_,
    pub interface: phy_interface_t::Type,
    pub speed: ::aya_bpf_cty::c_int,
    pub duplex: ::aya_bpf_cty::c_int,
    pub port: ::aya_bpf_cty::c_int,
    pub pause: ::aya_bpf_cty::c_int,
    pub asym_pause: ::aya_bpf_cty::c_int,
    pub master_slave_get: u8_,
    pub master_slave_set: u8_,
    pub master_slave_state: u8_,
    pub supported: [::aya_bpf_cty::c_ulong; 2usize],
    pub advertising: [::aya_bpf_cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf_cty::c_ulong; 2usize],
    pub adv_old: [::aya_bpf_cty::c_ulong; 2usize],
    pub eee_broken_modes: u32_,
    pub phy_led_triggers: *mut phy_led_trigger,
    pub phy_num_led_triggers: ::aya_bpf_cty::c_uint,
    pub last_triggered: *mut phy_led_trigger,
    pub led_link_trigger: *mut phy_led_trigger,
    pub irq: ::aya_bpf_cty::c_int,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub shared: *mut phy_package_shared,
    pub skb: *mut sk_buff,
    pub ehdr: *mut ::aya_bpf_cty::c_void,
    pub nest: *mut nlattr,
    pub state_queue: delayed_work,
    pub lock: mutex,
    pub sfp_bus_attached: bool_,
    pub sfp_bus: *mut sfp_bus,
    pub phylink: *mut phylink,
    pub attached_dev: *mut net_device,
    pub mii_ts: *mut mii_timestamper,
    pub mdix: u8_,
    pub mdix_ctrl: u8_,
    pub phy_link_change:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_)>,
    pub adjust_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub macsec_ops: *const macsec_ops,
}
impl phy_device {
    #[inline]
    pub fn is_c45(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_c45(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_internal(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_internal(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_pseudo_fixed_link(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_pseudo_fixed_link(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_gigabit_capable(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_gigabit_capable(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fixups(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fixups(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended_by_mdio_bus(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended_by_mdio_bus(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sysfs_links(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysfs_links(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback_enabled(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback_enabled(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downshifted_rate(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downshifted_rate(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg_complete(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg_complete(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupts(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupts(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_c45: ::aya_bpf_cty::c_uint,
        is_internal: ::aya_bpf_cty::c_uint,
        is_pseudo_fixed_link: ::aya_bpf_cty::c_uint,
        is_gigabit_capable: ::aya_bpf_cty::c_uint,
        has_fixups: ::aya_bpf_cty::c_uint,
        suspended: ::aya_bpf_cty::c_uint,
        suspended_by_mdio_bus: ::aya_bpf_cty::c_uint,
        sysfs_links: ::aya_bpf_cty::c_uint,
        loopback_enabled: ::aya_bpf_cty::c_uint,
        downshifted_rate: ::aya_bpf_cty::c_uint,
        autoneg: ::aya_bpf_cty::c_uint,
        link: ::aya_bpf_cty::c_uint,
        autoneg_complete: ::aya_bpf_cty::c_uint,
        interrupts: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_c45: u32 = unsafe { ::core::mem::transmute(is_c45) };
            is_c45 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_internal: u32 = unsafe { ::core::mem::transmute(is_internal) };
            is_internal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_pseudo_fixed_link: u32 = unsafe { ::core::mem::transmute(is_pseudo_fixed_link) };
            is_pseudo_fixed_link as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_gigabit_capable: u32 = unsafe { ::core::mem::transmute(is_gigabit_capable) };
            is_gigabit_capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fixups: u32 = unsafe { ::core::mem::transmute(has_fixups) };
            has_fixups as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let suspended: u32 = unsafe { ::core::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let suspended_by_mdio_bus: u32 =
                unsafe { ::core::mem::transmute(suspended_by_mdio_bus) };
            suspended_by_mdio_bus as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sysfs_links: u32 = unsafe { ::core::mem::transmute(sysfs_links) };
            sysfs_links as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let loopback_enabled: u32 = unsafe { ::core::mem::transmute(loopback_enabled) };
            loopback_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downshifted_rate: u32 = unsafe { ::core::mem::transmute(downshifted_rate) };
            downshifted_rate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let autoneg: u32 = unsafe { ::core::mem::transmute(autoneg) };
            autoneg as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let autoneg_complete: u32 = unsafe { ::core::mem::transmute(autoneg_complete) };
            autoneg_complete as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let interrupts: u32 = unsafe { ::core::mem::transmute(interrupts) };
            interrupts as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_tdr_config {
    pub first: u32_,
    pub last: u32_,
    pub step: u32_,
    pub pair: s8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdio_bus_stats {
    pub transfers: u64_stats_t,
    pub errors: u64_stats_t,
    pub writes: u64_stats_t,
    pub reads: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_bus {
    pub owner: *mut module,
    pub name: *const ::aya_bpf_cty::c_char,
    pub id: [::aya_bpf_cty::c_char; 61usize],
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_bus,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_bus,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mii_bus) -> ::aya_bpf_cty::c_int>,
    pub stats: [mdio_bus_stats; 32usize],
    pub mdio_lock: mutex,
    pub parent: *mut device,
    pub state: mii_bus__bindgen_ty_1::Type,
    pub dev: device,
    pub mdio_map: [*mut mdio_device; 32usize],
    pub phy_mask: u32_,
    pub phy_ignore_ta_mask: u32_,
    pub irq: [::aya_bpf_cty::c_int; 32usize],
    pub reset_delay_us: ::aya_bpf_cty::c_int,
    pub reset_post_delay_us: ::aya_bpf_cty::c_int,
    pub reset_gpiod: *mut gpio_desc,
    pub probe_capabilities: mii_bus__bindgen_ty_2::Type,
    pub shared_lock: mutex,
    pub shared: [*mut phy_package_shared; 32usize],
}
pub mod mii_bus__bindgen_ty_1 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MDIOBUS_ALLOCATED: Type = 1;
    pub const MDIOBUS_REGISTERED: Type = 2;
    pub const MDIOBUS_UNREGISTERED: Type = 3;
    pub const MDIOBUS_RELEASED: Type = 4;
}
pub mod mii_bus__bindgen_ty_2 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const MDIOBUS_NO_CAP: Type = 0;
    pub const MDIOBUS_C22: Type = 1;
    pub const MDIOBUS_C45: Type = 2;
    pub const MDIOBUS_C22_C45: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdio_driver_common {
    pub driver: device_driver,
    pub flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mii_timestamper {
    pub rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut sk_buff,
            arg3: ::aya_bpf_cty::c_int,
        ) -> bool_,
    >,
    pub txtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut sk_buff,
            arg3: ::aya_bpf_cty::c_int,
        ),
    >,
    pub hwtstamp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mii_timestamper, arg2: *mut ifreq) -> ::aya_bpf_cty::c_int,
    >,
    pub link_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mii_timestamper, arg2: *mut phy_device),
    >,
    pub ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut ethtool_ts_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub device: *mut device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_package_shared {
    pub addr: ::aya_bpf_cty::c_int,
    pub refcnt: refcount_t,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub priv_size: size_t,
    pub priv_: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_driver {
    pub mdiodrv: mdio_driver_common,
    pub phy_id: u32_,
    pub name: *mut ::aya_bpf_cty::c_char,
    pub phy_id_mask: u32_,
    pub features: *const ::aya_bpf_cty::c_ulong,
    pub flags: u32_,
    pub driver_data: *const ::aya_bpf_cty::c_void,
    pub soft_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub config_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub get_features:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub config_aneg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub aneg_done:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub read_status:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub config_intr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub handle_interrupt:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> irqreturn_t>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>,
    pub match_phy_device:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_wolinfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_wolinfo),
    >,
    pub link_change_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>,
    pub read_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub write_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u16_,
            arg4: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub read_page:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub write_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_modinfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cable_test_start:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub cable_test_tdr_start: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *const phy_tdr_config,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cable_test_get_status: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub get_sset_count:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub get_strings:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut u8_)>,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_tunable,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_tunable,
            arg3: *const ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_loopback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
    >,
    pub get_sqi:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    pub get_sqi_max:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
}
pub type irq_write_msi_msg_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut msi_desc, arg2: *mut msi_msg)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_msi_priv_data {
    pub dev: *mut device,
    pub host_data: *mut ::aya_bpf_cty::c_void,
    pub arg: msi_alloc_info_t,
    pub write_msg: irq_write_msi_msg_t,
    pub devid: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_led_trigger {
    pub trigger: led_trigger,
    pub name: [::aya_bpf_cty::c_char; 76usize],
    pub speed: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_eeprom_base {
    pub phys_id: u8_,
    pub phys_ext_id: u8_,
    pub connector: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub encoding: u8_,
    pub br_nominal: u8_,
    pub rate_id: u8_,
    pub link_len: [u8_; 6usize],
    pub vendor_name: [::aya_bpf_cty::c_char; 16usize],
    pub extended_cc: u8_,
    pub vendor_oui: [::aya_bpf_cty::c_char; 3usize],
    pub vendor_pn: [::aya_bpf_cty::c_char; 16usize],
    pub vendor_rev: [::aya_bpf_cty::c_char; 4usize],
    pub __bindgen_anon_1: sfp_eeprom_base__bindgen_ty_1,
    pub reserved62: u8_,
    pub cc_base: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sfp_eeprom_base__bindgen_ty_1 {
    pub optical_wavelength: __be16,
    pub cable_compliance: __be16,
    pub passive: sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1,
    pub active: sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sff8431_app_e(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_app_e(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_app_h(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_app_h(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved60_2(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved60_2(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved61(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved61(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sff8431_app_e: u8_,
        fc_pi_4_app_h: u8_,
        reserved60_2: u8_,
        reserved61: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sff8431_app_e: u8 = unsafe { ::core::mem::transmute(sff8431_app_e) };
            sff8431_app_e as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fc_pi_4_app_h: u8 = unsafe { ::core::mem::transmute(fc_pi_4_app_h) };
            fc_pi_4_app_h as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved60_2: u8 = unsafe { ::core::mem::transmute(reserved60_2) };
            reserved60_2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved61: u8 = unsafe { ::core::mem::transmute(reserved61) };
            reserved61 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn sff8431_app_e(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_app_e(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_app_h(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_app_h(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sff8431_lim(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_lim(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_lim(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_lim(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved60_4(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved60_4(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved61(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved61(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sff8431_app_e: u8_,
        fc_pi_4_app_h: u8_,
        sff8431_lim: u8_,
        fc_pi_4_lim: u8_,
        reserved60_4: u8_,
        reserved61: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sff8431_app_e: u8 = unsafe { ::core::mem::transmute(sff8431_app_e) };
            sff8431_app_e as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fc_pi_4_app_h: u8 = unsafe { ::core::mem::transmute(fc_pi_4_app_h) };
            fc_pi_4_app_h as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sff8431_lim: u8 = unsafe { ::core::mem::transmute(sff8431_lim) };
            sff8431_lim as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fc_pi_4_lim: u8 = unsafe { ::core::mem::transmute(fc_pi_4_lim) };
            fc_pi_4_lim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved60_4: u8 = unsafe { ::core::mem::transmute(reserved60_4) };
            reserved60_4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved61: u8 = unsafe { ::core::mem::transmute(reserved61) };
            reserved61 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl sfp_eeprom_base {
    #[inline]
    pub fn if_1x_copper_passive(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_copper_passive(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_copper_active(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_copper_active(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_sx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_sx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_sr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_sr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_lr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_lr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_lrm(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_lrm(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_er(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_er(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_smf_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_smf_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_smf_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_smf_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_5_3(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_5_3(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_smf_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_smf_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_smf_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_smf_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_5_7(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_5_7(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_reach_bit2(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_reach_bit2(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_reach_bit1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_reach_bit1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc192_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc192_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escon_smf_1310_laser(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_escon_smf_1310_laser(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escon_mmf_1310_led(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_escon_mmf_1310_led(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_sx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_sx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_cx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_cx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_t(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_t(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e100_base_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e100_base_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e100_base_fx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e100_base_fx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e_base_bx10(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e_base_bx10(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e_base_px(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e_base_px(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_electrical_inter_enclosure(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_electrical_inter_enclosure(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_lc(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_lc(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sa(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sa(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_m(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_m(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_l(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_l(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_i(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_i(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_s(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_s(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_v(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_v(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_8_0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_8_0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_8_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_8_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sfp_ct_passive(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sfp_ct_passive(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sfp_ct_active(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sfp_ct_active(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_ll(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_ll(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sl(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sl(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sn(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sn(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_electrical_intra_enclosure(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_electrical_intra_enclosure(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_sm(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_sm(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_9_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_9_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_m5(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_m5(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_m6(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_m6(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tv(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tv(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_mi(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_mi(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tp(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tp(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tw(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tw(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_100(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_100(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_10_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_10_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_3200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_3200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_400(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_400(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_1600(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_1600(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_800(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_800(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_1200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_1200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        if_1x_copper_passive: u8_,
        if_1x_copper_active: u8_,
        if_1x_lx: u8_,
        if_1x_sx: u8_,
        e10g_base_sr: u8_,
        e10g_base_lr: u8_,
        e10g_base_lrm: u8_,
        e10g_base_er: u8_,
        sonet_oc3_short_reach: u8_,
        sonet_oc3_smf_intermediate_reach: u8_,
        sonet_oc3_smf_long_reach: u8_,
        unallocated_5_3: u8_,
        sonet_oc12_short_reach: u8_,
        sonet_oc12_smf_intermediate_reach: u8_,
        sonet_oc12_smf_long_reach: u8_,
        unallocated_5_7: u8_,
        sonet_oc48_short_reach: u8_,
        sonet_oc48_intermediate_reach: u8_,
        sonet_oc48_long_reach: u8_,
        sonet_reach_bit2: u8_,
        sonet_reach_bit1: u8_,
        sonet_oc192_short_reach: u8_,
        escon_smf_1310_laser: u8_,
        escon_mmf_1310_led: u8_,
        e1000_base_sx: u8_,
        e1000_base_lx: u8_,
        e1000_base_cx: u8_,
        e1000_base_t: u8_,
        e100_base_lx: u8_,
        e100_base_fx: u8_,
        e_base_bx10: u8_,
        e_base_px: u8_,
        fc_tech_electrical_inter_enclosure: u8_,
        fc_tech_lc: u8_,
        fc_tech_sa: u8_,
        fc_ll_m: u8_,
        fc_ll_l: u8_,
        fc_ll_i: u8_,
        fc_ll_s: u8_,
        fc_ll_v: u8_,
        unallocated_8_0: u8_,
        unallocated_8_1: u8_,
        sfp_ct_passive: u8_,
        sfp_ct_active: u8_,
        fc_tech_ll: u8_,
        fc_tech_sl: u8_,
        fc_tech_sn: u8_,
        fc_tech_electrical_intra_enclosure: u8_,
        fc_media_sm: u8_,
        unallocated_9_1: u8_,
        fc_media_m5: u8_,
        fc_media_m6: u8_,
        fc_media_tv: u8_,
        fc_media_mi: u8_,
        fc_media_tp: u8_,
        fc_media_tw: u8_,
        fc_speed_100: u8_,
        unallocated_10_1: u8_,
        fc_speed_200: u8_,
        fc_speed_3200: u8_,
        fc_speed_400: u8_,
        fc_speed_1600: u8_,
        fc_speed_800: u8_,
        fc_speed_1200: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let if_1x_copper_passive: u8 = unsafe { ::core::mem::transmute(if_1x_copper_passive) };
            if_1x_copper_passive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let if_1x_copper_active: u8 = unsafe { ::core::mem::transmute(if_1x_copper_active) };
            if_1x_copper_active as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let if_1x_lx: u8 = unsafe { ::core::mem::transmute(if_1x_lx) };
            if_1x_lx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let if_1x_sx: u8 = unsafe { ::core::mem::transmute(if_1x_sx) };
            if_1x_sx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let e10g_base_sr: u8 = unsafe { ::core::mem::transmute(e10g_base_sr) };
            e10g_base_sr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let e10g_base_lr: u8 = unsafe { ::core::mem::transmute(e10g_base_lr) };
            e10g_base_lr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let e10g_base_lrm: u8 = unsafe { ::core::mem::transmute(e10g_base_lrm) };
            e10g_base_lrm as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let e10g_base_er: u8 = unsafe { ::core::mem::transmute(e10g_base_er) };
            e10g_base_er as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sonet_oc3_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_short_reach) };
            sonet_oc3_short_reach as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sonet_oc3_smf_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_smf_intermediate_reach) };
            sonet_oc3_smf_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sonet_oc3_smf_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_smf_long_reach) };
            sonet_oc3_smf_long_reach as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let unallocated_5_3: u8 = unsafe { ::core::mem::transmute(unallocated_5_3) };
            unallocated_5_3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let sonet_oc12_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_short_reach) };
            sonet_oc12_short_reach as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let sonet_oc12_smf_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_smf_intermediate_reach) };
            sonet_oc12_smf_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sonet_oc12_smf_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_smf_long_reach) };
            sonet_oc12_smf_long_reach as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let unallocated_5_7: u8 = unsafe { ::core::mem::transmute(unallocated_5_7) };
            unallocated_5_7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sonet_oc48_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_short_reach) };
            sonet_oc48_short_reach as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let sonet_oc48_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_intermediate_reach) };
            sonet_oc48_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sonet_oc48_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_long_reach) };
            sonet_oc48_long_reach as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sonet_reach_bit2: u8 = unsafe { ::core::mem::transmute(sonet_reach_bit2) };
            sonet_reach_bit2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sonet_reach_bit1: u8 = unsafe { ::core::mem::transmute(sonet_reach_bit1) };
            sonet_reach_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sonet_oc192_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc192_short_reach) };
            sonet_oc192_short_reach as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let escon_smf_1310_laser: u8 = unsafe { ::core::mem::transmute(escon_smf_1310_laser) };
            escon_smf_1310_laser as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let escon_mmf_1310_led: u8 = unsafe { ::core::mem::transmute(escon_mmf_1310_led) };
            escon_mmf_1310_led as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let e1000_base_sx: u8 = unsafe { ::core::mem::transmute(e1000_base_sx) };
            e1000_base_sx as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let e1000_base_lx: u8 = unsafe { ::core::mem::transmute(e1000_base_lx) };
            e1000_base_lx as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let e1000_base_cx: u8 = unsafe { ::core::mem::transmute(e1000_base_cx) };
            e1000_base_cx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let e1000_base_t: u8 = unsafe { ::core::mem::transmute(e1000_base_t) };
            e1000_base_t as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let e100_base_lx: u8 = unsafe { ::core::mem::transmute(e100_base_lx) };
            e100_base_lx as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let e100_base_fx: u8 = unsafe { ::core::mem::transmute(e100_base_fx) };
            e100_base_fx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let e_base_bx10: u8 = unsafe { ::core::mem::transmute(e_base_bx10) };
            e_base_bx10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let e_base_px: u8 = unsafe { ::core::mem::transmute(e_base_px) };
            e_base_px as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let fc_tech_electrical_inter_enclosure: u8 =
                unsafe { ::core::mem::transmute(fc_tech_electrical_inter_enclosure) };
            fc_tech_electrical_inter_enclosure as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let fc_tech_lc: u8 = unsafe { ::core::mem::transmute(fc_tech_lc) };
            fc_tech_lc as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let fc_tech_sa: u8 = unsafe { ::core::mem::transmute(fc_tech_sa) };
            fc_tech_sa as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let fc_ll_m: u8 = unsafe { ::core::mem::transmute(fc_ll_m) };
            fc_ll_m as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let fc_ll_l: u8 = unsafe { ::core::mem::transmute(fc_ll_l) };
            fc_ll_l as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let fc_ll_i: u8 = unsafe { ::core::mem::transmute(fc_ll_i) };
            fc_ll_i as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let fc_ll_s: u8 = unsafe { ::core::mem::transmute(fc_ll_s) };
            fc_ll_s as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let fc_ll_v: u8 = unsafe { ::core::mem::transmute(fc_ll_v) };
            fc_ll_v as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let unallocated_8_0: u8 = unsafe { ::core::mem::transmute(unallocated_8_0) };
            unallocated_8_0 as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let unallocated_8_1: u8 = unsafe { ::core::mem::transmute(unallocated_8_1) };
            unallocated_8_1 as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let sfp_ct_passive: u8 = unsafe { ::core::mem::transmute(sfp_ct_passive) };
            sfp_ct_passive as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let sfp_ct_active: u8 = unsafe { ::core::mem::transmute(sfp_ct_active) };
            sfp_ct_active as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let fc_tech_ll: u8 = unsafe { ::core::mem::transmute(fc_tech_ll) };
            fc_tech_ll as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let fc_tech_sl: u8 = unsafe { ::core::mem::transmute(fc_tech_sl) };
            fc_tech_sl as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let fc_tech_sn: u8 = unsafe { ::core::mem::transmute(fc_tech_sn) };
            fc_tech_sn as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let fc_tech_electrical_intra_enclosure: u8 =
                unsafe { ::core::mem::transmute(fc_tech_electrical_intra_enclosure) };
            fc_tech_electrical_intra_enclosure as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let fc_media_sm: u8 = unsafe { ::core::mem::transmute(fc_media_sm) };
            fc_media_sm as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let unallocated_9_1: u8 = unsafe { ::core::mem::transmute(unallocated_9_1) };
            unallocated_9_1 as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let fc_media_m5: u8 = unsafe { ::core::mem::transmute(fc_media_m5) };
            fc_media_m5 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let fc_media_m6: u8 = unsafe { ::core::mem::transmute(fc_media_m6) };
            fc_media_m6 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let fc_media_tv: u8 = unsafe { ::core::mem::transmute(fc_media_tv) };
            fc_media_tv as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let fc_media_mi: u8 = unsafe { ::core::mem::transmute(fc_media_mi) };
            fc_media_mi as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let fc_media_tp: u8 = unsafe { ::core::mem::transmute(fc_media_tp) };
            fc_media_tp as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let fc_media_tw: u8 = unsafe { ::core::mem::transmute(fc_media_tw) };
            fc_media_tw as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let fc_speed_100: u8 = unsafe { ::core::mem::transmute(fc_speed_100) };
            fc_speed_100 as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let unallocated_10_1: u8 = unsafe { ::core::mem::transmute(unallocated_10_1) };
            unallocated_10_1 as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let fc_speed_200: u8 = unsafe { ::core::mem::transmute(fc_speed_200) };
            fc_speed_200 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let fc_speed_3200: u8 = unsafe { ::core::mem::transmute(fc_speed_3200) };
            fc_speed_3200 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let fc_speed_400: u8 = unsafe { ::core::mem::transmute(fc_speed_400) };
            fc_speed_400 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let fc_speed_1600: u8 = unsafe { ::core::mem::transmute(fc_speed_1600) };
            fc_speed_1600 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fc_speed_800: u8 = unsafe { ::core::mem::transmute(fc_speed_800) };
            fc_speed_800 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let fc_speed_1200: u8 = unsafe { ::core::mem::transmute(fc_speed_1200) };
            fc_speed_1200 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_ext {
    pub options: __be16,
    pub br_max: u8_,
    pub br_min: u8_,
    pub vendor_sn: [::aya_bpf_cty::c_char; 16usize],
    pub datecode: [::aya_bpf_cty::c_char; 8usize],
    pub diagmon: u8_,
    pub enhopts: u8_,
    pub sff8472_compliance: u8_,
    pub cc_ext: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_eeprom_id {
    pub base: sfp_eeprom_base,
    pub ext: sfp_eeprom_ext,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_upstream_ops {
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void, arg2: *mut sfp_bus),
    >,
    pub detach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void, arg2: *mut sfp_bus),
    >,
    pub module_insert: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_void,
            arg2: *const sfp_eeprom_id,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub module_remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub module_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
    >,
    pub module_stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub link_down: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub link_up: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
    pub connect_phy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_void,
            arg2: *mut phy_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub disconnect_phy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_bus {
    pub kref: kref,
    pub node: list_head,
    pub fwnode: *mut fwnode_handle,
    pub socket_ops: *const sfp_socket_ops,
    pub sfp_dev: *mut device,
    pub sfp: *mut sfp,
    pub sfp_quirk: *const sfp_quirk,
    pub upstream_ops: *const sfp_upstream_ops,
    pub upstream: *mut ::aya_bpf_cty::c_void,
    pub phydev: *mut phy_device,
    pub registered: bool_,
    pub started: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_socket_ops {
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sfp, arg2: *mut ethtool_modinfo) -> ::aya_bpf_cty::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sfp,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_quirk {
    pub vendor: *const ::aya_bpf_cty::c_char,
    pub part: *const ::aya_bpf_cty::c_char,
    pub modes: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sfp_eeprom_id, arg2: *mut ::aya_bpf_cty::c_ulong),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_dissector {
    pub used_keys: ::aya_bpf_cty::c_uint,
    pub offset: [::aya_bpf_cty::c_ushort; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack {
    pub use_: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmpin {
    pub user: *mut user_struct,
    pub num_pg: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info {
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ubuf_info, arg2: bool_)>,
    pub __bindgen_anon_1: ubuf_info__bindgen_ty_1,
    pub refcnt: refcount_t,
    pub mmp: mmpin,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ubuf_info__bindgen_ty_1 {
    pub __bindgen_anon_1: ubuf_info__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ubuf_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ubuf_info__bindgen_ty_1__bindgen_ty_1 {
    pub desc: ::aya_bpf_cty::c_ulong,
    pub ctx: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ubuf_info__bindgen_ty_1__bindgen_ty_2 {
    pub id: u32_,
    pub len: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bytelen: u32_,
}
impl ubuf_info__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn zerocopy(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_zerocopy(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(zerocopy: u16_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zerocopy: u16 = unsafe { ::core::mem::transmute(zerocopy) };
            zerocopy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_tunnel_parm {
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub link: ::aya_bpf_cty::c_int,
    pub i_flags: __be16,
    pub o_flags: __be16,
    pub i_key: __be32,
    pub o_key: __be32,
    pub iph: iphdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_dev {
    pub wpan_phy: *mut wpan_phy,
    pub iftype: ::aya_bpf_cty::c_int,
    pub list: list_head,
    pub netdev: *mut net_device,
    pub header_ops: *const wpan_dev_header_ops,
    pub lowpan_dev: *mut net_device,
    pub identifier: u32_,
    pub pan_id: __le16,
    pub short_addr: __le16,
    pub extended_addr: __le64,
    pub bsn: atomic_t,
    pub dsn: atomic_t,
    pub min_be: u8_,
    pub max_be: u8_,
    pub csma_retries: u8_,
    pub frame_retries: s8,
    pub lbt: bool_,
    pub promiscuous_mode: bool_,
    pub ackreq: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct lwtunnel_state {
    pub type_: __u16,
    pub flags: __u16,
    pub headroom: __u16,
    pub refcnt: atomic_t,
    pub orig_output: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub orig_input:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf_cty::c_int>,
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh {
    pub nh_common: fib_nh_common,
    pub nh_hash: hlist_node,
    pub nh_parent: *mut fib_info,
    pub nh_tclassid: __u32,
    pub nh_saddr: __be32,
    pub nh_saddr_genid: ::aya_bpf_cty::c_int,
}
#[repr(C)]
pub struct fib_info {
    pub fib_hash: hlist_node,
    pub fib_lhash: hlist_node,
    pub nh_list: list_head,
    pub fib_net: *mut net,
    pub fib_treeref: ::aya_bpf_cty::c_int,
    pub fib_clntref: refcount_t,
    pub fib_flags: ::aya_bpf_cty::c_uint,
    pub fib_dead: ::aya_bpf_cty::c_uchar,
    pub fib_protocol: ::aya_bpf_cty::c_uchar,
    pub fib_scope: ::aya_bpf_cty::c_uchar,
    pub fib_type: ::aya_bpf_cty::c_uchar,
    pub fib_prefsrc: __be32,
    pub fib_tb_id: u32_,
    pub fib_priority: u32_,
    pub fib_metrics: *mut dst_metrics,
    pub fib_nhs: ::aya_bpf_cty::c_int,
    pub fib_nh_is_v6: bool_,
    pub nh_updated: bool_,
    pub nh: *mut nexthop,
    pub rcu: callback_head,
    pub fib_nh: __IncompleteArrayField<fib_nh>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nexthop {
    pub rb_node: rb_node,
    pub fi_list: list_head,
    pub f6i_list: list_head,
    pub fdb_list: list_head,
    pub grp_list: list_head,
    pub net: *mut net,
    pub id: u32_,
    pub protocol: u8_,
    pub nh_flags: u8_,
    pub is_group: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub __bindgen_anon_1: nexthop__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nexthop__bindgen_ty_1 {
    pub nh_info: *mut nh_info,
    pub nh_grp: *mut nh_group,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nh_info {
    pub dev_hash: hlist_node,
    pub nh_parent: *mut nexthop,
    pub family: u8_,
    pub reject_nh: bool_,
    pub fdb_nh: bool_,
    pub __bindgen_anon_1: nh_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nh_info__bindgen_ty_1 {
    pub fib_nhc: fib_nh_common,
    pub fib_nh: fib_nh,
    pub fib6_nh: fib6_nh,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nh_grp_entry {
    pub nh: *mut nexthop,
    pub weight: u8_,
    pub upper_bound: atomic_t,
    pub nh_list: list_head,
    pub nh_parent: *mut nexthop,
}
#[repr(C)]
#[derive(Debug)]
pub struct nh_group {
    pub spare: *mut nh_group,
    pub num_nh: u16_,
    pub mpath: bool_,
    pub fdb_nh: bool_,
    pub has_v4: bool_,
    pub nh_entries: __IncompleteArrayField<nh_grp_entry>,
}
pub mod nl802154_cca_modes {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const __NL802154_CCA_INVALID: Type = 0;
    pub const NL802154_CCA_ENERGY: Type = 1;
    pub const NL802154_CCA_CARRIER: Type = 2;
    pub const NL802154_CCA_ENERGY_CARRIER: Type = 3;
    pub const NL802154_CCA_ALOHA: Type = 4;
    pub const NL802154_CCA_UWB_SHR: Type = 5;
    pub const NL802154_CCA_UWB_MULTIPLEXED: Type = 6;
    pub const __NL802154_CCA_ATTR_AFTER_LAST: Type = 7;
    pub const NL802154_CCA_ATTR_MAX: Type = 6;
}
pub mod nl802154_cca_opts {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL802154_CCA_OPT_ENERGY_CARRIER_AND: Type = 0;
    pub const NL802154_CCA_OPT_ENERGY_CARRIER_OR: Type = 1;
    pub const __NL802154_CCA_OPT_ATTR_AFTER_LAST: Type = 2;
    pub const NL802154_CCA_OPT_ATTR_MAX: Type = 1;
}
pub mod nl802154_supported_bool_states {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL802154_SUPPORTED_BOOL_FALSE: Type = 0;
    pub const NL802154_SUPPORTED_BOOL_TRUE: Type = 1;
    pub const __NL802154_SUPPORTED_BOOL_INVALD: Type = 2;
    pub const NL802154_SUPPORTED_BOOL_BOTH: Type = 3;
    pub const __NL802154_SUPPORTED_BOOL_AFTER_LAST: Type = 4;
    pub const NL802154_SUPPORTED_BOOL_MAX: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_phy_supported {
    pub channels: [u32_; 32usize],
    pub cca_modes: u32_,
    pub cca_opts: u32_,
    pub iftypes: u32_,
    pub lbt: nl802154_supported_bool_states::Type,
    pub min_minbe: u8_,
    pub max_minbe: u8_,
    pub min_maxbe: u8_,
    pub max_maxbe: u8_,
    pub min_csma_backoffs: u8_,
    pub max_csma_backoffs: u8_,
    pub min_frame_retries: s8,
    pub max_frame_retries: s8,
    pub tx_powers_size: size_t,
    pub cca_ed_levels_size: size_t,
    pub tx_powers: *const s32,
    pub cca_ed_levels: *const s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_phy_cca {
    pub mode: nl802154_cca_modes::Type,
    pub opt: nl802154_cca_opts::Type,
}
#[repr(C)]
pub struct wpan_phy {
    pub privid: *const ::aya_bpf_cty::c_void,
    pub flags: u32_,
    pub current_channel: u8_,
    pub current_page: u8_,
    pub supported: wpan_phy_supported,
    pub transmit_power: s32,
    pub cca: wpan_phy_cca,
    pub perm_extended_addr: __le64,
    pub cca_ed_level: s32,
    pub symbol_duration: u8_,
    pub lifs_period: u16_,
    pub sifs_period: u16_,
    pub dev: device,
    pub _net: possible_net_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub priv_: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
impl wpan_phy {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee802154_addr {
    pub mode: u8_,
    pub pan_id: __le16,
    pub __bindgen_anon_1: ieee802154_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ieee802154_addr__bindgen_ty_1 {
    pub short_addr: __le16,
    pub extended_addr: __le64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_dev_header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *const ieee802154_addr,
            arg4: *const ieee802154_addr,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuidle_state_kobj {
    pub state: *mut cpuidle_state,
    pub state_usage: *mut cpuidle_state_usage,
    pub kobj_unregister: completion,
    pub kobj: kobject,
    pub device: *mut cpuidle_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuidle_device_kobj {
    pub dev: *mut cpuidle_device,
    pub kobj_unregister: completion,
    pub kobj: kobject,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libipw_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_public_data {
    pub spy_data: *mut iw_spy_data,
    pub libipw: *mut libipw_device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_param {
    pub value: __s32,
    pub fixed: __u8,
    pub disabled: __u8,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_point {
    pub pointer: *mut ::aya_bpf_cty::c_void,
    pub length: __u16,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_freq {
    pub m: __s32,
    pub e: __s16,
    pub i: __u8,
    pub flags: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_quality {
    pub qual: __u8,
    pub level: __u8,
    pub noise: __u8,
    pub updated: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_discarded {
    pub nwid: __u32,
    pub code: __u32,
    pub fragment: __u32,
    pub retries: __u32,
    pub misc: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_missed {
    pub beacon: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_statistics {
    pub status: __u16,
    pub qual: iw_quality,
    pub discard: iw_discarded,
    pub miss: iw_missed,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iwreq_data {
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub essid: iw_point,
    pub nwid: iw_param,
    pub freq: iw_freq,
    pub sens: iw_param,
    pub bitrate: iw_param,
    pub txpower: iw_param,
    pub rts: iw_param,
    pub frag: iw_param,
    pub mode: __u32,
    pub retry: iw_param,
    pub encoding: iw_point,
    pub power: iw_param,
    pub qual: iw_quality,
    pub ap_addr: sockaddr,
    pub addr: sockaddr,
    pub param: iw_param,
    pub data: iw_point,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_priv_args {
    pub cmd: __u32,
    pub set_args: __u16,
    pub get_args: __u16,
    pub name: [::aya_bpf_cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_request_info {
    pub cmd: __u16,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iw_spy_data {
    pub spy_number: ::aya_bpf_cty::c_int,
    pub spy_address: [u_char; 48usize],
    pub spy_stat: [iw_quality; 8usize],
    pub spy_thr_low: iw_quality,
    pub spy_thr_high: iw_quality,
    pub spy_thr_under: [u_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prot_inuse {
    pub val: [::aya_bpf_cty::c_int; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fastopen_queue {
    pub rskq_rst_head: *mut request_sock,
    pub rskq_rst_tail: *mut request_sock,
    pub lock: spinlock_t,
    pub qlen: ::aya_bpf_cty::c_int,
    pub max_qlen: ::aya_bpf_cty::c_int,
    pub ctx: *mut tcp_fastopen_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_sock_queue {
    pub rskq_lock: spinlock_t,
    pub rskq_defer_accept: u8_,
    pub synflood_warned: u32_,
    pub qlen: atomic_t,
    pub young: atomic_t,
    pub rskq_accept_head: *mut request_sock,
    pub rskq_accept_tail: *mut request_sock,
    pub fastopenq: fastopen_queue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_connection_sock_af_ops {
    pub queue_xmit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sk_buff,
            arg3: *mut flowi,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub send_check:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff)>,
    pub rebuild_header:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>,
    pub sk_rx_dst_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const sk_buff)>,
    pub conn_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub syn_recv_sock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sock,
            arg2: *mut sk_buff,
            arg3: *mut request_sock,
            arg4: *mut dst_entry,
            arg5: *mut request_sock,
            arg6: *mut bool_,
        ) -> *mut sock,
    >,
    pub net_header_len: u16_,
    pub net_frag_header_len: u16_,
    pub sockaddr_len: u16_,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: sockptr_t,
            arg5: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: *mut ::aya_bpf_cty::c_char,
            arg5: *mut ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub addr2sockaddr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sockaddr)>,
    pub mtu_reduced: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
}
#[repr(C)]
pub struct inet_connection_sock {
    pub icsk_inet: inet_sock,
    pub icsk_accept_queue: request_sock_queue,
    pub icsk_bind_hash: *mut inet_bind_bucket,
    pub icsk_timeout: ::aya_bpf_cty::c_ulong,
    pub icsk_retransmit_timer: timer_list,
    pub icsk_delack_timer: timer_list,
    pub icsk_rto: __u32,
    pub icsk_rto_min: __u32,
    pub icsk_delack_max: __u32,
    pub icsk_pmtu_cookie: __u32,
    pub icsk_ca_ops: *const tcp_congestion_ops,
    pub icsk_af_ops: *const inet_connection_sock_af_ops,
    pub icsk_ulp_ops: *const tcp_ulp_ops,
    pub icsk_ulp_data: *mut ::aya_bpf_cty::c_void,
    pub icsk_clean_acked: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_)>,
    pub icsk_listen_portaddr_node: hlist_node,
    pub icsk_sync_mss: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: u32_) -> ::aya_bpf_cty::c_uint,
    >,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub icsk_retransmits: __u8,
    pub icsk_pending: __u8,
    pub icsk_backoff: __u8,
    pub icsk_syn_retries: __u8,
    pub icsk_probes_out: __u8,
    pub icsk_ext_hdr_len: __u16,
    pub icsk_ack: inet_connection_sock__bindgen_ty_1,
    pub icsk_mtup: inet_connection_sock__bindgen_ty_2,
    pub icsk_probes_tstamp: u32_,
    pub icsk_user_timeout: u32_,
    pub icsk_ca_priv: [u64_; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_connection_sock__bindgen_ty_1 {
    pub pending: __u8,
    pub quick: __u8,
    pub pingpong: __u8,
    pub retry: __u8,
    pub ato: __u32,
    pub timeout: ::aya_bpf_cty::c_ulong,
    pub lrcvtime: __u32,
    pub last_seg_size: __u16,
    pub rcv_mss: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_connection_sock__bindgen_ty_2 {
    pub enabled: ::aya_bpf_cty::c_int,
    pub search_high: ::aya_bpf_cty::c_int,
    pub search_low: ::aya_bpf_cty::c_int,
    pub probe_size: ::aya_bpf_cty::c_int,
    pub probe_timestamp: u32_,
}
impl inet_connection_sock {
    #[inline]
    pub fn icsk_ca_state(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_state(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_initialized(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_initialized(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_setsockopt(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_setsockopt(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_dst_locked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_dst_locked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        icsk_ca_state: __u8,
        icsk_ca_initialized: __u8,
        icsk_ca_setsockopt: __u8,
        icsk_ca_dst_locked: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let icsk_ca_state: u8 = unsafe { ::core::mem::transmute(icsk_ca_state) };
            icsk_ca_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let icsk_ca_initialized: u8 = unsafe { ::core::mem::transmute(icsk_ca_initialized) };
            icsk_ca_initialized as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let icsk_ca_setsockopt: u8 = unsafe { ::core::mem::transmute(icsk_ca_setsockopt) };
            icsk_ca_setsockopt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let icsk_ca_dst_locked: u8 = unsafe { ::core::mem::transmute(icsk_ca_dst_locked) };
            icsk_ca_dst_locked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind_bucket {
    pub ib_net: possible_net_t,
    pub l3mdev: ::aya_bpf_cty::c_int,
    pub port: ::aya_bpf_cty::c_ushort,
    pub fastreuse: ::aya_bpf_cty::c_schar,
    pub fastreuseport: ::aya_bpf_cty::c_schar,
    pub fastuid: kuid_t,
    pub fast_v6_rcv_saddr: in6_addr,
    pub fast_rcv_saddr: __be32,
    pub fast_sk_family: ::aya_bpf_cty::c_ushort,
    pub fast_ipv6_only: bool_,
    pub node: hlist_node,
    pub owners: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_ulp_ops {
    pub list: list_head,
    pub init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut proto,
            arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
        ),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub get_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub get_info_size: ::core::option::Option<unsafe extern "C" fn(arg1: *const sock) -> size_t>,
    pub clone: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const request_sock, arg2: *mut sock, arg3: gfp_t),
    >,
    pub name: [::aya_bpf_cty::c_char; 16usize],
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_fastopen_cookie {
    pub val: [__le64; 2usize],
    pub len: s8,
    pub exp: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_sack_block {
    pub start_seq: u32_,
    pub end_seq: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_options_received {
    pub ts_recent_stamp: ::aya_bpf_cty::c_int,
    pub ts_recent: u32_,
    pub rcv_tsval: u32_,
    pub rcv_tsecr: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub num_sacks: u8_,
    pub user_mss: u16_,
    pub mss_clamp: u16_,
}
impl tcp_options_received {
    #[inline]
    pub fn saw_tstamp(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_saw_tstamp(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dsack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wscale_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_wscale_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sack_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_sack_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn smc_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_smc_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn snd_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_snd_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rcv_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rcv_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn saw_unknown(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_saw_unknown(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        saw_tstamp: u16_,
        tstamp_ok: u16_,
        dsack: u16_,
        wscale_ok: u16_,
        sack_ok: u16_,
        smc_ok: u16_,
        snd_wscale: u16_,
        rcv_wscale: u16_,
        saw_unknown: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let saw_tstamp: u16 = unsafe { ::core::mem::transmute(saw_tstamp) };
            saw_tstamp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
            tstamp_ok as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dsack: u16 = unsafe { ::core::mem::transmute(dsack) };
            dsack as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
            wscale_ok as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
            sack_ok as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
            smc_ok as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
            snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
            rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let saw_unknown: u8 = unsafe { ::core::mem::transmute(saw_unknown) };
            saw_unknown as u64
        });
        __bindgen_bitfield_unit.set(17usize, 7u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_rack {
    pub mstamp: u64_,
    pub rtt_us: u32_,
    pub end_seq: u32_,
    pub last_delivered: u32_,
    pub reo_wnd_steps: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl tcp_rack {
    #[inline]
    pub fn reo_wnd_persist(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reo_wnd_persist(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dsack_seen(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dsack_seen(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn advanced(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_advanced(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reo_wnd_persist: u8_,
        dsack_seen: u8_,
        advanced: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let reo_wnd_persist: u8 = unsafe { ::core::mem::transmute(reo_wnd_persist) };
            reo_wnd_persist as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsack_seen: u8 = unsafe { ::core::mem::transmute(dsack_seen) };
            dsack_seen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let advanced: u8 = unsafe { ::core::mem::transmute(advanced) };
            advanced as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp_sock {
    pub inet_conn: inet_connection_sock,
    pub tcp_header_len: u16_,
    pub gso_segs: u16_,
    pub pred_flags: __be32,
    pub bytes_received: u64_,
    pub segs_in: u32_,
    pub data_segs_in: u32_,
    pub rcv_nxt: u32_,
    pub copied_seq: u32_,
    pub rcv_wup: u32_,
    pub snd_nxt: u32_,
    pub segs_out: u32_,
    pub data_segs_out: u32_,
    pub bytes_sent: u64_,
    pub bytes_acked: u64_,
    pub dsack_dups: u32_,
    pub snd_una: u32_,
    pub snd_sml: u32_,
    pub rcv_tstamp: u32_,
    pub lsndtime: u32_,
    pub last_oow_ack_time: u32_,
    pub compressed_ack_rcv_nxt: u32_,
    pub tsoffset: u32_,
    pub tsq_node: list_head,
    pub tsorted_sent_queue: list_head,
    pub snd_wl1: u32_,
    pub snd_wnd: u32_,
    pub max_window: u32_,
    pub mss_cache: u32_,
    pub window_clamp: u32_,
    pub rcv_ssthresh: u32_,
    pub rack: tcp_rack,
    pub advmss: u16_,
    pub compressed_ack: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub chrono_start: u32_,
    pub chrono_stat: [u32_; 3usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub repair_queue: u8_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tlp_high_seq: u32_,
    pub tcp_tx_delay: u32_,
    pub tcp_wstamp_ns: u64_,
    pub tcp_clock_cache: u64_,
    pub tcp_mstamp: u64_,
    pub srtt_us: u32_,
    pub mdev_us: u32_,
    pub mdev_max_us: u32_,
    pub rttvar_us: u32_,
    pub rtt_seq: u32_,
    pub rtt_min: minmax,
    pub packets_out: u32_,
    pub retrans_out: u32_,
    pub max_packets_out: u32_,
    pub max_packets_seq: u32_,
    pub urg_data: u16_,
    pub ecn_flags: u8_,
    pub keepalive_probes: u8_,
    pub reordering: u32_,
    pub reord_seen: u32_,
    pub snd_up: u32_,
    pub rx_opt: tcp_options_received,
    pub snd_ssthresh: u32_,
    pub snd_cwnd: u32_,
    pub snd_cwnd_cnt: u32_,
    pub snd_cwnd_clamp: u32_,
    pub snd_cwnd_used: u32_,
    pub snd_cwnd_stamp: u32_,
    pub prior_cwnd: u32_,
    pub prr_delivered: u32_,
    pub prr_out: u32_,
    pub delivered: u32_,
    pub delivered_ce: u32_,
    pub lost: u32_,
    pub app_limited: u32_,
    pub first_tx_mstamp: u64_,
    pub delivered_mstamp: u64_,
    pub rate_delivered: u32_,
    pub rate_interval_us: u32_,
    pub rcv_wnd: u32_,
    pub write_seq: u32_,
    pub notsent_lowat: u32_,
    pub pushed_seq: u32_,
    pub lost_out: u32_,
    pub sacked_out: u32_,
    pub pacing_timer: hrtimer,
    pub compressed_ack_timer: hrtimer,
    pub lost_skb_hint: *mut sk_buff,
    pub retransmit_skb_hint: *mut sk_buff,
    pub out_of_order_queue: rb_root,
    pub ooo_last_skb: *mut sk_buff,
    pub duplicate_sack: [tcp_sack_block; 1usize],
    pub selective_acks: [tcp_sack_block; 4usize],
    pub recv_sack_cache: [tcp_sack_block; 4usize],
    pub highest_sack: *mut sk_buff,
    pub lost_cnt_hint: ::aya_bpf_cty::c_int,
    pub prior_ssthresh: u32_,
    pub high_seq: u32_,
    pub retrans_stamp: u32_,
    pub undo_marker: u32_,
    pub undo_retrans: ::aya_bpf_cty::c_int,
    pub bytes_retrans: u64_,
    pub total_retrans: u32_,
    pub urg_seq: u32_,
    pub keepalive_time: ::aya_bpf_cty::c_uint,
    pub keepalive_intvl: ::aya_bpf_cty::c_uint,
    pub linger2: ::aya_bpf_cty::c_int,
    pub bpf_sock_ops_cb_flags: u8_,
    pub timeout_rehash: u16_,
    pub rcv_ooopack: u32_,
    pub rcv_rtt_last_tsecr: u32_,
    pub rcv_rtt_est: tcp_sock__bindgen_ty_1,
    pub rcvq_space: tcp_sock__bindgen_ty_2,
    pub mtu_probe: tcp_sock__bindgen_ty_3,
    pub mtu_info: u32_,
    pub is_mptcp: bool_,
    pub syn_smc: bool_,
    pub af_specific: *const tcp_sock_af_ops,
    pub md5sig_info: *mut tcp_md5sig_info,
    pub fastopen_req: *mut tcp_fastopen_request,
    pub fastopen_rsk: *mut request_sock,
    pub saved_syn: *mut saved_syn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_1 {
    pub rtt_us: u32_,
    pub seq: u32_,
    pub time: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_2 {
    pub space: u32_,
    pub seq: u32_,
    pub time: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_3 {
    pub probe_seq_start: u32_,
    pub probe_seq_end: u32_,
}
impl tcp_sock {
    #[inline]
    pub fn dup_ack_counter(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dup_ack_counter(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tlp_retrans(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tlp_retrans(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dup_ack_counter: u8_,
        tlp_retrans: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dup_ack_counter: u8 = unsafe { ::core::mem::transmute(dup_ack_counter) };
            dup_ack_counter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tlp_retrans: u8 = unsafe { ::core::mem::transmute(tlp_retrans) };
            tlp_retrans as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn chrono_type(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_chrono_type(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rate_app_limited(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rate_app_limited(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_connect(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_connect(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_no_cookie(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_no_cookie(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sack_reneg(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sack_reneg(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_client_fail(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_client_fail(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nonagle(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_nonagle(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn thin_lto(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_thin_lto(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recvmsg_inq(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recvmsg_inq(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repair(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_repair(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frto(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frto(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        chrono_type: u8_,
        rate_app_limited: u8_,
        fastopen_connect: u8_,
        fastopen_no_cookie: u8_,
        is_sack_reneg: u8_,
        fastopen_client_fail: u8_,
        nonagle: u8_,
        thin_lto: u8_,
        recvmsg_inq: u8_,
        repair: u8_,
        frto: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chrono_type: u8 = unsafe { ::core::mem::transmute(chrono_type) };
            chrono_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rate_app_limited: u8 = unsafe { ::core::mem::transmute(rate_app_limited) };
            rate_app_limited as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fastopen_connect: u8 = unsafe { ::core::mem::transmute(fastopen_connect) };
            fastopen_connect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fastopen_no_cookie: u8 = unsafe { ::core::mem::transmute(fastopen_no_cookie) };
            fastopen_no_cookie as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_sack_reneg: u8 = unsafe { ::core::mem::transmute(is_sack_reneg) };
            is_sack_reneg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fastopen_client_fail: u8 = unsafe { ::core::mem::transmute(fastopen_client_fail) };
            fastopen_client_fail as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let nonagle: u8 = unsafe { ::core::mem::transmute(nonagle) };
            nonagle as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let thin_lto: u8 = unsafe { ::core::mem::transmute(thin_lto) };
            thin_lto as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let recvmsg_inq: u8 = unsafe { ::core::mem::transmute(recvmsg_inq) };
            recvmsg_inq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let repair: u8 = unsafe { ::core::mem::transmute(repair) };
            repair as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let frto: u8 = unsafe { ::core::mem::transmute(frto) };
            frto as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn save_syn(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_save_syn(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_data(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_data(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen_exp(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen_exp(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen_ch(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen_ch(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_data_acked(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_data_acked(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cwnd_limited(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_cwnd_limited(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        save_syn: u8_,
        syn_data: u8_,
        syn_fastopen: u8_,
        syn_fastopen_exp: u8_,
        syn_fastopen_ch: u8_,
        syn_data_acked: u8_,
        is_cwnd_limited: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let save_syn: u8 = unsafe { ::core::mem::transmute(save_syn) };
            save_syn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let syn_data: u8 = unsafe { ::core::mem::transmute(syn_data) };
            syn_data as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let syn_fastopen: u8 = unsafe { ::core::mem::transmute(syn_fastopen) };
            syn_fastopen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let syn_fastopen_exp: u8 = unsafe { ::core::mem::transmute(syn_fastopen_exp) };
            syn_fastopen_exp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let syn_fastopen_ch: u8 = unsafe { ::core::mem::transmute(syn_fastopen_ch) };
            syn_fastopen_ch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let syn_data_acked: u8 = unsafe { ::core::mem::transmute(syn_data_acked) };
            syn_data_acked as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_cwnd_limited: u8 = unsafe { ::core::mem::transmute(is_cwnd_limited) };
            is_cwnd_limited as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_sock_af_ops {
    pub md5_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *const sock) -> *mut tcp_md5sig_key,
    >,
    pub calc_md5_hash: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_char,
            arg2: *const tcp_md5sig_key,
            arg3: *const sock,
            arg4: *const sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub md5_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf_cty::c_int,
            arg3: sockptr_t,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig_info {
    pub head: hlist_head,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_fastopen_request {
    pub cookie: tcp_fastopen_cookie,
    pub data: *mut msghdr,
    pub size: size_t,
    pub copied: ::aya_bpf_cty::c_int,
    pub uarg: *mut ubuf_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_md5_addr {
    pub a4: in_addr,
    pub a6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig_key {
    pub node: hlist_node,
    pub keylen: u8_,
    pub family: u8_,
    pub prefixlen: u8_,
    pub addr: tcp_md5_addr,
    pub l3index: ::aya_bpf_cty::c_int,
    pub key: [u8_; 80usize],
    pub rcu: callback_head,
}
#[repr(C)]
pub struct inet_request_sock {
    pub req: request_sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub ir_mark: u32_,
    pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_request_sock__bindgen_ty_1 {
    pub ireq_opt: *mut ip_options_rcu,
    pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_request_sock__bindgen_ty_1__bindgen_ty_1 {
    pub ipv6_opt: *mut ipv6_txoptions,
    pub pktopts: *mut sk_buff,
}
impl inet_request_sock {
    #[inline]
    pub fn snd_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_snd_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rcv_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rcv_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sack_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sack_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wscale_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_wscale_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ecn_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ecn_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acked(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_acked(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_srccheck(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_no_srccheck(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smc_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_smc_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        snd_wscale: u16_,
        rcv_wscale: u16_,
        tstamp_ok: u16_,
        sack_ok: u16_,
        wscale_ok: u16_,
        ecn_ok: u16_,
        acked: u16_,
        no_srccheck: u16_,
        smc_ok: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
            snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
            rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
            tstamp_ok as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
            sack_ok as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
            wscale_ok as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ecn_ok: u16 = unsafe { ::core::mem::transmute(ecn_ok) };
            ecn_ok as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let acked: u16 = unsafe { ::core::mem::transmute(acked) };
            acked as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let no_srccheck: u16 = unsafe { ::core::mem::transmute(no_srccheck) };
            no_srccheck as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
            smc_ok as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp_request_sock {
    pub req: inet_request_sock,
    pub af_specific: *const tcp_request_sock_ops,
    pub snt_synack: u64_,
    pub tfo_listener: bool_,
    pub is_mptcp: bool_,
    pub drop_req: bool_,
    pub txhash: u32_,
    pub rcv_isn: u32_,
    pub snt_isn: u32_,
    pub ts_off: u32_,
    pub last_oow_ack_time: u32_,
    pub rcv_nxt: u32_,
    pub syn_tos: u8_,
}
pub mod tcp_synack_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const TCP_SYNACK_NORMAL: Type = 0;
    pub const TCP_SYNACK_FASTOPEN: Type = 1;
    pub const TCP_SYNACK_COOKIE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_request_sock_ops {
    pub mss_clamp: u16_,
    pub req_md5_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *const sock) -> *mut tcp_md5sig_key,
    >,
    pub calc_md5_hash: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf_cty::c_char,
            arg2: *const tcp_md5sig_key,
            arg3: *const sock,
            arg4: *const sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cookie_init_seq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut __u16) -> __u32,
    >,
    pub route_req: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sock,
            arg2: *mut sk_buff,
            arg3: *mut flowi,
            arg4: *mut request_sock,
        ) -> *mut dst_entry,
    >,
    pub init_seq: ::core::option::Option<unsafe extern "C" fn(arg1: *const sk_buff) -> u32_>,
    pub init_ts_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net, arg2: *const sk_buff) -> u32_,
    >,
    pub send_synack: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sock,
            arg2: *mut dst_entry,
            arg3: *mut flowi,
            arg4: *mut request_sock,
            arg5: *mut tcp_fastopen_cookie,
            arg6: tcp_synack_type::Type,
            arg7: *mut sk_buff,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdisc_walker {
    pub stop: ::aya_bpf_cty::c_int,
    pub skip: ::aya_bpf_cty::c_int,
    pub count: ::aya_bpf_cty::c_int,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf_cty::c_ulong,
            arg3: *mut qdisc_walker,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_rate_estimator {
    pub bstats: *mut gnet_stats_basic_packed,
    pub stats_lock: *mut spinlock_t,
    pub running: *mut seqcount_t,
    pub cpu_bstats: *mut gnet_stats_basic_cpu,
    pub ewma_log: u8_,
    pub intvl_log: u8_,
    pub seq: seqcount_t,
    pub last_packets: u64_,
    pub last_bytes: u64_,
    pub avpps: u64_,
    pub avbps: u64_,
    pub next_jiffies: ::aya_bpf_cty::c_ulong,
    pub timer: timer_list,
    pub rcu: callback_head,
}
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xt_table {
    pub list: list_head,
    pub valid_hooks: ::aya_bpf_cty::c_uint,
    pub private: *mut xt_table_info,
    pub me: *mut module,
    pub af: u_int8_t,
    pub priority: ::aya_bpf_cty::c_int,
    pub table_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net) -> ::aya_bpf_cty::c_int>,
    pub name: [::aya_bpf_cty::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_tcp_state {
    pub td_end: u_int32_t,
    pub td_maxend: u_int32_t,
    pub td_maxwin: u_int32_t,
    pub td_maxack: u_int32_t,
    pub td_scale: u_int8_t,
    pub flags: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_tcp {
    pub seen: [ip_ct_tcp_state; 2usize],
    pub state: u_int8_t,
    pub last_dir: u_int8_t,
    pub retrans: u_int8_t,
    pub last_index: u_int8_t,
    pub last_seq: u_int32_t,
    pub last_ack: u_int32_t,
    pub last_end: u_int32_t,
    pub last_win: u_int16_t,
    pub last_wscale: u_int8_t,
    pub last_flags: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_man_proto {
    pub all: __be16,
    pub tcp: nf_conntrack_man_proto__bindgen_ty_1,
    pub udp: nf_conntrack_man_proto__bindgen_ty_2,
    pub icmp: nf_conntrack_man_proto__bindgen_ty_3,
    pub dccp: nf_conntrack_man_proto__bindgen_ty_4,
    pub sctp: nf_conntrack_man_proto__bindgen_ty_5,
    pub gre: nf_conntrack_man_proto__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_1 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_2 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_3 {
    pub id: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_4 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_5 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_6 {
    pub key: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_dccp {
    pub role: [u_int8_t; 2usize],
    pub state: u_int8_t,
    pub last_pkt: u_int8_t,
    pub last_dir: u_int8_t,
    pub handshake_seq: u_int64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_sctp {
    pub state: sctp_conntrack::Type,
    pub vtag: [__be32; 2usize],
    pub last_dir: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_event_notifier {
    pub fcn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf_cty::c_uint,
            arg2: *mut nf_ct_event,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_exp_event_notifier {
    pub fcn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf_cty::c_uint,
            arg2: *mut nf_exp_event,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
pub const BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: ::aya_bpf_cty::c_uint = 1;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: ::aya_bpf_cty::c_uint = 2;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: ::aya_bpf_cty::c_uint = 4;
pub type _bindgen_ty_433 = ::aya_bpf_cty::c_uint;
pub mod devlink_port_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_PORT_TYPE_NOTSET: Type = 0;
    pub const DEVLINK_PORT_TYPE_AUTO: Type = 1;
    pub const DEVLINK_PORT_TYPE_ETH: Type = 2;
    pub const DEVLINK_PORT_TYPE_IB: Type = 3;
}
pub mod devlink_port_flavour {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_PORT_FLAVOUR_PHYSICAL: Type = 0;
    pub const DEVLINK_PORT_FLAVOUR_CPU: Type = 1;
    pub const DEVLINK_PORT_FLAVOUR_DSA: Type = 2;
    pub const DEVLINK_PORT_FLAVOUR_PCI_PF: Type = 3;
    pub const DEVLINK_PORT_FLAVOUR_PCI_VF: Type = 4;
    pub const DEVLINK_PORT_FLAVOUR_VIRTUAL: Type = 5;
    pub const DEVLINK_PORT_FLAVOUR_UNUSED: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_phys_attrs {
    pub port_number: u32_,
    pub split_subport_number: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_pci_pf_attrs {
    pub controller: u32_,
    pub pf: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl devlink_port_pci_pf_attrs {
    #[inline]
    pub fn external(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(external: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_pci_vf_attrs {
    pub controller: u32_,
    pub pf: u16_,
    pub vf: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl devlink_port_pci_vf_attrs {
    #[inline]
    pub fn external(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(external: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_port_attrs {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub lanes: u32_,
    pub flavour: devlink_port_flavour::Type,
    pub switch_id: netdev_phys_item_id,
    pub __bindgen_anon_1: devlink_port_attrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_port_attrs__bindgen_ty_1 {
    pub phys: devlink_port_phys_attrs,
    pub pci_pf: devlink_port_pci_pf_attrs,
    pub pci_vf: devlink_port_pci_vf_attrs,
}
impl devlink_port_attrs {
    #[inline]
    pub fn split(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_split(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn splittable(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_splittable(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(split: u8_, splittable: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let split: u8 = unsafe { ::core::mem::transmute(split) };
            split as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let splittable: u8 = unsafe { ::core::mem::transmute(splittable) };
            splittable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_port {
    pub list: list_head,
    pub param_list: list_head,
    pub region_list: list_head,
    pub devlink: *mut devlink,
    pub index: ::aya_bpf_cty::c_uint,
    pub registered: bool_,
    pub type_lock: spinlock_t,
    pub type_: devlink_port_type::Type,
    pub desired_type: devlink_port_type::Type,
    pub type_dev: *mut ::aya_bpf_cty::c_void,
    pub attrs: devlink_port_attrs,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub type_warn_dw: delayed_work,
    pub reporter_list: list_head,
    pub reporters_lock: mutex,
}
impl devlink_port {
    #[inline]
    pub fn attrs_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_attrs_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn switch_port(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_switch_port(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(attrs_set: u8_, switch_port: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let attrs_set: u8 = unsafe { ::core::mem::transmute(attrs_set) };
            attrs_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let switch_port: u8 = unsafe { ::core::mem::transmute(switch_port) };
            switch_port as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod phylink_op_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const PHYLINK_NETDEV: Type = 0;
    pub const PHYLINK_DEV: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_config {
    pub dev: *mut device,
    pub type_: phylink_op_type::Type,
    pub pcs_poll: bool_,
    pub poll_fixed_state: bool_,
    pub get_fixed_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phylink_config, arg2: *mut phylink_link_state),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_port {
    pub __bindgen_anon_1: dsa_port__bindgen_ty_1,
    pub tag_ops: *const dsa_device_ops,
    pub dst: *mut dsa_switch_tree,
    pub rcv: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *mut packet_type,
        ) -> *mut sk_buff,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut net_device) -> bool_,
    >,
    pub type_: dsa_port__bindgen_ty_2::Type,
    pub ds: *mut dsa_switch,
    pub index: ::aya_bpf_cty::c_uint,
    pub name: *const ::aya_bpf_cty::c_char,
    pub cpu_dp: *mut dsa_port,
    pub mac: *const ::aya_bpf_cty::c_char,
    pub dn: *mut device_node,
    pub ageing_time: ::aya_bpf_cty::c_uint,
    pub vlan_filtering: bool_,
    pub stp_state: u8_,
    pub bridge_dev: *mut net_device,
    pub devlink_port: devlink_port,
    pub devlink_port_setup: bool_,
    pub pl: *mut phylink,
    pub pl_config: phylink_config,
    pub list: list_head,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub orig_ethtool_ops: *const ethtool_ops,
    pub netdev_ops: *const dsa_netdevice_ops,
    pub setup: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dsa_port__bindgen_ty_1 {
    pub master: *mut net_device,
    pub slave: *mut net_device,
}
pub mod dsa_port__bindgen_ty_2 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DSA_PORT_TYPE_UNUSED: Type = 0;
    pub const DSA_PORT_TYPE_CPU: Type = 1;
    pub const DSA_PORT_TYPE_DSA: Type = 2;
    pub const DSA_PORT_TYPE_USER: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_type {
    pub type_: __be16,
    pub ignore_outgoing: bool_,
    pub dev: *mut net_device,
    pub func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *mut packet_type,
            arg4: *mut net_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub list_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut list_head, arg2: *mut packet_type, arg3: *mut net_device),
    >,
    pub id_match: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut packet_type, arg2: *mut sock) -> bool_,
    >,
    pub af_packet_priv: *mut ::aya_bpf_cty::c_void,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_notifier_changeupper_info {
    pub info: netdev_notifier_info,
    pub upper_dev: *mut net_device,
    pub master: bool_,
    pub linking: bool_,
    pub upper_info: *mut ::aya_bpf_cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_match {
    pub dissector: *mut flow_dissector,
    pub mask: *mut ::aya_bpf_cty::c_void,
    pub key: *mut ::aya_bpf_cty::c_void,
}
pub mod flow_action_id {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FLOW_ACTION_ACCEPT: Type = 0;
    pub const FLOW_ACTION_DROP: Type = 1;
    pub const FLOW_ACTION_TRAP: Type = 2;
    pub const FLOW_ACTION_GOTO: Type = 3;
    pub const FLOW_ACTION_REDIRECT: Type = 4;
    pub const FLOW_ACTION_MIRRED: Type = 5;
    pub const FLOW_ACTION_REDIRECT_INGRESS: Type = 6;
    pub const FLOW_ACTION_MIRRED_INGRESS: Type = 7;
    pub const FLOW_ACTION_VLAN_PUSH: Type = 8;
    pub const FLOW_ACTION_VLAN_POP: Type = 9;
    pub const FLOW_ACTION_VLAN_MANGLE: Type = 10;
    pub const FLOW_ACTION_TUNNEL_ENCAP: Type = 11;
    pub const FLOW_ACTION_TUNNEL_DECAP: Type = 12;
    pub const FLOW_ACTION_MANGLE: Type = 13;
    pub const FLOW_ACTION_ADD: Type = 14;
    pub const FLOW_ACTION_CSUM: Type = 15;
    pub const FLOW_ACTION_MARK: Type = 16;
    pub const FLOW_ACTION_PTYPE: Type = 17;
    pub const FLOW_ACTION_PRIORITY: Type = 18;
    pub const FLOW_ACTION_WAKE: Type = 19;
    pub const FLOW_ACTION_QUEUE: Type = 20;
    pub const FLOW_ACTION_SAMPLE: Type = 21;
    pub const FLOW_ACTION_POLICE: Type = 22;
    pub const FLOW_ACTION_CT: Type = 23;
    pub const FLOW_ACTION_CT_METADATA: Type = 24;
    pub const FLOW_ACTION_MPLS_PUSH: Type = 25;
    pub const FLOW_ACTION_MPLS_POP: Type = 26;
    pub const FLOW_ACTION_MPLS_MANGLE: Type = 27;
    pub const FLOW_ACTION_GATE: Type = 28;
    pub const NUM_FLOW_ACTIONS: Type = 29;
}
pub mod flow_action_mangle_base {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FLOW_ACT_MANGLE_UNSPEC: Type = 0;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_ETH: Type = 1;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_IP4: Type = 2;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_IP6: Type = 3;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_TCP: Type = 4;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_UDP: Type = 5;
}
pub mod flow_action_hw_stats {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FLOW_ACTION_HW_STATS_IMMEDIATE: Type = 1;
    pub const FLOW_ACTION_HW_STATS_DELAYED: Type = 2;
    pub const FLOW_ACTION_HW_STATS_ANY: Type = 3;
    pub const FLOW_ACTION_HW_STATS_DISABLED: Type = 4;
    pub const FLOW_ACTION_HW_STATS_DONT_CARE: Type = 7;
}
pub type action_destr =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct flow_action_cookie {
    pub cookie_len: u32_,
    pub cookie: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_flowtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_key {
    pub tun_id: __be64,
    pub u: ip_tunnel_key__bindgen_ty_1,
    pub tun_flags: __be16,
    pub tos: u8_,
    pub ttl: u8_,
    pub label: __be32,
    pub tp_src: __be16,
    pub tp_dst: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_tunnel_key__bindgen_ty_1 {
    pub ipv4: ip_tunnel_key__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: ip_tunnel_key__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_tunnel_key__bindgen_ty_1__bindgen_ty_1 {
    pub src: __be32,
    pub dst: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_key__bindgen_ty_1__bindgen_ty_2 {
    pub src: in6_addr,
    pub dst: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_cache {
    pub cache: *mut dst_cache_pcpu,
    pub reset_ts: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_info {
    pub key: ip_tunnel_key,
    pub dst_cache: dst_cache,
    pub options_len: u8_,
    pub mode: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry {
    pub id: flow_action_id::Type,
    pub hw_stats: flow_action_hw_stats::Type,
    pub destructor: action_destr,
    pub destructor_priv: *mut ::aya_bpf_cty::c_void,
    pub __bindgen_anon_1: flow_action_entry__bindgen_ty_1,
    pub cookie: *mut flow_action_cookie,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_action_entry__bindgen_ty_1 {
    pub chain_index: u32_,
    pub dev: *mut net_device,
    pub vlan: flow_action_entry__bindgen_ty_1__bindgen_ty_1,
    pub mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_2,
    pub tunnel: *mut ip_tunnel_info,
    pub csum_flags: u32_,
    pub mark: u32_,
    pub ptype: u16_,
    pub priority: u32_,
    pub queue: flow_action_entry__bindgen_ty_1__bindgen_ty_3,
    pub sample: flow_action_entry__bindgen_ty_1__bindgen_ty_4,
    pub police: flow_action_entry__bindgen_ty_1__bindgen_ty_5,
    pub ct: flow_action_entry__bindgen_ty_1__bindgen_ty_6,
    pub ct_metadata: flow_action_entry__bindgen_ty_1__bindgen_ty_7,
    pub mpls_push: flow_action_entry__bindgen_ty_1__bindgen_ty_8,
    pub mpls_pop: flow_action_entry__bindgen_ty_1__bindgen_ty_9,
    pub mpls_mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_10,
    pub gate: flow_action_entry__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_1 {
    pub vid: u16_,
    pub proto: __be16,
    pub prio: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_2 {
    pub htype: flow_action_mangle_base::Type,
    pub offset: u32_,
    pub mask: u32_,
    pub val: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_3 {
    pub ctx: u32_,
    pub index: u32_,
    pub vf: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_4 {
    pub psample_group: *mut psample_group,
    pub rate: u32_,
    pub trunc_size: u32_,
    pub truncate: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_5 {
    pub index: u32_,
    pub burst: u32_,
    pub rate_bytes_ps: u64_,
    pub mtu: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6 {
    pub action: ::aya_bpf_cty::c_int,
    pub zone: u16_,
    pub flow_table: *mut nf_flowtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_7 {
    pub cookie: ::aya_bpf_cty::c_ulong,
    pub mark: u32_,
    pub labels: [u32_; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_8 {
    pub label: u32_,
    pub proto: __be16,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_9 {
    pub proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_10 {
    pub label: u32_,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_11 {
    pub index: u32_,
    pub prio: s32,
    pub basetime: u64_,
    pub cycletime: u64_,
    pub cycletimeext: u64_,
    pub num_entries: u32_,
    pub entries: *mut action_gate_entry,
}
#[repr(C)]
pub struct flow_action {
    pub num_entries: ::aya_bpf_cty::c_uint,
    pub entries: __IncompleteArrayField<flow_action_entry>,
}
#[repr(C)]
pub struct flow_rule {
    pub match_: flow_match,
    pub action: flow_action,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_stats {
    pub pkts: u64_,
    pub bytes: u64_,
    pub drops: u64_,
    pub lastused: u64_,
    pub used_hw_stats: flow_action_hw_stats::Type,
    pub used_hw_stats_valid: bool_,
}
pub mod flow_cls_command {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const FLOW_CLS_REPLACE: Type = 0;
    pub const FLOW_CLS_DESTROY: Type = 1;
    pub const FLOW_CLS_STATS: Type = 2;
    pub const FLOW_CLS_TMPLT_CREATE: Type = 3;
    pub const FLOW_CLS_TMPLT_DESTROY: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_cls_common_offload {
    pub chain_index: u32_,
    pub protocol: __be16,
    pub prio: u32_,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_cls_offload {
    pub common: flow_cls_common_offload,
    pub command: flow_cls_command::Type,
    pub cookie: ::aya_bpf_cty::c_ulong,
    pub rule: *mut flow_rule,
    pub stats: flow_stats,
    pub classid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_chip_data {
    pub host_dev: *mut device,
    pub sw_addr: ::aya_bpf_cty::c_int,
    pub netdev: [*mut device; 12usize],
    pub eeprom_len: ::aya_bpf_cty::c_int,
    pub of_node: *mut device_node,
    pub port_names: [*mut ::aya_bpf_cty::c_char; 12usize],
    pub port_dn: [*mut device_node; 12usize],
    pub rtable: [s8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_platform_data {
    pub netdev: *mut device,
    pub of_netdev: *mut net_device,
    pub nr_chips: ::aya_bpf_cty::c_int,
    pub chip: *mut dsa_chip_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_link_state {
    pub advertising: [::aya_bpf_cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf_cty::c_ulong; 2usize],
    pub interface: phy_interface_t::Type,
    pub speed: ::aya_bpf_cty::c_int,
    pub duplex: ::aya_bpf_cty::c_int,
    pub pause: ::aya_bpf_cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl phylink_link_state {
    #[inline]
    pub fn link(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn an_enabled(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_an_enabled(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn an_complete(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_an_complete(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link: ::aya_bpf_cty::c_uint,
        an_enabled: ::aya_bpf_cty::c_uint,
        an_complete: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let an_enabled: u32 = unsafe { ::core::mem::transmute(an_enabled) };
            an_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let an_complete: u32 = unsafe { ::core::mem::transmute(an_complete) };
            an_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod devlink_sb_pool_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_SB_POOL_TYPE_INGRESS: Type = 0;
    pub const DEVLINK_SB_POOL_TYPE_EGRESS: Type = 1;
}
pub mod devlink_sb_threshold_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_SB_THRESHOLD_TYPE_STATIC: Type = 0;
    pub const DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC: Type = 1;
}
pub mod devlink_eswitch_encap_mode {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_ESWITCH_ENCAP_MODE_NONE: Type = 0;
    pub const DEVLINK_ESWITCH_ENCAP_MODE_BASIC: Type = 1;
}
pub mod devlink_param_cmode {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_PARAM_CMODE_RUNTIME: Type = 0;
    pub const DEVLINK_PARAM_CMODE_DRIVERINIT: Type = 1;
    pub const DEVLINK_PARAM_CMODE_PERMANENT: Type = 2;
    pub const __DEVLINK_PARAM_CMODE_MAX: Type = 3;
    pub const DEVLINK_PARAM_CMODE_MAX: Type = 2;
}
pub mod devlink_trap_action {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_TRAP_ACTION_DROP: Type = 0;
    pub const DEVLINK_TRAP_ACTION_TRAP: Type = 1;
    pub const DEVLINK_TRAP_ACTION_MIRROR: Type = 2;
}
pub mod devlink_trap_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_TRAP_TYPE_DROP: Type = 0;
    pub const DEVLINK_TRAP_TYPE_EXCEPTION: Type = 1;
    pub const DEVLINK_TRAP_TYPE_CONTROL: Type = 2;
}
pub mod devlink_reload_action {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_RELOAD_ACTION_UNSPEC: Type = 0;
    pub const DEVLINK_RELOAD_ACTION_DRIVER_REINIT: Type = 1;
    pub const DEVLINK_RELOAD_ACTION_FW_ACTIVATE: Type = 2;
    pub const __DEVLINK_RELOAD_ACTION_MAX: Type = 3;
    pub const DEVLINK_RELOAD_ACTION_MAX: Type = 2;
}
pub mod devlink_reload_limit {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_RELOAD_LIMIT_UNSPEC: Type = 0;
    pub const DEVLINK_RELOAD_LIMIT_NO_RESET: Type = 1;
    pub const __DEVLINK_RELOAD_LIMIT_MAX: Type = 2;
    pub const DEVLINK_RELOAD_LIMIT_MAX: Type = 1;
}
pub mod devlink_dpipe_field_mapping_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE: Type = 0;
    pub const DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dev_stats {
    pub reload_stats: [u32_; 6usize],
    pub remote_reload_stats: [u32_; 6usize],
}
#[repr(C)]
pub struct devlink {
    pub list: list_head,
    pub port_list: list_head,
    pub sb_list: list_head,
    pub dpipe_table_list: list_head,
    pub resource_list: list_head,
    pub param_list: list_head,
    pub region_list: list_head,
    pub reporter_list: list_head,
    pub reporters_lock: mutex,
    pub dpipe_headers: *mut devlink_dpipe_headers,
    pub trap_list: list_head,
    pub trap_group_list: list_head,
    pub trap_policer_list: list_head,
    pub ops: *const devlink_ops,
    pub snapshot_ids: xarray,
    pub stats: devlink_dev_stats,
    pub dev: *mut device,
    pub _net: possible_net_t,
    pub lock: mutex,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub priv_: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
impl devlink {
    #[inline]
    pub fn reload_failed(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reload_failed(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reload_enabled(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reload_enabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn registered(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reload_failed: u8_,
        reload_enabled: u8_,
        registered: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reload_failed: u8 = unsafe { ::core::mem::transmute(reload_failed) };
            reload_failed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reload_enabled: u8 = unsafe { ::core::mem::transmute(reload_enabled) };
            reload_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let registered: u8 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_headers {
    pub headers: *mut *mut devlink_dpipe_header,
    pub headers_count: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_ops {
    pub supported_flash_update_params: u32_,
    pub reload_actions: ::aya_bpf_cty::c_ulong,
    pub reload_limits: ::aya_bpf_cty::c_ulong,
    pub reload_down: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: bool_,
            arg3: devlink_reload_action::Type,
            arg4: devlink_reload_limit::Type,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub reload_up: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: devlink_reload_action::Type,
            arg3: devlink_reload_limit::Type,
            arg4: *mut u32_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_type_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: devlink_port_type::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_split: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_unsplit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: *mut devlink_sb_pool_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: u32_,
            arg5: devlink_sb_threshold_type::Type,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_port_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: u32_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_tc_pool_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: *mut u16_,
            arg6: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_tc_pool_bind_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: u16_,
            arg6: u32_,
            arg7: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_occ_snapshot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_occ_max_clear: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_occ_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: *mut u32_,
            arg5: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub sb_occ_tc_port_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf_cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: *mut u32_,
            arg6: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_mode_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u16_) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: u16_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_inline_mode_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u8_) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_inline_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: u8_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_encap_mode_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_eswitch_encap_mode::Type,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub eswitch_encap_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: devlink_eswitch_encap_mode::Type,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub info_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_info_req,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub flash_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_flash_update_params,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_fini: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: *mut ::aya_bpf_cty::c_void,
        ),
    >,
    pub trap_action_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: devlink_trap_action::Type,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_group_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_group_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
            arg3: *const devlink_trap_policer,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_group_action_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
            arg3: devlink_trap_action::Type,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_policer_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_policer_fini: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *const devlink_trap_policer),
    >,
    pub trap_policer_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
            arg3: u64_,
            arg4: u64_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub trap_policer_counter_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
            arg3: *mut u64_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_function_hw_addr_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_port,
            arg3: *mut u8_,
            arg4: *mut ::aya_bpf_cty::c_int,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_function_hw_addr_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_port,
            arg3: *const u8_,
            arg4: ::aya_bpf_cty::c_int,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_sb_pool_info {
    pub pool_type: devlink_sb_pool_type::Type,
    pub size: u32_,
    pub threshold_type: devlink_sb_threshold_type::Type,
    pub cell_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_field {
    pub name: *const ::aya_bpf_cty::c_char,
    pub id: ::aya_bpf_cty::c_uint,
    pub bitwidth: ::aya_bpf_cty::c_uint,
    pub mapping_type: devlink_dpipe_field_mapping_type::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_header {
    pub name: *const ::aya_bpf_cty::c_char,
    pub id: ::aya_bpf_cty::c_uint,
    pub fields: *mut devlink_dpipe_field,
    pub fields_count: ::aya_bpf_cty::c_uint,
    pub global: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_param_value {
    pub vu8: u8_,
    pub vu16: u16_,
    pub vu32: u32_,
    pub vstr: [::aya_bpf_cty::c_char; 32usize],
    pub vbool: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_param_gset_ctx {
    pub val: devlink_param_value,
    pub cmode: devlink_param_cmode::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_flash_update_params {
    pub fw: *const firmware,
    pub component: *const ::aya_bpf_cty::c_char,
    pub overwrite_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap_policer {
    pub id: u32_,
    pub init_rate: u64_,
    pub init_burst: u64_,
    pub max_rate: u64_,
    pub min_rate: u64_,
    pub max_burst: u64_,
    pub min_burst: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap_group {
    pub name: *const ::aya_bpf_cty::c_char,
    pub id: u16_,
    pub generic: bool_,
    pub init_policer_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap {
    pub type_: devlink_trap_type::Type,
    pub init_action: devlink_trap_action::Type,
    pub generic: bool_,
    pub id: u16_,
    pub name: *const ::aya_bpf_cty::c_char,
    pub init_group_id: u16_,
    pub metadata_cap: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_trans {
    pub ph_prepare: bool_,
}
pub mod switchdev_obj_id {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const SWITCHDEV_OBJ_ID_UNDEFINED: Type = 0;
    pub const SWITCHDEV_OBJ_ID_PORT_VLAN: Type = 1;
    pub const SWITCHDEV_OBJ_ID_PORT_MDB: Type = 2;
    pub const SWITCHDEV_OBJ_ID_HOST_MDB: Type = 3;
    pub const SWITCHDEV_OBJ_ID_MRP: Type = 4;
    pub const SWITCHDEV_OBJ_ID_RING_TEST_MRP: Type = 5;
    pub const SWITCHDEV_OBJ_ID_RING_ROLE_MRP: Type = 6;
    pub const SWITCHDEV_OBJ_ID_RING_STATE_MRP: Type = 7;
    pub const SWITCHDEV_OBJ_ID_IN_TEST_MRP: Type = 8;
    pub const SWITCHDEV_OBJ_ID_IN_ROLE_MRP: Type = 9;
    pub const SWITCHDEV_OBJ_ID_IN_STATE_MRP: Type = 10;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj {
    pub orig_dev: *mut net_device,
    pub id: switchdev_obj_id::Type,
    pub flags: u32_,
    pub complete_priv: *mut ::aya_bpf_cty::c_void,
    pub complete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_port_vlan {
    pub obj: switchdev_obj,
    pub flags: u16_,
    pub vid_begin: u16_,
    pub vid_end: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_port_mdb {
    pub obj: switchdev_obj,
    pub addr: [::aya_bpf_cty::c_uchar; 6usize],
    pub vid: u16_,
}
pub mod dsa_tag_protocol {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const DSA_TAG_PROTO_NONE: Type = 0;
    pub const DSA_TAG_PROTO_BRCM: Type = 1;
    pub const DSA_TAG_PROTO_BRCM_PREPEND: Type = 2;
    pub const DSA_TAG_PROTO_DSA: Type = 3;
    pub const DSA_TAG_PROTO_EDSA: Type = 4;
    pub const DSA_TAG_PROTO_GSWIP: Type = 5;
    pub const DSA_TAG_PROTO_KSZ9477: Type = 6;
    pub const DSA_TAG_PROTO_KSZ9893: Type = 7;
    pub const DSA_TAG_PROTO_LAN9303: Type = 8;
    pub const DSA_TAG_PROTO_MTK: Type = 9;
    pub const DSA_TAG_PROTO_QCA: Type = 10;
    pub const DSA_TAG_PROTO_TRAILER: Type = 11;
    pub const DSA_TAG_PROTO_8021Q: Type = 12;
    pub const DSA_TAG_PROTO_SJA1105: Type = 13;
    pub const DSA_TAG_PROTO_KSZ8795: Type = 14;
    pub const DSA_TAG_PROTO_OCELOT: Type = 15;
    pub const DSA_TAG_PROTO_AR9331: Type = 16;
    pub const DSA_TAG_PROTO_RTL4_A: Type = 17;
    pub const DSA_TAG_PROTO_HELLCREEK: Type = 18;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_device_ops {
    pub xmit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> *mut sk_buff,
    >,
    pub rcv: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *mut packet_type,
        ) -> *mut sk_buff,
    >,
    pub flow_dissect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sk_buff,
            arg2: *mut __be16,
            arg3: *mut ::aya_bpf_cty::c_int,
        ),
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut net_device) -> bool_,
    >,
    pub overhead: ::aya_bpf_cty::c_uint,
    pub name: *const ::aya_bpf_cty::c_char,
    pub proto: dsa_tag_protocol::Type,
    pub promisc_on_master: bool_,
    pub tail_tag: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_netdevice_ops {
    pub ndo_do_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch_tree {
    pub list: list_head,
    pub nh: raw_notifier_head,
    pub index: ::aya_bpf_cty::c_uint,
    pub refcount: kref,
    pub setup: bool_,
    pub pd: *mut dsa_platform_data,
    pub ports: list_head,
    pub rtable: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_mall_mirror_tc_entry {
    pub to_local_port: u8_,
    pub ingress: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_mall_policer_tc_entry {
    pub burst: u32_,
    pub rate_bytes_per_sec: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch {
    pub setup: bool_,
    pub dev: *mut device,
    pub dst: *mut dsa_switch_tree,
    pub index: ::aya_bpf_cty::c_uint,
    pub nb: notifier_block,
    pub priv_: *mut ::aya_bpf_cty::c_void,
    pub cd: *mut dsa_chip_data,
    pub ops: *const dsa_switch_ops,
    pub phys_mii_mask: u32_,
    pub slave_mii_bus: *mut mii_bus,
    pub ageing_time_min: ::aya_bpf_cty::c_uint,
    pub ageing_time_max: ::aya_bpf_cty::c_uint,
    pub devlink: *mut devlink,
    pub num_tx_queues: ::aya_bpf_cty::c_uint,
    pub vlan_filtering_is_global: bool_,
    pub configure_vlan_while_not_filtering: bool_,
    pub untag_bridge_pvid: bool_,
    pub vlan_filtering: bool_,
    pub pcs_poll: bool_,
    pub mtu_enforcement_ingress: bool_,
    pub num_ports: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fixed_phy_status___2 {
    _unused: [u8; 0],
}
pub type dsa_fdb_dump_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_bpf_cty::c_uchar,
        arg2: u16_,
        arg3: bool_,
        arg4: *mut ::aya_bpf_cty::c_void,
    ) -> ::aya_bpf_cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch_ops {
    pub get_tag_protocol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: dsa_tag_protocol::Type,
        ) -> dsa_tag_protocol::Type,
    >,
    pub setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    pub teardown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch)>,
    pub get_phy_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int) -> u32_,
    >,
    pub phy_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub phy_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub adjust_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut phy_device,
        ),
    >,
    pub fixed_link_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut fixed_phy_status___2,
        ),
    >,
    pub phylink_validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ::aya_bpf_cty::c_ulong,
            arg4: *mut phylink_link_state,
        ),
    >,
    pub phylink_mac_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut phylink_link_state,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub phylink_mac_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: *const phylink_link_state,
        ),
    >,
    pub phylink_mac_an_restart: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
    >,
    pub phylink_mac_link_down: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: phy_interface_t::Type,
        ),
    >,
    pub phylink_mac_link_up: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_uint,
            arg4: phy_interface_t::Type,
            arg5: *mut phy_device,
            arg6: ::aya_bpf_cty::c_int,
            arg7: ::aya_bpf_cty::c_int,
            arg8: bool_,
            arg9: bool_,
        ),
    >,
    pub phylink_fixed_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut phylink_link_state,
        ),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: u32_,
            arg4: *mut u8,
        ),
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: *mut u64),
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: *mut u64),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_wolinfo,
        ),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_wolinfo,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_ts_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    pub port_enable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut phy_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
    >,
    pub set_mac_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_eee,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_mac_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_eee,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_eeprom_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_regs_len: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_regs,
            arg4: *mut ::aya_bpf_cty::c_void,
        ),
    >,
    pub port_prechangeupper: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut netdev_notifier_changeupper_info,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_ageing_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_uint,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_bridge_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut net_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_bridge_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut net_device,
        ),
    >,
    pub port_stp_state_set: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
    >,
    pub port_fast_age: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
    >,
    pub port_egress_floods: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bool_,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_vlan_filtering: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: bool_,
            arg4: *mut switchdev_trans,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_vlan_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_vlan,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_vlan_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_vlan,
        ),
    >,
    pub port_vlan_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_vlan,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const ::aya_bpf_cty::c_uchar,
            arg4: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const ::aya_bpf_cty::c_uchar,
            arg4: u16_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: dsa_fdb_dump_cb_t,
            arg4: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_mdb_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_mdb,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_mdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_mdb,
        ),
    >,
    pub port_mdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *const switchdev_obj_port_mdb,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_rxnfc,
            arg4: *mut u32_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ethtool_rxnfc,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cls_flower_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cls_flower_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub cls_flower_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_mirror_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut dsa_mall_mirror_tc_entry,
            arg4: bool_,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_mirror_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut dsa_mall_mirror_tc_entry,
        ),
    >,
    pub port_policer_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut dsa_mall_policer_tc_entry,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_policer_del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
    >,
    pub port_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: tc_setup_type::Type,
            arg4: *mut ::aya_bpf_cty::c_void,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub crosschip_bridge_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
            arg5: *mut net_device,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub crosschip_bridge_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
            arg4: ::aya_bpf_cty::c_int,
            arg5: *mut net_device,
        ),
    >,
    pub port_hwtstamp_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ifreq,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_hwtstamp_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut ifreq,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_txtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut sk_buff,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> bool_,
    >,
    pub port_rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: *mut sk_buff,
            arg4: ::aya_bpf_cty::c_uint,
        ) -> bool_,
    >,
    pub devlink_param_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: u32_,
            arg3: *mut devlink_param_gset_ctx,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub devlink_param_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: u32_,
            arg3: *mut devlink_param_gset_ctx,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub devlink_info_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut devlink_info_req,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub port_max_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_zone {
    pub id: u16_,
    pub flags: u8_,
    pub dir: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_man {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_man_proto,
    pub l3num: u_int16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple {
    pub src: nf_conntrack_man,
    pub dst: nf_conntrack_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1 {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1,
    pub protonum: u_int8_t,
    pub dir: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub all: __be16,
    pub tcp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub udp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub icmp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub dccp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4,
    pub sctp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5,
    pub gre: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub type_: u_int8_t,
    pub code: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6 {
    pub key: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_hash {
    pub hnnode: hlist_nulls_node,
    pub tuple: nf_conntrack_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_udp {
    pub stream_ts: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_gre {
    pub stream_timeout: ::aya_bpf_cty::c_uint,
    pub timeout: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_proto {
    pub dccp: nf_ct_dccp,
    pub sctp: ip_ct_sctp,
    pub tcp: ip_ct_tcp,
    pub udp: nf_ct_udp,
    pub gre: nf_ct_gre,
    pub tmpl_padto: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conn {
    pub ct_general: nf_conntrack,
    pub lock: spinlock_t,
    pub timeout: u32_,
    pub zone: nf_conntrack_zone,
    pub tuplehash: [nf_conntrack_tuple_hash; 2usize],
    pub status: ::aya_bpf_cty::c_ulong,
    pub cpu: u16_,
    pub ct_net: possible_net_t,
    pub nat_bysource: hlist_node,
    pub __nfct_init_offset: nf_conn__bindgen_ty_1,
    pub master: *mut nf_conn,
    pub mark: u_int32_t,
    pub secmark: u_int32_t,
    pub ext: *mut nf_ct_ext,
    pub proto: nf_conntrack_proto,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conn__bindgen_ty_1 {}
#[repr(C)]
#[derive(Debug)]
pub struct xt_table_info {
    pub size: ::aya_bpf_cty::c_uint,
    pub number: ::aya_bpf_cty::c_uint,
    pub initial_entries: ::aya_bpf_cty::c_uint,
    pub hook_entry: [::aya_bpf_cty::c_uint; 5usize],
    pub underflow: [::aya_bpf_cty::c_uint; 5usize],
    pub stacksize: ::aya_bpf_cty::c_uint,
    pub jumpstack: *mut *mut *mut ::aya_bpf_cty::c_void,
    pub entries: __IncompleteArrayField<::aya_bpf_cty::c_uchar>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_mask {
    pub src: nf_conntrack_tuple_mask__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_mask__bindgen_ty_1 {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_man_proto,
}
#[repr(C)]
#[derive(Debug)]
pub struct nf_ct_ext {
    pub offset: [u8_; 9usize],
    pub len: u8_,
    pub data: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_helper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_expect {
    pub lnode: hlist_node,
    pub hnode: hlist_node,
    pub tuple: nf_conntrack_tuple,
    pub mask: nf_conntrack_tuple_mask,
    pub expectfn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nf_conn, arg2: *mut nf_conntrack_expect),
    >,
    pub helper: *mut nf_conntrack_helper,
    pub master: *mut nf_conn,
    pub timeout: timer_list,
    pub use_: refcount_t,
    pub flags: ::aya_bpf_cty::c_uint,
    pub class: ::aya_bpf_cty::c_uint,
    pub saved_addr: nf_inet_addr,
    pub saved_proto: nf_conntrack_man_proto,
    pub dir: ip_conntrack_dir::Type,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_event {
    pub ct: *mut nf_conn,
    pub portid: u32_,
    pub report: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_exp_event {
    pub exp: *mut nf_conntrack_expect,
    pub portid: u32_,
    pub report: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv4_devconf {
    pub sysctl: *mut ::aya_bpf_cty::c_void,
    pub data: [::aya_bpf_cty::c_int; 32usize],
    pub state: [::aya_bpf_cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_xdp_link {
    pub link: bpf_link,
    pub dev: *mut net_device,
    pub flags: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll_info {
    pub refcnt: refcount_t,
    pub dev_lock: semaphore,
    pub txq: sk_buff_head,
    pub tx_work: delayed_work,
    pub netpoll: *mut netpoll,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_info {
    pub type_: ::aya_bpf_cty::c_ushort,
    pub sa_family: sa_family_t,
    pub port: __be16,
    pub hw_priv: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_device {
    pub dev: *mut net_device,
    pub refcnt: refcount_t,
    pub dead: ::aya_bpf_cty::c_int,
    pub ifa_list: *mut in_ifaddr,
    pub mc_list: *mut ip_mc_list,
    pub mc_hash: *mut *mut ip_mc_list,
    pub mc_count: ::aya_bpf_cty::c_int,
    pub mc_tomb_lock: spinlock_t,
    pub mc_tomb: *mut ip_mc_list,
    pub mr_v1_seen: ::aya_bpf_cty::c_ulong,
    pub mr_v2_seen: ::aya_bpf_cty::c_ulong,
    pub mr_maxdelay: ::aya_bpf_cty::c_ulong,
    pub mr_qi: ::aya_bpf_cty::c_ulong,
    pub mr_qri: ::aya_bpf_cty::c_ulong,
    pub mr_qrv: ::aya_bpf_cty::c_uchar,
    pub mr_gq_running: ::aya_bpf_cty::c_uchar,
    pub mr_ifc_count: ::aya_bpf_cty::c_uchar,
    pub mr_gq_timer: timer_list,
    pub mr_ifc_timer: timer_list,
    pub arp_parms: *mut neigh_parms,
    pub cnf: ipv4_devconf,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll {
    pub dev: *mut net_device,
    pub dev_name: [::aya_bpf_cty::c_char; 16usize],
    pub name: *const ::aya_bpf_cty::c_char,
    pub local_ip: inet_addr,
    pub remote_ip: inet_addr,
    pub ipv6: bool_,
    pub local_port: u16_,
    pub remote_port: u16_,
    pub remote_mac: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_walker {
    pub stop: ::aya_bpf_cty::c_int,
    pub skip: ::aya_bpf_cty::c_int,
    pub count: ::aya_bpf_cty::c_int,
    pub nonempty: bool_,
    pub cookie: ::aya_bpf_cty::c_ulong,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: *mut ::aya_bpf_cty::c_void,
            arg3: *mut tcf_walker,
        ) -> ::aya_bpf_cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_ifaddr {
    pub hash: hlist_node,
    pub ifa_next: *mut in_ifaddr,
    pub ifa_dev: *mut in_device,
    pub callback_head: callback_head,
    pub ifa_local: __be32,
    pub ifa_address: __be32,
    pub ifa_mask: __be32,
    pub ifa_rt_priority: __u32,
    pub ifa_broadcast: __be32,
    pub ifa_scope: ::aya_bpf_cty::c_uchar,
    pub ifa_prefixlen: ::aya_bpf_cty::c_uchar,
    pub ifa_flags: __u32,
    pub ifa_label: [::aya_bpf_cty::c_char; 16usize],
    pub ifa_valid_lft: __u32,
    pub ifa_preferred_lft: __u32,
    pub ifa_cstamp: ::aya_bpf_cty::c_ulong,
    pub ifa_tstamp: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_shared {
    pub udp_tunnel_nic_info: *mut udp_tunnel_nic,
    pub devices: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seg6_pernet_data {
    pub lock: mutex,
    pub tun_src: *mut in6_addr,
    pub hmac_infos: rhashtable,
}
pub const BPF_F_RECOMPUTE_CSUM: ::aya_bpf_cty::c_uint = 1;
pub const BPF_F_INVALIDATE_HASH: ::aya_bpf_cty::c_uint = 2;
pub type _bindgen_ty_460 = ::aya_bpf_cty::c_uint;
pub const BPF_F_HDR_FIELD_MASK: ::aya_bpf_cty::c_uint = 15;
pub type _bindgen_ty_461 = ::aya_bpf_cty::c_uint;
pub const BPF_F_PSEUDO_HDR: ::aya_bpf_cty::c_uint = 16;
pub const BPF_F_MARK_MANGLED_0: ::aya_bpf_cty::c_uint = 32;
pub const BPF_F_MARK_ENFORCE: ::aya_bpf_cty::c_uint = 64;
pub type _bindgen_ty_462 = ::aya_bpf_cty::c_uint;
pub const BPF_F_INGRESS: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_463 = ::aya_bpf_cty::c_uint;
pub const BPF_F_TUNINFO_IPV6: ::aya_bpf_cty::c_uint = 1;
pub type _bindgen_ty_464 = ::aya_bpf_cty::c_uint;
pub const BPF_F_ZERO_CSUM_TX: ::aya_bpf_cty::c_uint = 2;
pub const BPF_F_DONT_FRAGMENT: ::aya_bpf_cty::c_uint = 4;
pub const BPF_F_SEQ_NUMBER: ::aya_bpf_cty::c_uint = 8;
pub type _bindgen_ty_465 = ::aya_bpf_cty::c_uint;
pub const BPF_CSUM_LEVEL_QUERY: ::aya_bpf_cty::c_uint = 0;
pub const BPF_CSUM_LEVEL_INC: ::aya_bpf_cty::c_uint = 1;
pub const BPF_CSUM_LEVEL_DEC: ::aya_bpf_cty::c_uint = 2;
pub const BPF_CSUM_LEVEL_RESET: ::aya_bpf_cty::c_uint = 3;
pub type _bindgen_ty_466 = ::aya_bpf_cty::c_uint;
pub const BPF_F_ADJ_ROOM_FIXED_GSO: ::aya_bpf_cty::c_uint = 1;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: ::aya_bpf_cty::c_uint = 2;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: ::aya_bpf_cty::c_uint = 4;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_GRE: ::aya_bpf_cty::c_uint = 8;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_UDP: ::aya_bpf_cty::c_uint = 16;
pub const BPF_F_ADJ_ROOM_NO_CSUM_RESET: ::aya_bpf_cty::c_uint = 32;
pub type _bindgen_ty_467 = ::aya_bpf_cty::c_uint;
pub const BPF_ADJ_ROOM_ENCAP_L2_MASK: ::aya_bpf_cty::c_uint = 255;
pub const BPF_ADJ_ROOM_ENCAP_L2_SHIFT: ::aya_bpf_cty::c_uint = 56;
pub type _bindgen_ty_468 = ::aya_bpf_cty::c_uint;
pub const BPF_SK_LOOKUP_F_REPLACE: ::aya_bpf_cty::c_uint = 1;
pub const BPF_SK_LOOKUP_F_NO_REUSEPORT: ::aya_bpf_cty::c_uint = 2;
pub type _bindgen_ty_469 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tunnel_key {
    pub tunnel_id: __u32,
    pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __u8,
    pub tunnel_ttl: __u8,
    pub tunnel_ext: __u16,
    pub tunnel_label: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_xfrm_state {
    pub reqid: __u32,
    pub spi: __u32,
    pub family: __u16,
    pub ext: __u16,
    pub __bindgen_anon_1: bpf_xfrm_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_xfrm_state__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_tcp_sock {
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub dsack_dups: __u32,
    pub delivered: __u32,
    pub delivered_ce: __u32,
    pub icsk_retransmits: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_tuple {
    pub __bindgen_anon_1: bpf_sock_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_tuple__bindgen_ty_1 {
    pub ipv4: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub saddr: __be32,
    pub daddr: __be32,
    pub sport: __be16,
    pub dport: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
    pub saddr: [__be32; 4usize],
    pub daddr: [__be32; 4usize],
    pub sport: __be16,
    pub dport: __be16,
}
pub const BPF_SOCK_OPS_RTO_CB_FLAG: ::aya_bpf_cty::c_uint = 1;
pub const BPF_SOCK_OPS_RETRANS_CB_FLAG: ::aya_bpf_cty::c_uint = 2;
pub const BPF_SOCK_OPS_STATE_CB_FLAG: ::aya_bpf_cty::c_uint = 4;
pub const BPF_SOCK_OPS_RTT_CB_FLAG: ::aya_bpf_cty::c_uint = 8;
pub const BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: ::aya_bpf_cty::c_uint = 16;
pub const BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: ::aya_bpf_cty::c_uint = 32;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: ::aya_bpf_cty::c_uint = 64;
pub const BPF_SOCK_OPS_ALL_CB_FLAGS: ::aya_bpf_cty::c_uint = 127;
pub type _bindgen_ty_470 = ::aya_bpf_cty::c_uint;
pub const BPF_SOCK_OPS_VOID: ::aya_bpf_cty::c_uint = 0;
pub const BPF_SOCK_OPS_TIMEOUT_INIT: ::aya_bpf_cty::c_uint = 1;
pub const BPF_SOCK_OPS_RWND_INIT: ::aya_bpf_cty::c_uint = 2;
pub const BPF_SOCK_OPS_TCP_CONNECT_CB: ::aya_bpf_cty::c_uint = 3;
pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: ::aya_bpf_cty::c_uint = 4;
pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: ::aya_bpf_cty::c_uint = 5;
pub const BPF_SOCK_OPS_NEEDS_ECN: ::aya_bpf_cty::c_uint = 6;
pub const BPF_SOCK_OPS_BASE_RTT: ::aya_bpf_cty::c_uint = 7;
pub const BPF_SOCK_OPS_RTO_CB: ::aya_bpf_cty::c_uint = 8;
pub const BPF_SOCK_OPS_RETRANS_CB: ::aya_bpf_cty::c_uint = 9;
pub const BPF_SOCK_OPS_STATE_CB: ::aya_bpf_cty::c_uint = 10;
pub const BPF_SOCK_OPS_TCP_LISTEN_CB: ::aya_bpf_cty::c_uint = 11;
pub const BPF_SOCK_OPS_RTT_CB: ::aya_bpf_cty::c_uint = 12;
pub const BPF_SOCK_OPS_PARSE_HDR_OPT_CB: ::aya_bpf_cty::c_uint = 13;
pub const BPF_SOCK_OPS_HDR_OPT_LEN_CB: ::aya_bpf_cty::c_uint = 14;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB: ::aya_bpf_cty::c_uint = 15;
pub type _bindgen_ty_471 = ::aya_bpf_cty::c_uint;
pub mod _bindgen_ty_473 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_LOAD_HDR_OPT_TCP_SYN: Type = 1;
}
pub const BPF_FIB_LOOKUP_DIRECT: ::aya_bpf_cty::c_uint = 1;
pub const BPF_FIB_LOOKUP_OUTPUT: ::aya_bpf_cty::c_uint = 2;
pub type _bindgen_ty_474 = ::aya_bpf_cty::c_uint;
pub const BPF_FIB_LKUP_RET_SUCCESS: ::aya_bpf_cty::c_uint = 0;
pub const BPF_FIB_LKUP_RET_BLACKHOLE: ::aya_bpf_cty::c_uint = 1;
pub const BPF_FIB_LKUP_RET_UNREACHABLE: ::aya_bpf_cty::c_uint = 2;
pub const BPF_FIB_LKUP_RET_PROHIBIT: ::aya_bpf_cty::c_uint = 3;
pub const BPF_FIB_LKUP_RET_NOT_FWDED: ::aya_bpf_cty::c_uint = 4;
pub const BPF_FIB_LKUP_RET_FWD_DISABLED: ::aya_bpf_cty::c_uint = 5;
pub const BPF_FIB_LKUP_RET_UNSUPP_LWT: ::aya_bpf_cty::c_uint = 6;
pub const BPF_FIB_LKUP_RET_NO_NEIGH: ::aya_bpf_cty::c_uint = 7;
pub const BPF_FIB_LKUP_RET_FRAG_NEEDED: ::aya_bpf_cty::c_uint = 8;
pub type _bindgen_ty_475 = ::aya_bpf_cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_fib_lookup {
    pub family: __u8,
    pub l4_protocol: __u8,
    pub sport: __be16,
    pub dport: __be16,
    pub tot_len: __u16,
    pub ifindex: __u32,
    pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_fib_lookup__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_fib_lookup__bindgen_ty_3,
    pub h_vlan_proto: __be16,
    pub h_vlan_TCI: __be16,
    pub smac: [__u8; 6usize],
    pub dmac: [__u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_1 {
    pub tos: __u8,
    pub flowinfo: __be32,
    pub rt_metric: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_2 {
    pub ipv4_src: __be32,
    pub ipv6_src: [__u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_3 {
    pub ipv4_dst: __be32,
    pub ipv6_dst: [__u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_redir_neigh {
    pub nh_family: __u32,
    pub __bindgen_anon_1: bpf_redir_neigh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_redir_neigh__bindgen_ty_1 {
    pub ipv4_nh: __be32,
    pub ipv6_nh: [__u32; 4usize],
}
#[repr(C)]
pub struct inet_timewait_sock {
    pub __tw_common: sock_common,
    pub tw_mark: __u32,
    pub tw_substate: ::aya_bpf_cty::c_uchar,
    pub tw_rcv_wscale: ::aya_bpf_cty::c_uchar,
    pub tw_sport: __be16,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tw_txhash: u32_,
    pub tw_priority: u32_,
    pub tw_timer: timer_list,
    pub tw_tb: *mut inet_bind_bucket,
}
impl inet_timewait_sock {
    #[inline]
    pub fn tw_kill(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tw_kill(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_transparent(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tw_transparent(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_flowlabel(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_tw_flowlabel(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_pad(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tw_pad(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_tos(&self) -> ::aya_bpf_cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tw_tos(&mut self, val: ::aya_bpf_cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tw_kill: ::aya_bpf_cty::c_uint,
        tw_transparent: ::aya_bpf_cty::c_uint,
        tw_flowlabel: ::aya_bpf_cty::c_uint,
        tw_pad: ::aya_bpf_cty::c_uint,
        tw_tos: ::aya_bpf_cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tw_kill: u32 = unsafe { ::core::mem::transmute(tw_kill) };
            tw_kill as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tw_transparent: u32 = unsafe { ::core::mem::transmute(tw_transparent) };
            tw_transparent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 20u8, {
            let tw_flowlabel: u32 = unsafe { ::core::mem::transmute(tw_flowlabel) };
            tw_flowlabel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tw_pad: u32 = unsafe { ::core::mem::transmute(tw_pad) };
            tw_pad as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let tw_tos: u32 = unsafe { ::core::mem::transmute(tw_tos) };
            tw_tos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp_timewait_sock {
    pub tw_sk: inet_timewait_sock,
    pub tw_rcv_wnd: u32_,
    pub tw_ts_offset: u32_,
    pub tw_ts_recent: u32_,
    pub tw_last_oow_ack_time: u32_,
    pub tw_ts_recent_stamp: ::aya_bpf_cty::c_int,
    pub tw_tx_delay: u32_,
    pub tw_md5_key: *mut tcp_md5sig_key,
}
#[repr(C)]
pub struct udp_sock {
    pub inet: inet_sock,
    pub pending: ::aya_bpf_cty::c_int,
    pub corkflag: ::aya_bpf_cty::c_uint,
    pub encap_type: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub len: __u16,
    pub gso_size: __u16,
    pub pcslen: __u16,
    pub pcrlen: __u16,
    pub pcflag: __u8,
    pub unused: [__u8; 3usize],
    pub encap_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub encap_err_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
    >,
    pub encap_destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub gro_receive: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut list_head,
            arg3: *mut sk_buff,
        ) -> *mut sk_buff,
    >,
    pub gro_complete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sk_buff,
            arg3: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub reader_queue: sk_buff_head,
    pub forward_deficit: ::aya_bpf_cty::c_int,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 40usize]>,
}
impl udp_sock {
    #[inline]
    pub fn no_check6_tx(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_check6_tx(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_check6_rx(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_check6_rx(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_enabled(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_enabled(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gro_enabled(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gro_enabled(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept_udp_l4(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accept_udp_l4(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept_udp_fraglist(&self) -> ::aya_bpf_cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accept_udp_fraglist(&mut self, val: ::aya_bpf_cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        no_check6_tx: ::aya_bpf_cty::c_uchar,
        no_check6_rx: ::aya_bpf_cty::c_uchar,
        encap_enabled: ::aya_bpf_cty::c_uchar,
        gro_enabled: ::aya_bpf_cty::c_uchar,
        accept_udp_l4: ::aya_bpf_cty::c_uchar,
        accept_udp_fraglist: ::aya_bpf_cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_check6_tx: u8 = unsafe { ::core::mem::transmute(no_check6_tx) };
            no_check6_tx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_check6_rx: u8 = unsafe { ::core::mem::transmute(no_check6_rx) };
            no_check6_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encap_enabled: u8 = unsafe { ::core::mem::transmute(encap_enabled) };
            encap_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gro_enabled: u8 = unsafe { ::core::mem::transmute(gro_enabled) };
            gro_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let accept_udp_l4: u8 = unsafe { ::core::mem::transmute(accept_udp_l4) };
            accept_udp_l4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let accept_udp_fraglist: u8 = unsafe { ::core::mem::transmute(accept_udp_fraglist) };
            accept_udp_fraglist as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct udp6_sock {
    pub udp: udp_sock,
    pub inet6: ipv6_pinfo,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl udp6_sock {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp6_sock {
    pub tcp: tcp_sock,
    pub inet6: ipv6_pinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_umem {
    pub addrs: *mut ::aya_bpf_cty::c_void,
    pub size: u64_,
    pub headroom: u32_,
    pub chunk_size: u32_,
    pub chunks: u32_,
    pub npgs: u32_,
    pub user: *mut user_struct,
    pub users: refcount_t,
    pub flags: u8_,
    pub zc: bool_,
    pub pgs: *mut *mut page,
    pub id: ::aya_bpf_cty::c_int,
    pub xsk_dma_list: list_head,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_crypto_info {
    pub version: __u16,
    pub cipher_type: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_aes_gcm_128 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf_cty::c_uchar; 8usize],
    pub key: [::aya_bpf_cty::c_uchar; 16usize],
    pub salt: [::aya_bpf_cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf_cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_aes_gcm_256 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf_cty::c_uchar; 8usize],
    pub key: [::aya_bpf_cty::c_uchar; 32usize],
    pub salt: [::aya_bpf_cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf_cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct tls12_crypto_info_chacha20_poly1305 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf_cty::c_uchar; 12usize],
    pub key: [::aya_bpf_cty::c_uchar; 32usize],
    pub salt: __IncompleteArrayField<::aya_bpf_cty::c_uchar>,
    pub rec_seq: [::aya_bpf_cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_context {
    pub iv: *mut ::aya_bpf_cty::c_char,
    pub rec_seq: *mut ::aya_bpf_cty::c_char,
}
#[repr(C)]
pub struct tls_crypto_context {
    pub info: __BindgenUnionField<tls_crypto_info>,
    pub __bindgen_anon_1: __BindgenUnionField<tls_crypto_context__bindgen_ty_1>,
    pub bindgen_union_field: [u16; 28usize],
}
#[repr(C)]
pub struct tls_crypto_context__bindgen_ty_1 {
    pub aes_gcm_128: __BindgenUnionField<tls12_crypto_info_aes_gcm_128>,
    pub aes_gcm_256: __BindgenUnionField<tls12_crypto_info_aes_gcm_256>,
    pub chacha20_poly1305: __BindgenUnionField<tls12_crypto_info_chacha20_poly1305>,
    pub bindgen_union_field: [u16; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_prot_info {
    pub version: u16_,
    pub cipher_type: u16_,
    pub prepend_size: u16_,
    pub tag_size: u16_,
    pub overhead_size: u16_,
    pub iv_size: u16_,
    pub salt_size: u16_,
    pub rec_seq_size: u16_,
    pub aad_size: u16_,
    pub tail_size: u16_,
}
#[repr(C)]
pub struct tls_context {
    pub prot_info: tls_prot_info,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub push_pending_record: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
    >,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub priv_ctx_tx: *mut ::aya_bpf_cty::c_void,
    pub priv_ctx_rx: *mut ::aya_bpf_cty::c_void,
    pub netdev: *mut net_device,
    pub tx: cipher_context,
    pub rx: cipher_context,
    pub partially_sent_record: *mut scatterlist,
    pub partially_sent_offset: u16_,
    pub in_tcp_sendpages: bool_,
    pub pending_open_record_frags: bool_,
    pub tx_lock: mutex,
    pub flags: ::aya_bpf_cty::c_ulong,
    pub sk_proto: *mut proto,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub crypto_send: tls_crypto_context,
    pub crypto_recv: tls_crypto_context,
    pub list: list_head,
    pub refcount: refcount_t,
    pub rcu: callback_head,
}
impl tls_context {
    #[inline]
    pub fn tx_conf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_tx_conf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_conf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rx_conf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tx_conf: u8_, rx_conf: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_conf: u8 = unsafe { ::core::mem::transmute(tx_conf) };
            tx_conf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let rx_conf: u8 = unsafe { ::core::mem::transmute(rx_conf) };
            rx_conf as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const BPF_F_NEIGH: ::aya_bpf_cty::c_uint = 2;
pub const BPF_F_PEER: ::aya_bpf_cty::c_uint = 4;
pub const BPF_F_NEXTHOP: ::aya_bpf_cty::c_uint = 8;
pub type _bindgen_ty_478 = ::aya_bpf_cty::c_uint;
#[repr(C)]
pub struct xsk_buff_pool {
    pub dev: *mut device,
    pub netdev: *mut net_device,
    pub xsk_tx_list: list_head,
    pub xsk_tx_list_lock: spinlock_t,
    pub users: refcount_t,
    pub umem: *mut xdp_umem,
    pub work: work_struct,
    pub free_list: list_head,
    pub heads_cnt: u32_,
    pub queue_id: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub fq: *mut xsk_queue,
    pub cq: *mut xsk_queue,
    pub dma_pages: *mut dma_addr_t,
    pub heads: *mut xdp_buff_xsk,
    pub chunk_mask: u64_,
    pub addrs_cnt: u64_,
    pub free_list_cnt: u32_,
    pub dma_pages_cnt: u32_,
    pub free_heads_cnt: u32_,
    pub headroom: u32_,
    pub chunk_size: u32_,
    pub frame_len: u32_,
    pub cached_need_wakeup: u8_,
    pub uses_need_wakeup: bool_,
    pub dma_need_sync: bool_,
    pub unaligned: bool_,
    pub addrs: *mut ::aya_bpf_cty::c_void,
    pub cq_lock: spinlock_t,
    pub free_heads: __IncompleteArrayField<*mut xdp_buff_xsk>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl xsk_buff_pool {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_buff_xsk {
    pub xdp: xdp_buff,
    pub dma: dma_addr_t,
    pub frame_dma: dma_addr_t,
    pub pool: *mut xsk_buff_pool,
    pub unaligned: bool_,
    pub orig_addr: u64_,
    pub free_list_node: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_cache_pcpu {
    pub refresh_ts: ::aya_bpf_cty::c_ulong,
    pub dst: *mut dst_entry,
    pub cookie: u32_,
    pub __bindgen_anon_1: dst_cache_pcpu__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dst_cache_pcpu__bindgen_ty_1 {
    pub in_saddr: in_addr,
    pub in6_saddr: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_info_req {
    pub msg: *mut sk_buff,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psample_group {
    pub list: list_head,
    pub net: *mut net,
    pub group_num: u32_,
    pub refcount: u32_,
    pub seq: u32_,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_gate_entry {
    pub gate_state: u8_,
    pub interval: u32_,
    pub ipv: s32,
    pub maxoctets: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_queue_entry {
    pub list: list_head,
    pub skb: *mut sk_buff,
    pub id: ::aya_bpf_cty::c_uint,
    pub hook_index: ::aya_bpf_cty::c_uint,
    pub physin: *mut net_device,
    pub physout: *mut net_device,
    pub state: nf_hook_state,
    pub size: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_loginfo {
    pub type_: u_int8_t,
    pub u: nf_loginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_loginfo__bindgen_ty_1 {
    pub ulog: nf_loginfo__bindgen_ty_1__bindgen_ty_1,
    pub log: nf_loginfo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_loginfo__bindgen_ty_1__bindgen_ty_1 {
    pub copy_len: u_int32_t,
    pub group: u_int16_t,
    pub qthreshold: u_int16_t,
    pub flags: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_loginfo__bindgen_ty_1__bindgen_ty_2 {
    pub level: u_int8_t,
    pub logflags: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mc_list {
    pub interface: *mut in_device,
    pub multiaddr: __be32,
    pub sfmode: ::aya_bpf_cty::c_uint,
    pub sources: *mut ip_sf_list,
    pub tomb: *mut ip_sf_list,
    pub sfcount: [::aya_bpf_cty::c_ulong; 2usize],
    pub __bindgen_anon_1: ip_mc_list__bindgen_ty_1,
    pub next_hash: *mut ip_mc_list,
    pub timer: timer_list,
    pub users: ::aya_bpf_cty::c_int,
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub tm_running: ::aya_bpf_cty::c_char,
    pub reporter: ::aya_bpf_cty::c_char,
    pub unsolicit_count: ::aya_bpf_cty::c_char,
    pub loaded: ::aya_bpf_cty::c_char,
    pub gsquery: ::aya_bpf_cty::c_uchar,
    pub crcount: ::aya_bpf_cty::c_uchar,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_mc_list__bindgen_ty_1 {
    pub next: *mut ip_mc_list,
    pub next_rcu: *mut ip_mc_list,
}
#[repr(C)]
#[derive(Debug)]
pub struct ip_sf_socklist {
    pub sl_max: ::aya_bpf_cty::c_uint,
    pub sl_count: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
    pub sl_addr: __IncompleteArrayField<__be32>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mc_socklist {
    pub next_rcu: *mut ip_mc_socklist,
    pub multi: ip_mreqn,
    pub sfmode: ::aya_bpf_cty::c_uint,
    pub sflist: *mut ip_sf_socklist,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_sf_list {
    pub sf_next: *mut ip_sf_list,
    pub sf_count: [::aya_bpf_cty::c_ulong; 2usize],
    pub sf_inaddr: __be32,
    pub sf_gsresp: ::aya_bpf_cty::c_uchar,
    pub sf_oldin: ::aya_bpf_cty::c_uchar,
    pub sf_crcount: ::aya_bpf_cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uncached_list {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_hashinfo {
    pub lock: rwlock_t,
    pub ht: [hlist_head; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpvegas_info {
    pub tcpv_enabled: __u32,
    pub tcpv_rttcnt: __u32,
    pub tcpv_rtt: __u32,
    pub tcpv_minrtt: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_dctcp_info {
    pub dctcp_enabled: __u16,
    pub dctcp_ce_state: __u16,
    pub dctcp_alpha: __u32,
    pub dctcp_ab_ecn: __u32,
    pub dctcp_ab_tot: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_bbr_info {
    pub bbr_bw_lo: __u32,
    pub bbr_bw_hi: __u32,
    pub bbr_min_rtt: __u32,
    pub bbr_pacing_gain: __u32,
    pub bbr_cwnd_gain: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_cc_info {
    pub vegas: tcpvegas_info,
    pub dctcp: tcp_dctcp_info,
    pub bbr: tcp_bbr_info,
}
pub const BPF_TCP_ESTABLISHED: ::aya_bpf_cty::c_uint = 1;
pub const BPF_TCP_SYN_SENT: ::aya_bpf_cty::c_uint = 2;
pub const BPF_TCP_SYN_RECV: ::aya_bpf_cty::c_uint = 3;
pub const BPF_TCP_FIN_WAIT1: ::aya_bpf_cty::c_uint = 4;
pub const BPF_TCP_FIN_WAIT2: ::aya_bpf_cty::c_uint = 5;
pub const BPF_TCP_TIME_WAIT: ::aya_bpf_cty::c_uint = 6;
pub const BPF_TCP_CLOSE: ::aya_bpf_cty::c_uint = 7;
pub const BPF_TCP_CLOSE_WAIT: ::aya_bpf_cty::c_uint = 8;
pub const BPF_TCP_LAST_ACK: ::aya_bpf_cty::c_uint = 9;
pub const BPF_TCP_LISTEN: ::aya_bpf_cty::c_uint = 10;
pub const BPF_TCP_CLOSING: ::aya_bpf_cty::c_uint = 11;
pub const BPF_TCP_NEW_SYN_RECV: ::aya_bpf_cty::c_uint = 12;
pub const BPF_TCP_MAX_STATES: ::aya_bpf_cty::c_uint = 13;
pub type _bindgen_ty_551 = ::aya_bpf_cty::c_uint;
pub mod _bindgen_ty_555 {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const BPF_WRITE_HDR_TCP_CURRENT_MSS: Type = 1;
    pub const BPF_WRITE_HDR_TCP_SYNACK_COOKIE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlan_group {
    pub nr_vlan_devs: ::aya_bpf_cty::c_uint,
    pub hlist: hlist_node,
    pub vlan_devices_arrays: [*mut *mut net_device; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlan_info {
    pub real_dev: *mut net_device,
    pub grp: vlan_group,
    pub vid_list: list_head,
    pub nr_vids: ::aya_bpf_cty::c_uint,
    pub rcu: callback_head,
}
pub mod nl80211_iftype {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_IFTYPE_UNSPECIFIED: Type = 0;
    pub const NL80211_IFTYPE_ADHOC: Type = 1;
    pub const NL80211_IFTYPE_STATION: Type = 2;
    pub const NL80211_IFTYPE_AP: Type = 3;
    pub const NL80211_IFTYPE_AP_VLAN: Type = 4;
    pub const NL80211_IFTYPE_WDS: Type = 5;
    pub const NL80211_IFTYPE_MONITOR: Type = 6;
    pub const NL80211_IFTYPE_MESH_POINT: Type = 7;
    pub const NL80211_IFTYPE_P2P_CLIENT: Type = 8;
    pub const NL80211_IFTYPE_P2P_GO: Type = 9;
    pub const NL80211_IFTYPE_P2P_DEVICE: Type = 10;
    pub const NL80211_IFTYPE_OCB: Type = 11;
    pub const NL80211_IFTYPE_NAN: Type = 12;
    pub const NUM_NL80211_IFTYPES: Type = 13;
    pub const NL80211_IFTYPE_MAX: Type = 12;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_conn {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_cached_keys {
    _unused: [u8; 0],
}
pub mod ieee80211_bss_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IEEE80211_BSS_TYPE_ESS: Type = 0;
    pub const IEEE80211_BSS_TYPE_PBSS: Type = 1;
    pub const IEEE80211_BSS_TYPE_IBSS: Type = 2;
    pub const IEEE80211_BSS_TYPE_MBSS: Type = 3;
    pub const IEEE80211_BSS_TYPE_ANY: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_internal_bss {
    _unused: [u8; 0],
}
pub mod nl80211_chan_width {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_CHAN_WIDTH_20_NOHT: Type = 0;
    pub const NL80211_CHAN_WIDTH_20: Type = 1;
    pub const NL80211_CHAN_WIDTH_40: Type = 2;
    pub const NL80211_CHAN_WIDTH_80: Type = 3;
    pub const NL80211_CHAN_WIDTH_80P80: Type = 4;
    pub const NL80211_CHAN_WIDTH_160: Type = 5;
    pub const NL80211_CHAN_WIDTH_5: Type = 6;
    pub const NL80211_CHAN_WIDTH_10: Type = 7;
    pub const NL80211_CHAN_WIDTH_1: Type = 8;
    pub const NL80211_CHAN_WIDTH_2: Type = 9;
    pub const NL80211_CHAN_WIDTH_4: Type = 10;
    pub const NL80211_CHAN_WIDTH_8: Type = 11;
    pub const NL80211_CHAN_WIDTH_16: Type = 12;
}
pub mod ieee80211_edmg_bw_config {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const IEEE80211_EDMG_BW_CONFIG_4: Type = 4;
    pub const IEEE80211_EDMG_BW_CONFIG_5: Type = 5;
    pub const IEEE80211_EDMG_BW_CONFIG_6: Type = 6;
    pub const IEEE80211_EDMG_BW_CONFIG_7: Type = 7;
    pub const IEEE80211_EDMG_BW_CONFIG_8: Type = 8;
    pub const IEEE80211_EDMG_BW_CONFIG_9: Type = 9;
    pub const IEEE80211_EDMG_BW_CONFIG_10: Type = 10;
    pub const IEEE80211_EDMG_BW_CONFIG_11: Type = 11;
    pub const IEEE80211_EDMG_BW_CONFIG_12: Type = 12;
    pub const IEEE80211_EDMG_BW_CONFIG_13: Type = 13;
    pub const IEEE80211_EDMG_BW_CONFIG_14: Type = 14;
    pub const IEEE80211_EDMG_BW_CONFIG_15: Type = 15;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_edmg {
    pub channels: u8_,
    pub bw_config: ieee80211_edmg_bw_config::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_chan_def {
    pub chan: *mut ieee80211_channel,
    pub width: nl80211_chan_width::Type,
    pub center_freq1: u32_,
    pub center_freq2: u32_,
    pub edmg: ieee80211_edmg,
    pub freq1_offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_mcs_info {
    pub rx_mask: [u8_; 10usize],
    pub rx_highest: __le16,
    pub tx_params: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_ht_cap {
    pub cap_info: __le16,
    pub ampdu_params_info: u8_,
    pub mcs: ieee80211_mcs_info,
    pub extended_ht_cap_info: __le16,
    pub tx_BF_cap_info: __le32,
    pub antenna_selection_info: u8_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_ibss_params {
    pub ssid: *const u8_,
    pub bssid: *const u8_,
    pub chandef: cfg80211_chan_def,
    pub ie: *const u8_,
    pub ssid_len: u8_,
    pub ie_len: u8_,
    pub beacon_interval: u16_,
    pub basic_rates: u32_,
    pub channel_fixed: bool_,
    pub privacy: bool_,
    pub control_port: bool_,
    pub control_port_over_nl80211: bool_,
    pub userspace_handles_dfs: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mcast_rate: [::aya_bpf_cty::c_int; 5usize],
    pub ht_capa: ieee80211_ht_cap,
    pub ht_capa_mask: ieee80211_ht_cap,
    pub wep_keys: *mut key_params,
    pub wep_tx_key: ::aya_bpf_cty::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl cfg80211_ibss_params {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub mod nl80211_auth_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_AUTHTYPE_OPEN_SYSTEM: Type = 0;
    pub const NL80211_AUTHTYPE_SHARED_KEY: Type = 1;
    pub const NL80211_AUTHTYPE_FT: Type = 2;
    pub const NL80211_AUTHTYPE_NETWORK_EAP: Type = 3;
    pub const NL80211_AUTHTYPE_SAE: Type = 4;
    pub const NL80211_AUTHTYPE_FILS_SK: Type = 5;
    pub const NL80211_AUTHTYPE_FILS_SK_PFS: Type = 6;
    pub const NL80211_AUTHTYPE_FILS_PK: Type = 7;
    pub const __NL80211_AUTHTYPE_NUM: Type = 8;
    pub const NL80211_AUTHTYPE_MAX: Type = 7;
    pub const NL80211_AUTHTYPE_AUTOMATIC: Type = 8;
}
pub mod nl80211_mfp {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_MFP_NO: Type = 0;
    pub const NL80211_MFP_REQUIRED: Type = 1;
    pub const NL80211_MFP_OPTIONAL: Type = 2;
}
pub mod nl80211_sae_pwe_mechanism {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_SAE_PWE_UNSPECIFIED: Type = 0;
    pub const NL80211_SAE_PWE_HUNT_AND_PECK: Type = 1;
    pub const NL80211_SAE_PWE_HASH_TO_ELEMENT: Type = 2;
    pub const NL80211_SAE_PWE_BOTH: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_crypto_settings {
    pub wpa_versions: u32_,
    pub cipher_group: u32_,
    pub n_ciphers_pairwise: ::aya_bpf_cty::c_int,
    pub ciphers_pairwise: [u32_; 5usize],
    pub n_akm_suites: ::aya_bpf_cty::c_int,
    pub akm_suites: [u32_; 2usize],
    pub control_port: bool_,
    pub control_port_ethertype: __be16,
    pub control_port_no_encrypt: bool_,
    pub control_port_over_nl80211: bool_,
    pub control_port_no_preauth: bool_,
    pub wep_keys: *mut key_params,
    pub wep_tx_key: ::aya_bpf_cty::c_int,
    pub psk: *const u8_,
    pub sae_pwd: *const u8_,
    pub sae_pwd_len: u8_,
    pub sae_pwe: nl80211_sae_pwe_mechanism::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_vht_mcs_info {
    pub rx_mcs_map: __le16,
    pub rx_highest: __le16,
    pub tx_mcs_map: __le16,
    pub tx_highest: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_vht_cap {
    pub vht_cap_info: __le32,
    pub supp_mcs: ieee80211_vht_mcs_info,
}
pub mod nl80211_bss_select_attr {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const __NL80211_BSS_SELECT_ATTR_INVALID: Type = 0;
    pub const NL80211_BSS_SELECT_ATTR_RSSI: Type = 1;
    pub const NL80211_BSS_SELECT_ATTR_BAND_PREF: Type = 2;
    pub const NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: Type = 3;
    pub const __NL80211_BSS_SELECT_ATTR_AFTER_LAST: Type = 4;
    pub const NL80211_BSS_SELECT_ATTR_MAX: Type = 3;
}
pub mod nl80211_band {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_BAND_2GHZ: Type = 0;
    pub const NL80211_BAND_5GHZ: Type = 1;
    pub const NL80211_BAND_60GHZ: Type = 2;
    pub const NL80211_BAND_6GHZ: Type = 3;
    pub const NL80211_BAND_S1GHZ: Type = 4;
    pub const NUM_NL80211_BANDS: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_bss_select_adjust {
    pub band: nl80211_band::Type,
    pub delta: s8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfg80211_bss_selection {
    pub behaviour: nl80211_bss_select_attr::Type,
    pub param: cfg80211_bss_selection__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cfg80211_bss_selection__bindgen_ty_1 {
    pub band_pref: nl80211_band::Type,
    pub adjust: cfg80211_bss_select_adjust,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct cfg80211_connect_params {
    pub channel: *mut ieee80211_channel,
    pub channel_hint: *mut ieee80211_channel,
    pub bssid: *const u8_,
    pub bssid_hint: *const u8_,
    pub ssid: *const u8_,
    pub ssid_len: size_t,
    pub auth_type: nl80211_auth_type::Type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ie: *const u8_,
    pub ie_len: size_t,
    pub privacy: bool_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mfp: nl80211_mfp::Type,
    pub crypto: cfg80211_crypto_settings,
    pub key: *const u8_,
    pub key_len: u8_,
    pub key_idx: u8_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flags: u32_,
    pub bg_scan_period: ::aya_bpf_cty::c_int,
    pub ht_capa: ieee80211_ht_cap,
    pub ht_capa_mask: ieee80211_ht_cap,
    pub vht_capa: ieee80211_vht_cap,
    pub vht_capa_mask: ieee80211_vht_cap,
    pub pbss: bool_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub bss_select: cfg80211_bss_selection,
    pub prev_bssid: *const u8_,
    pub fils_erp_username: *const u8_,
    pub fils_erp_username_len: size_t,
    pub fils_erp_realm: *const u8_,
    pub fils_erp_realm_len: size_t,
    pub fils_erp_next_seq_num: u16_,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub fils_erp_rrk: *const u8_,
    pub fils_erp_rrk_len: size_t,
    pub want_1x: bool_,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub edmg: ieee80211_edmg,
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl cfg80211_connect_params {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_4() -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_5() -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_6() -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_7() -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_cqm_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev {
    pub wiphy: *mut wiphy,
    pub iftype: nl80211_iftype::Type,
    pub list: list_head,
    pub netdev: *mut net_device,
    pub identifier: u32_,
    pub mgmt_registrations: list_head,
    pub mgmt_registrations_lock: spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mtx: mutex,
    pub use_4addr: bool_,
    pub is_running: bool_,
    pub address: [u8_; 6usize],
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
    pub mesh_id_len: u8_,
    pub mesh_id_up_len: u8_,
    pub conn: *mut cfg80211_conn,
    pub connect_keys: *mut cfg80211_cached_keys,
    pub conn_bss_type: ieee80211_bss_type::Type,
    pub conn_owner_nlportid: u32_,
    pub disconnect_wk: work_struct,
    pub disconnect_bssid: [u8_; 6usize],
    pub event_list: list_head,
    pub event_lock: spinlock_t,
    pub current_bss: *mut cfg80211_internal_bss,
    pub preset_chandef: cfg80211_chan_def,
    pub chandef: cfg80211_chan_def,
    pub ibss_fixed: bool_,
    pub ibss_dfs_possible: bool_,
    pub ps: bool_,
    pub ps_timeout: ::aya_bpf_cty::c_int,
    pub beacon_interval: ::aya_bpf_cty::c_int,
    pub ap_unexpected_nlportid: u32_,
    pub owner_nlportid: u32_,
    pub nl_owner_dead: bool_,
    pub cac_started: bool_,
    pub cac_start_time: ::aya_bpf_cty::c_ulong,
    pub cac_time_ms: ::aya_bpf_cty::c_uint,
    pub wext: wireless_dev__bindgen_ty_1,
    pub cqm_config: *mut cfg80211_cqm_config,
    pub pmsr_list: list_head,
    pub pmsr_lock: spinlock_t,
    pub pmsr_free_wk: work_struct,
    pub unprot_beacon_reported: ::aya_bpf_cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev__bindgen_ty_1 {
    pub ibss: cfg80211_ibss_params,
    pub connect: cfg80211_connect_params,
    pub keys: *mut cfg80211_cached_keys,
    pub ie: *const u8_,
    pub ie_len: size_t,
    pub bssid: [u8_; 6usize],
    pub prev_bssid: [u8_; 6usize],
    pub ssid: [u8_; 32usize],
    pub default_key: s8,
    pub default_mgmt_key: s8,
    pub prev_bssid_valid: bool_,
}
impl wireless_dev {
    #[inline]
    pub fn mgmt_registrations_need_update(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mgmt_registrations_need_update(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mgmt_registrations_need_update: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mgmt_registrations_need_update: u8 =
                unsafe { ::core::mem::transmute(mgmt_registrations_need_update) };
            mgmt_registrations_need_update as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod nl80211_reg_initiator {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_REGDOM_SET_BY_CORE: Type = 0;
    pub const NL80211_REGDOM_SET_BY_USER: Type = 1;
    pub const NL80211_REGDOM_SET_BY_DRIVER: Type = 2;
    pub const NL80211_REGDOM_SET_BY_COUNTRY_IE: Type = 3;
}
pub mod nl80211_dfs_regions {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_DFS_UNSET: Type = 0;
    pub const NL80211_DFS_FCC: Type = 1;
    pub const NL80211_DFS_ETSI: Type = 2;
    pub const NL80211_DFS_JP: Type = 3;
}
pub mod nl80211_user_reg_hint_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_USER_REG_HINT_USER: Type = 0;
    pub const NL80211_USER_REG_HINT_CELL_BASE: Type = 1;
    pub const NL80211_USER_REG_HINT_INDOOR: Type = 2;
}
pub mod nl80211_key_mode {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_KEY_RX_TX: Type = 0;
    pub const NL80211_KEY_NO_TX: Type = 1;
    pub const NL80211_KEY_SET_TX: Type = 2;
}
pub mod nl80211_bss_scan_width {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_BSS_CHAN_WIDTH_20: Type = 0;
    pub const NL80211_BSS_CHAN_WIDTH_10: Type = 1;
    pub const NL80211_BSS_CHAN_WIDTH_5: Type = 2;
    pub const NL80211_BSS_CHAN_WIDTH_1: Type = 3;
    pub const NL80211_BSS_CHAN_WIDTH_2: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_seq {
    pub start: __u32,
    pub offset: __u32,
    pub len: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct nl80211_wowlan_tcp_data_token {
    pub offset: __u32,
    pub len: __u32,
    pub token_stream: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_token_feature {
    pub min_len: __u32,
    pub max_len: __u32,
    pub bufsize: __u32,
}
pub mod nl80211_dfs_state {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_DFS_USABLE: Type = 0;
    pub const NL80211_DFS_UNAVAILABLE: Type = 1;
    pub const NL80211_DFS_AVAILABLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_vendor_cmd_info {
    pub vendor_id: __u32,
    pub subcmd: __u32,
}
pub mod nl80211_sar_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const NL80211_SAR_TYPE_POWER: Type = 0;
    pub const NUM_NL80211_SAR_TYPE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_cap_elem {
    pub mac_cap_info: [u8_; 6usize],
    pub phy_cap_info: [u8_; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_mcs_nss_supp {
    pub rx_mcs_80: __le16,
    pub tx_mcs_80: __le16,
    pub rx_mcs_160: __le16,
    pub tx_mcs_160: __le16,
    pub rx_mcs_80p80: __le16,
    pub tx_mcs_80p80: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_6ghz_capa {
    pub capa: __le16,
}
pub mod environment_cap {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const ENVIRON_ANY: Type = 0;
    pub const ENVIRON_INDOOR: Type = 1;
    pub const ENVIRON_OUTDOOR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regulatory_request {
    pub callback_head: callback_head,
    pub wiphy_idx: ::aya_bpf_cty::c_int,
    pub initiator: nl80211_reg_initiator::Type,
    pub user_reg_hint_type: nl80211_user_reg_hint_type::Type,
    pub alpha2: [::aya_bpf_cty::c_char; 3usize],
    pub dfs_region: nl80211_dfs_regions::Type,
    pub intersect: bool_,
    pub processed: bool_,
    pub country_ie_env: environment_cap::Type,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_freq_range {
    pub start_freq_khz: u32_,
    pub end_freq_khz: u32_,
    pub max_bandwidth_khz: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_power_rule {
    pub max_antenna_gain: u32_,
    pub max_eirp: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_wmm_ac {
    pub cw_min: u16_,
    pub cw_max: u16_,
    pub cot: u16_,
    pub aifsn: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_wmm_rule {
    pub client: [ieee80211_wmm_ac; 4usize],
    pub ap: [ieee80211_wmm_ac; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_reg_rule {
    pub freq_range: ieee80211_freq_range,
    pub power_rule: ieee80211_power_rule,
    pub wmm_rule: ieee80211_wmm_rule,
    pub flags: u32_,
    pub dfs_cac_ms: u32_,
    pub has_wmm: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct ieee80211_regdomain {
    pub callback_head: callback_head,
    pub n_reg_rules: u32_,
    pub alpha2: [::aya_bpf_cty::c_char; 3usize],
    pub dfs_region: nl80211_dfs_regions::Type,
    pub reg_rules: __IncompleteArrayField<ieee80211_reg_rule>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_channel {
    pub band: nl80211_band::Type,
    pub center_freq: u32_,
    pub freq_offset: u16_,
    pub hw_value: u16_,
    pub flags: u32_,
    pub max_antenna_gain: ::aya_bpf_cty::c_int,
    pub max_power: ::aya_bpf_cty::c_int,
    pub max_reg_power: ::aya_bpf_cty::c_int,
    pub beacon_found: bool_,
    pub orig_flags: u32_,
    pub orig_mag: ::aya_bpf_cty::c_int,
    pub orig_mpwr: ::aya_bpf_cty::c_int,
    pub dfs_state: nl80211_dfs_state::Type,
    pub dfs_state_entered: ::aya_bpf_cty::c_ulong,
    pub dfs_cac_ms: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_rate {
    pub flags: u32_,
    pub bitrate: u16_,
    pub hw_value: u16_,
    pub hw_value_short: u16_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_ht_cap {
    pub cap: u16_,
    pub ht_supported: bool_,
    pub ampdu_factor: u8_,
    pub ampdu_density: u8_,
    pub mcs: ieee80211_mcs_info,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ieee80211_sta_ht_cap {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_vht_cap {
    pub vht_supported: bool_,
    pub cap: u32_,
    pub vht_mcs: ieee80211_vht_mcs_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_he_cap {
    pub has_he: bool_,
    pub he_cap_elem: ieee80211_he_cap_elem,
    pub he_mcs_nss_supp: ieee80211_he_mcs_nss_supp,
    pub ppe_thres: [u8_; 25usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sband_iftype_data {
    pub types_mask: u16_,
    pub he_cap: ieee80211_sta_he_cap,
    pub he_6ghz_capa: ieee80211_he_6ghz_capa,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ieee80211_sband_iftype_data {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_s1g_cap {
    pub s1g: bool_,
    pub cap: [u8_; 10usize],
    pub nss_mcs: [u8_; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_supported_band {
    pub channels: *mut ieee80211_channel,
    pub bitrates: *mut ieee80211_rate,
    pub band: nl80211_band::Type,
    pub n_channels: ::aya_bpf_cty::c_int,
    pub n_bitrates: ::aya_bpf_cty::c_int,
    pub ht_cap: ieee80211_sta_ht_cap,
    pub vht_cap: ieee80211_sta_vht_cap,
    pub s1g_cap: ieee80211_sta_s1g_cap,
    pub edmg_cap: ieee80211_edmg,
    pub n_iftype_data: u16_,
    pub iftype_data: *const ieee80211_sband_iftype_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_params {
    pub key: *const u8_,
    pub seq: *const u8_,
    pub key_len: ::aya_bpf_cty::c_int,
    pub seq_len: ::aya_bpf_cty::c_int,
    pub vlan_id: u16_,
    pub cipher: u32_,
    pub mode: nl80211_key_mode::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mac_address {
    pub addr: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sar_freq_ranges {
    pub start_freq: u32_,
    pub end_freq: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sar_capa {
    pub type_: nl80211_sar_type::Type,
    pub num_freq_ranges: u32_,
    pub freq_ranges: *const cfg80211_sar_freq_ranges,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_ssid {
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
}
pub mod cfg80211_signal_type {
    pub type Type = ::aya_bpf_cty::c_uint;
    pub const CFG80211_SIGNAL_TYPE_NONE: Type = 0;
    pub const CFG80211_SIGNAL_TYPE_MBM: Type = 1;
    pub const CFG80211_SIGNAL_TYPE_UNSPEC: Type = 2;
}
#[repr(C)]
pub struct wiphy {
    pub perm_addr: [u8_; 6usize],
    pub addr_mask: [u8_; 6usize],
    pub addresses: *mut mac_address,
    pub mgmt_stypes: *const ieee80211_txrx_stypes,
    pub iface_combinations: *const ieee80211_iface_combination,
    pub n_iface_combinations: ::aya_bpf_cty::c_int,
    pub software_iftypes: u16_,
    pub n_addresses: u16_,
    pub interface_modes: u16_,
    pub max_acl_mac_addrs: u16_,
    pub flags: u32_,
    pub regulatory_flags: u32_,
    pub features: u32_,
    pub ext_features: [u8_; 7usize],
    pub ap_sme_capa: u32_,
    pub signal_type: cfg80211_signal_type::Type,
    pub bss_priv_size: ::aya_bpf_cty::c_int,
    pub max_scan_ssids: u8_,
    pub max_sched_scan_reqs: u8_,
    pub max_sched_scan_ssids: u8_,
    pub max_match_sets: u8_,
    pub max_scan_ie_len: u16_,
    pub max_sched_scan_ie_len: u16_,
    pub max_sched_scan_plans: u32_,
    pub max_sched_scan_plan_interval: u32_,
    pub max_sched_scan_plan_iterations: u32_,
    pub n_cipher_suites: ::aya_bpf_cty::c_int,
    pub cipher_suites: *const u32_,
    pub n_akm_suites: ::aya_bpf_cty::c_int,
    pub akm_suites: *const u32_,
    pub iftype_akm_suites: *const wiphy_iftype_akm_suites,
    pub num_iftype_akm_suites: ::aya_bpf_cty::c_uint,
    pub retry_short: u8_,
    pub retry_long: u8_,
    pub frag_threshold: u32_,
    pub rts_threshold: u32_,
    pub coverage_class: u8_,
    pub fw_version: [::aya_bpf_cty::c_char; 32usize],
    pub hw_version: u32_,
    pub wowlan: *const wiphy_wowlan_support,
    pub wowlan_config: *mut cfg80211_wowlan,
    pub max_remain_on_channel_duration: u16_,
    pub max_num_pmkids: u8_,
    pub available_antennas_tx: u32_,
    pub available_antennas_rx: u32_,
    pub probe_resp_offload: u32_,
    pub extended_capabilities: *const u8_,
    pub extended_capabilities_mask: *const u8_,
    pub extended_capabilities_len: u8_,
    pub iftype_ext_capab: *const wiphy_iftype_ext_capab,
    pub num_iftype_ext_capab: ::aya_bpf_cty::c_uint,
    pub privid: *const ::aya_bpf_cty::c_void,
    pub bands: [*mut ieee80211_supported_band; 5usize],
    pub reg_notifier: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut wiphy, arg2: *mut regulatory_request),
    >,
    pub regd: *const ieee80211_regdomain,
    pub dev: device,
    pub registered: bool_,
    pub debugfsdir: *mut dentry,
    pub ht_capa_mod_mask: *const ieee80211_ht_cap,
    pub vht_capa_mod_mask: *const ieee80211_vht_cap,
    pub wdev_list: list_head,
    pub _net: possible_net_t,
    pub wext: *const iw_handler_def,
    pub coalesce: *const wiphy_coalesce_support,
    pub vendor_commands: *const wiphy_vendor_command,
    pub vendor_events: *const nl80211_vendor_cmd_info,
    pub n_vendor_commands: ::aya_bpf_cty::c_int,
    pub n_vendor_events: ::aya_bpf_cty::c_int,
    pub max_ap_assoc_sta: u16_,
    pub max_num_csa_counters: u8_,
    pub bss_select_support: u32_,
    pub nan_supported_bands: u8_,
    pub txq_limit: u32_,
    pub txq_memory_limit: u32_,
    pub txq_quantum: u32_,
    pub tx_queue_len: ::aya_bpf_cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pmsr_capa: *const cfg80211_pmsr_capabilities,
    pub tid_config_support: wiphy__bindgen_ty_1,
    pub max_data_retry_count: u8_,
    pub sar_capa: *const cfg80211_sar_capa,
    pub priv_: __IncompleteArrayField<::aya_bpf_cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy__bindgen_ty_1 {
    pub peer: u64_,
    pub vif: u64_,
    pub max_retry: u8_,
}
impl wiphy {
    #[inline]
    pub fn support_mbssid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_mbssid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn support_only_he_mbssid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_only_he_mbssid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        support_mbssid: u8_,
        support_only_he_mbssid: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let support_mbssid: u8 = unsafe { ::core::mem::transmute(support_mbssid) };
            support_mbssid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let support_only_he_mbssid: u8 =
                unsafe { ::core::mem::transmute(support_only_he_mbssid) };
            support_only_he_mbssid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_match_set {
    pub ssid: cfg80211_ssid,
    pub bssid: [u8_; 6usize],
    pub rssi_thold: s32,
    pub per_band_rssi_thold: [s32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sched_scan_plan {
    pub interval: u32_,
    pub iterations: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct cfg80211_sched_scan_request {
    pub reqid: u64_,
    pub ssids: *mut cfg80211_ssid,
    pub n_ssids: ::aya_bpf_cty::c_int,
    pub n_channels: u32_,
    pub scan_width: nl80211_bss_scan_width::Type,
    pub ie: *const u8_,
    pub ie_len: size_t,
    pub flags: u32_,
    pub match_sets: *mut cfg80211_match_set,
    pub n_match_sets: ::aya_bpf_cty::c_int,
    pub min_rssi_thold: s32,
    pub delay: u32_,
    pub scan_plans: *mut cfg80211_sched_scan_plan,
    pub n_scan_plans: ::aya_bpf_cty::c_int,
    pub mac_addr: [u8_; 6usize],
    pub mac_addr_mask: [u8_; 6usize],
    pub relative_rssi_set: bool_,
    pub relative_rssi: s8,
    pub rssi_adjust: cfg80211_bss_select_adjust,
    pub wiphy: *mut wiphy,
    pub dev: *mut net_device,
    pub scan_start: ::aya_bpf_cty::c_ulong,
    pub report_results: bool_,
    pub callback_head: callback_head,
    pub owner_nlportid: u32_,
    pub nl_owner_dead: bool_,
    pub list: list_head,
    pub channels: __IncompleteArrayField<*mut ieee80211_channel>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pkt_pattern {
    pub mask: *const u8_,
    pub pattern: *const u8_,
    pub pattern_len: ::aya_bpf_cty::c_int,
    pub pkt_offset: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct cfg80211_wowlan_tcp {
    pub sock: *mut socket,
    pub src: __be32,
    pub dst: __be32,
    pub src_port: u16_,
    pub dst_port: u16_,
    pub dst_mac: [u8_; 6usize],
    pub payload_len: ::aya_bpf_cty::c_int,
    pub payload: *const u8_,
    pub payload_seq: nl80211_wowlan_tcp_data_seq,
    pub data_interval: u32_,
    pub wake_len: u32_,
    pub wake_data: *const u8_,
    pub wake_mask: *const u8_,
    pub tokens_size: u32_,
    pub payload_tok: nl80211_wowlan_tcp_data_token,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_wowlan {
    pub any: bool_,
    pub disconnect: bool_,
    pub magic_pkt: bool_,
    pub gtk_rekey_failure: bool_,
    pub eap_identity_req: bool_,
    pub four_way_handshake: bool_,
    pub rfkill_release: bool_,
    pub patterns: *mut cfg80211_pkt_pattern,
    pub tcp: *mut cfg80211_wowlan_tcp,
    pub n_patterns: ::aya_bpf_cty::c_int,
    pub nd_config: *mut cfg80211_sched_scan_request,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_iface_limit {
    pub max: u16_,
    pub types: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_iface_combination {
    pub limits: *const ieee80211_iface_limit,
    pub num_different_channels: u32_,
    pub max_interfaces: u16_,
    pub n_limits: u8_,
    pub beacon_int_infra_match: bool_,
    pub radar_detect_widths: u8_,
    pub radar_detect_regions: u8_,
    pub beacon_int_min_gcd: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_txrx_stypes {
    pub tx: u16_,
    pub rx: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_wowlan_tcp_support {
    pub tok: *const nl80211_wowlan_tcp_data_token_feature,
    pub data_payload_max: u32_,
    pub data_interval_max: u32_,
    pub wake_payload_max: u32_,
    pub seq: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_wowlan_support {
    pub flags: u32_,
    pub n_patterns: ::aya_bpf_cty::c_int,
    pub pattern_max_len: ::aya_bpf_cty::c_int,
    pub pattern_min_len: ::aya_bpf_cty::c_int,
    pub max_pkt_offset: ::aya_bpf_cty::c_int,
    pub max_nd_match_sets: ::aya_bpf_cty::c_int,
    pub tcp: *const wiphy_wowlan_tcp_support,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_coalesce_support {
    pub n_rules: ::aya_bpf_cty::c_int,
    pub max_delay: ::aya_bpf_cty::c_int,
    pub n_patterns: ::aya_bpf_cty::c_int,
    pub pattern_max_len: ::aya_bpf_cty::c_int,
    pub pattern_min_len: ::aya_bpf_cty::c_int,
    pub max_pkt_offset: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_vendor_command {
    pub info: nl80211_vendor_cmd_info,
    pub flags: u32_,
    pub doit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wiphy,
            arg2: *mut wireless_dev,
            arg3: *const ::aya_bpf_cty::c_void,
            arg4: ::aya_bpf_cty::c_int,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub dumpit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wiphy,
            arg2: *mut wireless_dev,
            arg3: *mut sk_buff,
            arg4: *const ::aya_bpf_cty::c_void,
            arg5: ::aya_bpf_cty::c_int,
            arg6: *mut ::aya_bpf_cty::c_ulong,
        ) -> ::aya_bpf_cty::c_int,
    >,
    pub policy: *const nla_policy,
    pub maxattr: ::aya_bpf_cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_iftype_ext_capab {
    pub iftype: nl80211_iftype::Type,
    pub extended_capabilities: *const u8_,
    pub extended_capabilities_mask: *const u8_,
    pub extended_capabilities_len: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pmsr_capabilities {
    pub max_peers: ::aya_bpf_cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ftm: cfg80211_pmsr_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pmsr_capabilities__bindgen_ty_1 {
    pub preambles: u32_,
    pub bandwidths: u32_,
    pub max_bursts_exponent: s8,
    pub max_ftms_per_burst: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl cfg80211_pmsr_capabilities__bindgen_ty_1 {
    #[inline]
    pub fn supported(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_asap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_asap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_asap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_lci(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_lci(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_civicloc(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_civicloc(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger_based(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trigger_based(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_trigger_based(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_trigger_based(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u8_,
        asap: u8_,
        non_asap: u8_,
        request_lci: u8_,
        request_civicloc: u8_,
        trigger_based: u8_,
        non_trigger_based: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u8 = unsafe { ::core::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let asap: u8 = unsafe { ::core::mem::transmute(asap) };
            asap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let non_asap: u8 = unsafe { ::core::mem::transmute(non_asap) };
            non_asap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let request_lci: u8 = unsafe { ::core::mem::transmute(request_lci) };
            request_lci as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_civicloc: u8 = unsafe { ::core::mem::transmute(request_civicloc) };
            request_civicloc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let trigger_based: u8 = unsafe { ::core::mem::transmute(trigger_based) };
            trigger_based as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let non_trigger_based: u8 = unsafe { ::core::mem::transmute(non_trigger_based) };
            non_trigger_based as u64
        });
        __bindgen_bitfield_unit
    }
}
impl cfg80211_pmsr_capabilities {
    #[inline]
    pub fn report_ap_tsf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_report_ap_tsf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn randomize_mac_addr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_randomize_mac_addr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        report_ap_tsf: u8_,
        randomize_mac_addr: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let report_ap_tsf: u8 = unsafe { ::core::mem::transmute(report_ap_tsf) };
            report_ap_tsf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let randomize_mac_addr: u8 = unsafe { ::core::mem::transmute(randomize_mac_addr) };
            randomize_mac_addr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_iftype_akm_suites {
    pub iftypes_mask: u16_,
    pub akm_suites: *const u32_,
    pub n_akm_suites: ::aya_bpf_cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xsk_queue {
    pub ring_mask: u32_,
    pub nentries: u32_,
    pub cached_prod: u32_,
    pub cached_cons: u32_,
    pub ring: *mut xdp_ring,
    pub invalid_descs: u64_,
    pub queue_empty_descs: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_ring {
    pub producer: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 64usize]>,
    pub pad1: u32_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 64usize]>,
    pub consumer: u32_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 64usize]>,
    pub pad2: u32_,
    pub flags: u32_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub pad3: u32_,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 64usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mptcp_mib {
    pub mibs: [::aya_bpf_cty::c_ulong; 23usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_def {
    pub type_: ::aya_bpf_cty::c_uint,
    pub key_size: ::aya_bpf_cty::c_uint,
    pub value_size: ::aya_bpf_cty::c_uint,
    pub max_entries: ::aya_bpf_cty::c_uint,
    pub map_flags: ::aya_bpf_cty::c_uint,
    pub id: ::aya_bpf_cty::c_uint,
    pub pinning: ::aya_bpf_cty::c_uint,
}
pub const TC_ACT_UNSPEC: i32 = -1;
pub const TC_ACT_OK: u32 = 0;
pub const TC_ACT_RECLASSIFY: u32 = 1;
pub const TC_ACT_SHOT: u32 = 2;
pub const TC_ACT_PIPE: u32 = 3;
pub const TC_ACT_STOLEN: u32 = 4;
pub const TC_ACT_QUEUED: u32 = 5;
pub const TC_ACT_REPEAT: u32 = 6;
pub const TC_ACT_REDIRECT: u32 = 7;
pub const TC_ACT_TRAP: u32 = 8;
pub const TC_ACT_VALUE_MAX: u32 = 8;
pub const TC_ACT_EXT_VAL_MASK: u32 = 268435455;
