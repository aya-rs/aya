use super::bindings::*;
impl<Storage> __BindgenBitfieldUnit<Storage> {}
impl atomic_t {
    pub fn counter(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.counter) }.ok()
    }
}
impl atomic64_t {
    pub fn counter(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.counter) }.ok()
    }
}
impl list_head {
    pub fn next(&self) -> Option<*mut list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev(&self) -> Option<*mut list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl hlist_head {
    pub fn first(&self) -> Option<*mut hlist_node> {
        let v = unsafe { crate::bpf_probe_read(&self.first) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl hlist_node {
    pub fn next(&self) -> Option<*mut hlist_node> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pprev(&self) -> Option<*mut *mut hlist_node> {
        let v = unsafe { crate::bpf_probe_read(&self.pprev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl callback_head {
    pub fn next(&self) -> Option<*mut callback_head> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut callback_head)>> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
}
impl lock_class_key {}
impl file_system_type {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fs_flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fs_flags) }.ok()
    }
    pub fn init_fs_context(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.init_fs_context) }.ok()
    }
    pub fn parameters(&self) -> Option<*const fs_parameter_spec> {
        let v = unsafe { crate::bpf_probe_read(&self.parameters) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mount(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file_system_type,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: *mut ::aya_bpf_cty::c_void,
            ) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mount) }.ok()
    }
    pub fn kill_sb(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>> {
        unsafe { crate::bpf_probe_read(&self.kill_sb) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut file_system_type> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fs_supers(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.fs_supers) }.ok()
    }
    pub fn s_lock_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.s_lock_key) }.ok()
    }
    pub fn s_umount_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.s_umount_key) }.ok()
    }
    pub fn s_vfs_rename_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.s_vfs_rename_key) }.ok()
    }
    pub fn s_writers_key(&self) -> Option<[lock_class_key; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.s_writers_key) }.ok()
    }
    pub fn i_lock_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.i_lock_key) }.ok()
    }
    pub fn i_mutex_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.i_mutex_key) }.ok()
    }
    pub fn i_mutex_dir_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.i_mutex_dir_key) }.ok()
    }
}
impl qspinlock {
    pub fn val(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.val) }.ok()
    }
    pub fn locked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.locked) }.ok()
    }
    pub fn pending(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.pending) }.ok()
    }
    pub fn locked_pending(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.locked_pending) }
            .ok()
    }
    pub fn tail(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.tail) }.ok()
    }
}
impl qspinlock__bindgen_ty_1 {
    pub fn val(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn locked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.locked) }.ok()
    }
    pub fn pending(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pending) }.ok()
    }
    pub fn locked_pending(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.locked_pending) }.ok()
    }
    pub fn tail(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.tail) }.ok()
    }
}
impl qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub fn locked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.locked) }.ok()
    }
    pub fn pending(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
}
impl qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub fn locked_pending(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.locked_pending) }.ok()
    }
    pub fn tail(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
}
impl qrwlock {
    pub fn cnts(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.cnts) }.ok()
    }
    pub fn wlocked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.wlocked) }.ok()
    }
    pub fn __lstate(&self) -> Option<[u8_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.__lstate) }.ok()
    }
    pub fn wait_lock(&self) -> Option<arch_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.wait_lock) }.ok()
    }
}
impl qrwlock__bindgen_ty_1 {
    pub fn cnts(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.cnts) }.ok()
    }
    pub fn wlocked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.wlocked) }.ok()
    }
    pub fn __lstate(&self) -> Option<[u8_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__lstate) }.ok()
    }
}
impl qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub fn wlocked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.wlocked) }.ok()
    }
    pub fn __lstate(&self) -> Option<[u8_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__lstate) }.ok()
    }
}
impl raw_spinlock {
    pub fn raw_lock(&self) -> Option<arch_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.raw_lock) }.ok()
    }
}
impl spinlock {
    pub fn rlock(&self) -> Option<raw_spinlock> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rlock) }.ok()
    }
}
impl spinlock__bindgen_ty_1 {
    pub fn rlock(&self) -> Option<raw_spinlock> {
        unsafe { crate::bpf_probe_read(&self.rlock) }.ok()
    }
}
impl rwlock_t {
    pub fn raw_lock(&self) -> Option<arch_rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.raw_lock) }.ok()
    }
}
impl ratelimit_state {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn interval(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.interval) }.ok()
    }
    pub fn burst(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.burst) }.ok()
    }
    pub fn printed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.printed) }.ok()
    }
    pub fn missed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.missed) }.ok()
    }
    pub fn begin(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.begin) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl file_operations {
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn llseek(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: ::aya_bpf_cty::c_int,
            ) -> loff_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.llseek) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn read_iter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_iter) }.ok()
    }
    pub fn write_iter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_iter) }.ok()
    }
    pub fn iopoll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.iopoll) }.ok()
    }
    pub fn iterate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.iterate) }.ok()
    }
    pub fn iterate_shared(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.iterate_shared) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn unlocked_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unlocked_ioctl) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
    pub fn mmap_supported_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_supported_flags) }.ok()
    }
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn flush(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: fl_owner_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flush) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn fsync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: loff_t,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fsync) }.ok()
    }
    pub fn fasync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_bpf_cty::c_int,
                arg2: *mut file,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fasync) }.ok()
    }
    pub fn lock(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut file_lock,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn sendpage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut page,
                arg3: ::aya_bpf_cty::c_int,
                arg4: size_t,
                arg5: *mut loff_t,
                arg6: ::aya_bpf_cty::c_int,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendpage) }.ok()
    }
    pub fn get_unmapped_area(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: ::aya_bpf_cty::c_ulong,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_unmapped_area) }.ok()
    }
    pub fn check_flags(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_int) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_flags) }.ok()
    }
    pub fn setfl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setfl) }.ok()
    }
    pub fn flock(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut file_lock,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flock) }.ok()
    }
    pub fn splice_write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pipe_inode_info,
                arg2: *mut file,
                arg3: *mut loff_t,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.splice_write) }.ok()
    }
    pub fn splice_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut loff_t,
                arg3: *mut pipe_inode_info,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.splice_read) }.ok()
    }
    pub fn setlease(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_long,
                arg3: *mut *mut file_lock,
                arg4: *mut *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setlease) }.ok()
    }
    pub fn fallocate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_int,
                arg3: loff_t,
                arg4: loff_t,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fallocate) }.ok()
    }
    pub fn show_fdinfo(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut file)>>
    {
        unsafe { crate::bpf_probe_read(&self.show_fdinfo) }.ok()
    }
    pub fn copy_file_range(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: *mut file,
                arg4: loff_t,
                arg5: size_t,
                arg6: ::aya_bpf_cty::c_uint,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.copy_file_range) }.ok()
    }
    pub fn remap_file_range(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: *mut file,
                arg4: loff_t,
                arg5: loff_t,
                arg6: ::aya_bpf_cty::c_uint,
            ) -> loff_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.remap_file_range) }.ok()
    }
    pub fn fadvise(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: loff_t,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fadvise) }.ok()
    }
}
impl __kernel_timespec {
    pub fn tv_sec(&self) -> Option<__kernel_time64_t> {
        unsafe { crate::bpf_probe_read(&self.tv_sec) }.ok()
    }
    pub fn tv_nsec(&self) -> Option<::aya_bpf_cty::c_longlong> {
        unsafe { crate::bpf_probe_read(&self.tv_nsec) }.ok()
    }
}
impl timespec64 {
    pub fn tv_sec(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.tv_sec) }.ok()
    }
    pub fn tv_nsec(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.tv_nsec) }.ok()
    }
}
impl old_timespec32 {
    pub fn tv_sec(&self) -> Option<old_time32_t> {
        unsafe { crate::bpf_probe_read(&self.tv_sec) }.ok()
    }
    pub fn tv_nsec(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.tv_nsec) }.ok()
    }
}
impl restart_block {
    pub fn fn_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut restart_block) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
    pub fn futex(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.futex) }.ok()
    }
    pub fn nanosleep(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nanosleep) }.ok()
    }
    pub fn poll(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.poll) }.ok()
    }
}
impl restart_block__bindgen_ty_1 {
    pub fn futex(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.futex) }.ok()
    }
    pub fn nanosleep(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.nanosleep) }.ok()
    }
    pub fn poll(&self) -> Option<restart_block__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
}
impl restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub fn uaddr(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.uaddr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn val(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn bitset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bitset) }.ok()
    }
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
    pub fn uaddr2(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.uaddr2) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub fn clockid(&self) -> Option<clockid_t> {
        unsafe { crate::bpf_probe_read(&self.clockid) }.ok()
    }
    pub fn type_(&self) -> Option<timespec_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn rmtp(&self) -> Option<*mut __kernel_timespec> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rmtp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn compat_rmtp(&self) -> Option<*mut old_timespec32> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.compat_rmtp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn expires(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
}
impl restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub fn rmtp(&self) -> Option<*mut __kernel_timespec> {
        let v = unsafe { crate::bpf_probe_read(&self.rmtp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn compat_rmtp(&self) -> Option<*mut old_timespec32> {
        let v = unsafe { crate::bpf_probe_read(&self.compat_rmtp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub fn ufds(&self) -> Option<*mut pollfd> {
        let v = unsafe { crate::bpf_probe_read(&self.ufds) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nfds(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nfds) }.ok()
    }
    pub fn has_timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.has_timeout) }.ok()
    }
    pub fn tv_sec(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tv_sec) }.ok()
    }
    pub fn tv_nsec(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tv_nsec) }.ok()
    }
}
impl thread_info {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn syscall_work(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.syscall_work) }.ok()
    }
    pub fn status(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
}
impl refcount_struct {
    pub fn refs(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refs) }.ok()
    }
}
impl llist_node {
    pub fn next(&self) -> Option<*mut llist_node> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __call_single_node {
    pub fn llist(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.llist) }.ok()
    }
    pub fn u_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.u_flags) }.ok()
    }
    pub fn a_flags(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.a_flags) }.ok()
    }
    pub fn src(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
    pub fn dst(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
}
impl __call_single_node__bindgen_ty_1 {
    pub fn u_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.u_flags) }.ok()
    }
    pub fn a_flags(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.a_flags) }.ok()
    }
}
impl load_weight {
    pub fn weight(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.weight) }.ok()
    }
    pub fn inv_weight(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.inv_weight) }.ok()
    }
}
impl rb_node {
    pub fn __rb_parent_color(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__rb_parent_color) }.ok()
    }
    pub fn rb_right(&self) -> Option<*mut rb_node> {
        let v = unsafe { crate::bpf_probe_read(&self.rb_right) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rb_left(&self) -> Option<*mut rb_node> {
        let v = unsafe { crate::bpf_probe_read(&self.rb_left) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sched_statistics {
    pub fn wait_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.wait_start) }.ok()
    }
    pub fn wait_max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.wait_max) }.ok()
    }
    pub fn wait_count(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.wait_count) }.ok()
    }
    pub fn wait_sum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.wait_sum) }.ok()
    }
    pub fn iowait_count(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.iowait_count) }.ok()
    }
    pub fn iowait_sum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.iowait_sum) }.ok()
    }
    pub fn sleep_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.sleep_start) }.ok()
    }
    pub fn sleep_max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.sleep_max) }.ok()
    }
    pub fn sum_sleep_runtime(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.sum_sleep_runtime) }.ok()
    }
    pub fn block_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.block_start) }.ok()
    }
    pub fn block_max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.block_max) }.ok()
    }
    pub fn exec_max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.exec_max) }.ok()
    }
    pub fn slice_max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.slice_max) }.ok()
    }
    pub fn nr_migrations_cold(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_migrations_cold) }.ok()
    }
    pub fn nr_failed_migrations_affine(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_failed_migrations_affine) }.ok()
    }
    pub fn nr_failed_migrations_running(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_failed_migrations_running) }.ok()
    }
    pub fn nr_failed_migrations_hot(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_failed_migrations_hot) }.ok()
    }
    pub fn nr_forced_migrations(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_forced_migrations) }.ok()
    }
    pub fn nr_wakeups(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups) }.ok()
    }
    pub fn nr_wakeups_sync(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_sync) }.ok()
    }
    pub fn nr_wakeups_migrate(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_migrate) }.ok()
    }
    pub fn nr_wakeups_local(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_local) }.ok()
    }
    pub fn nr_wakeups_remote(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_remote) }.ok()
    }
    pub fn nr_wakeups_affine(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_affine) }.ok()
    }
    pub fn nr_wakeups_affine_attempts(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_affine_attempts) }.ok()
    }
    pub fn nr_wakeups_passive(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_passive) }.ok()
    }
    pub fn nr_wakeups_idle(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_wakeups_idle) }.ok()
    }
}
impl util_est {
    pub fn enqueued(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.enqueued) }.ok()
    }
    pub fn ewma(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ewma) }.ok()
    }
}
impl sched_avg {
    pub fn last_update_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_update_time) }.ok()
    }
    pub fn load_sum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.load_sum) }.ok()
    }
    pub fn runnable_sum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.runnable_sum) }.ok()
    }
    pub fn util_sum(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.util_sum) }.ok()
    }
    pub fn period_contrib(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.period_contrib) }.ok()
    }
    pub fn load_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.load_avg) }.ok()
    }
    pub fn runnable_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.runnable_avg) }.ok()
    }
    pub fn util_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.util_avg) }.ok()
    }
    pub fn util_est(&self) -> Option<util_est> {
        unsafe { crate::bpf_probe_read(&self.util_est) }.ok()
    }
}
impl sched_entity {
    pub fn load(&self) -> Option<load_weight> {
        unsafe { crate::bpf_probe_read(&self.load) }.ok()
    }
    pub fn run_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.run_node) }.ok()
    }
    pub fn group_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.group_node) }.ok()
    }
    pub fn on_rq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.on_rq) }.ok()
    }
    pub fn exec_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.exec_start) }.ok()
    }
    pub fn sum_exec_runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.sum_exec_runtime) }.ok()
    }
    pub fn vruntime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.vruntime) }.ok()
    }
    pub fn prev_sum_exec_runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.prev_sum_exec_runtime) }.ok()
    }
    pub fn nr_migrations(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_migrations) }.ok()
    }
    pub fn statistics(&self) -> Option<sched_statistics> {
        unsafe { crate::bpf_probe_read(&self.statistics) }.ok()
    }
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
    pub fn parent(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cfs_rq(&self) -> Option<*mut cfs_rq> {
        let v = unsafe { crate::bpf_probe_read(&self.cfs_rq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn my_q(&self) -> Option<*mut cfs_rq> {
        let v = unsafe { crate::bpf_probe_read(&self.my_q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn runnable_weight(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.runnable_weight) }.ok()
    }
    pub fn avg(&self) -> Option<sched_avg> {
        unsafe { crate::bpf_probe_read(&self.avg) }.ok()
    }
}
impl sched_rt_entity {
    pub fn run_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.run_list) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn watchdog_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.watchdog_stamp) }.ok()
    }
    pub fn time_slice(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.time_slice) }.ok()
    }
    pub fn on_rq(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.on_rq) }.ok()
    }
    pub fn on_list(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.on_list) }.ok()
    }
    pub fn back(&self) -> Option<*mut sched_rt_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.back) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl timerqueue_node {
    pub fn node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn expires(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
}
impl hrtimer {
    pub fn node(&self) -> Option<timerqueue_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn _softexpires(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self._softexpires) }.ok()
    }
    pub fn function(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart::Type>,
    > {
        unsafe { crate::bpf_probe_read(&self.function) }.ok()
    }
    pub fn base(&self) -> Option<*mut hrtimer_clock_base> {
        let v = unsafe { crate::bpf_probe_read(&self.base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn is_rel(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.is_rel) }.ok()
    }
    pub fn is_soft(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.is_soft) }.ok()
    }
    pub fn is_hard(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.is_hard) }.ok()
    }
}
impl sched_dl_entity {
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()
    }
    pub fn dl_runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl_runtime) }.ok()
    }
    pub fn dl_deadline(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl_deadline) }.ok()
    }
    pub fn dl_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl_period) }.ok()
    }
    pub fn dl_bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl_bw) }.ok()
    }
    pub fn dl_density(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl_density) }.ok()
    }
    pub fn runtime(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.runtime) }.ok()
    }
    pub fn deadline(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.deadline) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn dl_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.dl_timer) }.ok()
    }
    pub fn inactive_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.inactive_timer) }.ok()
    }
    pub fn pi_se(&self) -> Option<*mut sched_dl_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.pi_se) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl uclamp_se {
    pub fn __bindgen_padding_0(&self) -> Option<u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl cpumask {
    pub fn bits(&self) -> Option<[::aya_bpf_cty::c_ulong; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.bits) }.ok()
    }
}
impl rcu_special {
    pub fn b(&self) -> Option<rcu_special__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.b) }.ok()
    }
    pub fn s(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.s) }.ok()
    }
}
impl rcu_special__bindgen_ty_1 {
    pub fn blocked(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.blocked) }.ok()
    }
    pub fn need_qs(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.need_qs) }.ok()
    }
    pub fn exp_hint(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.exp_hint) }.ok()
    }
    pub fn need_mb(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.need_mb) }.ok()
    }
}
impl sched_info {
    pub fn pcount(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pcount) }.ok()
    }
    pub fn run_delay(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.run_delay) }.ok()
    }
    pub fn last_arrival(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.last_arrival) }.ok()
    }
    pub fn last_queued(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.last_queued) }.ok()
    }
}
impl plist_node {
    pub fn prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn prio_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.prio_list) }.ok()
    }
    pub fn node_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node_list) }.ok()
    }
}
impl vmacache {
    pub fn seqnum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.seqnum) }.ok()
    }
    pub fn vmas(&self) -> Option<[*mut vm_area_struct; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.vmas) }.ok()
    }
}
impl task_rss_stat {
    pub fn events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn count(&self) -> Option<[::aya_bpf_cty::c_int; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl prev_cputime {
    pub fn utime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.utime) }.ok()
    }
    pub fn stime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stime) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl rb_root {
    pub fn rb_node(&self) -> Option<*mut rb_node> {
        let v = unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rb_root_cached {
    pub fn rb_root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.rb_root) }.ok()
    }
    pub fn rb_leftmost(&self) -> Option<*mut rb_node> {
        let v = unsafe { crate::bpf_probe_read(&self.rb_leftmost) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl timerqueue_head {
    pub fn rb_root(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.rb_root) }.ok()
    }
}
impl posix_cputimer_base {
    pub fn nextevt(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nextevt) }.ok()
    }
    pub fn tqhead(&self) -> Option<timerqueue_head> {
        unsafe { crate::bpf_probe_read(&self.tqhead) }.ok()
    }
}
impl posix_cputimers {
    pub fn bases(&self) -> Option<[posix_cputimer_base; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.bases) }.ok()
    }
    pub fn timers_active(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timers_active) }.ok()
    }
    pub fn expiry_active(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.expiry_active) }.ok()
    }
}
impl posix_cputimers_work {
    pub fn work(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn scheduled(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.scheduled) }.ok()
    }
}
impl sysv_sem {
    pub fn undo_list(&self) -> Option<*mut sem_undo_list> {
        let v = unsafe { crate::bpf_probe_read(&self.undo_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sysv_shm {
    pub fn shm_clist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.shm_clist) }.ok()
    }
}
impl sigset_t {
    pub fn sig(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.sig) }.ok()
    }
}
impl sigpending {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn signal(&self) -> Option<sigset_t> {
        unsafe { crate::bpf_probe_read(&self.signal) }.ok()
    }
}
impl kuid_t {
    pub fn val(&self) -> Option<uid_t> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl seccomp {
    pub fn mode(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn filter_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.filter_count) }.ok()
    }
    pub fn filter(&self) -> Option<*mut seccomp_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl syscall_user_dispatch {
    pub fn selector(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.selector) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn on_dispatch(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.on_dispatch) }.ok()
    }
}
impl wake_q_node {
    pub fn next(&self) -> Option<*mut wake_q_node> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl task_io_accounting {
    pub fn rchar(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rchar) }.ok()
    }
    pub fn wchar(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.wchar) }.ok()
    }
    pub fn syscr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.syscr) }.ok()
    }
    pub fn syscw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.syscw) }.ok()
    }
    pub fn read_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.read_bytes) }.ok()
    }
    pub fn write_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.write_bytes) }.ok()
    }
    pub fn cancelled_write_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cancelled_write_bytes) }.ok()
    }
}
impl nodemask_t {
    pub fn bits(&self) -> Option<[::aya_bpf_cty::c_ulong; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.bits) }.ok()
    }
}
impl seqcount {
    pub fn sequence(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sequence) }.ok()
    }
}
impl seqcount_spinlock {
    pub fn seqcount(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.seqcount) }.ok()
    }
}
impl optimistic_spin_queue {
    pub fn tail(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
}
impl mutex {
    pub fn owner(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.owner) }.ok()
    }
    pub fn wait_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.wait_lock) }.ok()
    }
    pub fn osq(&self) -> Option<optimistic_spin_queue> {
        unsafe { crate::bpf_probe_read(&self.osq) }.ok()
    }
    pub fn wait_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.wait_list) }.ok()
    }
}
impl arch_tlbflush_unmap_batch {
    pub fn cpumask(&self) -> Option<cpumask> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
}
impl tlbflush_unmap_batch {
    pub fn arch(&self) -> Option<arch_tlbflush_unmap_batch> {
        unsafe { crate::bpf_probe_read(&self.arch) }.ok()
    }
    pub fn flush_required(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.flush_required) }.ok()
    }
    pub fn writable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.writable) }.ok()
    }
}
impl page_frag {
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl kmap_ctrl {}
impl llist_head {
    pub fn first(&self) -> Option<*mut llist_node> {
        let v = unsafe { crate::bpf_probe_read(&self.first) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl desc_struct {
    pub fn limit0(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.limit0) }.ok()
    }
    pub fn base0(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.base0) }.ok()
    }
}
impl fregs_state {
    pub fn cwd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cwd) }.ok()
    }
    pub fn swd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.swd) }.ok()
    }
    pub fn twd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.twd) }.ok()
    }
    pub fn fip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fip) }.ok()
    }
    pub fn fcs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fcs) }.ok()
    }
    pub fn foo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.foo) }.ok()
    }
    pub fn fos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fos) }.ok()
    }
    pub fn st_space(&self) -> Option<[u32_; 20usize]> {
        unsafe { crate::bpf_probe_read(&self.st_space) }.ok()
    }
    pub fn status(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
}
impl fxregs_state {
    pub fn cwd(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cwd) }.ok()
    }
    pub fn swd(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.swd) }.ok()
    }
    pub fn twd(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.twd) }.ok()
    }
    pub fn fop(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.fop) }.ok()
    }
    pub fn rip(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.rip) }.ok()
    }
    pub fn rdp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.rdp) }.ok()
    }
    pub fn fip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.fip) }.ok()
    }
    pub fn fcs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.fcs) }.ok()
    }
    pub fn foo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.foo) }.ok()
    }
    pub fn fos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.fos) }.ok()
    }
    pub fn mxcsr(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mxcsr) }.ok()
    }
    pub fn mxcsr_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mxcsr_mask) }.ok()
    }
    pub fn st_space(&self) -> Option<[u32_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.st_space) }.ok()
    }
    pub fn xmm_space(&self) -> Option<[u32_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.xmm_space) }.ok()
    }
    pub fn padding(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn padding1(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.padding1) }.ok()
    }
    pub fn sw_reserved(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.sw_reserved) }.ok()
    }
}
impl fxregs_state__bindgen_ty_1 {
    pub fn rip(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rip) }.ok()
    }
    pub fn rdp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rdp) }.ok()
    }
    pub fn fip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.fip) }.ok()
    }
    pub fn fcs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.fcs) }.ok()
    }
    pub fn foo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.foo) }.ok()
    }
    pub fn fos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.fos) }.ok()
    }
}
impl fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub fn rip(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rip) }.ok()
    }
    pub fn rdp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rdp) }.ok()
    }
}
impl fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fn fip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fip) }.ok()
    }
    pub fn fcs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fcs) }.ok()
    }
    pub fn foo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.foo) }.ok()
    }
    pub fn fos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fos) }.ok()
    }
}
impl fxregs_state__bindgen_ty_2 {
    pub fn padding1(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.padding1) }.ok()
    }
    pub fn sw_reserved(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.sw_reserved) }.ok()
    }
}
impl swregs_state {
    pub fn cwd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cwd) }.ok()
    }
    pub fn swd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.swd) }.ok()
    }
    pub fn twd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.twd) }.ok()
    }
    pub fn fip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fip) }.ok()
    }
    pub fn fcs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fcs) }.ok()
    }
    pub fn foo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.foo) }.ok()
    }
    pub fn fos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fos) }.ok()
    }
    pub fn st_space(&self) -> Option<[u32_; 20usize]> {
        unsafe { crate::bpf_probe_read(&self.st_space) }.ok()
    }
    pub fn ftop(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ftop) }.ok()
    }
    pub fn changed(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.changed) }.ok()
    }
    pub fn lookahead(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.lookahead) }.ok()
    }
    pub fn no_update(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.no_update) }.ok()
    }
    pub fn rm(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rm) }.ok()
    }
    pub fn alimit(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.alimit) }.ok()
    }
    pub fn info(&self) -> Option<*mut math_emu_info> {
        let v = unsafe { crate::bpf_probe_read(&self.info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entry_eip(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.entry_eip) }.ok()
    }
}
impl xstate_header {
    pub fn xfeatures(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.xfeatures) }.ok()
    }
    pub fn xcomp_bv(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.xcomp_bv) }.ok()
    }
    pub fn reserved(&self) -> Option<[u64_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl xregs_state {
    pub fn i387(&self) -> Option<fxregs_state> {
        unsafe { crate::bpf_probe_read(&self.i387) }.ok()
    }
    pub fn header(&self) -> Option<xstate_header> {
        unsafe { crate::bpf_probe_read(&self.header) }.ok()
    }
    pub fn extended_state_area(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.extended_state_area) }.ok()
    }
}
impl fpregs_state {
    pub fn fsave(&self) -> Option<__BindgenUnionField<fregs_state>> {
        unsafe { crate::bpf_probe_read(&self.fsave) }.ok()
    }
    pub fn fxsave(&self) -> Option<__BindgenUnionField<fxregs_state>> {
        unsafe { crate::bpf_probe_read(&self.fxsave) }.ok()
    }
    pub fn soft(&self) -> Option<__BindgenUnionField<swregs_state>> {
        unsafe { crate::bpf_probe_read(&self.soft) }.ok()
    }
    pub fn xsave(&self) -> Option<__BindgenUnionField<xregs_state>> {
        unsafe { crate::bpf_probe_read(&self.xsave) }.ok()
    }
    pub fn __padding(&self) -> Option<__BindgenUnionField<[u8_; 4096usize]>> {
        unsafe { crate::bpf_probe_read(&self.__padding) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u64; 512usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl fpu {
    pub fn last_cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.last_cpu) }.ok()
    }
    pub fn avx512_timestamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.avx512_timestamp) }.ok()
    }
    pub fn state(&self) -> Option<fpregs_state> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
}
impl thread_struct {
    pub fn tls_array(&self) -> Option<[desc_struct; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.tls_array) }.ok()
    }
    pub fn sp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sp) }.ok()
    }
    pub fn es(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.es) }.ok()
    }
    pub fn ds(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ds) }.ok()
    }
    pub fn fsindex(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.fsindex) }.ok()
    }
    pub fn gsindex(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.gsindex) }.ok()
    }
    pub fn fsbase(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fsbase) }.ok()
    }
    pub fn gsbase(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.gsbase) }.ok()
    }
    pub fn ptrace_bps(&self) -> Option<[*mut perf_event; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ptrace_bps) }.ok()
    }
    pub fn virtual_dr6(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.virtual_dr6) }.ok()
    }
    pub fn ptrace_dr7(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ptrace_dr7) }.ok()
    }
    pub fn cr2(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cr2) }.ok()
    }
    pub fn trap_nr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trap_nr) }.ok()
    }
    pub fn error_code(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.error_code) }.ok()
    }
    pub fn io_bitmap(&self) -> Option<*mut io_bitmap> {
        let v = unsafe { crate::bpf_probe_read(&self.io_bitmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iopl_emul(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.iopl_emul) }.ok()
    }
    pub fn fpu(&self) -> Option<fpu> {
        unsafe { crate::bpf_probe_read(&self.fpu) }.ok()
    }
}
impl task_struct {
    pub fn thread_info(&self) -> Option<thread_info> {
        unsafe { crate::bpf_probe_read(&self.thread_info) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn stack(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn usage(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn ptrace(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ptrace) }.ok()
    }
    pub fn on_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.on_cpu) }.ok()
    }
    pub fn wake_entry(&self) -> Option<__call_single_node> {
        unsafe { crate::bpf_probe_read(&self.wake_entry) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn wakee_flips(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.wakee_flips) }.ok()
    }
    pub fn wakee_flip_decay_ts(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.wakee_flip_decay_ts) }.ok()
    }
    pub fn last_wakee(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.last_wakee) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn recent_used_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.recent_used_cpu) }.ok()
    }
    pub fn wake_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wake_cpu) }.ok()
    }
    pub fn on_rq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.on_rq) }.ok()
    }
    pub fn prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn static_prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.static_prio) }.ok()
    }
    pub fn normal_prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.normal_prio) }.ok()
    }
    pub fn rt_priority(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rt_priority) }.ok()
    }
    pub fn sched_class(&self) -> Option<*const sched_class> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_class) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn se(&self) -> Option<sched_entity> {
        unsafe { crate::bpf_probe_read(&self.se) }.ok()
    }
    pub fn rt(&self) -> Option<sched_rt_entity> {
        unsafe { crate::bpf_probe_read(&self.rt) }.ok()
    }
    pub fn sched_task_group(&self) -> Option<*mut task_group> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_task_group) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dl(&self) -> Option<sched_dl_entity> {
        unsafe { crate::bpf_probe_read(&self.dl) }.ok()
    }
    pub fn uclamp_req(&self) -> Option<[uclamp_se; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp_req) }.ok()
    }
    pub fn uclamp(&self) -> Option<[uclamp_se; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp) }.ok()
    }
    pub fn preempt_notifiers(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.preempt_notifiers) }.ok()
    }
    pub fn btrace_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.btrace_seq) }.ok()
    }
    pub fn policy(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.policy) }.ok()
    }
    pub fn nr_cpus_allowed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_cpus_allowed) }.ok()
    }
    pub fn cpus_ptr(&self) -> Option<*const cpumask_t> {
        let v = unsafe { crate::bpf_probe_read(&self.cpus_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpus_mask(&self) -> Option<cpumask_t> {
        unsafe { crate::bpf_probe_read(&self.cpus_mask) }.ok()
    }
    pub fn migration_pending(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.migration_pending) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn migration_disabled(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.migration_disabled) }.ok()
    }
    pub fn migration_flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.migration_flags) }.ok()
    }
    pub fn trc_reader_nesting(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.trc_reader_nesting) }.ok()
    }
    pub fn trc_ipi_to_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.trc_ipi_to_cpu) }.ok()
    }
    pub fn trc_reader_special(&self) -> Option<rcu_special> {
        unsafe { crate::bpf_probe_read(&self.trc_reader_special) }.ok()
    }
    pub fn trc_reader_checked(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.trc_reader_checked) }.ok()
    }
    pub fn trc_holdout_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.trc_holdout_list) }.ok()
    }
    pub fn sched_info(&self) -> Option<sched_info> {
        unsafe { crate::bpf_probe_read(&self.sched_info) }.ok()
    }
    pub fn tasks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tasks) }.ok()
    }
    pub fn pushable_tasks(&self) -> Option<plist_node> {
        unsafe { crate::bpf_probe_read(&self.pushable_tasks) }.ok()
    }
    pub fn pushable_dl_tasks(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.pushable_dl_tasks) }.ok()
    }
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn active_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.active_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vmacache(&self) -> Option<vmacache> {
        unsafe { crate::bpf_probe_read(&self.vmacache) }.ok()
    }
    pub fn rss_stat(&self) -> Option<task_rss_stat> {
        unsafe { crate::bpf_probe_read(&self.rss_stat) }.ok()
    }
    pub fn exit_state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.exit_state) }.ok()
    }
    pub fn exit_code(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.exit_code) }.ok()
    }
    pub fn exit_signal(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.exit_signal) }.ok()
    }
    pub fn pdeath_signal(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pdeath_signal) }.ok()
    }
    pub fn jobctl(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.jobctl) }.ok()
    }
    pub fn personality(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.personality) }.ok()
    }
    pub fn atomic_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.atomic_flags) }.ok()
    }
    pub fn restart_block(&self) -> Option<restart_block> {
        unsafe { crate::bpf_probe_read(&self.restart_block) }.ok()
    }
    pub fn pid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn tgid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.tgid) }.ok()
    }
    pub fn stack_canary(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.stack_canary) }.ok()
    }
    pub fn real_parent(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.real_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn children(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.children) }.ok()
    }
    pub fn sibling(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sibling) }.ok()
    }
    pub fn group_leader(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.group_leader) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ptraced(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ptraced) }.ok()
    }
    pub fn ptrace_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ptrace_entry) }.ok()
    }
    pub fn thread_pid(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.thread_pid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pid_links(&self) -> Option<[hlist_node; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.pid_links) }.ok()
    }
    pub fn thread_group(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.thread_group) }.ok()
    }
    pub fn thread_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.thread_node) }.ok()
    }
    pub fn vfork_done(&self) -> Option<*mut completion> {
        let v = unsafe { crate::bpf_probe_read(&self.vfork_done) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn set_child_tid(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.set_child_tid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn clear_child_tid(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.clear_child_tid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn utime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.utime) }.ok()
    }
    pub fn stime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stime) }.ok()
    }
    pub fn gtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.gtime) }.ok()
    }
    pub fn prev_cputime(&self) -> Option<prev_cputime> {
        unsafe { crate::bpf_probe_read(&self.prev_cputime) }.ok()
    }
    pub fn nvcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nvcsw) }.ok()
    }
    pub fn nivcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nivcsw) }.ok()
    }
    pub fn start_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.start_time) }.ok()
    }
    pub fn start_boottime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.start_boottime) }.ok()
    }
    pub fn min_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_flt) }.ok()
    }
    pub fn maj_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.maj_flt) }.ok()
    }
    pub fn posix_cputimers(&self) -> Option<posix_cputimers> {
        unsafe { crate::bpf_probe_read(&self.posix_cputimers) }.ok()
    }
    pub fn posix_cputimers_work(&self) -> Option<posix_cputimers_work> {
        unsafe { crate::bpf_probe_read(&self.posix_cputimers_work) }.ok()
    }
    pub fn ptracer_cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.ptracer_cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn real_cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.real_cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cached_requested_key(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.cached_requested_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn comm(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.comm) }.ok()
    }
    pub fn nameidata(&self) -> Option<*mut nameidata> {
        let v = unsafe { crate::bpf_probe_read(&self.nameidata) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysvsem(&self) -> Option<sysv_sem> {
        unsafe { crate::bpf_probe_read(&self.sysvsem) }.ok()
    }
    pub fn sysvshm(&self) -> Option<sysv_shm> {
        unsafe { crate::bpf_probe_read(&self.sysvshm) }.ok()
    }
    pub fn last_switch_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_switch_count) }.ok()
    }
    pub fn last_switch_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_switch_time) }.ok()
    }
    pub fn fs(&self) -> Option<*mut fs_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn files(&self) -> Option<*mut files_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.files) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn io_uring(&self) -> Option<*mut io_uring_task> {
        let v = unsafe { crate::bpf_probe_read(&self.io_uring) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nsproxy(&self) -> Option<*mut nsproxy> {
        let v = unsafe { crate::bpf_probe_read(&self.nsproxy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn signal(&self) -> Option<*mut signal_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.signal) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sighand(&self) -> Option<*mut sighand_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.sighand) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blocked(&self) -> Option<sigset_t> {
        unsafe { crate::bpf_probe_read(&self.blocked) }.ok()
    }
    pub fn real_blocked(&self) -> Option<sigset_t> {
        unsafe { crate::bpf_probe_read(&self.real_blocked) }.ok()
    }
    pub fn saved_sigmask(&self) -> Option<sigset_t> {
        unsafe { crate::bpf_probe_read(&self.saved_sigmask) }.ok()
    }
    pub fn pending(&self) -> Option<sigpending> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
    pub fn sas_ss_sp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sas_ss_sp) }.ok()
    }
    pub fn sas_ss_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.sas_ss_size) }.ok()
    }
    pub fn sas_ss_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sas_ss_flags) }.ok()
    }
    pub fn task_works(&self) -> Option<*mut callback_head> {
        let v = unsafe { crate::bpf_probe_read(&self.task_works) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn audit_context(&self) -> Option<*mut audit_context> {
        let v = unsafe { crate::bpf_probe_read(&self.audit_context) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn loginuid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.loginuid) }.ok()
    }
    pub fn sessionid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sessionid) }.ok()
    }
    pub fn seccomp(&self) -> Option<seccomp> {
        unsafe { crate::bpf_probe_read(&self.seccomp) }.ok()
    }
    pub fn syscall_dispatch(&self) -> Option<syscall_user_dispatch> {
        unsafe { crate::bpf_probe_read(&self.syscall_dispatch) }.ok()
    }
    pub fn parent_exec_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.parent_exec_id) }.ok()
    }
    pub fn self_exec_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.self_exec_id) }.ok()
    }
    pub fn alloc_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.alloc_lock) }.ok()
    }
    pub fn pi_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.pi_lock) }.ok()
    }
    pub fn wake_q(&self) -> Option<wake_q_node> {
        unsafe { crate::bpf_probe_read(&self.wake_q) }.ok()
    }
    pub fn pi_waiters(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.pi_waiters) }.ok()
    }
    pub fn pi_top_task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.pi_top_task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pi_blocked_on(&self) -> Option<*mut rt_mutex_waiter> {
        let v = unsafe { crate::bpf_probe_read(&self.pi_blocked_on) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn journal_info(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.journal_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bio_list(&self) -> Option<*mut bio_list> {
        let v = unsafe { crate::bpf_probe_read(&self.bio_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn plug(&self) -> Option<*mut blk_plug> {
        let v = unsafe { crate::bpf_probe_read(&self.plug) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reclaim_state(&self) -> Option<*mut reclaim_state> {
        let v = unsafe { crate::bpf_probe_read(&self.reclaim_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn backing_dev_info(&self) -> Option<*mut backing_dev_info> {
        let v = unsafe { crate::bpf_probe_read(&self.backing_dev_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn io_context(&self) -> Option<*mut io_context> {
        let v = unsafe { crate::bpf_probe_read(&self.io_context) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn capture_control(&self) -> Option<*mut capture_control> {
        let v = unsafe { crate::bpf_probe_read(&self.capture_control) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ptrace_message(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ptrace_message) }.ok()
    }
    pub fn last_siginfo(&self) -> Option<*mut kernel_siginfo_t> {
        let v = unsafe { crate::bpf_probe_read(&self.last_siginfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioac(&self) -> Option<task_io_accounting> {
        unsafe { crate::bpf_probe_read(&self.ioac) }.ok()
    }
    pub fn psi_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.psi_flags) }.ok()
    }
    pub fn acct_rss_mem1(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.acct_rss_mem1) }.ok()
    }
    pub fn acct_vm_mem1(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.acct_vm_mem1) }.ok()
    }
    pub fn acct_timexpd(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.acct_timexpd) }.ok()
    }
    pub fn mems_allowed(&self) -> Option<nodemask_t> {
        unsafe { crate::bpf_probe_read(&self.mems_allowed) }.ok()
    }
    pub fn mems_allowed_seq(&self) -> Option<seqcount_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mems_allowed_seq) }.ok()
    }
    pub fn cpuset_mem_spread_rotor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpuset_mem_spread_rotor) }.ok()
    }
    pub fn cpuset_slab_spread_rotor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpuset_slab_spread_rotor) }.ok()
    }
    pub fn cgroups(&self) -> Option<*mut css_set> {
        let v = unsafe { crate::bpf_probe_read(&self.cgroups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cg_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cg_list) }.ok()
    }
    pub fn closid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.closid) }.ok()
    }
    pub fn rmid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rmid) }.ok()
    }
    pub fn robust_list(&self) -> Option<*mut robust_list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.robust_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn compat_robust_list(&self) -> Option<*mut compat_robust_list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.compat_robust_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pi_state_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pi_state_list) }.ok()
    }
    pub fn pi_state_cache(&self) -> Option<*mut futex_pi_state> {
        let v = unsafe { crate::bpf_probe_read(&self.pi_state_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn futex_exit_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.futex_exit_mutex) }.ok()
    }
    pub fn futex_state(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.futex_state) }.ok()
    }
    pub fn perf_event_ctxp(&self) -> Option<[*mut perf_event_context; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.perf_event_ctxp) }.ok()
    }
    pub fn perf_event_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.perf_event_mutex) }.ok()
    }
    pub fn perf_event_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.perf_event_list) }.ok()
    }
    pub fn mempolicy(&self) -> Option<*mut mempolicy> {
        let v = unsafe { crate::bpf_probe_read(&self.mempolicy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn il_prev(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.il_prev) }.ok()
    }
    pub fn pref_node_fork(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.pref_node_fork) }.ok()
    }
    pub fn numa_scan_seq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_scan_seq) }.ok()
    }
    pub fn numa_scan_period(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.numa_scan_period) }.ok()
    }
    pub fn numa_scan_period_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.numa_scan_period_max) }.ok()
    }
    pub fn numa_preferred_nid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_preferred_nid) }.ok()
    }
    pub fn numa_migrate_retry(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.numa_migrate_retry) }.ok()
    }
    pub fn node_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.node_stamp) }.ok()
    }
    pub fn last_task_numa_placement(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_task_numa_placement) }.ok()
    }
    pub fn last_sum_exec_runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_sum_exec_runtime) }.ok()
    }
    pub fn numa_work(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.numa_work) }.ok()
    }
    pub fn numa_group(&self) -> Option<*mut numa_group> {
        let v = unsafe { crate::bpf_probe_read(&self.numa_group) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn numa_faults(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.numa_faults) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn total_numa_faults(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_numa_faults) }.ok()
    }
    pub fn numa_faults_locality(&self) -> Option<[::aya_bpf_cty::c_ulong; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.numa_faults_locality) }.ok()
    }
    pub fn numa_pages_migrated(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.numa_pages_migrated) }.ok()
    }
    pub fn rseq(&self) -> Option<*mut rseq> {
        let v = unsafe { crate::bpf_probe_read(&self.rseq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rseq_sig(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rseq_sig) }.ok()
    }
    pub fn rseq_event_mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rseq_event_mask) }.ok()
    }
    pub fn tlb_ubc(&self) -> Option<tlbflush_unmap_batch> {
        unsafe { crate::bpf_probe_read(&self.tlb_ubc) }.ok()
    }
    pub fn rcu_users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu_users) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn splice_pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.splice_pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn task_frag(&self) -> Option<page_frag> {
        unsafe { crate::bpf_probe_read(&self.task_frag) }.ok()
    }
    pub fn delays(&self) -> Option<*mut task_delay_info> {
        let v = unsafe { crate::bpf_probe_read(&self.delays) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_dirtied(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_dirtied) }.ok()
    }
    pub fn nr_dirtied_pause(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_dirtied_pause) }.ok()
    }
    pub fn dirty_paused_when(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirty_paused_when) }.ok()
    }
    pub fn timer_slack_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.timer_slack_ns) }.ok()
    }
    pub fn default_timer_slack_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.default_timer_slack_ns) }.ok()
    }
    pub fn curr_ret_stack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.curr_ret_stack) }.ok()
    }
    pub fn curr_ret_depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.curr_ret_depth) }.ok()
    }
    pub fn ret_stack(&self) -> Option<*mut ftrace_ret_stack> {
        let v = unsafe { crate::bpf_probe_read(&self.ret_stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ftrace_timestamp(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.ftrace_timestamp) }.ok()
    }
    pub fn trace_overrun(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.trace_overrun) }.ok()
    }
    pub fn tracing_graph_pause(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tracing_graph_pause) }.ok()
    }
    pub fn trace(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trace) }.ok()
    }
    pub fn trace_recursion(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trace_recursion) }.ok()
    }
    pub fn memcg_in_oom(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg_in_oom) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn memcg_oom_gfp_mask(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.memcg_oom_gfp_mask) }.ok()
    }
    pub fn memcg_oom_order(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.memcg_oom_order) }.ok()
    }
    pub fn memcg_nr_pages_over_high(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.memcg_nr_pages_over_high) }.ok()
    }
    pub fn active_memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.active_memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn throttle_queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.throttle_queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn utask(&self) -> Option<*mut uprobe_task> {
        let v = unsafe { crate::bpf_probe_read(&self.utask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sequential_io(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sequential_io) }.ok()
    }
    pub fn sequential_io_avg(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sequential_io_avg) }.ok()
    }
    pub fn kmap_ctrl(&self) -> Option<kmap_ctrl> {
        unsafe { crate::bpf_probe_read(&self.kmap_ctrl) }.ok()
    }
    pub fn pagefault_disabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pagefault_disabled) }.ok()
    }
    pub fn oom_reaper_list(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.oom_reaper_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stack_vm_area(&self) -> Option<*mut vm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.stack_vm_area) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stack_refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.stack_refcount) }.ok()
    }
    pub fn patch_state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.patch_state) }.ok()
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mce_vaddr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.mce_vaddr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mce_kflags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.mce_kflags) }.ok()
    }
    pub fn mce_addr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.mce_addr) }.ok()
    }
    pub fn mce_kill_me(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.mce_kill_me) }.ok()
    }
    pub fn kretprobe_instances(&self) -> Option<llist_head> {
        unsafe { crate::bpf_probe_read(&self.kretprobe_instances) }.ok()
    }
    pub fn thread(&self) -> Option<thread_struct> {
        unsafe { crate::bpf_probe_read(&self.thread) }.ok()
    }
}
impl task_struct__bindgen_ty_1 {
    pub fn rcu_users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.rcu_users) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl range {
    pub fn start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn end(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
}
impl pt_regs {
    pub fn r15(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r15) }.ok()
    }
    pub fn r14(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r14) }.ok()
    }
    pub fn r13(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r13) }.ok()
    }
    pub fn r12(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r12) }.ok()
    }
    pub fn bp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.bp) }.ok()
    }
    pub fn bx(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.bx) }.ok()
    }
    pub fn r11(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r11) }.ok()
    }
    pub fn r10(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r10) }.ok()
    }
    pub fn r9(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r9) }.ok()
    }
    pub fn r8(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.r8) }.ok()
    }
    pub fn ax(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ax) }.ok()
    }
    pub fn cx(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cx) }.ok()
    }
    pub fn dx(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dx) }.ok()
    }
    pub fn si(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.si) }.ok()
    }
    pub fn di(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.di) }.ok()
    }
    pub fn orig_ax(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.orig_ax) }.ok()
    }
    pub fn ip(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ip) }.ok()
    }
    pub fn cs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cs) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn sp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sp) }.ok()
    }
    pub fn ss(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ss) }.ok()
    }
}
impl pte_t {
    pub fn pte(&self) -> Option<pteval_t> {
        unsafe { crate::bpf_probe_read(&self.pte) }.ok()
    }
}
impl pgprot {
    pub fn pgprot(&self) -> Option<pgprotval_t> {
        unsafe { crate::bpf_probe_read(&self.pgprot) }.ok()
    }
}
impl pgd_t {
    pub fn pgd(&self) -> Option<pgdval_t> {
        unsafe { crate::bpf_probe_read(&self.pgd) }.ok()
    }
}
impl pud_t {
    pub fn pud(&self) -> Option<pudval_t> {
        unsafe { crate::bpf_probe_read(&self.pud) }.ok()
    }
}
impl pmd_t {
    pub fn pmd(&self) -> Option<pmdval_t> {
        unsafe { crate::bpf_probe_read(&self.pmd) }.ok()
    }
}
impl page {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.lru) }.ok()
    }
    pub fn mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.mapping) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.index) }.ok()
    }
    pub fn private(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.private) }.ok()
    }
    pub fn dma_addr(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.dma_addr) }.ok()
    }
    pub fn slab_list(&self) -> Option<list_head> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .slab_list,
            )
        }
        .ok()
    }
    pub fn next(&self) -> Option<*mut page> {
        let v = unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .next,
            )
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .pages,
            )
        }
        .ok()
    }
    pub fn pobjects(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .pobjects,
            )
        }
        .ok()
    }
    pub fn slab_cache(&self) -> Option<*mut kmem_cache> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_3.slab_cache) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn freelist(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_3.freelist) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_mem(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_2
                    .s_mem,
            )
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn counters(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_3
                    .__bindgen_anon_2
                    .counters,
            )
        }
        .ok()
    }
    pub fn compound_head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.compound_head) }.ok()
    }
    pub fn compound_dtor(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.compound_dtor) }.ok()
    }
    pub fn compound_order(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.compound_order) }
            .ok()
    }
    pub fn compound_mapcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.compound_mapcount) }
            .ok()
    }
    pub fn compound_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.compound_nr) }.ok()
    }
    pub fn _compound_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_5._compound_pad_1) }
            .ok()
    }
    pub fn hpage_pinned_refcount(&self) -> Option<atomic_t> {
        unsafe {
            crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_5.hpage_pinned_refcount)
        }
        .ok()
    }
    pub fn deferred_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_5.deferred_list) }.ok()
    }
    pub fn _pt_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6._pt_pad_1) }.ok()
    }
    pub fn pmd_huge_pte(&self) -> Option<pgtable_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.pmd_huge_pte) }.ok()
    }
    pub fn _pt_pad_2(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6._pt_pad_2) }.ok()
    }
    pub fn pt_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_6
                    .__bindgen_anon_1
                    .pt_mm,
            )
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pt_frag_refcount(&self) -> Option<atomic_t> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_6
                    .__bindgen_anon_1
                    .pt_frag_refcount,
            )
        }
        .ok()
    }
    pub fn ptl(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.ptl) }.ok()
    }
    pub fn pgmap(&self) -> Option<*mut dev_pagemap> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_7.pgmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn zone_device_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe {
            crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_7.zone_device_data)
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.callback_head) }.ok()
    }
    pub fn _mapcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2._mapcount) }.ok()
    }
    pub fn page_type(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.page_type) }.ok()
    }
    pub fn active(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.active) }.ok()
    }
    pub fn units(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.units) }.ok()
    }
    pub fn _refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self._refcount) }.ok()
    }
    pub fn memcg_data(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.memcg_data) }.ok()
    }
}
impl page__bindgen_ty_1 {
    pub fn lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lru) }.ok()
    }
    pub fn mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mapping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.index) }.ok()
    }
    pub fn private(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.private) }.ok()
    }
    pub fn dma_addr(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.dma_addr) }.ok()
    }
    pub fn slab_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.slab_list) }.ok()
    }
    pub fn next(&self) -> Option<*mut page> {
        let v = unsafe {
            crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.__bindgen_anon_1.next)
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .pages,
            )
        }
        .ok()
    }
    pub fn pobjects(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_3
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .pobjects,
            )
        }
        .ok()
    }
    pub fn slab_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.slab_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn freelist(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.freelist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_mem(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_2.s_mem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn counters(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_2.counters) }.ok()
    }
    pub fn compound_head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.compound_head) }.ok()
    }
    pub fn compound_dtor(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.compound_dtor) }.ok()
    }
    pub fn compound_order(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.compound_order) }.ok()
    }
    pub fn compound_mapcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.compound_mapcount) }.ok()
    }
    pub fn compound_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.compound_nr) }.ok()
    }
    pub fn _compound_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5._compound_pad_1) }.ok()
    }
    pub fn hpage_pinned_refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.hpage_pinned_refcount) }.ok()
    }
    pub fn deferred_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.deferred_list) }.ok()
    }
    pub fn _pt_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6._pt_pad_1) }.ok()
    }
    pub fn pmd_huge_pte(&self) -> Option<pgtable_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.pmd_huge_pte) }.ok()
    }
    pub fn _pt_pad_2(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6._pt_pad_2) }.ok()
    }
    pub fn pt_mm(&self) -> Option<*mut mm_struct> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.pt_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pt_frag_refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.pt_frag_refcount) }
            .ok()
    }
    pub fn ptl(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.ptl) }.ok()
    }
    pub fn pgmap(&self) -> Option<*mut dev_pagemap> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.pgmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn zone_device_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.zone_device_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_1 {
    pub fn lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.lru) }.ok()
    }
    pub fn mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.mapping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn private(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.private) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_2 {
    pub fn dma_addr(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.dma_addr) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_3 {
    pub fn slab_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.slab_list) }.ok()
    }
    pub fn next(&self) -> Option<*mut page> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.pages) }.ok()
    }
    pub fn pobjects(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.pobjects) }.ok()
    }
    pub fn slab_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.slab_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn freelist(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.freelist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_mem(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.s_mem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn counters(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.counters) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub fn slab_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.slab_list) }.ok()
    }
    pub fn next(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pages) }.ok()
    }
    pub fn pobjects(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pobjects) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pages) }.ok()
    }
    pub fn pobjects(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pobjects) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub fn s_mem(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.s_mem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn counters(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.counters) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {}
impl page__bindgen_ty_1__bindgen_ty_4 {
    pub fn compound_head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.compound_head) }.ok()
    }
    pub fn compound_dtor(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.compound_dtor) }.ok()
    }
    pub fn compound_order(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.compound_order) }.ok()
    }
    pub fn compound_mapcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.compound_mapcount) }.ok()
    }
    pub fn compound_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.compound_nr) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_5 {
    pub fn _compound_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._compound_pad_1) }.ok()
    }
    pub fn hpage_pinned_refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.hpage_pinned_refcount) }.ok()
    }
    pub fn deferred_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.deferred_list) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_6 {
    pub fn _pt_pad_1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._pt_pad_1) }.ok()
    }
    pub fn pmd_huge_pte(&self) -> Option<pgtable_t> {
        unsafe { crate::bpf_probe_read(&self.pmd_huge_pte) }.ok()
    }
    pub fn _pt_pad_2(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._pt_pad_2) }.ok()
    }
    pub fn pt_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pt_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pt_frag_refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pt_frag_refcount) }.ok()
    }
    pub fn ptl(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.ptl) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub fn pt_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.pt_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pt_frag_refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.pt_frag_refcount) }.ok()
    }
}
impl page__bindgen_ty_1__bindgen_ty_7 {
    pub fn pgmap(&self) -> Option<*mut dev_pagemap> {
        let v = unsafe { crate::bpf_probe_read(&self.pgmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn zone_device_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.zone_device_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl page__bindgen_ty_2 {
    pub fn _mapcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self._mapcount) }.ok()
    }
    pub fn page_type(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.page_type) }.ok()
    }
    pub fn active(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.active) }.ok()
    }
    pub fn units(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.units) }.ok()
    }
}
impl rw_semaphore {
    pub fn count(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn owner(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.owner) }.ok()
    }
    pub fn osq(&self) -> Option<optimistic_spin_queue> {
        unsafe { crate::bpf_probe_read(&self.osq) }.ok()
    }
    pub fn wait_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.wait_lock) }.ok()
    }
    pub fn wait_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.wait_list) }.ok()
    }
}
impl mm_rss_stat {
    pub fn count(&self) -> Option<[atomic_long_t; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl mm_context_t {
    pub fn ctx_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ctx_id) }.ok()
    }
    pub fn tlb_gen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.tlb_gen) }.ok()
    }
    pub fn ldt_usr_sem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.ldt_usr_sem) }.ok()
    }
    pub fn ldt(&self) -> Option<*mut ldt_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.ldt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn vdso(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.vdso) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vdso_image(&self) -> Option<*const vdso_image> {
        let v = unsafe { crate::bpf_probe_read(&self.vdso_image) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn perf_rdpmc_allowed(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.perf_rdpmc_allowed) }.ok()
    }
    pub fn pkey_allocation_map(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.pkey_allocation_map) }.ok()
    }
    pub fn execute_only_pkey(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.execute_only_pkey) }.ok()
    }
}
impl uprobes_state {
    pub fn xol_area(&self) -> Option<*mut xol_area> {
        let v = unsafe { crate::bpf_probe_read(&self.xol_area) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl work_struct {
    pub fn data(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn func(&self) -> Option<work_func_t> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
}
impl mm_struct {
    pub fn mmap(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mm_rb(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mm_rb) }.ok()
    }
    pub fn vmacache_seqnum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.vmacache_seqnum) }.ok()
    }
    pub fn get_unmapped_area(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: ::aya_bpf_cty::c_ulong,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.get_unmapped_area) }.ok()
    }
    pub fn mmap_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap_base) }.ok()
    }
    pub fn mmap_legacy_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap_legacy_base) }.ok()
    }
    pub fn mmap_compat_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap_compat_base) }.ok()
    }
    pub fn mmap_compat_legacy_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap_compat_legacy_base) }.ok()
    }
    pub fn task_size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.task_size) }.ok()
    }
    pub fn highest_vm_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.highest_vm_end) }.ok()
    }
    pub fn pgd(&self) -> Option<*mut pgd_t> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pgd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn membarrier_state(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.membarrier_state) }.ok()
    }
    pub fn mm_users(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mm_users) }.ok()
    }
    pub fn mm_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mm_count) }.ok()
    }
    pub fn has_pinned(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.has_pinned) }.ok()
    }
    pub fn write_protect_seq(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.write_protect_seq) }.ok()
    }
    pub fn pgtables_bytes(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pgtables_bytes) }.ok()
    }
    pub fn map_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_count) }.ok()
    }
    pub fn page_table_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.page_table_lock) }.ok()
    }
    pub fn mmap_lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap_lock) }.ok()
    }
    pub fn mmlist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmlist) }.ok()
    }
    pub fn hiwater_rss(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hiwater_rss) }.ok()
    }
    pub fn hiwater_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hiwater_vm) }.ok()
    }
    pub fn total_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.total_vm) }.ok()
    }
    pub fn locked_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.locked_vm) }.ok()
    }
    pub fn pinned_vm(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pinned_vm) }.ok()
    }
    pub fn data_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.data_vm) }.ok()
    }
    pub fn exec_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.exec_vm) }.ok()
    }
    pub fn stack_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.stack_vm) }.ok()
    }
    pub fn def_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.def_flags) }.ok()
    }
    pub fn arg_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg_lock) }.ok()
    }
    pub fn start_code(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_code) }.ok()
    }
    pub fn end_code(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.end_code) }.ok()
    }
    pub fn start_data(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_data) }.ok()
    }
    pub fn end_data(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.end_data) }.ok()
    }
    pub fn start_brk(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_brk) }.ok()
    }
    pub fn brk(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.brk) }.ok()
    }
    pub fn start_stack(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_stack) }.ok()
    }
    pub fn arg_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg_start) }.ok()
    }
    pub fn arg_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg_end) }.ok()
    }
    pub fn env_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.env_start) }.ok()
    }
    pub fn env_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.env_end) }.ok()
    }
    pub fn saved_auxv(&self) -> Option<[::aya_bpf_cty::c_ulong; 46usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.saved_auxv) }.ok()
    }
    pub fn rss_stat(&self) -> Option<mm_rss_stat> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rss_stat) }.ok()
    }
    pub fn binfmt(&self) -> Option<*mut linux_binfmt> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.binfmt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn context(&self) -> Option<mm_context_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.context) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.flags) }.ok()
    }
    pub fn core_state(&self) -> Option<*mut core_state> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.core_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ioctx_lock) }.ok()
    }
    pub fn ioctx_table(&self) -> Option<*mut kioctx_table> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ioctx_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn exe_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.exe_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notifier_subscriptions(&self) -> Option<*mut mmu_notifier_subscriptions> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.notifier_subscriptions) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn numa_next_scan(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.numa_next_scan) }.ok()
    }
    pub fn numa_scan_offset(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.numa_scan_offset) }.ok()
    }
    pub fn numa_scan_seq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.numa_scan_seq) }.ok()
    }
    pub fn tlb_flush_pending(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tlb_flush_pending) }.ok()
    }
    pub fn tlb_flush_batched(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tlb_flush_batched) }.ok()
    }
    pub fn uprobes_state(&self) -> Option<uprobes_state> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.uprobes_state) }.ok()
    }
    pub fn hugetlb_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hugetlb_usage) }.ok()
    }
    pub fn async_put_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.async_put_work) }.ok()
    }
    pub fn pasid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pasid) }.ok()
    }
    pub fn cpu_bitmap(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.cpu_bitmap) }.ok()
    }
}
impl mm_struct__bindgen_ty_1 {
    pub fn mmap(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mm_rb(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.mm_rb) }.ok()
    }
    pub fn vmacache_seqnum(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.vmacache_seqnum) }.ok()
    }
    pub fn get_unmapped_area(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: ::aya_bpf_cty::c_ulong,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_unmapped_area) }.ok()
    }
    pub fn mmap_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_base) }.ok()
    }
    pub fn mmap_legacy_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_legacy_base) }.ok()
    }
    pub fn mmap_compat_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_compat_base) }.ok()
    }
    pub fn mmap_compat_legacy_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_compat_legacy_base) }.ok()
    }
    pub fn task_size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.task_size) }.ok()
    }
    pub fn highest_vm_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.highest_vm_end) }.ok()
    }
    pub fn pgd(&self) -> Option<*mut pgd_t> {
        let v = unsafe { crate::bpf_probe_read(&self.pgd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn membarrier_state(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.membarrier_state) }.ok()
    }
    pub fn mm_users(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.mm_users) }.ok()
    }
    pub fn mm_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.mm_count) }.ok()
    }
    pub fn has_pinned(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.has_pinned) }.ok()
    }
    pub fn write_protect_seq(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.write_protect_seq) }.ok()
    }
    pub fn pgtables_bytes(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.pgtables_bytes) }.ok()
    }
    pub fn map_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.map_count) }.ok()
    }
    pub fn page_table_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.page_table_lock) }.ok()
    }
    pub fn mmap_lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.mmap_lock) }.ok()
    }
    pub fn mmlist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mmlist) }.ok()
    }
    pub fn hiwater_rss(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hiwater_rss) }.ok()
    }
    pub fn hiwater_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hiwater_vm) }.ok()
    }
    pub fn total_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_vm) }.ok()
    }
    pub fn locked_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.locked_vm) }.ok()
    }
    pub fn pinned_vm(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.pinned_vm) }.ok()
    }
    pub fn data_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.data_vm) }.ok()
    }
    pub fn exec_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.exec_vm) }.ok()
    }
    pub fn stack_vm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.stack_vm) }.ok()
    }
    pub fn def_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.def_flags) }.ok()
    }
    pub fn arg_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.arg_lock) }.ok()
    }
    pub fn start_code(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start_code) }.ok()
    }
    pub fn end_code(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.end_code) }.ok()
    }
    pub fn start_data(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start_data) }.ok()
    }
    pub fn end_data(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.end_data) }.ok()
    }
    pub fn start_brk(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start_brk) }.ok()
    }
    pub fn brk(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.brk) }.ok()
    }
    pub fn start_stack(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start_stack) }.ok()
    }
    pub fn arg_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.arg_start) }.ok()
    }
    pub fn arg_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.arg_end) }.ok()
    }
    pub fn env_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.env_start) }.ok()
    }
    pub fn env_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.env_end) }.ok()
    }
    pub fn saved_auxv(&self) -> Option<[::aya_bpf_cty::c_ulong; 46usize]> {
        unsafe { crate::bpf_probe_read(&self.saved_auxv) }.ok()
    }
    pub fn rss_stat(&self) -> Option<mm_rss_stat> {
        unsafe { crate::bpf_probe_read(&self.rss_stat) }.ok()
    }
    pub fn binfmt(&self) -> Option<*mut linux_binfmt> {
        let v = unsafe { crate::bpf_probe_read(&self.binfmt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn context(&self) -> Option<mm_context_t> {
        unsafe { crate::bpf_probe_read(&self.context) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn core_state(&self) -> Option<*mut core_state> {
        let v = unsafe { crate::bpf_probe_read(&self.core_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.ioctx_lock) }.ok()
    }
    pub fn ioctx_table(&self) -> Option<*mut kioctx_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ioctx_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn exe_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.exe_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notifier_subscriptions(&self) -> Option<*mut mmu_notifier_subscriptions> {
        let v = unsafe { crate::bpf_probe_read(&self.notifier_subscriptions) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn numa_next_scan(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.numa_next_scan) }.ok()
    }
    pub fn numa_scan_offset(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.numa_scan_offset) }.ok()
    }
    pub fn numa_scan_seq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_scan_seq) }.ok()
    }
    pub fn tlb_flush_pending(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tlb_flush_pending) }.ok()
    }
    pub fn tlb_flush_batched(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tlb_flush_batched) }.ok()
    }
    pub fn uprobes_state(&self) -> Option<uprobes_state> {
        unsafe { crate::bpf_probe_read(&self.uprobes_state) }.ok()
    }
    pub fn hugetlb_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.hugetlb_usage) }.ok()
    }
    pub fn async_put_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.async_put_work) }.ok()
    }
    pub fn pasid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
}
impl vm_userfaultfd_ctx {
    pub fn ctx(&self) -> Option<*mut userfaultfd_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl vm_area_struct {
    pub fn vm_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vm_start) }.ok()
    }
    pub fn vm_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vm_end) }.ok()
    }
    pub fn vm_next(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_prev(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_rb(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.vm_rb) }.ok()
    }
    pub fn rb_subtree_gap(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rb_subtree_gap) }.ok()
    }
    pub fn vm_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_page_prot(&self) -> Option<pgprot_t> {
        unsafe { crate::bpf_probe_read(&self.vm_page_prot) }.ok()
    }
    pub fn vm_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vm_flags) }.ok()
    }
    pub fn shared(&self) -> Option<vm_area_struct__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.shared) }.ok()
    }
    pub fn anon_vma_chain(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.anon_vma_chain) }.ok()
    }
    pub fn anon_vma(&self) -> Option<*mut anon_vma> {
        let v = unsafe { crate::bpf_probe_read(&self.anon_vma) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_ops(&self) -> Option<*const vm_operations_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_pgoff(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vm_pgoff) }.ok()
    }
    pub fn vm_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_prfile(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_prfile) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_private_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_private_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn swap_readahead_info(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.swap_readahead_info) }.ok()
    }
    pub fn vm_policy(&self) -> Option<*mut mempolicy> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_userfaultfd_ctx(&self) -> Option<vm_userfaultfd_ctx> {
        unsafe { crate::bpf_probe_read(&self.vm_userfaultfd_ctx) }.ok()
    }
}
impl vm_area_struct__bindgen_ty_1 {
    pub fn rb(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb) }.ok()
    }
    pub fn rb_subtree_last(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rb_subtree_last) }.ok()
    }
}
impl math_emu_info {
    pub fn ___orig_eip(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.___orig_eip) }.ok()
    }
    pub fn regs(&self) -> Option<*mut pt_regs> {
        let v = unsafe { crate::bpf_probe_read(&self.regs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl vm_struct {
    pub fn next(&self) -> Option<*mut vm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pages(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_pages) }.ok()
    }
    pub fn phys_addr(&self) -> Option<phys_addr_t> {
        unsafe { crate::bpf_probe_read(&self.phys_addr) }.ok()
    }
    pub fn caller(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.caller) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl wait_queue_head {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
}
impl seqcount_raw_spinlock {
    pub fn seqcount(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.seqcount) }.ok()
    }
}
impl seqlock_t {
    pub fn seqcount(&self) -> Option<seqcount_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.seqcount) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl swait_queue_head {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn task_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.task_list) }.ok()
    }
}
impl completion {
    pub fn done(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn wait(&self) -> Option<swait_queue_head> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl arch_uprobe_task {
    pub fn saved_scratch_register(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.saved_scratch_register) }.ok()
    }
    pub fn saved_trap_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.saved_trap_nr) }.ok()
    }
    pub fn saved_tf(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.saved_tf) }.ok()
    }
}
impl uprobe_task {
    pub fn state(&self) -> Option<uprobe_task_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn autask(&self) -> Option<arch_uprobe_task> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.autask) }.ok()
    }
    pub fn vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.vaddr) }.ok()
    }
    pub fn dup_xol_work(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.dup_xol_work) }.ok()
    }
    pub fn dup_xol_addr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.dup_xol_addr) }.ok()
    }
    pub fn active_uprobe(&self) -> Option<*mut uprobe> {
        let v = unsafe { crate::bpf_probe_read(&self.active_uprobe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xol_vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.xol_vaddr) }.ok()
    }
    pub fn return_instances(&self) -> Option<*mut return_instance> {
        let v = unsafe { crate::bpf_probe_read(&self.return_instances) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
}
impl uprobe_task__bindgen_ty_1 {
    pub fn autask(&self) -> Option<arch_uprobe_task> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.autask) }.ok()
    }
    pub fn vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.vaddr) }.ok()
    }
    pub fn dup_xol_work(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.dup_xol_work) }.ok()
    }
    pub fn dup_xol_addr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.dup_xol_addr) }.ok()
    }
}
impl uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub fn autask(&self) -> Option<arch_uprobe_task> {
        unsafe { crate::bpf_probe_read(&self.autask) }.ok()
    }
    pub fn vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vaddr) }.ok()
    }
}
impl uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub fn dup_xol_work(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.dup_xol_work) }.ok()
    }
    pub fn dup_xol_addr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dup_xol_addr) }.ok()
    }
}
impl return_instance {
    pub fn uprobe(&self) -> Option<*mut uprobe> {
        let v = unsafe { crate::bpf_probe_read(&self.uprobe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn stack(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.stack) }.ok()
    }
    pub fn orig_ret_vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.orig_ret_vaddr) }.ok()
    }
    pub fn chained(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.chained) }.ok()
    }
    pub fn next(&self) -> Option<*mut return_instance> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl vdso_image {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn alt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.alt) }.ok()
    }
    pub fn alt_len(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.alt_len) }.ok()
    }
    pub fn extable_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.extable_base) }.ok()
    }
    pub fn extable_len(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.extable_len) }.ok()
    }
    pub fn extable(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.extable) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sym_vvar_start(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_vvar_start) }.ok()
    }
    pub fn sym_vvar_page(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_vvar_page) }.ok()
    }
    pub fn sym_pvclock_page(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_pvclock_page) }.ok()
    }
    pub fn sym_hvclock_page(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_hvclock_page) }.ok()
    }
    pub fn sym_timens_page(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_timens_page) }.ok()
    }
    pub fn sym_VDSO32_NOTE_MASK(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_VDSO32_NOTE_MASK) }.ok()
    }
    pub fn sym___kernel_sigreturn(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym___kernel_sigreturn) }.ok()
    }
    pub fn sym___kernel_rt_sigreturn(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym___kernel_rt_sigreturn) }.ok()
    }
    pub fn sym___kernel_vsyscall(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym___kernel_vsyscall) }.ok()
    }
    pub fn sym_int80_landing_pad(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_int80_landing_pad) }.ok()
    }
    pub fn sym_vdso32_sigreturn_landing_pad(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_vdso32_sigreturn_landing_pad) }.ok()
    }
    pub fn sym_vdso32_rt_sigreturn_landing_pad(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sym_vdso32_rt_sigreturn_landing_pad) }.ok()
    }
}
impl xarray {
    pub fn xa_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.xa_lock) }.ok()
    }
    pub fn xa_flags(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.xa_flags) }.ok()
    }
    pub fn xa_head(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.xa_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl address_space {
    pub fn host(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.host) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_pages(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.i_pages) }.ok()
    }
    pub fn gfp_mask(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.gfp_mask) }.ok()
    }
    pub fn i_mmap_writable(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.i_mmap_writable) }.ok()
    }
    pub fn i_mmap(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.i_mmap) }.ok()
    }
    pub fn i_mmap_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.i_mmap_rwsem) }.ok()
    }
    pub fn nrpages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nrpages) }.ok()
    }
    pub fn nrexceptional(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nrexceptional) }.ok()
    }
    pub fn writeback_index(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.writeback_index) }.ok()
    }
    pub fn a_ops(&self) -> Option<*const address_space_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.a_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn wb_err(&self) -> Option<errseq_t> {
        unsafe { crate::bpf_probe_read(&self.wb_err) }.ok()
    }
    pub fn private_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.private_lock) }.ok()
    }
    pub fn private_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.private_list) }.ok()
    }
    pub fn private_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl vmem_altmap {
    pub fn base_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.base_pfn) }.ok()
    }
    pub fn end_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.end_pfn) }.ok()
    }
    pub fn reserve(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reserve) }.ok()
    }
    pub fn free(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn align(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.align) }.ok()
    }
    pub fn alloc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.alloc) }.ok()
    }
}
impl percpu_ref {
    pub fn percpu_count_ptr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.percpu_count_ptr) }.ok()
    }
    pub fn data(&self) -> Option<*mut percpu_ref_data> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl dev_pagemap {
    pub fn altmap(&self) -> Option<vmem_altmap> {
        unsafe { crate::bpf_probe_read(&self.altmap) }.ok()
    }
    pub fn ref_(&self) -> Option<*mut percpu_ref> {
        let v = unsafe { crate::bpf_probe_read(&self.ref_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn internal_ref(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.internal_ref) }.ok()
    }
    pub fn done(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn type_(&self) -> Option<memory_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn ops(&self) -> Option<*const dev_pagemap_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_range(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_range) }.ok()
    }
    pub fn range(&self) -> Option<__BindgenUnionField<range>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.range) }.ok()
    }
    pub fn ranges(&self) -> Option<__BindgenUnionField<[range; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ranges) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u64; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bindgen_union_field) }.ok()
    }
}
impl dev_pagemap__bindgen_ty_1 {
    pub fn range(&self) -> Option<__BindgenUnionField<range>> {
        unsafe { crate::bpf_probe_read(&self.range) }.ok()
    }
    pub fn ranges(&self) -> Option<__BindgenUnionField<[range; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.ranges) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u64; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl path {
    pub fn mnt(&self) -> Option<*mut vfsmount> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dentry(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dentry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fown_struct {
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn pid(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.pid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pid_type(&self) -> Option<pid_type::Type> {
        unsafe { crate::bpf_probe_read(&self.pid_type) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn euid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.euid) }.ok()
    }
    pub fn signum(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.signum) }.ok()
    }
}
impl file_ra_state {
    pub fn start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn async_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.async_size) }.ok()
    }
    pub fn ra_pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ra_pages) }.ok()
    }
    pub fn mmap_miss(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mmap_miss) }.ok()
    }
    pub fn prev_pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.prev_pos) }.ok()
    }
}
impl file {
    pub fn f_u(&self) -> Option<file__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.f_u) }.ok()
    }
    pub fn f_path(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.f_path) }.ok()
    }
    pub fn f_inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.f_inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_op(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.f_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.f_lock) }.ok()
    }
    pub fn f_write_hint(&self) -> Option<rw_hint::Type> {
        unsafe { crate::bpf_probe_read(&self.f_write_hint) }.ok()
    }
    pub fn f_count(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.f_count) }.ok()
    }
    pub fn f_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.f_flags) }.ok()
    }
    pub fn f_mode(&self) -> Option<fmode_t> {
        unsafe { crate::bpf_probe_read(&self.f_mode) }.ok()
    }
    pub fn f_pos_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.f_pos_lock) }.ok()
    }
    pub fn f_pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.f_pos) }.ok()
    }
    pub fn f_owner(&self) -> Option<fown_struct> {
        unsafe { crate::bpf_probe_read(&self.f_owner) }.ok()
    }
    pub fn f_cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.f_cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_ra(&self) -> Option<file_ra_state> {
        unsafe { crate::bpf_probe_read(&self.f_ra) }.ok()
    }
    pub fn f_version(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_version) }.ok()
    }
    pub fn f_security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.f_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_ep(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.f_ep) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.f_mapping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn f_wb_err(&self) -> Option<errseq_t> {
        unsafe { crate::bpf_probe_read(&self.f_wb_err) }.ok()
    }
    pub fn f_sb_err(&self) -> Option<errseq_t> {
        unsafe { crate::bpf_probe_read(&self.f_sb_err) }.ok()
    }
}
impl file__bindgen_ty_1 {
    pub fn fu_llist(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.fu_llist) }.ok()
    }
    pub fn fu_rcuhead(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.fu_rcuhead) }.ok()
    }
}
impl vm_operations_struct {
    pub fn open(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>> {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn close(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>> {
        unsafe { crate::bpf_probe_read(&self.close) }.ok()
    }
    pub fn may_split(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.may_split) }.ok()
    }
    pub fn mremap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mremap) }.ok()
    }
    pub fn mprotect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mprotect) }.ok()
    }
    pub fn fault(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>>
    {
        unsafe { crate::bpf_probe_read(&self.fault) }.ok()
    }
    pub fn huge_fault(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut vm_fault, arg2: page_entry_size::Type) -> vm_fault_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.huge_fault) }.ok()
    }
    pub fn map_pages(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_fault,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_pages) }.ok()
    }
    pub fn pagesize(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut vm_area_struct) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pagesize) }.ok()
    }
    pub fn page_mkwrite(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>>
    {
        unsafe { crate::bpf_probe_read(&self.page_mkwrite) }.ok()
    }
    pub fn pfn_mkwrite(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>>
    {
        unsafe { crate::bpf_probe_read(&self.pfn_mkwrite) }.ok()
    }
    pub fn access(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: ::aya_bpf_cty::c_int,
                arg5: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.access) }.ok()
    }
    pub fn name(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut vm_area_struct) -> *const ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn set_policy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: *mut mempolicy,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_policy) }.ok()
    }
    pub fn get_policy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> *mut mempolicy,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_policy) }.ok()
    }
    pub fn find_special_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vm_area_struct,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> *mut page,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.find_special_page) }.ok()
    }
}
impl core_thread {
    pub fn task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut core_thread> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl core_state {
    pub fn nr_threads(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_threads) }.ok()
    }
    pub fn dumper(&self) -> Option<core_thread> {
        unsafe { crate::bpf_probe_read(&self.dumper) }.ok()
    }
    pub fn startup(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.startup) }.ok()
    }
}
impl vm_fault {
    pub fn vma(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vma) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn gfp_mask(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.gfp_mask) }.ok()
    }
    pub fn pgoff(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pgoff) }.ok()
    }
    pub fn address(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.address) }.ok()
    }
    pub fn pmd(&self) -> Option<*mut pmd_t> {
        let v = unsafe { crate::bpf_probe_read(&self.pmd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pud(&self) -> Option<*mut pud_t> {
        let v = unsafe { crate::bpf_probe_read(&self.pud) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn orig_pte(&self) -> Option<pte_t> {
        unsafe { crate::bpf_probe_read(&self.orig_pte) }.ok()
    }
    pub fn cow_page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.cow_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pte(&self) -> Option<*mut pte_t> {
        let v = unsafe { crate::bpf_probe_read(&self.pte) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ptl(&self) -> Option<*mut spinlock_t> {
        let v = unsafe { crate::bpf_probe_read(&self.ptl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prealloc_pte(&self) -> Option<pgtable_t> {
        unsafe { crate::bpf_probe_read(&self.prealloc_pte) }.ok()
    }
}
impl percpu_ref_data {
    pub fn count(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn release(&self) -> Option<percpu_ref_func_t> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn confirm_switch(&self) -> Option<percpu_ref_func_t> {
        unsafe { crate::bpf_probe_read(&self.confirm_switch) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn ref_(&self) -> Option<*mut percpu_ref> {
        let v = unsafe { crate::bpf_probe_read(&self.ref_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl shrink_control {
    pub fn gfp_mask(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.gfp_mask) }.ok()
    }
    pub fn nid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nid) }.ok()
    }
    pub fn nr_to_scan(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_to_scan) }.ok()
    }
    pub fn nr_scanned(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_scanned) }.ok()
    }
    pub fn memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl shrinker {
    pub fn count_objects(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut shrinker,
                arg2: *mut shrink_control,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.count_objects) }.ok()
    }
    pub fn scan_objects(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut shrinker,
                arg2: *mut shrink_control,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.scan_objects) }.ok()
    }
    pub fn batch(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.batch) }.ok()
    }
    pub fn seeks(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.seeks) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn nr_deferred(&self) -> Option<*mut atomic_long_t> {
        let v = unsafe { crate::bpf_probe_read(&self.nr_deferred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rlimit {
    pub fn rlim_cur(&self) -> Option<__kernel_ulong_t> {
        unsafe { crate::bpf_probe_read(&self.rlim_cur) }.ok()
    }
    pub fn rlim_max(&self) -> Option<__kernel_ulong_t> {
        unsafe { crate::bpf_probe_read(&self.rlim_max) }.ok()
    }
}
impl dev_pagemap_ops {
    pub fn page_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>> {
        unsafe { crate::bpf_probe_read(&self.page_free) }.ok()
    }
    pub fn kill(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dev_pagemap)>> {
        unsafe { crate::bpf_probe_read(&self.kill) }.ok()
    }
    pub fn cleanup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dev_pagemap)>> {
        unsafe { crate::bpf_probe_read(&self.cleanup) }.ok()
    }
    pub fn migrate_to_ram(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>>
    {
        unsafe { crate::bpf_probe_read(&self.migrate_to_ram) }.ok()
    }
}
impl upid {
    pub fn nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr) }.ok()
    }
    pub fn ns(&self) -> Option<*mut pid_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl pid {
    pub fn count(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn level(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn tasks(&self) -> Option<[hlist_head; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.tasks) }.ok()
    }
    pub fn inodes(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.inodes) }.ok()
    }
    pub fn wait_pidfd(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait_pidfd) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn numbers(&self) -> Option<[upid; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.numbers) }.ok()
    }
}
impl kgid_t {
    pub fn val(&self) -> Option<gid_t> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl hrtimer_clock_base {
    pub fn cpu_base(&self) -> Option<*mut hrtimer_cpu_base> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn clockid(&self) -> Option<clockid_t> {
        unsafe { crate::bpf_probe_read(&self.clockid) }.ok()
    }
    pub fn seq(&self) -> Option<seqcount_raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn running(&self) -> Option<*mut hrtimer> {
        let v = unsafe { crate::bpf_probe_read(&self.running) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn active(&self) -> Option<timerqueue_head> {
        unsafe { crate::bpf_probe_read(&self.active) }.ok()
    }
    pub fn get_time(&self) -> Option<::core::option::Option<unsafe extern "C" fn() -> ktime_t>> {
        unsafe { crate::bpf_probe_read(&self.get_time) }.ok()
    }
    pub fn offset(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl hrtimer_cpu_base {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn active_bases(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.active_bases) }.ok()
    }
    pub fn clock_was_set_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_was_set_seq) }.ok()
    }
    pub fn nr_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_events) }.ok()
    }
    pub fn nr_retries(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.nr_retries) }.ok()
    }
    pub fn nr_hangs(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.nr_hangs) }.ok()
    }
    pub fn max_hang_time(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_hang_time) }.ok()
    }
    pub fn expires_next(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.expires_next) }.ok()
    }
    pub fn next_timer(&self) -> Option<*mut hrtimer> {
        let v = unsafe { crate::bpf_probe_read(&self.next_timer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn softirq_expires_next(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.softirq_expires_next) }.ok()
    }
    pub fn softirq_next_timer(&self) -> Option<*mut hrtimer> {
        let v = unsafe { crate::bpf_probe_read(&self.softirq_next_timer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn clock_base(&self) -> Option<[hrtimer_clock_base; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.clock_base) }.ok()
    }
}
impl sigval {
    pub fn sival_int(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sival_int) }.ok()
    }
    pub fn sival_ptr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sival_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __sifields {
    pub fn _kill(&self) -> Option<__sifields__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self._kill) }.ok()
    }
    pub fn _timer(&self) -> Option<__sifields__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self._timer) }.ok()
    }
    pub fn _rt(&self) -> Option<__sifields__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self._rt) }.ok()
    }
    pub fn _sigchld(&self) -> Option<__sifields__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self._sigchld) }.ok()
    }
    pub fn _sigfault(&self) -> Option<__sifields__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self._sigfault) }.ok()
    }
    pub fn _sigpoll(&self) -> Option<__sifields__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self._sigpoll) }.ok()
    }
    pub fn _sigsys(&self) -> Option<__sifields__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self._sigsys) }.ok()
    }
}
impl __sifields__bindgen_ty_1 {
    pub fn _pid(&self) -> Option<__kernel_pid_t> {
        unsafe { crate::bpf_probe_read(&self._pid) }.ok()
    }
    pub fn _uid(&self) -> Option<__kernel_uid32_t> {
        unsafe { crate::bpf_probe_read(&self._uid) }.ok()
    }
}
impl __sifields__bindgen_ty_2 {
    pub fn _tid(&self) -> Option<__kernel_timer_t> {
        unsafe { crate::bpf_probe_read(&self._tid) }.ok()
    }
    pub fn _overrun(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self._overrun) }.ok()
    }
    pub fn _sigval(&self) -> Option<sigval_t> {
        unsafe { crate::bpf_probe_read(&self._sigval) }.ok()
    }
    pub fn _sys_private(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self._sys_private) }.ok()
    }
}
impl __sifields__bindgen_ty_3 {
    pub fn _pid(&self) -> Option<__kernel_pid_t> {
        unsafe { crate::bpf_probe_read(&self._pid) }.ok()
    }
    pub fn _uid(&self) -> Option<__kernel_uid32_t> {
        unsafe { crate::bpf_probe_read(&self._uid) }.ok()
    }
    pub fn _sigval(&self) -> Option<sigval_t> {
        unsafe { crate::bpf_probe_read(&self._sigval) }.ok()
    }
}
impl __sifields__bindgen_ty_4 {
    pub fn _pid(&self) -> Option<__kernel_pid_t> {
        unsafe { crate::bpf_probe_read(&self._pid) }.ok()
    }
    pub fn _uid(&self) -> Option<__kernel_uid32_t> {
        unsafe { crate::bpf_probe_read(&self._uid) }.ok()
    }
    pub fn _status(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self._status) }.ok()
    }
    pub fn _utime(&self) -> Option<__kernel_clock_t> {
        unsafe { crate::bpf_probe_read(&self._utime) }.ok()
    }
    pub fn _stime(&self) -> Option<__kernel_clock_t> {
        unsafe { crate::bpf_probe_read(&self._stime) }.ok()
    }
}
impl __sifields__bindgen_ty_5 {
    pub fn _addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self._addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _addr_lsb(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1._addr_lsb) }.ok()
    }
    pub fn _addr_bnd(&self) -> Option<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1._addr_bnd) }.ok()
    }
    pub fn _addr_pkey(&self) -> Option<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1._addr_pkey) }.ok()
    }
}
impl __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub fn _addr_lsb(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self._addr_lsb) }.ok()
    }
    pub fn _addr_bnd(&self) -> Option<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self._addr_bnd) }.ok()
    }
    pub fn _addr_pkey(&self) -> Option<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self._addr_pkey) }.ok()
    }
}
impl __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub fn _dummy_bnd(&self) -> Option<[::aya_bpf_cty::c_char; 8usize]> {
        unsafe { crate::bpf_probe_read(&self._dummy_bnd) }.ok()
    }
    pub fn _lower(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self._lower) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _upper(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self._upper) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub fn _dummy_pkey(&self) -> Option<[::aya_bpf_cty::c_char; 8usize]> {
        unsafe { crate::bpf_probe_read(&self._dummy_pkey) }.ok()
    }
    pub fn _pkey(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self._pkey) }.ok()
    }
}
impl __sifields__bindgen_ty_6 {
    pub fn _band(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self._band) }.ok()
    }
    pub fn _fd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self._fd) }.ok()
    }
}
impl __sifields__bindgen_ty_7 {
    pub fn _call_addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self._call_addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _syscall(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self._syscall) }.ok()
    }
    pub fn _arch(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self._arch) }.ok()
    }
}
impl kernel_siginfo {
    pub fn si_signo(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.si_signo) }.ok()
    }
    pub fn si_errno(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.si_errno) }.ok()
    }
    pub fn si_code(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.si_code) }.ok()
    }
    pub fn _sifields(&self) -> Option<__sifields> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1._sifields) }.ok()
    }
}
impl kernel_siginfo__bindgen_ty_1 {
    pub fn si_signo(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.si_signo) }.ok()
    }
    pub fn si_errno(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.si_errno) }.ok()
    }
    pub fn si_code(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.si_code) }.ok()
    }
    pub fn _sifields(&self) -> Option<__sifields> {
        unsafe { crate::bpf_probe_read(&self._sifields) }.ok()
    }
}
impl user_struct {
    pub fn __count(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.__count) }.ok()
    }
    pub fn processes(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.processes) }.ok()
    }
    pub fn sigpending(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sigpending) }.ok()
    }
    pub fn fanotify_listeners(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.fanotify_listeners) }.ok()
    }
    pub fn epoll_watches(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.epoll_watches) }.ok()
    }
    pub fn mq_bytes(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mq_bytes) }.ok()
    }
    pub fn locked_shm(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.locked_shm) }.ok()
    }
    pub fn unix_inflight(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.unix_inflight) }.ok()
    }
    pub fn pipe_bufs(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.pipe_bufs) }.ok()
    }
    pub fn uidhash_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.uidhash_node) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn locked_vm(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.locked_vm) }.ok()
    }
    pub fn nr_watches(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_watches) }.ok()
    }
    pub fn ratelimit(&self) -> Option<ratelimit_state> {
        unsafe { crate::bpf_probe_read(&self.ratelimit) }.ok()
    }
}
impl sigaction {
    pub fn sa_handler(&self) -> Option<__sighandler_t> {
        unsafe { crate::bpf_probe_read(&self.sa_handler) }.ok()
    }
    pub fn sa_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sa_flags) }.ok()
    }
    pub fn sa_restorer(&self) -> Option<__sigrestore_t> {
        unsafe { crate::bpf_probe_read(&self.sa_restorer) }.ok()
    }
    pub fn sa_mask(&self) -> Option<sigset_t> {
        unsafe { crate::bpf_probe_read(&self.sa_mask) }.ok()
    }
}
impl k_sigaction {
    pub fn sa(&self) -> Option<sigaction> {
        unsafe { crate::bpf_probe_read(&self.sa) }.ok()
    }
}
impl cpu_itimer {
    pub fn expires(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
    pub fn incr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.incr) }.ok()
    }
}
impl task_cputime_atomic {
    pub fn utime(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.utime) }.ok()
    }
    pub fn stime(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.stime) }.ok()
    }
    pub fn sum_exec_runtime(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.sum_exec_runtime) }.ok()
    }
}
impl thread_group_cputimer {
    pub fn cputime_atomic(&self) -> Option<task_cputime_atomic> {
        unsafe { crate::bpf_probe_read(&self.cputime_atomic) }.ok()
    }
}
impl pacct_struct {
    pub fn ac_flag(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ac_flag) }.ok()
    }
    pub fn ac_exitcode(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.ac_exitcode) }.ok()
    }
    pub fn ac_mem(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ac_mem) }.ok()
    }
    pub fn ac_utime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ac_utime) }.ok()
    }
    pub fn ac_stime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ac_stime) }.ok()
    }
    pub fn ac_minflt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ac_minflt) }.ok()
    }
    pub fn ac_majflt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ac_majflt) }.ok()
    }
}
impl signal_struct {
    pub fn sigcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.sigcnt) }.ok()
    }
    pub fn live(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.live) }.ok()
    }
    pub fn nr_threads(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_threads) }.ok()
    }
    pub fn thread_head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.thread_head) }.ok()
    }
    pub fn wait_chldexit(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait_chldexit) }.ok()
    }
    pub fn curr_target(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.curr_target) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn shared_pending(&self) -> Option<sigpending> {
        unsafe { crate::bpf_probe_read(&self.shared_pending) }.ok()
    }
    pub fn multiprocess(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.multiprocess) }.ok()
    }
    pub fn group_exit_code(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.group_exit_code) }.ok()
    }
    pub fn notify_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.notify_count) }.ok()
    }
    pub fn group_exit_task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.group_exit_task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn group_stop_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.group_stop_count) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn posix_timer_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.posix_timer_id) }.ok()
    }
    pub fn posix_timers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.posix_timers) }.ok()
    }
    pub fn real_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.real_timer) }.ok()
    }
    pub fn it_real_incr(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.it_real_incr) }.ok()
    }
    pub fn it(&self) -> Option<[cpu_itimer; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.it) }.ok()
    }
    pub fn cputimer(&self) -> Option<thread_group_cputimer> {
        unsafe { crate::bpf_probe_read(&self.cputimer) }.ok()
    }
    pub fn posix_cputimers(&self) -> Option<posix_cputimers> {
        unsafe { crate::bpf_probe_read(&self.posix_cputimers) }.ok()
    }
    pub fn pids(&self) -> Option<[*mut pid; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.pids) }.ok()
    }
    pub fn tty_old_pgrp(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.tty_old_pgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn leader(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.leader) }.ok()
    }
    pub fn tty(&self) -> Option<*mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.tty) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn autogroup(&self) -> Option<*mut autogroup> {
        let v = unsafe { crate::bpf_probe_read(&self.autogroup) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stats_lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.stats_lock) }.ok()
    }
    pub fn utime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.utime) }.ok()
    }
    pub fn stime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stime) }.ok()
    }
    pub fn cutime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cutime) }.ok()
    }
    pub fn cstime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cstime) }.ok()
    }
    pub fn gtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.gtime) }.ok()
    }
    pub fn cgtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cgtime) }.ok()
    }
    pub fn prev_cputime(&self) -> Option<prev_cputime> {
        unsafe { crate::bpf_probe_read(&self.prev_cputime) }.ok()
    }
    pub fn nvcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nvcsw) }.ok()
    }
    pub fn nivcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nivcsw) }.ok()
    }
    pub fn cnvcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cnvcsw) }.ok()
    }
    pub fn cnivcsw(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cnivcsw) }.ok()
    }
    pub fn min_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_flt) }.ok()
    }
    pub fn maj_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.maj_flt) }.ok()
    }
    pub fn cmin_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cmin_flt) }.ok()
    }
    pub fn cmaj_flt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cmaj_flt) }.ok()
    }
    pub fn inblock(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.inblock) }.ok()
    }
    pub fn oublock(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.oublock) }.ok()
    }
    pub fn cinblock(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cinblock) }.ok()
    }
    pub fn coublock(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.coublock) }.ok()
    }
    pub fn maxrss(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.maxrss) }.ok()
    }
    pub fn cmaxrss(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cmaxrss) }.ok()
    }
    pub fn ioac(&self) -> Option<task_io_accounting> {
        unsafe { crate::bpf_probe_read(&self.ioac) }.ok()
    }
    pub fn sum_sched_runtime(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.sum_sched_runtime) }.ok()
    }
    pub fn rlim(&self) -> Option<[rlimit; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.rlim) }.ok()
    }
    pub fn pacct(&self) -> Option<pacct_struct> {
        unsafe { crate::bpf_probe_read(&self.pacct) }.ok()
    }
    pub fn stats(&self) -> Option<*mut taskstats> {
        let v = unsafe { crate::bpf_probe_read(&self.stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn audit_tty(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.audit_tty) }.ok()
    }
    pub fn tty_audit_buf(&self) -> Option<*mut tty_audit_buf> {
        let v = unsafe { crate::bpf_probe_read(&self.tty_audit_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn oom_flag_origin(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.oom_flag_origin) }.ok()
    }
    pub fn oom_score_adj(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.oom_score_adj) }.ok()
    }
    pub fn oom_score_adj_min(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.oom_score_adj_min) }.ok()
    }
    pub fn oom_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.oom_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cred_guard_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.cred_guard_mutex) }.ok()
    }
    pub fn exec_update_lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.exec_update_lock) }.ok()
    }
}
impl rseq {
    pub fn cpu_id_start(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cpu_id_start) }.ok()
    }
    pub fn cpu_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cpu_id) }.ok()
    }
    pub fn rseq_cs(&self) -> Option<rseq__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.rseq_cs) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl rseq__bindgen_ty_1 {
    pub fn ptr64(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ptr64) }.ok()
    }
    pub fn ptr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ptr) }.ok()
    }
}
impl sched_class {
    pub fn uclamp_enabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.uclamp_enabled) }.ok()
    }
    pub fn enqueue_task(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enqueue_task) }.ok()
    }
    pub fn dequeue_task(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dequeue_task) }.ok()
    }
    pub fn yield_task(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>> {
        unsafe { crate::bpf_probe_read(&self.yield_task) }.ok()
    }
    pub fn yield_to_task(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.yield_to_task) }.ok()
    }
    pub fn check_preempt_curr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_preempt_curr) }.ok()
    }
    pub fn pick_next_task(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq) -> *mut task_struct>>
    {
        unsafe { crate::bpf_probe_read(&self.pick_next_task) }.ok()
    }
    pub fn put_prev_task(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>>
    {
        unsafe { crate::bpf_probe_read(&self.put_prev_task) }.ok()
    }
    pub fn set_next_task(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: bool_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_next_task) }.ok()
    }
    pub fn balance(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut rq,
                arg2: *mut task_struct,
                arg3: *mut rq_flags,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.balance) }.ok()
    }
    pub fn select_task_rq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut task_struct,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.select_task_rq) }.ok()
    }
    pub fn migrate_task_rq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut task_struct, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.migrate_task_rq) }.ok()
    }
    pub fn task_woken(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>>
    {
        unsafe { crate::bpf_probe_read(&self.task_woken) }.ok()
    }
    pub fn set_cpus_allowed(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut task_struct, arg2: *const cpumask, arg3: u32_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_cpus_allowed) }.ok()
    }
    pub fn rq_online(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>> {
        unsafe { crate::bpf_probe_read(&self.rq_online) }.ok()
    }
    pub fn rq_offline(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>> {
        unsafe { crate::bpf_probe_read(&self.rq_offline) }.ok()
    }
    pub fn find_lock_rq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut rq) -> *mut rq,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.find_lock_rq) }.ok()
    }
    pub fn task_tick(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.task_tick) }.ok()
    }
    pub fn task_fork(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>> {
        unsafe { crate::bpf_probe_read(&self.task_fork) }.ok()
    }
    pub fn task_dead(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>> {
        unsafe { crate::bpf_probe_read(&self.task_dead) }.ok()
    }
    pub fn switched_from(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>>
    {
        unsafe { crate::bpf_probe_read(&self.switched_from) }.ok()
    }
    pub fn switched_to(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>>
    {
        unsafe { crate::bpf_probe_read(&self.switched_to) }.ok()
    }
    pub fn prio_changed(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.prio_changed) }.ok()
    }
    pub fn get_rr_interval(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_rr_interval) }.ok()
    }
    pub fn update_curr(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>> {
        unsafe { crate::bpf_probe_read(&self.update_curr) }.ok()
    }
    pub fn task_change_group(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut task_struct, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.task_change_group) }.ok()
    }
}
impl kernel_cap_struct {
    pub fn cap(&self) -> Option<[__u32; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.cap) }.ok()
    }
}
impl cred {
    pub fn usage(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn suid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.suid) }.ok()
    }
    pub fn sgid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.sgid) }.ok()
    }
    pub fn euid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.euid) }.ok()
    }
    pub fn egid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.egid) }.ok()
    }
    pub fn fsuid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.fsuid) }.ok()
    }
    pub fn fsgid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.fsgid) }.ok()
    }
    pub fn securebits(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.securebits) }.ok()
    }
    pub fn cap_inheritable(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.cap_inheritable) }.ok()
    }
    pub fn cap_permitted(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.cap_permitted) }.ok()
    }
    pub fn cap_effective(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.cap_effective) }.ok()
    }
    pub fn cap_bset(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.cap_bset) }.ok()
    }
    pub fn cap_ambient(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.cap_ambient) }.ok()
    }
    pub fn jit_keyring(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.jit_keyring) }.ok()
    }
    pub fn session_keyring(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.session_keyring) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn process_keyring(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.process_keyring) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn thread_keyring(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.thread_keyring) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn request_key_auth(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.request_key_auth) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn group_info(&self) -> Option<*mut group_info> {
        let v = unsafe { crate::bpf_probe_read(&self.group_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn non_rcu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.non_rcu) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
}
impl cred__bindgen_ty_1 {
    pub fn non_rcu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.non_rcu) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl keyring_index_key {
    pub fn hash(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn desc_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.desc_len) }.ok()
    }
    pub fn desc(&self) -> Option<[::aya_bpf_cty::c_char; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.desc) }.ok()
    }
    pub fn x(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.x) }.ok()
    }
    pub fn type_(&self) -> Option<*mut key_type> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain_tag(&self) -> Option<*mut key_tag> {
        let v = unsafe { crate::bpf_probe_read(&self.domain_tag) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn description(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl keyring_index_key__bindgen_ty_1 {
    pub fn desc_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.desc_len) }.ok()
    }
    pub fn desc(&self) -> Option<[::aya_bpf_cty::c_char; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.desc) }.ok()
    }
    pub fn x(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.x) }.ok()
    }
}
impl keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub fn desc_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.desc_len) }.ok()
    }
    pub fn desc(&self) -> Option<[::aya_bpf_cty::c_char; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.desc) }.ok()
    }
}
impl key_payload {
    pub fn rcu_data0(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.rcu_data0) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<[*mut ::aya_bpf_cty::c_void; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl assoc_array_ptr {}
impl assoc_array {
    pub fn root(&self) -> Option<*mut assoc_array_ptr> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_leaves_on_tree(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_leaves_on_tree) }.ok()
    }
}
impl key {
    pub fn usage(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn serial(&self) -> Option<key_serial_t> {
        unsafe { crate::bpf_probe_read(&self.serial) }.ok()
    }
    pub fn graveyard_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.graveyard_link) }.ok()
    }
    pub fn serial_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.serial_node) }.ok()
    }
    pub fn watchers(&self) -> Option<*mut watch_list> {
        let v = unsafe { crate::bpf_probe_read(&self.watchers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.sem) }.ok()
    }
    pub fn user(&self) -> Option<*mut key_user> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn expiry(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.expiry) }.ok()
    }
    pub fn revoked_at(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.revoked_at) }.ok()
    }
    pub fn last_used_at(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.last_used_at) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn perm(&self) -> Option<key_perm_t> {
        unsafe { crate::bpf_probe_read(&self.perm) }.ok()
    }
    pub fn quotalen(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.quotalen) }.ok()
    }
    pub fn datalen(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.datalen) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn index_key(&self) -> Option<keyring_index_key> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.index_key) }.ok()
    }
    pub fn hash(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.hash) }.ok()
    }
    pub fn len_desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.len_desc) }.ok()
    }
    pub fn type_(&self) -> Option<*mut key_type> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain_tag(&self) -> Option<*mut key_tag> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.domain_tag) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.description) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn payload(&self) -> Option<key_payload> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.payload) }.ok()
    }
    pub fn name_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.__bindgen_anon_1.name_link) }.ok()
    }
    pub fn keys(&self) -> Option<assoc_array> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.__bindgen_anon_1.keys) }.ok()
    }
    pub fn restrict_link(&self) -> Option<*mut key_restriction> {
        let v = unsafe { crate::bpf_probe_read(&self.restrict_link) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl key__bindgen_ty_1 {
    pub fn graveyard_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.graveyard_link) }.ok()
    }
    pub fn serial_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.serial_node) }.ok()
    }
}
impl key__bindgen_ty_2 {
    pub fn expiry(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.expiry) }.ok()
    }
    pub fn revoked_at(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.revoked_at) }.ok()
    }
}
impl key__bindgen_ty_3 {
    pub fn index_key(&self) -> Option<keyring_index_key> {
        unsafe { crate::bpf_probe_read(&self.index_key) }.ok()
    }
    pub fn hash(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hash) }.ok()
    }
    pub fn len_desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.len_desc) }.ok()
    }
    pub fn type_(&self) -> Option<*mut key_type> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain_tag(&self) -> Option<*mut key_tag> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.domain_tag) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl key__bindgen_ty_3__bindgen_ty_1 {
    pub fn hash(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn len_desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.len_desc) }.ok()
    }
    pub fn type_(&self) -> Option<*mut key_type> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain_tag(&self) -> Option<*mut key_tag> {
        let v = unsafe { crate::bpf_probe_read(&self.domain_tag) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl key__bindgen_ty_4 {
    pub fn payload(&self) -> Option<key_payload> {
        unsafe { crate::bpf_probe_read(&self.payload) }.ok()
    }
    pub fn name_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.name_link) }.ok()
    }
    pub fn keys(&self) -> Option<assoc_array> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.keys) }.ok()
    }
}
impl key__bindgen_ty_4__bindgen_ty_1 {
    pub fn name_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.name_link) }.ok()
    }
    pub fn keys(&self) -> Option<assoc_array> {
        unsafe { crate::bpf_probe_read(&self.keys) }.ok()
    }
}
impl sighand_struct {
    pub fn siglock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.siglock) }.ok()
    }
    pub fn count(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn signalfd_wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.signalfd_wqh) }.ok()
    }
    pub fn action(&self) -> Option<[k_sigaction; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
}
impl io_context {
    pub fn refcount(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn active_ref(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.active_ref) }.ok()
    }
    pub fn nr_tasks(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_tasks) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn ioprio(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ioprio) }.ok()
    }
    pub fn icq_tree(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.icq_tree) }.ok()
    }
    pub fn icq_hint(&self) -> Option<*mut io_cq> {
        let v = unsafe { crate::bpf_probe_read(&self.icq_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icq_list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.icq_list) }.ok()
    }
    pub fn release_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.release_work) }.ok()
    }
}
impl hlist_bl_head {
    pub fn first(&self) -> Option<*mut hlist_bl_node> {
        let v = unsafe { crate::bpf_probe_read(&self.first) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl hlist_bl_node {
    pub fn next(&self) -> Option<*mut hlist_bl_node> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pprev(&self) -> Option<*mut *mut hlist_bl_node> {
        let v = unsafe { crate::bpf_probe_read(&self.pprev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl lockref {
    pub fn lock_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lock_count) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.lock) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.count) }.ok()
    }
}
impl lockref__bindgen_ty_1 {
    pub fn lock_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.lock_count) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lock) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.count) }.ok()
    }
}
impl lockref__bindgen_ty_1__bindgen_ty_1 {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl qstr {
    pub fn hash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.hash) }.ok()
    }
    pub fn len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.len) }.ok()
    }
    pub fn hash_len(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hash_len) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl qstr__bindgen_ty_1 {
    pub fn hash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hash) }.ok()
    }
    pub fn len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.len) }.ok()
    }
    pub fn hash_len(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.hash_len) }.ok()
    }
}
impl qstr__bindgen_ty_1__bindgen_ty_1 {
    pub fn hash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
}
impl dentry {
    pub fn d_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.d_flags) }.ok()
    }
    pub fn d_seq(&self) -> Option<seqcount_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.d_seq) }.ok()
    }
    pub fn d_hash(&self) -> Option<hlist_bl_node> {
        unsafe { crate::bpf_probe_read(&self.d_hash) }.ok()
    }
    pub fn d_parent(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.d_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_name(&self) -> Option<qstr> {
        unsafe { crate::bpf_probe_read(&self.d_name) }.ok()
    }
    pub fn d_inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.d_inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_iname(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.d_iname) }.ok()
    }
    pub fn d_lockref(&self) -> Option<lockref> {
        unsafe { crate::bpf_probe_read(&self.d_lockref) }.ok()
    }
    pub fn d_op(&self) -> Option<*const dentry_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.d_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_sb(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.d_sb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.d_time) }.ok()
    }
    pub fn d_fsdata(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.d_fsdata) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.d_lru) }.ok()
    }
    pub fn d_wait(&self) -> Option<*mut wait_queue_head_t> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.d_wait) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn d_child(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.d_child) }.ok()
    }
    pub fn d_subdirs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.d_subdirs) }.ok()
    }
    pub fn d_u(&self) -> Option<dentry__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.d_u) }.ok()
    }
}
impl dentry__bindgen_ty_1 {
    pub fn d_lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.d_lru) }.ok()
    }
    pub fn d_wait(&self) -> Option<*mut wait_queue_head_t> {
        let v = unsafe { crate::bpf_probe_read(&self.d_wait) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl dentry__bindgen_ty_2 {
    pub fn d_alias(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.d_alias) }.ok()
    }
    pub fn d_in_lookup_hash(&self) -> Option<hlist_bl_node> {
        unsafe { crate::bpf_probe_read(&self.d_in_lookup_hash) }.ok()
    }
    pub fn d_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.d_rcu) }.ok()
    }
}
impl inode {
    pub fn i_mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.i_mode) }.ok()
    }
    pub fn i_opflags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.i_opflags) }.ok()
    }
    pub fn i_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.i_uid) }.ok()
    }
    pub fn i_gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.i_gid) }.ok()
    }
    pub fn i_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_flags) }.ok()
    }
    pub fn i_acl(&self) -> Option<*mut posix_acl> {
        let v = unsafe { crate::bpf_probe_read(&self.i_acl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_default_acl(&self) -> Option<*mut posix_acl> {
        let v = unsafe { crate::bpf_probe_read(&self.i_default_acl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_op(&self) -> Option<*const inode_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.i_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_sb(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.i_sb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.i_mapping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.i_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_ino(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.i_ino) }.ok()
    }
    pub fn i_nlink(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.i_nlink) }.ok()
    }
    pub fn __i_nlink(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__i_nlink) }.ok()
    }
    pub fn i_rdev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.i_rdev) }.ok()
    }
    pub fn i_size(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.i_size) }.ok()
    }
    pub fn i_atime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.i_atime) }.ok()
    }
    pub fn i_mtime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.i_mtime) }.ok()
    }
    pub fn i_ctime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.i_ctime) }.ok()
    }
    pub fn i_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.i_lock) }.ok()
    }
    pub fn i_bytes(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.i_bytes) }.ok()
    }
    pub fn i_blkbits(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.i_blkbits) }.ok()
    }
    pub fn i_write_hint(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.i_write_hint) }.ok()
    }
    pub fn i_blocks(&self) -> Option<blkcnt_t> {
        unsafe { crate::bpf_probe_read(&self.i_blocks) }.ok()
    }
    pub fn i_state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.i_state) }.ok()
    }
    pub fn i_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.i_rwsem) }.ok()
    }
    pub fn dirtied_when(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirtied_when) }.ok()
    }
    pub fn dirtied_time_when(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirtied_time_when) }.ok()
    }
    pub fn i_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.i_hash) }.ok()
    }
    pub fn i_io_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.i_io_list) }.ok()
    }
    pub fn i_wb(&self) -> Option<*mut bdi_writeback> {
        let v = unsafe { crate::bpf_probe_read(&self.i_wb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_wb_frn_winner(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.i_wb_frn_winner) }.ok()
    }
    pub fn i_wb_frn_avg_time(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.i_wb_frn_avg_time) }.ok()
    }
    pub fn i_wb_frn_history(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.i_wb_frn_history) }.ok()
    }
    pub fn i_lru(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.i_lru) }.ok()
    }
    pub fn i_sb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.i_sb_list) }.ok()
    }
    pub fn i_wb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.i_wb_list) }.ok()
    }
    pub fn i_dentry(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.i_dentry) }.ok()
    }
    pub fn i_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.i_rcu) }.ok()
    }
    pub fn i_version(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.i_version) }.ok()
    }
    pub fn i_sequence(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.i_sequence) }.ok()
    }
    pub fn i_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.i_count) }.ok()
    }
    pub fn i_dio_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.i_dio_count) }.ok()
    }
    pub fn i_writecount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.i_writecount) }.ok()
    }
    pub fn i_readcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.i_readcount) }.ok()
    }
    pub fn i_fop(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.i_fop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.free_inode) }.ok()
    }
    pub fn i_flctx(&self) -> Option<*mut file_lock_context> {
        let v = unsafe { crate::bpf_probe_read(&self.i_flctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_data(&self) -> Option<address_space> {
        unsafe { crate::bpf_probe_read(&self.i_data) }.ok()
    }
    pub fn i_devices(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.i_devices) }.ok()
    }
    pub fn i_pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.i_pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_cdev(&self) -> Option<*mut cdev> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.i_cdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_link(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.i_link) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_dir_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.i_dir_seq) }.ok()
    }
    pub fn i_generation(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.i_generation) }.ok()
    }
    pub fn i_fsnotify_mask(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.i_fsnotify_mask) }.ok()
    }
    pub fn i_fsnotify_marks(&self) -> Option<*mut fsnotify_mark_connector> {
        let v = unsafe { crate::bpf_probe_read(&self.i_fsnotify_marks) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_crypt_info(&self) -> Option<*mut fscrypt_info> {
        let v = unsafe { crate::bpf_probe_read(&self.i_crypt_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_verity_info(&self) -> Option<*mut fsverity_info> {
        let v = unsafe { crate::bpf_probe_read(&self.i_verity_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.i_private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl inode__bindgen_ty_1 {
    pub fn i_nlink(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_nlink) }.ok()
    }
    pub fn __i_nlink(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__i_nlink) }.ok()
    }
}
impl inode__bindgen_ty_2 {
    pub fn i_dentry(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.i_dentry) }.ok()
    }
    pub fn i_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.i_rcu) }.ok()
    }
}
impl inode__bindgen_ty_3 {
    pub fn i_fop(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.i_fop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
        unsafe { crate::bpf_probe_read(&self.free_inode) }.ok()
    }
}
impl inode__bindgen_ty_4 {
    pub fn i_pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.i_pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_cdev(&self) -> Option<*mut cdev> {
        let v = unsafe { crate::bpf_probe_read(&self.i_cdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_link(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.i_link) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn i_dir_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_dir_seq) }.ok()
    }
}
impl dentry_operations {
    pub fn d_revalidate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_revalidate) }.ok()
    }
    pub fn d_weak_revalidate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_weak_revalidate) }.ok()
    }
    pub fn d_hash(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_hash) }.ok()
    }
    pub fn d_compare(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const dentry,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: *const qstr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_compare) }.ok()
    }
    pub fn d_delete(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.d_delete) }.ok()
    }
    pub fn d_init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.d_init) }.ok()
    }
    pub fn d_release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>> {
        unsafe { crate::bpf_probe_read(&self.d_release) }.ok()
    }
    pub fn d_prune(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>> {
        unsafe { crate::bpf_probe_read(&self.d_prune) }.ok()
    }
    pub fn d_iput(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>>
    {
        unsafe { crate::bpf_probe_read(&self.d_iput) }.ok()
    }
    pub fn d_dname(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: ::aya_bpf_cty::c_int,
            ) -> *mut ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_dname) }.ok()
    }
    pub fn d_automount(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>>
    {
        unsafe { crate::bpf_probe_read(&self.d_automount) }.ok()
    }
    pub fn d_manage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_manage) }.ok()
    }
    pub fn d_real(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.d_real) }.ok()
    }
}
impl mtd_info {}
impl mem_dqinfo {
    pub fn dqi_format(&self) -> Option<*mut quota_format_type> {
        let v = unsafe { crate::bpf_probe_read(&self.dqi_format) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dqi_fmt_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dqi_fmt_id) }.ok()
    }
    pub fn dqi_dirty_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dqi_dirty_list) }.ok()
    }
    pub fn dqi_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dqi_flags) }.ok()
    }
    pub fn dqi_bgrace(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dqi_bgrace) }.ok()
    }
    pub fn dqi_igrace(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dqi_igrace) }.ok()
    }
    pub fn dqi_max_spc_limit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqi_max_spc_limit) }.ok()
    }
    pub fn dqi_max_ino_limit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqi_max_ino_limit) }.ok()
    }
    pub fn dqi_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.dqi_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl quota_info {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn dqio_sem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.dqio_sem) }.ok()
    }
    pub fn files(&self) -> Option<[*mut inode; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.files) }.ok()
    }
    pub fn info(&self) -> Option<[mem_dqinfo; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn ops(&self) -> Option<[*const quota_format_ops; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.ops) }.ok()
    }
}
impl rcu_sync {
    pub fn gp_state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gp_state) }.ok()
    }
    pub fn gp_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gp_count) }.ok()
    }
    pub fn gp_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.gp_wait) }.ok()
    }
    pub fn cb_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.cb_head) }.ok()
    }
}
impl rcuwait {
    pub fn task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl percpu_rw_semaphore {
    pub fn rss(&self) -> Option<rcu_sync> {
        unsafe { crate::bpf_probe_read(&self.rss) }.ok()
    }
    pub fn read_count(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.read_count) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn writer(&self) -> Option<rcuwait> {
        unsafe { crate::bpf_probe_read(&self.writer) }.ok()
    }
    pub fn waiters(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.waiters) }.ok()
    }
    pub fn block(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.block) }.ok()
    }
}
impl sb_writers {
    pub fn frozen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.frozen) }.ok()
    }
    pub fn wait_unfrozen(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait_unfrozen) }.ok()
    }
    pub fn rw_sem(&self) -> Option<[percpu_rw_semaphore; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.rw_sem) }.ok()
    }
}
impl uuid_t {
    pub fn b(&self) -> Option<[__u8; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.b) }.ok()
    }
}
impl list_lru {
    pub fn node(&self) -> Option<*mut list_lru_node> {
        let v = unsafe { crate::bpf_probe_read(&self.node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn shrinker_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.shrinker_id) }.ok()
    }
    pub fn memcg_aware(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.memcg_aware) }.ok()
    }
}
impl super_block {
    pub fn s_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.s_list) }.ok()
    }
    pub fn s_dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.s_dev) }.ok()
    }
    pub fn s_blocksize_bits(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.s_blocksize_bits) }.ok()
    }
    pub fn s_blocksize(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.s_blocksize) }.ok()
    }
    pub fn s_maxbytes(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.s_maxbytes) }.ok()
    }
    pub fn s_type(&self) -> Option<*mut file_system_type> {
        let v = unsafe { crate::bpf_probe_read(&self.s_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_op(&self) -> Option<*const super_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.s_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dq_op(&self) -> Option<*const dquot_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.dq_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_qcop(&self) -> Option<*const quotactl_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.s_qcop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_export_op(&self) -> Option<*const export_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.s_export_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.s_flags) }.ok()
    }
    pub fn s_iflags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.s_iflags) }.ok()
    }
    pub fn s_magic(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.s_magic) }.ok()
    }
    pub fn s_root(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.s_root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_umount(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.s_umount) }.ok()
    }
    pub fn s_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.s_count) }.ok()
    }
    pub fn s_active(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.s_active) }.ok()
    }
    pub fn s_security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.s_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_xattr(&self) -> Option<*mut *const xattr_handler> {
        let v = unsafe { crate::bpf_probe_read(&self.s_xattr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_cop(&self) -> Option<*const fscrypt_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.s_cop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_master_keys(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.s_master_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_vop(&self) -> Option<*const fsverity_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.s_vop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_encoding(&self) -> Option<*mut unicode_map> {
        let v = unsafe { crate::bpf_probe_read(&self.s_encoding) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_encoding_flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.s_encoding_flags) }.ok()
    }
    pub fn s_roots(&self) -> Option<hlist_bl_head> {
        unsafe { crate::bpf_probe_read(&self.s_roots) }.ok()
    }
    pub fn s_mounts(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.s_mounts) }.ok()
    }
    pub fn s_bdev(&self) -> Option<*mut block_device> {
        let v = unsafe { crate::bpf_probe_read(&self.s_bdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_bdi(&self) -> Option<*mut backing_dev_info> {
        let v = unsafe { crate::bpf_probe_read(&self.s_bdi) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_mtd(&self) -> Option<*mut mtd_info> {
        let v = unsafe { crate::bpf_probe_read(&self.s_mtd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_instances(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.s_instances) }.ok()
    }
    pub fn s_quota_types(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.s_quota_types) }.ok()
    }
    pub fn s_dquot(&self) -> Option<quota_info> {
        unsafe { crate::bpf_probe_read(&self.s_dquot) }.ok()
    }
    pub fn s_writers(&self) -> Option<sb_writers> {
        unsafe { crate::bpf_probe_read(&self.s_writers) }.ok()
    }
    pub fn s_fs_info(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.s_fs_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_time_gran(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.s_time_gran) }.ok()
    }
    pub fn s_time_min(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.s_time_min) }.ok()
    }
    pub fn s_time_max(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.s_time_max) }.ok()
    }
    pub fn s_fsnotify_mask(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.s_fsnotify_mask) }.ok()
    }
    pub fn s_fsnotify_marks(&self) -> Option<*mut fsnotify_mark_connector> {
        let v = unsafe { crate::bpf_probe_read(&self.s_fsnotify_marks) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_id(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.s_id) }.ok()
    }
    pub fn s_uuid(&self) -> Option<uuid_t> {
        unsafe { crate::bpf_probe_read(&self.s_uuid) }.ok()
    }
    pub fn s_max_links(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.s_max_links) }.ok()
    }
    pub fn s_mode(&self) -> Option<fmode_t> {
        unsafe { crate::bpf_probe_read(&self.s_mode) }.ok()
    }
    pub fn s_vfs_rename_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.s_vfs_rename_mutex) }.ok()
    }
    pub fn s_subtype(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.s_subtype) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_d_op(&self) -> Option<*const dentry_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.s_d_op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cleancache_poolid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cleancache_poolid) }.ok()
    }
    pub fn s_shrink(&self) -> Option<shrinker> {
        unsafe { crate::bpf_probe_read(&self.s_shrink) }.ok()
    }
    pub fn s_remove_count(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.s_remove_count) }.ok()
    }
    pub fn s_fsnotify_inode_refs(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.s_fsnotify_inode_refs) }.ok()
    }
    pub fn s_readonly_remount(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.s_readonly_remount) }.ok()
    }
    pub fn s_wb_err(&self) -> Option<errseq_t> {
        unsafe { crate::bpf_probe_read(&self.s_wb_err) }.ok()
    }
    pub fn s_dio_done_wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.s_dio_done_wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_pins(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.s_pins) }.ok()
    }
    pub fn s_user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.s_user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_dentry_lru(&self) -> Option<list_lru> {
        unsafe { crate::bpf_probe_read(&self.s_dentry_lru) }.ok()
    }
    pub fn s_inode_lru(&self) -> Option<list_lru> {
        unsafe { crate::bpf_probe_read(&self.s_inode_lru) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn destroy_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.destroy_work) }.ok()
    }
    pub fn s_sync_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.s_sync_lock) }.ok()
    }
    pub fn s_stack_depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.s_stack_depth) }.ok()
    }
    pub fn s_inode_list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.s_inode_list_lock) }.ok()
    }
    pub fn s_inodes(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.s_inodes) }.ok()
    }
    pub fn s_inode_wblist_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.s_inode_wblist_lock) }.ok()
    }
    pub fn s_inodes_wb(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.s_inodes_wb) }.ok()
    }
}
impl kstat {
    pub fn result_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.result_mask) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn nlink(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nlink) }.ok()
    }
    pub fn blksize(&self) -> Option<u32> {
        unsafe { crate::bpf_probe_read(&self.blksize) }.ok()
    }
    pub fn attributes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.attributes) }.ok()
    }
    pub fn attributes_mask(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.attributes_mask) }.ok()
    }
    pub fn ino(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ino) }.ok()
    }
    pub fn dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn rdev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.rdev) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn size(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn atime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.atime) }.ok()
    }
    pub fn mtime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.mtime) }.ok()
    }
    pub fn ctime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ctime) }.ok()
    }
    pub fn btime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.btime) }.ok()
    }
    pub fn blocks(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.blocks) }.ok()
    }
    pub fn mnt_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.mnt_id) }.ok()
    }
}
impl list_lru_one {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn nr_items(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.nr_items) }.ok()
    }
}
impl list_lru_memcg {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn lru(&self) -> Option<__IncompleteArrayField<*mut list_lru_one>> {
        unsafe { crate::bpf_probe_read(&self.lru) }.ok()
    }
}
impl list_lru_node {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn lru(&self) -> Option<list_lru_one> {
        unsafe { crate::bpf_probe_read(&self.lru) }.ok()
    }
    pub fn memcg_lrus(&self) -> Option<*mut list_lru_memcg> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg_lrus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_items(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.nr_items) }.ok()
    }
}
impl key_tag {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn usage(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn removed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.removed) }.ok()
    }
}
impl key_type {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn def_datalen(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.def_datalen) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn vet_description(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_char) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.vet_description) }.ok()
    }
    pub fn preparse(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut key_preparsed_payload) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.preparse) }.ok()
    }
    pub fn free_preparse(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut key_preparsed_payload)>>
    {
        unsafe { crate::bpf_probe_read(&self.free_preparse) }.ok()
    }
    pub fn instantiate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut key,
                arg2: *mut key_preparsed_payload,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.instantiate) }.ok()
    }
    pub fn update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut key,
                arg2: *mut key_preparsed_payload,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update) }.ok()
    }
    pub fn match_preparse(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut key_match_data) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.match_preparse) }.ok()
    }
    pub fn match_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut key_match_data)>> {
        unsafe { crate::bpf_probe_read(&self.match_free) }.ok()
    }
    pub fn revoke(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>> {
        unsafe { crate::bpf_probe_read(&self.revoke) }.ok()
    }
    pub fn destroy(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn describe(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const key, arg2: *mut seq_file)>>
    {
        unsafe { crate::bpf_probe_read(&self.describe) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const key,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn request_key(&self) -> Option<request_key_actor_t> {
        unsafe { crate::bpf_probe_read(&self.request_key) }.ok()
    }
    pub fn lookup_restriction(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_char) -> *mut key_restriction,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lookup_restriction) }.ok()
    }
    pub fn asym_query(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const kernel_pkey_params,
                arg2: *mut kernel_pkey_query,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.asym_query) }.ok()
    }
    pub fn asym_eds_op(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernel_pkey_params,
                arg2: *const ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.asym_eds_op) }.ok()
    }
    pub fn asym_verify_signature(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernel_pkey_params,
                arg2: *const ::aya_bpf_cty::c_void,
                arg3: *const ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.asym_verify_signature) }.ok()
    }
    pub fn link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn lock_class(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.lock_class) }.ok()
    }
}
impl key_restriction {
    pub fn check(&self) -> Option<key_restrict_link_func_t> {
        unsafe { crate::bpf_probe_read(&self.check) }.ok()
    }
    pub fn key(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn keytype(&self) -> Option<*mut key_type> {
        let v = unsafe { crate::bpf_probe_read(&self.keytype) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl group_info {
    pub fn usage(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn ngroups(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ngroups) }.ok()
    }
    pub fn gid(&self) -> Option<__IncompleteArrayField<kgid_t>> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
}
impl delayed_call {
    pub fn fn_(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
    pub fn arg(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.arg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl io_cq {
    pub fn q(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioc(&self) -> Option<*mut io_context> {
        let v = unsafe { crate::bpf_probe_read(&self.ioc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn q_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.q_node) }.ok()
    }
    pub fn __rcu_icq_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__rcu_icq_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioc_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ioc_node) }.ok()
    }
    pub fn __rcu_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__rcu_head) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl io_cq__bindgen_ty_1 {
    pub fn q_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.q_node) }.ok()
    }
    pub fn __rcu_icq_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.__rcu_icq_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl io_cq__bindgen_ty_2 {
    pub fn ioc_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.ioc_node) }.ok()
    }
    pub fn __rcu_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__rcu_head) }.ok()
    }
}
impl kiocb {
    pub fn ki_filp(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.ki_filp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ki_pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.ki_pos) }.ok()
    }
    pub fn ki_complete(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kiocb,
                arg2: ::aya_bpf_cty::c_long,
                arg3: ::aya_bpf_cty::c_long,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ki_complete) }.ok()
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ki_flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ki_flags) }.ok()
    }
    pub fn ki_hint(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.ki_hint) }.ok()
    }
    pub fn ki_ioprio(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.ki_ioprio) }.ok()
    }
    pub fn ki_cookie(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ki_cookie) }.ok()
    }
    pub fn ki_waitq(&self) -> Option<*mut wait_page_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ki_waitq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kiocb__bindgen_ty_1 {
    pub fn ki_cookie(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ki_cookie) }.ok()
    }
    pub fn ki_waitq(&self) -> Option<*mut wait_page_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.ki_waitq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iattr {
    pub fn ia_valid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ia_valid) }.ok()
    }
    pub fn ia_mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.ia_mode) }.ok()
    }
    pub fn ia_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.ia_uid) }.ok()
    }
    pub fn ia_gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.ia_gid) }.ok()
    }
    pub fn ia_size(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.ia_size) }.ok()
    }
    pub fn ia_atime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_atime) }.ok()
    }
    pub fn ia_mtime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_mtime) }.ok()
    }
    pub fn ia_ctime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_ctime) }.ok()
    }
    pub fn ia_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.ia_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kprojid_t {
    pub fn val(&self) -> Option<projid_t> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl kqid {
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.gid) }.ok()
    }
    pub fn projid(&self) -> Option<kprojid_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.projid) }.ok()
    }
    pub fn type_(&self) -> Option<quota_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl kqid__bindgen_ty_1 {
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn projid(&self) -> Option<kprojid_t> {
        unsafe { crate::bpf_probe_read(&self.projid) }.ok()
    }
}
impl mem_dqblk {
    pub fn dqb_bhardlimit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_bhardlimit) }.ok()
    }
    pub fn dqb_bsoftlimit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_bsoftlimit) }.ok()
    }
    pub fn dqb_curspace(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_curspace) }.ok()
    }
    pub fn dqb_rsvspace(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_rsvspace) }.ok()
    }
    pub fn dqb_ihardlimit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_ihardlimit) }.ok()
    }
    pub fn dqb_isoftlimit(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_isoftlimit) }.ok()
    }
    pub fn dqb_curinodes(&self) -> Option<qsize_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_curinodes) }.ok()
    }
    pub fn dqb_btime(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_btime) }.ok()
    }
    pub fn dqb_itime(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.dqb_itime) }.ok()
    }
}
impl dquot {
    pub fn dq_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.dq_hash) }.ok()
    }
    pub fn dq_inuse(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dq_inuse) }.ok()
    }
    pub fn dq_free(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dq_free) }.ok()
    }
    pub fn dq_dirty(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dq_dirty) }.ok()
    }
    pub fn dq_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.dq_lock) }.ok()
    }
    pub fn dq_dqb_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.dq_dqb_lock) }.ok()
    }
    pub fn dq_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dq_count) }.ok()
    }
    pub fn dq_sb(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.dq_sb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dq_id(&self) -> Option<kqid> {
        unsafe { crate::bpf_probe_read(&self.dq_id) }.ok()
    }
    pub fn dq_off(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.dq_off) }.ok()
    }
    pub fn dq_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dq_flags) }.ok()
    }
    pub fn dq_dqb(&self) -> Option<mem_dqblk> {
        unsafe { crate::bpf_probe_read(&self.dq_dqb) }.ok()
    }
}
impl quota_format_type {
    pub fn qf_fmt_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.qf_fmt_id) }.ok()
    }
    pub fn qf_ops(&self) -> Option<*const quota_format_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.qf_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qf_owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.qf_owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qf_next(&self) -> Option<*mut quota_format_type> {
        let v = unsafe { crate::bpf_probe_read(&self.qf_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl quota_format_ops {
    pub fn check_quota_file(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_quota_file) }.ok()
    }
    pub fn read_file_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_file_info) }.ok()
    }
    pub fn write_file_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_file_info) }.ok()
    }
    pub fn free_file_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free_file_info) }.ok()
    }
    pub fn read_dqblk(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.read_dqblk) }.ok()
    }
    pub fn commit_dqblk(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.commit_dqblk) }.ok()
    }
    pub fn release_dqblk(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.release_dqblk) }.ok()
    }
    pub fn get_next_id(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_next_id) }.ok()
    }
}
impl dquot_operations {
    pub fn write_dquot(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.write_dquot) }.ok()
    }
    pub fn alloc_dquot(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::aya_bpf_cty::c_int) -> *mut dquot,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.alloc_dquot) }.ok()
    }
    pub fn destroy_dquot(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>> {
        unsafe { crate::bpf_probe_read(&self.destroy_dquot) }.ok()
    }
    pub fn acquire_dquot(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.acquire_dquot) }.ok()
    }
    pub fn release_dquot(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.release_dquot) }.ok()
    }
    pub fn mark_dirty(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.mark_dirty) }.ok()
    }
    pub fn write_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_info) }.ok()
    }
    pub fn get_reserved_space(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>>
    {
        unsafe { crate::bpf_probe_read(&self.get_reserved_space) }.ok()
    }
    pub fn get_projid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_projid) }.ok()
    }
    pub fn get_inode_usage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_inode_usage) }.ok()
    }
    pub fn get_next_id(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_next_id) }.ok()
    }
}
impl qc_dqblk {
    pub fn d_fieldmask(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.d_fieldmask) }.ok()
    }
    pub fn d_spc_hardlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_spc_hardlimit) }.ok()
    }
    pub fn d_spc_softlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_spc_softlimit) }.ok()
    }
    pub fn d_ino_hardlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_ino_hardlimit) }.ok()
    }
    pub fn d_ino_softlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_ino_softlimit) }.ok()
    }
    pub fn d_space(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_space) }.ok()
    }
    pub fn d_ino_count(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_ino_count) }.ok()
    }
    pub fn d_ino_timer(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.d_ino_timer) }.ok()
    }
    pub fn d_spc_timer(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.d_spc_timer) }.ok()
    }
    pub fn d_ino_warns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.d_ino_warns) }.ok()
    }
    pub fn d_spc_warns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.d_spc_warns) }.ok()
    }
    pub fn d_rt_spc_hardlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_rt_spc_hardlimit) }.ok()
    }
    pub fn d_rt_spc_softlimit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_rt_spc_softlimit) }.ok()
    }
    pub fn d_rt_space(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.d_rt_space) }.ok()
    }
    pub fn d_rt_spc_timer(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.d_rt_spc_timer) }.ok()
    }
    pub fn d_rt_spc_warns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.d_rt_spc_warns) }.ok()
    }
}
impl qc_type_state {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn spc_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.spc_timelimit) }.ok()
    }
    pub fn ino_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ino_timelimit) }.ok()
    }
    pub fn rt_spc_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rt_spc_timelimit) }.ok()
    }
    pub fn spc_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.spc_warnlimit) }.ok()
    }
    pub fn ino_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ino_warnlimit) }.ok()
    }
    pub fn rt_spc_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rt_spc_warnlimit) }.ok()
    }
    pub fn ino(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.ino) }.ok()
    }
    pub fn blocks(&self) -> Option<blkcnt_t> {
        unsafe { crate::bpf_probe_read(&self.blocks) }.ok()
    }
    pub fn nextents(&self) -> Option<blkcnt_t> {
        unsafe { crate::bpf_probe_read(&self.nextents) }.ok()
    }
}
impl qc_state {
    pub fn s_incoredqs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.s_incoredqs) }.ok()
    }
    pub fn s_state(&self) -> Option<[qc_type_state; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.s_state) }.ok()
    }
}
impl qc_info {
    pub fn i_fieldmask(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.i_fieldmask) }.ok()
    }
    pub fn i_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_flags) }.ok()
    }
    pub fn i_spc_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_spc_timelimit) }.ok()
    }
    pub fn i_ino_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_ino_timelimit) }.ok()
    }
    pub fn i_rt_spc_timelimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_rt_spc_timelimit) }.ok()
    }
    pub fn i_spc_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_spc_warnlimit) }.ok()
    }
    pub fn i_ino_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_ino_warnlimit) }.ok()
    }
    pub fn i_rt_spc_warnlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.i_rt_spc_warnlimit) }.ok()
    }
}
impl quotactl_ops {
    pub fn quota_on(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *const path,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_on) }.ok()
    }
    pub fn quota_off(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_off) }.ok()
    }
    pub fn quota_enable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_enable) }.ok()
    }
    pub fn quota_disable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_disable) }.ok()
    }
    pub fn quota_sync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_sync) }.ok()
    }
    pub fn set_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut qc_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_info) }.ok()
    }
    pub fn get_dqblk(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: kqid,
                arg3: *mut qc_dqblk,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_dqblk) }.ok()
    }
    pub fn get_nextdqblk(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut kqid,
                arg3: *mut qc_dqblk,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_nextdqblk) }.ok()
    }
    pub fn set_dqblk(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: kqid,
                arg3: *mut qc_dqblk,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_dqblk) }.ok()
    }
    pub fn get_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut qc_state,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_state) }.ok()
    }
    pub fn rm_xquota(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rm_xquota) }.ok()
    }
}
impl address_space_operations {
    pub fn writepage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut page,
                arg2: *mut writeback_control,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.writepage) }.ok()
    }
    pub fn readpage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut page) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.readpage) }.ok()
    }
    pub fn writepages(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut address_space,
                arg2: *mut writeback_control,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.writepages) }.ok()
    }
    pub fn set_page_dirty(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.set_page_dirty) }.ok()
    }
    pub fn readpages(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut address_space,
                arg3: *mut list_head,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.readpages) }.ok()
    }
    pub fn readahead(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>> {
        unsafe { crate::bpf_probe_read(&self.readahead) }.ok()
    }
    pub fn write_begin(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut address_space,
                arg3: loff_t,
                arg4: ::aya_bpf_cty::c_uint,
                arg5: ::aya_bpf_cty::c_uint,
                arg6: *mut *mut page,
                arg7: *mut *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_begin) }.ok()
    }
    pub fn write_end(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut address_space,
                arg3: loff_t,
                arg4: ::aya_bpf_cty::c_uint,
                arg5: ::aya_bpf_cty::c_uint,
                arg6: *mut page,
                arg7: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_end) }.ok()
    }
    pub fn bmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bmap) }.ok()
    }
    pub fn invalidatepage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut page,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.invalidatepage) }.ok()
    }
    pub fn releasepage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut page, arg2: gfp_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.releasepage) }.ok()
    }
    pub fn freepage(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>> {
        unsafe { crate::bpf_probe_read(&self.freepage) }.ok()
    }
    pub fn direct_IO(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.direct_IO) }.ok()
    }
    pub fn migratepage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut address_space,
                arg2: *mut page,
                arg3: *mut page,
                arg4: migrate_mode::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.migratepage) }.ok()
    }
    pub fn isolate_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut page, arg2: isolate_mode_t) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.isolate_page) }.ok()
    }
    pub fn putback_page(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>> {
        unsafe { crate::bpf_probe_read(&self.putback_page) }.ok()
    }
    pub fn launder_page(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.launder_page) }.ok()
    }
    pub fn is_partially_uptodate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut page,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_partially_uptodate) }.ok()
    }
    pub fn is_dirty_writeback(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut page, arg2: *mut bool_, arg3: *mut bool_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_dirty_writeback) }.ok()
    }
    pub fn error_remove_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.error_remove_page) }.ok()
    }
    pub fn swap_activate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut swap_info_struct,
                arg2: *mut file,
                arg3: *mut sector_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.swap_activate) }.ok()
    }
    pub fn swap_deactivate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file)>> {
        unsafe { crate::bpf_probe_read(&self.swap_deactivate) }.ok()
    }
}
impl inode_operations {
    pub fn lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lookup) }.ok()
    }
    pub fn get_link(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut inode,
                arg3: *mut delayed_call,
            ) -> *const ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_link) }.ok()
    }
    pub fn permission(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.permission) }.ok()
    }
    pub fn get_acl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf_cty::c_int) -> *mut posix_acl,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_acl) }.ok()
    }
    pub fn readlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.readlink) }.ok()
    }
    pub fn create(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: umode_t,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.create) }.ok()
    }
    pub fn link(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut inode,
                arg3: *mut dentry,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn unlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unlink) }.ok()
    }
    pub fn symlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: *const ::aya_bpf_cty::c_char,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.symlink) }.ok()
    }
    pub fn mkdir(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: umode_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mkdir) }.ok()
    }
    pub fn rmdir(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rmdir) }.ok()
    }
    pub fn mknod(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: umode_t,
                arg4: dev_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mknod) }.ok()
    }
    pub fn rename(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: *mut inode,
                arg4: *mut dentry,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rename) }.ok()
    }
    pub fn setattr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut iattr) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setattr) }.ok()
    }
    pub fn getattr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const path,
                arg2: *mut kstat,
                arg3: u32_,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getattr) }.ok()
    }
    pub fn listxattr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.listxattr) }.ok()
    }
    pub fn fiemap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut fiemap_extent_info,
                arg3: u64_,
                arg4: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fiemap) }.ok()
    }
    pub fn update_time(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut timespec64,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update_time) }.ok()
    }
    pub fn atomic_open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: *mut file,
                arg4: ::aya_bpf_cty::c_uint,
                arg5: umode_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.atomic_open) }.ok()
    }
    pub fn tmpfile(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: umode_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tmpfile) }.ok()
    }
    pub fn set_acl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut posix_acl,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_acl) }.ok()
    }
}
impl file_lock_context {
    pub fn flc_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.flc_lock) }.ok()
    }
    pub fn flc_flock(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flc_flock) }.ok()
    }
    pub fn flc_posix(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flc_posix) }.ok()
    }
    pub fn flc_lease(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flc_lease) }.ok()
    }
}
impl file_lock_operations {
    pub fn fl_copy_lock(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    > {
        unsafe { crate::bpf_probe_read(&self.fl_copy_lock) }.ok()
    }
    pub fn fl_release_private(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>> {
        unsafe { crate::bpf_probe_read(&self.fl_release_private) }.ok()
    }
}
impl nlm_lockowner {}
impl nfs_lock_info {
    pub fn state(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn owner(&self) -> Option<*mut nlm_lockowner> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl nfs4_lock_state {}
impl nfs4_lock_info {
    pub fn owner(&self) -> Option<*mut nfs4_lock_state> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl file_lock {
    pub fn fl_blocker(&self) -> Option<*mut file_lock> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_blocker) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fl_list) }.ok()
    }
    pub fn fl_link(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.fl_link) }.ok()
    }
    pub fn fl_blocked_requests(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fl_blocked_requests) }.ok()
    }
    pub fn fl_blocked_member(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fl_blocked_member) }.ok()
    }
    pub fn fl_owner(&self) -> Option<fl_owner_t> {
        unsafe { crate::bpf_probe_read(&self.fl_owner) }.ok()
    }
    pub fn fl_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fl_flags) }.ok()
    }
    pub fn fl_type(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.fl_type) }.ok()
    }
    pub fn fl_pid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fl_pid) }.ok()
    }
    pub fn fl_link_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fl_link_cpu) }.ok()
    }
    pub fn fl_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.fl_wait) }.ok()
    }
    pub fn fl_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl_start(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.fl_start) }.ok()
    }
    pub fn fl_end(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.fl_end) }.ok()
    }
    pub fn fl_fasync(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_fasync) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl_break_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fl_break_time) }.ok()
    }
    pub fn fl_downgrade_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fl_downgrade_time) }.ok()
    }
    pub fn fl_ops(&self) -> Option<*const file_lock_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl_lmops(&self) -> Option<*const lock_manager_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_lmops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl_u(&self) -> Option<file_lock__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.fl_u) }.ok()
    }
}
impl file_lock__bindgen_ty_1 {
    pub fn nfs_fl(&self) -> Option<nfs_lock_info> {
        unsafe { crate::bpf_probe_read(&self.nfs_fl) }.ok()
    }
    pub fn nfs4_fl(&self) -> Option<nfs4_lock_info> {
        unsafe { crate::bpf_probe_read(&self.nfs4_fl) }.ok()
    }
    pub fn afs(&self) -> Option<file_lock__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.afs) }.ok()
    }
}
impl file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub fn link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn debug_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.debug_id) }.ok()
    }
}
impl lock_manager_operations {
    pub fn lm_get_owner(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>> {
        unsafe { crate::bpf_probe_read(&self.lm_get_owner) }.ok()
    }
    pub fn lm_put_owner(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>> {
        unsafe { crate::bpf_probe_read(&self.lm_put_owner) }.ok()
    }
    pub fn lm_notify(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>> {
        unsafe { crate::bpf_probe_read(&self.lm_notify) }.ok()
    }
    pub fn lm_grant(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file_lock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lm_grant) }.ok()
    }
    pub fn lm_break(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.lm_break) }.ok()
    }
    pub fn lm_change(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file_lock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut list_head,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lm_change) }.ok()
    }
    pub fn lm_setup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lm_setup) }.ok()
    }
    pub fn lm_breaker_owns_lease(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.lm_breaker_owns_lease) }.ok()
    }
}
impl fasync_struct {
    pub fn fa_lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.fa_lock) }.ok()
    }
    pub fn magic(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn fa_fd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fa_fd) }.ok()
    }
    pub fn fa_next(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fa_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fa_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.fa_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fa_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.fa_rcu) }.ok()
    }
}
impl super_operations {
    pub fn alloc_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> *mut inode>>
    {
        unsafe { crate::bpf_probe_read(&self.alloc_inode) }.ok()
    }
    pub fn destroy_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
        unsafe { crate::bpf_probe_read(&self.destroy_inode) }.ok()
    }
    pub fn free_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
        unsafe { crate::bpf_probe_read(&self.free_inode) }.ok()
    }
    pub fn dirty_inode(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf_cty::c_int)>,
    > {
        unsafe { crate::bpf_probe_read(&self.dirty_inode) }.ok()
    }
    pub fn write_inode(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut writeback_control,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_inode) }.ok()
    }
    pub fn drop_inode(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.drop_inode) }.ok()
    }
    pub fn evict_inode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
        unsafe { crate::bpf_probe_read(&self.evict_inode) }.ok()
    }
    pub fn put_super(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>> {
        unsafe { crate::bpf_probe_read(&self.put_super) }.ok()
    }
    pub fn sync_fs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_fs) }.ok()
    }
    pub fn freeze_super(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.freeze_super) }.ok()
    }
    pub fn freeze_fs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.freeze_fs) }.ok()
    }
    pub fn thaw_super(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.thaw_super) }.ok()
    }
    pub fn unfreeze_fs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unfreeze_fs) }.ok()
    }
    pub fn statfs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.statfs) }.ok()
    }
    pub fn remount_fs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_char,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.remount_fs) }.ok()
    }
    pub fn umount_begin(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>> {
        unsafe { crate::bpf_probe_read(&self.umount_begin) }.ok()
    }
    pub fn show_options(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_options) }.ok()
    }
    pub fn show_devname(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_devname) }.ok()
    }
    pub fn show_path(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_path) }.ok()
    }
    pub fn show_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_stats) }.ok()
    }
    pub fn quota_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_char,
                arg4: size_t,
                arg5: loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_read) }.ok()
    }
    pub fn quota_write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: size_t,
                arg5: loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.quota_write) }.ok()
    }
    pub fn get_dquots(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>>
    {
        unsafe { crate::bpf_probe_read(&self.get_dquots) }.ok()
    }
    pub fn bdev_try_to_free_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut page,
                arg3: gfp_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bdev_try_to_free_page) }.ok()
    }
    pub fn nr_cached_objects(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut shrink_control,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.nr_cached_objects) }.ok()
    }
    pub fn free_cached_objects(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut shrink_control,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free_cached_objects) }.ok()
    }
    pub fn real_loop(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> *mut file>> {
        unsafe { crate::bpf_probe_read(&self.real_loop) }.ok()
    }
}
impl iomap {}
impl export_operations {
    pub fn encode_fh(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut __u32,
                arg3: *mut ::aya_bpf_cty::c_int,
                arg4: *mut inode,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.encode_fh) }.ok()
    }
    pub fn fh_to_dentry(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut fid,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
            ) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fh_to_dentry) }.ok()
    }
    pub fn fh_to_parent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut fid,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
            ) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fh_to_parent) }.ok()
    }
    pub fn get_name(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: *mut dentry,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_name) }.ok()
    }
    pub fn get_parent(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> *mut dentry>>
    {
        unsafe { crate::bpf_probe_read(&self.get_parent) }.ok()
    }
    pub fn commit_metadata(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.commit_metadata) }.ok()
    }
    pub fn get_uuid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut u8_,
                arg3: *mut u32_,
                arg4: *mut u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_uuid) }.ok()
    }
    pub fn map_blocks(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: loff_t,
                arg3: u64_,
                arg4: *mut iomap,
                arg5: bool_,
                arg6: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_blocks) }.ok()
    }
    pub fn commit_blocks(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut iomap,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *mut iattr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.commit_blocks) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl xattr_handler {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prefix(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.prefix) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn list(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const xattr_handler,
                arg2: *mut dentry,
                arg3: *mut inode,
                arg4: *const ::aya_bpf_cty::c_char,
                arg5: *mut ::aya_bpf_cty::c_void,
                arg6: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const xattr_handler,
                arg2: *mut dentry,
                arg3: *mut inode,
                arg4: *const ::aya_bpf_cty::c_char,
                arg5: *const ::aya_bpf_cty::c_void,
                arg6: size_t,
                arg7: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set) }.ok()
    }
}
impl fscrypt_operations {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn key_prefix(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.key_prefix) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn get_context(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_context) }.ok()
    }
    pub fn set_context(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *const ::aya_bpf_cty::c_void,
                arg3: size_t,
                arg4: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_context) }.ok()
    }
    pub fn get_dummy_policy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> *const fscrypt_policy,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_dummy_policy) }.ok()
    }
    pub fn empty_dir(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.empty_dir) }.ok()
    }
    pub fn max_namelen(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_namelen) }.ok()
    }
    pub fn has_stable_inodes(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.has_stable_inodes) }.ok()
    }
    pub fn get_ino_and_lblk_bits(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_int,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ino_and_lblk_bits) }.ok()
    }
    pub fn get_num_devices(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_num_devices) }.ok()
    }
    pub fn get_devices(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut *mut request_queue),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_devices) }.ok()
    }
}
impl fsverity_operations {
    pub fn begin_enable_verity(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.begin_enable_verity) }.ok()
    }
    pub fn end_enable_verity(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *const ::aya_bpf_cty::c_void,
                arg3: size_t,
                arg4: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.end_enable_verity) }.ok()
    }
    pub fn get_verity_descriptor(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_verity_descriptor) }.ok()
    }
    pub fn read_merkle_tree_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> *mut page,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_merkle_tree_page) }.ok()
    }
    pub fn write_merkle_tree_block(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *const ::aya_bpf_cty::c_void,
                arg3: u64_,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_merkle_tree_block) }.ok()
    }
}
impl dir_context {
    pub fn actor(&self) -> Option<filldir_t> {
        unsafe { crate::bpf_probe_read(&self.actor) }.ok()
    }
    pub fn pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.pos) }.ok()
    }
}
impl fs_parameter_spec {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<fs_param_type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn opt(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.opt) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernel_symbol {
    pub fn value_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.value_offset) }.ok()
    }
    pub fn name_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.name_offset) }.ok()
    }
    pub fn namespace_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.namespace_offset) }.ok()
    }
}
impl lockdep_map {}
impl jump_entry {
    pub fn code(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
    pub fn target(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.target) }.ok()
    }
    pub fn key(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl static_key {
    pub fn enabled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.enabled) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.type_) }.ok()
    }
    pub fn entries(&self) -> Option<*mut jump_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut static_key_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl static_key__bindgen_ty_1 {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn entries(&self) -> Option<*mut jump_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut static_key_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bug_entry {
    pub fn bug_addr_disp(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bug_addr_disp) }.ok()
    }
    pub fn file_disp(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.file_disp) }.ok()
    }
    pub fn line(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.line) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl tracepoint_func {
    pub fn func(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.func) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
}
impl tracepoint {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key(&self) -> Option<static_key> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn static_call_key(&self) -> Option<*mut static_call_key> {
        let v = unsafe { crate::bpf_probe_read(&self.static_call_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn static_call_tramp(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.static_call_tramp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iterator(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iterator) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn regfunc(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_int>> {
        unsafe { crate::bpf_probe_read(&self.regfunc) }.ok()
    }
    pub fn unregfunc(&self) -> Option<::core::option::Option<unsafe extern "C" fn()>> {
        unsafe { crate::bpf_probe_read(&self.unregfunc) }.ok()
    }
    pub fn funcs(&self) -> Option<*mut tracepoint_func> {
        let v = unsafe { crate::bpf_probe_read(&self.funcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl static_call_key {
    pub fn func(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.func) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.type_) }.ok()
    }
    pub fn mods(&self) -> Option<*mut static_call_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mods) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sites(&self) -> Option<*mut static_call_site> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl static_call_key__bindgen_ty_1 {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn mods(&self) -> Option<*mut static_call_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.mods) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sites(&self) -> Option<*mut static_call_site> {
        let v = unsafe { crate::bpf_probe_read(&self.sites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_raw_event_map {
    pub fn tp(&self) -> Option<*mut tracepoint> {
        let v = unsafe { crate::bpf_probe_read(&self.tp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bpf_func(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.bpf_func) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_args(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_args) }.ok()
    }
    pub fn writable_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.writable_size) }.ok()
    }
}
impl seq_operations {
    pub fn start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn stop(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn next(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.next) }.ok()
    }
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
}
impl local_t {
    pub fn a(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.a) }.ok()
    }
}
impl local64_t {
    pub fn a(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.a) }.ok()
    }
}
impl perf_event_attr {
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn config(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.config) }.ok()
    }
    pub fn sample_period(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sample_period) }.ok()
    }
    pub fn sample_freq(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sample_freq) }.ok()
    }
    pub fn sample_type(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_type) }.ok()
    }
    pub fn read_format(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.read_format) }.ok()
    }
    pub fn wakeup_events(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.wakeup_events) }.ok()
    }
    pub fn wakeup_watermark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.wakeup_watermark) }.ok()
    }
    pub fn bp_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bp_type) }.ok()
    }
    pub fn bp_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.bp_addr) }.ok()
    }
    pub fn kprobe_func(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.kprobe_func) }.ok()
    }
    pub fn uprobe_path(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.uprobe_path) }.ok()
    }
    pub fn config1(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.config1) }.ok()
    }
    pub fn bp_len(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.bp_len) }.ok()
    }
    pub fn kprobe_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.kprobe_addr) }.ok()
    }
    pub fn probe_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.probe_offset) }.ok()
    }
    pub fn config2(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.config2) }.ok()
    }
    pub fn branch_sample_type(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.branch_sample_type) }.ok()
    }
    pub fn sample_regs_user(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_regs_user) }.ok()
    }
    pub fn sample_stack_user(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sample_stack_user) }.ok()
    }
    pub fn clockid(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.clockid) }.ok()
    }
    pub fn sample_regs_intr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_regs_intr) }.ok()
    }
    pub fn aux_watermark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.aux_watermark) }.ok()
    }
    pub fn sample_max_stack(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.sample_max_stack) }.ok()
    }
    pub fn __reserved_2(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__reserved_2) }.ok()
    }
    pub fn aux_sample_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.aux_sample_size) }.ok()
    }
    pub fn __reserved_3(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__reserved_3) }.ok()
    }
}
impl perf_event_attr__bindgen_ty_1 {
    pub fn sample_period(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_period) }.ok()
    }
    pub fn sample_freq(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_freq) }.ok()
    }
}
impl perf_event_attr__bindgen_ty_2 {
    pub fn wakeup_events(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.wakeup_events) }.ok()
    }
    pub fn wakeup_watermark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.wakeup_watermark) }.ok()
    }
}
impl perf_event_attr__bindgen_ty_3 {
    pub fn bp_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bp_addr) }.ok()
    }
    pub fn kprobe_func(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.kprobe_func) }.ok()
    }
    pub fn uprobe_path(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.uprobe_path) }.ok()
    }
    pub fn config1(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.config1) }.ok()
    }
}
impl perf_event_attr__bindgen_ty_4 {
    pub fn bp_len(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bp_len) }.ok()
    }
    pub fn kprobe_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.kprobe_addr) }.ok()
    }
    pub fn probe_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.probe_offset) }.ok()
    }
    pub fn config2(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.config2) }.ok()
    }
}
impl hw_perf_event_extra {
    pub fn config(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.config) }.ok()
    }
    pub fn reg(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reg) }.ok()
    }
    pub fn alloc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.alloc) }.ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.idx) }.ok()
    }
}
impl arch_hw_breakpoint {
    pub fn address(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.address) }.ok()
    }
    pub fn mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn type_(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl hw_perf_event {
    pub fn config(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.config) }.ok()
    }
    pub fn last_tag(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.last_tag) }.ok()
    }
    pub fn config_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.config_base) }.ok()
    }
    pub fn event_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.event_base) }.ok()
    }
    pub fn event_base_rdpmc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.event_base_rdpmc) }
            .ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.idx) }.ok()
    }
    pub fn last_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.last_cpu) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.flags) }.ok()
    }
    pub fn extra_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.extra_reg) }.ok()
    }
    pub fn branch_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.branch_reg) }.ok()
    }
    pub fn hrtimer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.hrtimer) }.ok()
    }
    pub fn tp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_3.tp_list) }.ok()
    }
    pub fn pwr_acc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.pwr_acc) }.ok()
    }
    pub fn ptsc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_4.ptsc) }.ok()
    }
    pub fn info(&self) -> Option<arch_hw_breakpoint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_5.info) }.ok()
    }
    pub fn bp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_5.bp_list) }.ok()
    }
    pub fn iommu_bank(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.iommu_bank) }.ok()
    }
    pub fn iommu_cntr(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.iommu_cntr) }.ok()
    }
    pub fn padding(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.padding) }.ok()
    }
    pub fn conf(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.conf) }.ok()
    }
    pub fn conf1(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_6.conf1) }.ok()
    }
    pub fn target(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.target) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn addr_filters(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addr_filters) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn addr_filters_gen(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.addr_filters_gen) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn prev_count(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.prev_count) }.ok()
    }
    pub fn sample_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.sample_period) }.ok()
    }
    pub fn last_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.last_period) }.ok()
    }
    pub fn period_left(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.period_left) }.ok()
    }
    pub fn saved_metric(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_2.saved_metric) }.ok()
    }
    pub fn saved_slots(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_2.saved_slots) }.ok()
    }
    pub fn interrupts_seq(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.interrupts_seq) }.ok()
    }
    pub fn interrupts(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.interrupts) }.ok()
    }
    pub fn freq_time_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.freq_time_stamp) }.ok()
    }
    pub fn freq_count_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.freq_count_stamp) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1 {
    pub fn config(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.config) }.ok()
    }
    pub fn last_tag(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.last_tag) }.ok()
    }
    pub fn config_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.config_base) }.ok()
    }
    pub fn event_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.event_base) }.ok()
    }
    pub fn event_base_rdpmc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.event_base_rdpmc) }.ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.idx) }.ok()
    }
    pub fn last_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.last_cpu) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.flags) }.ok()
    }
    pub fn extra_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.extra_reg) }.ok()
    }
    pub fn branch_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.branch_reg) }.ok()
    }
    pub fn hrtimer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.hrtimer) }.ok()
    }
    pub fn tp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.tp_list) }.ok()
    }
    pub fn pwr_acc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.pwr_acc) }.ok()
    }
    pub fn ptsc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.ptsc) }.ok()
    }
    pub fn info(&self) -> Option<arch_hw_breakpoint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.info) }.ok()
    }
    pub fn bp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.bp_list) }.ok()
    }
    pub fn iommu_bank(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.iommu_bank) }.ok()
    }
    pub fn iommu_cntr(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.iommu_cntr) }.ok()
    }
    pub fn padding(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.padding) }.ok()
    }
    pub fn conf(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.conf) }.ok()
    }
    pub fn conf1(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.conf1) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_1 {
    pub fn config(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.config) }.ok()
    }
    pub fn last_tag(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_tag) }.ok()
    }
    pub fn config_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.config_base) }.ok()
    }
    pub fn event_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.event_base) }.ok()
    }
    pub fn event_base_rdpmc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.event_base_rdpmc) }.ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.idx) }.ok()
    }
    pub fn last_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.last_cpu) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn extra_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.extra_reg) }.ok()
    }
    pub fn branch_reg(&self) -> Option<hw_perf_event_extra> {
        unsafe { crate::bpf_probe_read(&self.branch_reg) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_2 {
    pub fn hrtimer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.hrtimer) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_3 {
    pub fn tp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tp_list) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_4 {
    pub fn pwr_acc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.pwr_acc) }.ok()
    }
    pub fn ptsc(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ptsc) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_5 {
    pub fn info(&self) -> Option<arch_hw_breakpoint> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn bp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.bp_list) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_1__bindgen_ty_6 {
    pub fn iommu_bank(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.iommu_bank) }.ok()
    }
    pub fn iommu_cntr(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.iommu_cntr) }.ok()
    }
    pub fn padding(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn conf(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.conf) }.ok()
    }
    pub fn conf1(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.conf1) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_2 {
    pub fn last_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.last_period) }.ok()
    }
    pub fn period_left(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.period_left) }.ok()
    }
    pub fn saved_metric(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.saved_metric) }.ok()
    }
    pub fn saved_slots(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.saved_slots) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_2__bindgen_ty_1 {
    pub fn last_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_period) }.ok()
    }
    pub fn period_left(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.period_left) }.ok()
    }
}
impl hw_perf_event__bindgen_ty_2__bindgen_ty_2 {
    pub fn saved_metric(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.saved_metric) }.ok()
    }
    pub fn saved_slots(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.saved_slots) }.ok()
    }
}
impl irq_work {
    pub fn node(&self) -> Option<__call_single_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn func(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_work)>> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
}
impl perf_addr_filters_head {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nr_file_filters(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_file_filters) }.ok()
    }
}
impl ftrace_ops_hash {
    pub fn notrace_hash(&self) -> Option<*mut ftrace_hash> {
        let v = unsafe { crate::bpf_probe_read(&self.notrace_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter_hash(&self) -> Option<*mut ftrace_hash> {
        let v = unsafe { crate::bpf_probe_read(&self.filter_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn regex_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.regex_lock) }.ok()
    }
}
impl ftrace_ops {
    pub fn func(&self) -> Option<ftrace_func_t> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn next(&self) -> Option<*mut ftrace_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saved_func(&self) -> Option<ftrace_func_t> {
        unsafe { crate::bpf_probe_read(&self.saved_func) }.ok()
    }
    pub fn local_hash(&self) -> Option<ftrace_ops_hash> {
        unsafe { crate::bpf_probe_read(&self.local_hash) }.ok()
    }
    pub fn func_hash(&self) -> Option<*mut ftrace_ops_hash> {
        let v = unsafe { crate::bpf_probe_read(&self.func_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn old_hash(&self) -> Option<ftrace_ops_hash> {
        unsafe { crate::bpf_probe_read(&self.old_hash) }.ok()
    }
    pub fn trampoline(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trampoline) }.ok()
    }
    pub fn trampoline_size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trampoline_size) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl perf_event {
    pub fn event_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.event_entry) }.ok()
    }
    pub fn sibling_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sibling_list) }.ok()
    }
    pub fn active_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.active_list) }.ok()
    }
    pub fn group_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.group_node) }.ok()
    }
    pub fn group_index(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.group_index) }.ok()
    }
    pub fn migrate_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.migrate_entry) }.ok()
    }
    pub fn hlist_entry(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hlist_entry) }.ok()
    }
    pub fn active_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.active_entry) }.ok()
    }
    pub fn nr_siblings(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_siblings) }.ok()
    }
    pub fn event_caps(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.event_caps) }.ok()
    }
    pub fn group_caps(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.group_caps) }.ok()
    }
    pub fn group_leader(&self) -> Option<*mut perf_event> {
        let v = unsafe { crate::bpf_probe_read(&self.group_leader) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pmu(&self) -> Option<*mut pmu> {
        let v = unsafe { crate::bpf_probe_read(&self.pmu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pmu_private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.pmu_private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state(&self) -> Option<perf_event_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn attach_state(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.attach_state) }.ok()
    }
    pub fn count(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn child_count(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.child_count) }.ok()
    }
    pub fn total_time_enabled(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.total_time_enabled) }.ok()
    }
    pub fn total_time_running(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.total_time_running) }.ok()
    }
    pub fn tstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tstamp) }.ok()
    }
    pub fn shadow_ctx_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.shadow_ctx_time) }.ok()
    }
    pub fn attr(&self) -> Option<perf_event_attr> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
    pub fn header_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.header_size) }.ok()
    }
    pub fn id_header_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.id_header_size) }.ok()
    }
    pub fn read_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.read_size) }.ok()
    }
    pub fn hw(&self) -> Option<hw_perf_event> {
        unsafe { crate::bpf_probe_read(&self.hw) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut perf_event_context> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcount(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn child_total_time_enabled(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.child_total_time_enabled) }.ok()
    }
    pub fn child_total_time_running(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.child_total_time_running) }.ok()
    }
    pub fn child_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.child_mutex) }.ok()
    }
    pub fn child_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.child_list) }.ok()
    }
    pub fn parent(&self) -> Option<*mut perf_event> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn oncpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.oncpu) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn owner_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.owner_entry) }.ok()
    }
    pub fn owner(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mmap_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mmap_mutex) }.ok()
    }
    pub fn mmap_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.mmap_count) }.ok()
    }
    pub fn rb(&self) -> Option<*mut perf_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.rb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rb_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rb_entry) }.ok()
    }
    pub fn rcu_batches(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rcu_batches) }.ok()
    }
    pub fn rcu_pending(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rcu_pending) }.ok()
    }
    pub fn waitq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.waitq) }.ok()
    }
    pub fn fasync(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fasync) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pending_wakeup(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pending_wakeup) }.ok()
    }
    pub fn pending_kill(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pending_kill) }.ok()
    }
    pub fn pending_disable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pending_disable) }.ok()
    }
    pub fn pending(&self) -> Option<irq_work> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
    pub fn event_limit(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.event_limit) }.ok()
    }
    pub fn addr_filters(&self) -> Option<perf_addr_filters_head> {
        unsafe { crate::bpf_probe_read(&self.addr_filters) }.ok()
    }
    pub fn addr_filter_ranges(&self) -> Option<*mut perf_addr_filter_range> {
        let v = unsafe { crate::bpf_probe_read(&self.addr_filter_ranges) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn addr_filters_gen(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.addr_filters_gen) }.ok()
    }
    pub fn aux_event(&self) -> Option<*mut perf_event> {
        let v = unsafe { crate::bpf_probe_read(&self.aux_event) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn ns(&self) -> Option<*mut pid_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn clock(&self) -> Option<::core::option::Option<unsafe extern "C" fn() -> u64_>> {
        unsafe { crate::bpf_probe_read(&self.clock) }.ok()
    }
    pub fn overflow_handler(&self) -> Option<perf_overflow_handler_t> {
        unsafe { crate::bpf_probe_read(&self.overflow_handler) }.ok()
    }
    pub fn overflow_handler_context(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.overflow_handler_context) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn orig_overflow_handler(&self) -> Option<perf_overflow_handler_t> {
        unsafe { crate::bpf_probe_read(&self.orig_overflow_handler) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tp_event(&self) -> Option<*mut trace_event_call> {
        let v = unsafe { crate::bpf_probe_read(&self.tp_event) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter(&self) -> Option<*mut event_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ftrace_ops(&self) -> Option<ftrace_ops> {
        unsafe { crate::bpf_probe_read(&self.ftrace_ops) }.ok()
    }
    pub fn cgrp(&self) -> Option<*mut perf_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sb_list) }.ok()
    }
}
impl uid_gid_extent {
    pub fn first(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.first) }.ok()
    }
    pub fn lower_first(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.lower_first) }.ok()
    }
    pub fn count(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl uid_gid_map {
    pub fn nr_extents(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nr_extents) }.ok()
    }
    pub fn extent(&self) -> Option<[uid_gid_extent; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.extent) }.ok()
    }
    pub fn forward(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.forward) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reverse(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.reverse) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl uid_gid_map__bindgen_ty_1 {
    pub fn extent(&self) -> Option<[uid_gid_extent; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.extent) }.ok()
    }
    pub fn forward(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.forward) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reverse(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.reverse) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub fn forward(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.forward) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reverse(&self) -> Option<*mut uid_gid_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.reverse) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ns_common {
    pub fn stashed(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.stashed) }.ok()
    }
    pub fn ops(&self) -> Option<*const proc_ns_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inum(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.inum) }.ok()
    }
    pub fn count(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl ctl_table_header {
    pub fn ctl_table(&self) -> Option<*mut ctl_table> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ctl_table) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.used) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.count) }.ok()
    }
    pub fn nreg(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.nreg) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn unregistering(&self) -> Option<*mut completion> {
        let v = unsafe { crate::bpf_probe_read(&self.unregistering) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctl_table_arg(&self) -> Option<*mut ctl_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ctl_table_arg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root(&self) -> Option<*mut ctl_table_root> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn set(&self) -> Option<*mut ctl_table_set> {
        let v = unsafe { crate::bpf_probe_read(&self.set) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent(&self) -> Option<*mut ctl_dir> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<*mut ctl_node> {
        let v = unsafe { crate::bpf_probe_read(&self.node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inodes(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.inodes) }.ok()
    }
}
impl ctl_table_header__bindgen_ty_1 {
    pub fn ctl_table(&self) -> Option<*mut ctl_table> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ctl_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.used) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.count) }.ok()
    }
    pub fn nreg(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nreg) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub fn ctl_table(&self) -> Option<*mut ctl_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ctl_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.used) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn nreg(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nreg) }.ok()
    }
}
impl ctl_dir {
    pub fn header(&self) -> Option<ctl_table_header> {
        unsafe { crate::bpf_probe_read(&self.header) }.ok()
    }
    pub fn root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.root) }.ok()
    }
}
impl ctl_table_set {
    pub fn is_seen(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_seen) }.ok()
    }
    pub fn dir(&self) -> Option<ctl_dir> {
        unsafe { crate::bpf_probe_read(&self.dir) }.ok()
    }
}
impl user_namespace {
    pub fn uid_map(&self) -> Option<uid_gid_map> {
        unsafe { crate::bpf_probe_read(&self.uid_map) }.ok()
    }
    pub fn gid_map(&self) -> Option<uid_gid_map> {
        unsafe { crate::bpf_probe_read(&self.gid_map) }.ok()
    }
    pub fn projid_map(&self) -> Option<uid_gid_map> {
        unsafe { crate::bpf_probe_read(&self.projid_map) }.ok()
    }
    pub fn parent(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn level(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn owner(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.owner) }.ok()
    }
    pub fn group(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.group) }.ok()
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn parent_could_setfcap(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.parent_could_setfcap) }.ok()
    }
    pub fn keyring_name_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.keyring_name_list) }.ok()
    }
    pub fn user_keyring_register(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.user_keyring_register) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn keyring_sem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.keyring_sem) }.ok()
    }
    pub fn persistent_keyring_register(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.persistent_keyring_register) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn set(&self) -> Option<ctl_table_set> {
        unsafe { crate::bpf_probe_read(&self.set) }.ok()
    }
    pub fn sysctls(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctls) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucount_max(&self) -> Option<[::aya_bpf_cty::c_int; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.ucount_max) }.ok()
    }
}
impl pollfd {
    pub fn fd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fd) }.ok()
    }
    pub fn events(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn revents(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.revents) }.ok()
    }
}
impl __call_single_data {
    pub fn node(&self) -> Option<__call_single_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn func(&self) -> Option<smp_call_func_t> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn info(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl wait_queue_entry {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func(&self) -> Option<wait_queue_func_t> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
}
impl timer_list {
    pub fn entry(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
    pub fn function(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>> {
        unsafe { crate::bpf_probe_read(&self.function) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl delayed_work {
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
}
impl rcu_work {
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rcu_segcblist {
    pub fn head(&self) -> Option<*mut callback_head> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tails(&self) -> Option<[*mut *mut callback_head; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.tails) }.ok()
    }
    pub fn gp_seq(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.gp_seq) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn enabled(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.enabled) }.ok()
    }
    pub fn offloaded(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.offloaded) }.ok()
    }
}
impl srcu_data {
    pub fn srcu_lock_count(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.srcu_lock_count) }.ok()
    }
    pub fn srcu_unlock_count(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.srcu_unlock_count) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn srcu_cblist(&self) -> Option<rcu_segcblist> {
        unsafe { crate::bpf_probe_read(&self.srcu_cblist) }.ok()
    }
    pub fn srcu_gp_seq_needed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq_needed) }.ok()
    }
    pub fn srcu_gp_seq_needed_exp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq_needed_exp) }.ok()
    }
    pub fn srcu_cblist_invoking(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.srcu_cblist_invoking) }.ok()
    }
    pub fn delay_work(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.delay_work) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn srcu_barrier_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.srcu_barrier_head) }.ok()
    }
    pub fn mynode(&self) -> Option<*mut srcu_node> {
        let v = unsafe { crate::bpf_probe_read(&self.mynode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn grpmask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.grpmask) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn ssp(&self) -> Option<*mut srcu_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.ssp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl srcu_node {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn srcu_have_cbs(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.srcu_have_cbs) }.ok()
    }
    pub fn srcu_data_have_cbs(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.srcu_data_have_cbs) }.ok()
    }
    pub fn srcu_gp_seq_needed_exp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq_needed_exp) }.ok()
    }
    pub fn srcu_parent(&self) -> Option<*mut srcu_node> {
        let v = unsafe { crate::bpf_probe_read(&self.srcu_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn grplo(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.grplo) }.ok()
    }
    pub fn grphi(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.grphi) }.ok()
    }
}
impl srcu_struct {
    pub fn node(&self) -> Option<[srcu_node; 521usize]> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn level(&self) -> Option<[*mut srcu_node; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn srcu_cb_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.srcu_cb_mutex) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn srcu_gp_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_mutex) }.ok()
    }
    pub fn srcu_idx(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.srcu_idx) }.ok()
    }
    pub fn srcu_gp_seq(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq) }.ok()
    }
    pub fn srcu_gp_seq_needed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq_needed) }.ok()
    }
    pub fn srcu_gp_seq_needed_exp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_gp_seq_needed_exp) }.ok()
    }
    pub fn srcu_last_gp_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_last_gp_end) }.ok()
    }
    pub fn sda(&self) -> Option<*mut srcu_data> {
        let v = unsafe { crate::bpf_probe_read(&self.sda) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn srcu_barrier_seq(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.srcu_barrier_seq) }.ok()
    }
    pub fn srcu_barrier_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.srcu_barrier_mutex) }.ok()
    }
    pub fn srcu_barrier_completion(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.srcu_barrier_completion) }.ok()
    }
    pub fn srcu_barrier_cpu_cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.srcu_barrier_cpu_cnt) }.ok()
    }
    pub fn work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
}
impl anon_vma {
    pub fn root(&self) -> Option<*mut anon_vma> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.rwsem) }.ok()
    }
    pub fn refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn degree(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.degree) }.ok()
    }
    pub fn parent(&self) -> Option<*mut anon_vma> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rb_root(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.rb_root) }.ok()
    }
}
impl mempolicy {
    pub fn refcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn mode(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn v(&self) -> Option<mempolicy__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.v) }.ok()
    }
    pub fn w(&self) -> Option<mempolicy__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.w) }.ok()
    }
}
impl mempolicy__bindgen_ty_1 {
    pub fn preferred_node(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.preferred_node) }.ok()
    }
    pub fn nodes(&self) -> Option<nodemask_t> {
        unsafe { crate::bpf_probe_read(&self.nodes) }.ok()
    }
}
impl mempolicy__bindgen_ty_2 {
    pub fn cpuset_mems_allowed(&self) -> Option<nodemask_t> {
        unsafe { crate::bpf_probe_read(&self.cpuset_mems_allowed) }.ok()
    }
    pub fn user_nodemask(&self) -> Option<nodemask_t> {
        unsafe { crate::bpf_probe_read(&self.user_nodemask) }.ok()
    }
}
impl linux_binfmt {
    pub fn lh(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.lh) }.ok()
    }
    pub fn module(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.module) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn load_binary(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut linux_binprm) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.load_binary) }.ok()
    }
    pub fn load_shlib(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.load_shlib) }.ok()
    }
    pub fn core_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut coredump_params) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.core_dump) }.ok()
    }
    pub fn min_coredump(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_coredump) }.ok()
    }
}
impl free_area {
    pub fn free_list(&self) -> Option<[list_head; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.free_list) }.ok()
    }
    pub fn nr_free(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_free) }.ok()
    }
}
impl zone_padding {
    pub fn x(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.x) }.ok()
    }
}
impl lruvec {
    pub fn lists(&self) -> Option<[list_head; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.lists) }.ok()
    }
    pub fn lru_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lru_lock) }.ok()
    }
    pub fn anon_cost(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.anon_cost) }.ok()
    }
    pub fn file_cost(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.file_cost) }.ok()
    }
    pub fn nonresident_age(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.nonresident_age) }.ok()
    }
    pub fn refaults(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.refaults) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pgdat(&self) -> Option<*mut pglist_data> {
        let v = unsafe { crate::bpf_probe_read(&self.pgdat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl zone {
    pub fn _watermark(&self) -> Option<[::aya_bpf_cty::c_ulong; 3usize]> {
        unsafe { crate::bpf_probe_read(&self._watermark) }.ok()
    }
    pub fn watermark_boost(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.watermark_boost) }.ok()
    }
    pub fn nr_reserved_highatomic(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_reserved_highatomic) }.ok()
    }
    pub fn lowmem_reserve(&self) -> Option<[::aya_bpf_cty::c_long; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.lowmem_reserve) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn zone_pgdat(&self) -> Option<*mut pglist_data> {
        let v = unsafe { crate::bpf_probe_read(&self.zone_pgdat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pageset(&self) -> Option<*mut per_cpu_pageset> {
        let v = unsafe { crate::bpf_probe_read(&self.pageset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pageset_high(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pageset_high) }.ok()
    }
    pub fn pageset_batch(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pageset_batch) }.ok()
    }
    pub fn zone_start_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.zone_start_pfn) }.ok()
    }
    pub fn managed_pages(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.managed_pages) }.ok()
    }
    pub fn spanned_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.spanned_pages) }.ok()
    }
    pub fn present_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.present_pages) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_isolate_pageblock(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_isolate_pageblock) }.ok()
    }
    pub fn span_seqlock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.span_seqlock) }.ok()
    }
    pub fn initialized(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.initialized) }.ok()
    }
    pub fn _pad1_(&self) -> Option<zone_padding> {
        unsafe { crate::bpf_probe_read(&self._pad1_) }.ok()
    }
    pub fn free_area(&self) -> Option<[free_area; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.free_area) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn _pad2_(&self) -> Option<zone_padding> {
        unsafe { crate::bpf_probe_read(&self._pad2_) }.ok()
    }
    pub fn percpu_drift_mark(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.percpu_drift_mark) }.ok()
    }
    pub fn compact_cached_free_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.compact_cached_free_pfn) }.ok()
    }
    pub fn compact_cached_migrate_pfn(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.compact_cached_migrate_pfn) }.ok()
    }
    pub fn compact_init_migrate_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.compact_init_migrate_pfn) }.ok()
    }
    pub fn compact_init_free_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.compact_init_free_pfn) }.ok()
    }
    pub fn compact_considered(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.compact_considered) }.ok()
    }
    pub fn compact_defer_shift(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.compact_defer_shift) }.ok()
    }
    pub fn compact_order_failed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.compact_order_failed) }.ok()
    }
    pub fn compact_blockskip_flush(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.compact_blockskip_flush) }.ok()
    }
    pub fn contiguous(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.contiguous) }.ok()
    }
    pub fn _pad3_(&self) -> Option<zone_padding> {
        unsafe { crate::bpf_probe_read(&self._pad3_) }.ok()
    }
    pub fn vm_stat(&self) -> Option<[atomic_long_t; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_stat) }.ok()
    }
    pub fn vm_numa_stat(&self) -> Option<[atomic_long_t; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_numa_stat) }.ok()
    }
}
impl zoneref {
    pub fn zone(&self) -> Option<*mut zone> {
        let v = unsafe { crate::bpf_probe_read(&self.zone) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn zone_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.zone_idx) }.ok()
    }
}
impl zonelist {
    pub fn _zonerefs(&self) -> Option<[zoneref; 5121usize]> {
        unsafe { crate::bpf_probe_read(&self._zonerefs) }.ok()
    }
}
impl deferred_split {
    pub fn split_queue_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.split_queue_lock) }.ok()
    }
    pub fn split_queue(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.split_queue) }.ok()
    }
    pub fn split_queue_len(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.split_queue_len) }.ok()
    }
}
impl pglist_data {
    pub fn node_zones(&self) -> Option<[zone; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.node_zones) }.ok()
    }
    pub fn node_zonelists(&self) -> Option<[zonelist; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.node_zonelists) }.ok()
    }
    pub fn nr_zones(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_zones) }.ok()
    }
    pub fn node_size_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.node_size_lock) }.ok()
    }
    pub fn node_start_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.node_start_pfn) }.ok()
    }
    pub fn node_present_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.node_present_pages) }.ok()
    }
    pub fn node_spanned_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.node_spanned_pages) }.ok()
    }
    pub fn node_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node_id) }.ok()
    }
    pub fn kswapd_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.kswapd_wait) }.ok()
    }
    pub fn pfmemalloc_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.pfmemalloc_wait) }.ok()
    }
    pub fn kswapd(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.kswapd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kswapd_order(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.kswapd_order) }.ok()
    }
    pub fn kswapd_highest_zoneidx(&self) -> Option<zone_type::Type> {
        unsafe { crate::bpf_probe_read(&self.kswapd_highest_zoneidx) }.ok()
    }
    pub fn kswapd_failures(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.kswapd_failures) }.ok()
    }
    pub fn kcompactd_max_order(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.kcompactd_max_order) }.ok()
    }
    pub fn kcompactd_highest_zoneidx(&self) -> Option<zone_type::Type> {
        unsafe { crate::bpf_probe_read(&self.kcompactd_highest_zoneidx) }.ok()
    }
    pub fn kcompactd_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.kcompactd_wait) }.ok()
    }
    pub fn kcompactd(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.kcompactd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn totalreserve_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.totalreserve_pages) }.ok()
    }
    pub fn min_unmapped_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_unmapped_pages) }.ok()
    }
    pub fn min_slab_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_slab_pages) }.ok()
    }
    pub fn _pad1_(&self) -> Option<zone_padding> {
        unsafe { crate::bpf_probe_read(&self._pad1_) }.ok()
    }
    pub fn deferred_split_queue(&self) -> Option<deferred_split> {
        unsafe { crate::bpf_probe_read(&self.deferred_split_queue) }.ok()
    }
    pub fn __lruvec(&self) -> Option<lruvec> {
        unsafe { crate::bpf_probe_read(&self.__lruvec) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn _pad2_(&self) -> Option<zone_padding> {
        unsafe { crate::bpf_probe_read(&self._pad2_) }.ok()
    }
    pub fn per_cpu_nodestats(&self) -> Option<*mut per_cpu_nodestat> {
        let v = unsafe { crate::bpf_probe_read(&self.per_cpu_nodestats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vm_stat(&self) -> Option<[atomic_long_t; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_stat) }.ok()
    }
}
impl per_cpu_pages {
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn high(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.high) }.ok()
    }
    pub fn batch(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.batch) }.ok()
    }
    pub fn lists(&self) -> Option<[list_head; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lists) }.ok()
    }
}
impl per_cpu_pageset {
    pub fn pcp(&self) -> Option<per_cpu_pages> {
        unsafe { crate::bpf_probe_read(&self.pcp) }.ok()
    }
    pub fn expire(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.expire) }.ok()
    }
    pub fn vm_numa_stat_diff(&self) -> Option<[u16_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_numa_stat_diff) }.ok()
    }
    pub fn stat_threshold(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.stat_threshold) }.ok()
    }
    pub fn vm_stat_diff(&self) -> Option<[s8; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_stat_diff) }.ok()
    }
}
impl per_cpu_nodestat {
    pub fn stat_threshold(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.stat_threshold) }.ok()
    }
    pub fn vm_node_stat_diff(&self) -> Option<[s8; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.vm_node_stat_diff) }.ok()
    }
}
impl irq_domain {
    pub fn link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const irq_domain_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn host_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.host_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn mapcount(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mapcount) }.ok()
    }
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bus_token(&self) -> Option<irq_domain_bus_token::Type> {
        unsafe { crate::bpf_probe_read(&self.bus_token) }.ok()
    }
    pub fn gc(&self) -> Option<*mut irq_domain_chip_generic> {
        let v = unsafe { crate::bpf_probe_read(&self.gc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent(&self) -> Option<*mut irq_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hwirq_max(&self) -> Option<irq_hw_number_t> {
        unsafe { crate::bpf_probe_read(&self.hwirq_max) }.ok()
    }
    pub fn revmap_direct_max_irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.revmap_direct_max_irq) }.ok()
    }
    pub fn revmap_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.revmap_size) }.ok()
    }
    pub fn revmap_tree(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.revmap_tree) }.ok()
    }
    pub fn revmap_tree_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.revmap_tree_mutex) }.ok()
    }
    pub fn linear_revmap(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_uint>> {
        unsafe { crate::bpf_probe_read(&self.linear_revmap) }.ok()
    }
}
impl ctl_table {
    pub fn procname(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.procname) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn maxlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.maxlen) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn child(&self) -> Option<*mut ctl_table> {
        let v = unsafe { crate::bpf_probe_read(&self.child) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_handler(&self) -> Option<proc_handler> {
        unsafe { crate::bpf_probe_read(&self.proc_handler) }.ok()
    }
    pub fn poll(&self) -> Option<*mut ctl_table_poll> {
        let v = unsafe { crate::bpf_probe_read(&self.poll) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extra1(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.extra1) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extra2(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.extra2) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ctl_table_poll {
    pub fn event(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl ctl_node {
    pub fn node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn header(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.header) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ctl_table_root {
    pub fn default_set(&self) -> Option<ctl_table_set> {
        unsafe { crate::bpf_probe_read(&self.default_set) }.ok()
    }
    pub fn lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ctl_table_root) -> *mut ctl_table_set,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lookup) }.ok()
    }
    pub fn set_ownership(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ctl_table_header,
                arg2: *mut ctl_table,
                arg3: *mut kuid_t,
                arg4: *mut kgid_t,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_ownership) }.ok()
    }
    pub fn permissions(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ctl_table_header,
                arg2: *mut ctl_table,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.permissions) }.ok()
    }
}
impl elf64_sym {
    pub fn st_name(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.st_name) }.ok()
    }
    pub fn st_info(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.st_info) }.ok()
    }
    pub fn st_other(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.st_other) }.ok()
    }
    pub fn st_shndx(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.st_shndx) }.ok()
    }
    pub fn st_value(&self) -> Option<Elf64_Addr> {
        unsafe { crate::bpf_probe_read(&self.st_value) }.ok()
    }
    pub fn st_size(&self) -> Option<Elf64_Xword> {
        unsafe { crate::bpf_probe_read(&self.st_size) }.ok()
    }
}
impl elf64_hdr {
    pub fn e_ident(&self) -> Option<[::aya_bpf_cty::c_uchar; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.e_ident) }.ok()
    }
    pub fn e_type(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_type) }.ok()
    }
    pub fn e_machine(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_machine) }.ok()
    }
    pub fn e_version(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.e_version) }.ok()
    }
    pub fn e_entry(&self) -> Option<Elf64_Addr> {
        unsafe { crate::bpf_probe_read(&self.e_entry) }.ok()
    }
    pub fn e_phoff(&self) -> Option<Elf64_Off> {
        unsafe { crate::bpf_probe_read(&self.e_phoff) }.ok()
    }
    pub fn e_shoff(&self) -> Option<Elf64_Off> {
        unsafe { crate::bpf_probe_read(&self.e_shoff) }.ok()
    }
    pub fn e_flags(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.e_flags) }.ok()
    }
    pub fn e_ehsize(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_ehsize) }.ok()
    }
    pub fn e_phentsize(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_phentsize) }.ok()
    }
    pub fn e_phnum(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_phnum) }.ok()
    }
    pub fn e_shentsize(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_shentsize) }.ok()
    }
    pub fn e_shnum(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_shnum) }.ok()
    }
    pub fn e_shstrndx(&self) -> Option<Elf64_Half> {
        unsafe { crate::bpf_probe_read(&self.e_shstrndx) }.ok()
    }
}
impl elf64_shdr {
    pub fn sh_name(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.sh_name) }.ok()
    }
    pub fn sh_type(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.sh_type) }.ok()
    }
    pub fn sh_flags(&self) -> Option<Elf64_Xword> {
        unsafe { crate::bpf_probe_read(&self.sh_flags) }.ok()
    }
    pub fn sh_addr(&self) -> Option<Elf64_Addr> {
        unsafe { crate::bpf_probe_read(&self.sh_addr) }.ok()
    }
    pub fn sh_offset(&self) -> Option<Elf64_Off> {
        unsafe { crate::bpf_probe_read(&self.sh_offset) }.ok()
    }
    pub fn sh_size(&self) -> Option<Elf64_Xword> {
        unsafe { crate::bpf_probe_read(&self.sh_size) }.ok()
    }
    pub fn sh_link(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.sh_link) }.ok()
    }
    pub fn sh_info(&self) -> Option<Elf64_Word> {
        unsafe { crate::bpf_probe_read(&self.sh_info) }.ok()
    }
    pub fn sh_addralign(&self) -> Option<Elf64_Xword> {
        unsafe { crate::bpf_probe_read(&self.sh_addralign) }.ok()
    }
    pub fn sh_entsize(&self) -> Option<Elf64_Xword> {
        unsafe { crate::bpf_probe_read(&self.sh_entsize) }.ok()
    }
}
impl idr {
    pub fn idr_rt(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.idr_rt) }.ok()
    }
    pub fn idr_base(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.idr_base) }.ok()
    }
    pub fn idr_next(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.idr_next) }.ok()
    }
}
impl kernfs_elem_dir {
    pub fn subdirs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.subdirs) }.ok()
    }
    pub fn children(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.children) }.ok()
    }
    pub fn root(&self) -> Option<*mut kernfs_root> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernfs_root {
    pub fn kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn ino_idr(&self) -> Option<idr> {
        unsafe { crate::bpf_probe_read(&self.ino_idr) }.ok()
    }
    pub fn last_id_lowbits(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_id_lowbits) }.ok()
    }
    pub fn id_highbits(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id_highbits) }.ok()
    }
    pub fn syscall_ops(&self) -> Option<*mut kernfs_syscall_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.syscall_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn supers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.supers) }.ok()
    }
    pub fn deactivate_waitq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.deactivate_waitq) }.ok()
    }
}
impl kernfs_elem_symlink {
    pub fn target_kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.target_kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernfs_elem_attr {
    pub fn ops(&self) -> Option<*const kernfs_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn open(&self) -> Option<*mut kernfs_open_node> {
        let v = unsafe { crate::bpf_probe_read(&self.open) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn notify_next(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.notify_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernfs_node {
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn active(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.active) }.ok()
    }
    pub fn parent(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rb(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb) }.ok()
    }
    pub fn ns(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn dir(&self) -> Option<kernfs_elem_dir> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dir) }.ok()
    }
    pub fn symlink(&self) -> Option<kernfs_elem_symlink> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.symlink) }.ok()
    }
    pub fn attr(&self) -> Option<kernfs_elem_attr> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.attr) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn iattr(&self) -> Option<*mut kernfs_iattrs> {
        let v = unsafe { crate::bpf_probe_read(&self.iattr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernfs_node__bindgen_ty_1 {
    pub fn dir(&self) -> Option<kernfs_elem_dir> {
        unsafe { crate::bpf_probe_read(&self.dir) }.ok()
    }
    pub fn symlink(&self) -> Option<kernfs_elem_symlink> {
        unsafe { crate::bpf_probe_read(&self.symlink) }.ok()
    }
    pub fn attr(&self) -> Option<kernfs_elem_attr> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
}
impl kernfs_ops {
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn seq_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_show) }.ok()
    }
    pub fn seq_start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_start) }.ok()
    }
    pub fn seq_next(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_next) }.ok()
    }
    pub fn seq_stop(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_stop) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn atomic_write_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.atomic_write_len) }.ok()
    }
    pub fn prealloc(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.prealloc) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut poll_table_struct,
            ) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
}
impl kernfs_syscall_ops {
    pub fn show_options(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut kernfs_root,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_options) }.ok()
    }
    pub fn mkdir(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_node,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: umode_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mkdir) }.ok()
    }
    pub fn rmdir(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kernfs_node) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rmdir) }.ok()
    }
    pub fn rename(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_node,
                arg2: *mut kernfs_node,
                arg3: *const ::aya_bpf_cty::c_char,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rename) }.ok()
    }
    pub fn show_path(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut kernfs_node,
                arg3: *mut kernfs_root,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show_path) }.ok()
    }
}
impl seq_file {
    pub fn buf(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn from(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.from) }.ok()
    }
    pub fn count(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn pad_until(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.pad_until) }.ok()
    }
    pub fn index(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn read_pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.read_pos) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn op(&self) -> Option<*const seq_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.op) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn poll_event(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.poll_event) }.ok()
    }
    pub fn file(&self) -> Option<*const file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernfs_open_file {
    pub fn kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq_file(&self) -> Option<*mut seq_file> {
        let v = unsafe { crate::bpf_probe_read(&self.seq_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn prealloc_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.prealloc_mutex) }.ok()
    }
    pub fn event(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn prealloc_buf(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.prealloc_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn atomic_write_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.atomic_write_len) }.ok()
    }
    pub fn vm_ops(&self) -> Option<*const vm_operations_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vm_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl poll_table_struct {
    pub fn _qproc(&self) -> Option<poll_queue_proc> {
        unsafe { crate::bpf_probe_read(&self._qproc) }.ok()
    }
    pub fn _key(&self) -> Option<__poll_t> {
        unsafe { crate::bpf_probe_read(&self._key) }.ok()
    }
}
impl kobj_ns_type_operations {
    pub fn type_(&self) -> Option<kobj_ns_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn current_may_mount(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.current_may_mount) }.ok()
    }
    pub fn grab_current_ns(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.grab_current_ns) }.ok()
    }
    pub fn netlink_ns(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock) -> *const ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.netlink_ns) }.ok()
    }
    pub fn initial_ns(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> *const ::aya_bpf_cty::c_void>>
    {
        unsafe { crate::bpf_probe_read(&self.initial_ns) }.ok()
    }
    pub fn drop_ns(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.drop_ns) }.ok()
    }
}
impl attribute {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
}
impl attribute_group {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn is_visible(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: ::aya_bpf_cty::c_int,
            ) -> umode_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_visible) }.ok()
    }
    pub fn is_bin_visible(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut bin_attribute,
                arg3: ::aya_bpf_cty::c_int,
            ) -> umode_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_bin_visible) }.ok()
    }
    pub fn attrs(&self) -> Option<*mut *mut attribute> {
        let v = unsafe { crate::bpf_probe_read(&self.attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bin_attrs(&self) -> Option<*mut *mut bin_attribute> {
        let v = unsafe { crate::bpf_probe_read(&self.bin_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kref {
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
}
impl kobject {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn parent(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kset(&self) -> Option<*mut kset> {
        let v = unsafe { crate::bpf_probe_read(&self.kset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ktype(&self) -> Option<*mut kobj_type> {
        let v = unsafe { crate::bpf_probe_read(&self.ktype) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sd(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.sd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl bin_attribute {
    pub fn attr(&self) -> Option<attribute> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                arg3: *mut bin_attribute,
                arg4: *mut ::aya_bpf_cty::c_char,
                arg5: loff_t,
                arg6: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                arg3: *mut bin_attribute,
                arg4: *mut ::aya_bpf_cty::c_char,
                arg5: loff_t,
                arg6: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                arg3: *mut bin_attribute,
                arg4: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
}
impl sysfs_ops {
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: *mut ::aya_bpf_cty::c_char,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
    pub fn store(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.store) }.ok()
    }
}
impl kset {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.list_lock) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn uevent_ops(&self) -> Option<*const kset_uevent_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.uevent_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kobj_type {
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut kobject)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn sysfs_ops(&self) -> Option<*const sysfs_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.sysfs_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn default_attrs(&self) -> Option<*mut *mut attribute> {
        let v = unsafe { crate::bpf_probe_read(&self.default_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn default_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.default_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn child_ns_type(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kobject) -> *const kobj_ns_type_operations,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.child_ns_type) }.ok()
    }
    pub fn namespace(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kobject) -> *const ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.namespace) }.ok()
    }
    pub fn get_ownership(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kobject, arg2: *mut kuid_t, arg3: *mut kgid_t),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ownership) }.ok()
    }
}
impl kobj_uevent_env {
    pub fn argv(&self) -> Option<[*mut ::aya_bpf_cty::c_char; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.argv) }.ok()
    }
    pub fn envp(&self) -> Option<[*mut ::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.envp) }.ok()
    }
    pub fn envp_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.envp_idx) }.ok()
    }
    pub fn buf(&self) -> Option<[::aya_bpf_cty::c_char; 2048usize]> {
        unsafe { crate::bpf_probe_read(&self.buf) }.ok()
    }
    pub fn buflen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.buflen) }.ok()
    }
}
impl kset_uevent_ops {
    pub fn filter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kset, arg2: *mut kobject) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.filter) }.ok()
    }
    pub fn name(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kset,
                arg2: *mut kobject,
            ) -> *const ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn uevent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kset,
                arg2: *mut kobject,
                arg3: *mut kobj_uevent_env,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.uevent) }.ok()
    }
}
impl kernel_param_ops {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf_cty::c_char,
                arg2: *const kernel_param,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_char,
                arg2: *const kernel_param,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
}
impl kernel_param {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const kernel_param_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn perm(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.perm) }.ok()
    }
    pub fn level(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn arg(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn str_(&self) -> Option<*const kparam_string> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.str_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arr(&self) -> Option<*const kparam_array> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernel_param__bindgen_ty_1 {
    pub fn arg(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.arg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn str_(&self) -> Option<*const kparam_string> {
        let v = unsafe { crate::bpf_probe_read(&self.str_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arr(&self) -> Option<*const kparam_array> {
        let v = unsafe { crate::bpf_probe_read(&self.arr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kparam_string {
    pub fn maxlen(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.maxlen) }.ok()
    }
    pub fn string(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.string) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kparam_array {
    pub fn max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn elemsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.elemsize) }.ok()
    }
    pub fn num(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.num) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const kernel_param_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elem(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.elem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl module_kobject {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn drivers_dir(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.drivers_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mp(&self) -> Option<*mut module_param_attrs> {
        let v = unsafe { crate::bpf_probe_read(&self.mp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj_completion(&self) -> Option<*mut completion> {
        let v = unsafe { crate::bpf_probe_read(&self.kobj_completion) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl latch_tree_node {
    pub fn node(&self) -> Option<[rb_node; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
}
impl mod_tree_node {
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<latch_tree_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
}
impl module_layout {
    pub fn base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn text_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.text_size) }.ok()
    }
    pub fn ro_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ro_size) }.ok()
    }
    pub fn ro_after_init_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ro_after_init_size) }.ok()
    }
    pub fn mtn(&self) -> Option<mod_tree_node> {
        unsafe { crate::bpf_probe_read(&self.mtn) }.ok()
    }
}
impl mod_arch_specific {}
impl mod_kallsyms {
    pub fn symtab(&self) -> Option<*mut Elf64_Sym> {
        let v = unsafe { crate::bpf_probe_read(&self.symtab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_symtab(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_symtab) }.ok()
    }
    pub fn strtab(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.strtab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn typetab(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.typetab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl module {
    pub fn state(&self) -> Option<module_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 56usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn mkobj(&self) -> Option<module_kobject> {
        unsafe { crate::bpf_probe_read(&self.mkobj) }.ok()
    }
    pub fn modinfo_attrs(&self) -> Option<*mut module_attribute> {
        let v = unsafe { crate::bpf_probe_read(&self.modinfo_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn version(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.version) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn srcversion(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.srcversion) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn holders_dir(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.holders_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn syms(&self) -> Option<*const kernel_symbol> {
        let v = unsafe { crate::bpf_probe_read(&self.syms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn crcs(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.crcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_syms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_syms) }.ok()
    }
    pub fn param_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.param_lock) }.ok()
    }
    pub fn kp(&self) -> Option<*mut kernel_param> {
        let v = unsafe { crate::bpf_probe_read(&self.kp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_kp(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_kp) }.ok()
    }
    pub fn num_gpl_syms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_gpl_syms) }.ok()
    }
    pub fn gpl_syms(&self) -> Option<*const kernel_symbol> {
        let v = unsafe { crate::bpf_probe_read(&self.gpl_syms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gpl_crcs(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.gpl_crcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn using_gplonly_symbols(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.using_gplonly_symbols) }.ok()
    }
    pub fn unused_syms(&self) -> Option<*const kernel_symbol> {
        let v = unsafe { crate::bpf_probe_read(&self.unused_syms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn unused_crcs(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.unused_crcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_unused_syms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_unused_syms) }.ok()
    }
    pub fn num_unused_gpl_syms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_unused_gpl_syms) }.ok()
    }
    pub fn unused_gpl_syms(&self) -> Option<*const kernel_symbol> {
        let v = unsafe { crate::bpf_probe_read(&self.unused_gpl_syms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn unused_gpl_crcs(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.unused_gpl_crcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sig_ok(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.sig_ok) }.ok()
    }
    pub fn async_probe_requested(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.async_probe_requested) }.ok()
    }
    pub fn gpl_future_syms(&self) -> Option<*const kernel_symbol> {
        let v = unsafe { crate::bpf_probe_read(&self.gpl_future_syms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gpl_future_crcs(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.gpl_future_crcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_gpl_future_syms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_gpl_future_syms) }.ok()
    }
    pub fn num_exentries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_exentries) }.ok()
    }
    pub fn extable(&self) -> Option<*mut exception_table_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.extable) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_int>> {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn core_layout(&self) -> Option<module_layout> {
        unsafe { crate::bpf_probe_read(&self.core_layout) }.ok()
    }
    pub fn init_layout(&self) -> Option<module_layout> {
        unsafe { crate::bpf_probe_read(&self.init_layout) }.ok()
    }
    pub fn arch(&self) -> Option<mod_arch_specific> {
        unsafe { crate::bpf_probe_read(&self.arch) }.ok()
    }
    pub fn taints(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.taints) }.ok()
    }
    pub fn num_bugs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_bugs) }.ok()
    }
    pub fn bug_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.bug_list) }.ok()
    }
    pub fn bug_table(&self) -> Option<*mut bug_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.bug_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kallsyms(&self) -> Option<*mut mod_kallsyms> {
        let v = unsafe { crate::bpf_probe_read(&self.kallsyms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn core_kallsyms(&self) -> Option<mod_kallsyms> {
        unsafe { crate::bpf_probe_read(&self.core_kallsyms) }.ok()
    }
    pub fn sect_attrs(&self) -> Option<*mut module_sect_attrs> {
        let v = unsafe { crate::bpf_probe_read(&self.sect_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notes_attrs(&self) -> Option<*mut module_notes_attrs> {
        let v = unsafe { crate::bpf_probe_read(&self.notes_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn args(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.args) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.percpu_size) }.ok()
    }
    pub fn noinstr_text_start(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.noinstr_text_start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn noinstr_text_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.noinstr_text_size) }.ok()
    }
    pub fn num_tracepoints(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_tracepoints) }.ok()
    }
    pub fn tracepoints_ptrs(&self) -> Option<*mut tracepoint_ptr_t> {
        let v = unsafe { crate::bpf_probe_read(&self.tracepoints_ptrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_srcu_structs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_srcu_structs) }.ok()
    }
    pub fn srcu_struct_ptrs(&self) -> Option<*mut *mut srcu_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.srcu_struct_ptrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_bpf_raw_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_bpf_raw_events) }.ok()
    }
    pub fn bpf_raw_events(&self) -> Option<*mut bpf_raw_event_map> {
        let v = unsafe { crate::bpf_probe_read(&self.bpf_raw_events) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_data_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.btf_data_size) }.ok()
    }
    pub fn btf_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.btf_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn jump_entries(&self) -> Option<*mut jump_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.jump_entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_jump_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_jump_entries) }.ok()
    }
    pub fn num_trace_bprintk_fmt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_trace_bprintk_fmt) }.ok()
    }
    pub fn trace_bprintk_fmt_start(&self) -> Option<*mut *const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.trace_bprintk_fmt_start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trace_events(&self) -> Option<*mut *mut trace_event_call> {
        let v = unsafe { crate::bpf_probe_read(&self.trace_events) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_trace_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_trace_events) }.ok()
    }
    pub fn trace_evals(&self) -> Option<*mut *mut trace_eval_map> {
        let v = unsafe { crate::bpf_probe_read(&self.trace_evals) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_trace_evals(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_trace_evals) }.ok()
    }
    pub fn num_ftrace_callsites(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_ftrace_callsites) }.ok()
    }
    pub fn ftrace_callsites(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.ftrace_callsites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kprobes_text_start(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.kprobes_text_start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kprobes_text_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.kprobes_text_size) }.ok()
    }
    pub fn kprobe_blacklist(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.kprobe_blacklist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_kprobe_blacklist(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_kprobe_blacklist) }.ok()
    }
    pub fn num_static_call_sites(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.num_static_call_sites) }.ok()
    }
    pub fn static_call_sites(&self) -> Option<*mut static_call_site> {
        let v = unsafe { crate::bpf_probe_read(&self.static_call_sites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn klp(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.klp) }.ok()
    }
    pub fn klp_alive(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.klp_alive) }.ok()
    }
    pub fn klp_info(&self) -> Option<*mut klp_modinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.klp_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn source_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.source_list) }.ok()
    }
    pub fn target_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.target_list) }.ok()
    }
    pub fn exit(&self) -> Option<::core::option::Option<unsafe extern "C" fn()>> {
        unsafe { crate::bpf_probe_read(&self.exit) }.ok()
    }
    pub fn refcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn ei_funcs(&self) -> Option<*mut error_injection_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.ei_funcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_ei_funcs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_ei_funcs) }.ok()
    }
}
impl error_injection_entry {
    pub fn addr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn etype(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.etype) }.ok()
    }
}
impl static_call_site {
    pub fn addr(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn key(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl module_attribute {
    pub fn attr(&self) -> Option<attribute> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut module_attribute,
                arg2: *mut module_kobject,
                arg3: *mut ::aya_bpf_cty::c_char,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
    pub fn store(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut module_attribute,
                arg2: *mut module_kobject,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.store) }.ok()
    }
    pub fn setup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut module, arg2: *const ::aya_bpf_cty::c_char),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
    pub fn test(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.test) }.ok()
    }
    pub fn free(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
}
impl klp_modinfo {
    pub fn hdr(&self) -> Option<Elf64_Ehdr> {
        unsafe { crate::bpf_probe_read(&self.hdr) }.ok()
    }
    pub fn sechdrs(&self) -> Option<*mut Elf64_Shdr> {
        let v = unsafe { crate::bpf_probe_read(&self.sechdrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn secstrings(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.secstrings) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn symndx(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.symndx) }.ok()
    }
}
impl exception_table_entry {
    pub fn insn(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.insn) }.ok()
    }
    pub fn fixup(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fixup) }.ok()
    }
    pub fn handler(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
}
impl trace_event {
    pub fn node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn funcs(&self) -> Option<*mut trace_event_functions> {
        let v = unsafe { crate::bpf_probe_read(&self.funcs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl trace_event_call {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn class(&self) -> Option<*mut trace_event_class> {
        let v = unsafe { crate::bpf_probe_read(&self.class) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tp(&self) -> Option<*mut tracepoint> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn event(&self) -> Option<trace_event> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn print_fmt(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.print_fmt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter(&self) -> Option<*mut event_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mod_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn perf_refcount(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.perf_refcount) }.ok()
    }
    pub fn perf_events(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.perf_events) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prog_array(&self) -> Option<*mut bpf_prog_array> {
        let v = unsafe { crate::bpf_probe_read(&self.prog_array) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn perf_perm(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_event_call,
                arg2: *mut perf_event,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.perf_perm) }.ok()
    }
}
impl trace_event_call__bindgen_ty_1 {
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tp(&self) -> Option<*mut tracepoint> {
        let v = unsafe { crate::bpf_probe_read(&self.tp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl trace_eval_map {
    pub fn system(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.system) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn eval_string(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.eval_string) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn eval_value(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.eval_value) }.ok()
    }
}
impl cgroup_subsys_state {
    pub fn cgroup(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.cgroup) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ss(&self) -> Option<*mut cgroup_subsys> {
        let v = unsafe { crate::bpf_probe_read(&self.ss) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn sibling(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sibling) }.ok()
    }
    pub fn children(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.children) }.ok()
    }
    pub fn rstat_css_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rstat_css_node) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn serial_nr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.serial_nr) }.ok()
    }
    pub fn online_cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.online_cnt) }.ok()
    }
    pub fn destroy_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.destroy_work) }.ok()
    }
    pub fn destroy_rwork(&self) -> Option<rcu_work> {
        unsafe { crate::bpf_probe_read(&self.destroy_rwork) }.ok()
    }
    pub fn parent(&self) -> Option<*mut cgroup_subsys_state> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl mem_cgroup_id {
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn ref_(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
}
impl page_counter {
    pub fn usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn min(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn low(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.low) }.ok()
    }
    pub fn high(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.high) }.ok()
    }
    pub fn max(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn parent(&self) -> Option<*mut page_counter> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn emin(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.emin) }.ok()
    }
    pub fn min_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.min_usage) }.ok()
    }
    pub fn children_min_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.children_min_usage) }.ok()
    }
    pub fn elow(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.elow) }.ok()
    }
    pub fn low_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.low_usage) }.ok()
    }
    pub fn children_low_usage(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.children_low_usage) }.ok()
    }
    pub fn watermark(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.watermark) }.ok()
    }
    pub fn failcnt(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.failcnt) }.ok()
    }
}
impl vmpressure {
    pub fn scanned(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.scanned) }.ok()
    }
    pub fn reclaimed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reclaimed) }.ok()
    }
    pub fn tree_scanned(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tree_scanned) }.ok()
    }
    pub fn tree_reclaimed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tree_reclaimed) }.ok()
    }
    pub fn sr_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.sr_lock) }.ok()
    }
    pub fn events(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn events_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.events_lock) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
}
impl cgroup_file {
    pub fn kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notified_at(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.notified_at) }.ok()
    }
    pub fn notify_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.notify_timer) }.ok()
    }
}
impl mem_cgroup_thresholds {
    pub fn primary(&self) -> Option<*mut mem_cgroup_threshold_ary> {
        let v = unsafe { crate::bpf_probe_read(&self.primary) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn spare(&self) -> Option<*mut mem_cgroup_threshold_ary> {
        let v = unsafe { crate::bpf_probe_read(&self.spare) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl memcg_padding {
    pub fn x(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.x) }.ok()
    }
}
impl percpu_counter {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn count(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn counters(&self) -> Option<*mut s32> {
        let v = unsafe { crate::bpf_probe_read(&self.counters) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fprop_global {
    pub fn events(&self) -> Option<percpu_counter> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn period(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.period) }.ok()
    }
    pub fn sequence(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.sequence) }.ok()
    }
}
impl wb_domain {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn completions(&self) -> Option<fprop_global> {
        unsafe { crate::bpf_probe_read(&self.completions) }.ok()
    }
    pub fn period_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.period_timer) }.ok()
    }
    pub fn period_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.period_time) }.ok()
    }
    pub fn dirty_limit_tstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirty_limit_tstamp) }.ok()
    }
    pub fn dirty_limit(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirty_limit) }.ok()
    }
}
impl wb_completion {
    pub fn cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.cnt) }.ok()
    }
    pub fn waitq(&self) -> Option<*mut wait_queue_head_t> {
        let v = unsafe { crate::bpf_probe_read(&self.waitq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl memcg_cgwb_frn {
    pub fn bdi_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bdi_id) }.ok()
    }
    pub fn memcg_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.memcg_id) }.ok()
    }
    pub fn at(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.at) }.ok()
    }
    pub fn done(&self) -> Option<wb_completion> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
}
impl mem_cgroup {
    pub fn css(&self) -> Option<cgroup_subsys_state> {
        unsafe { crate::bpf_probe_read(&self.css) }.ok()
    }
    pub fn id(&self) -> Option<mem_cgroup_id> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn memory(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.memory) }.ok()
    }
    pub fn swap(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.swap) }.ok()
    }
    pub fn memsw(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.memsw) }.ok()
    }
    pub fn kmem(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.kmem) }.ok()
    }
    pub fn tcpmem(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.tcpmem) }.ok()
    }
    pub fn high_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.high_work) }.ok()
    }
    pub fn soft_limit(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.soft_limit) }.ok()
    }
    pub fn vmpressure(&self) -> Option<vmpressure> {
        unsafe { crate::bpf_probe_read(&self.vmpressure) }.ok()
    }
    pub fn oom_group(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.oom_group) }.ok()
    }
    pub fn oom_lock(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.oom_lock) }.ok()
    }
    pub fn under_oom(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.under_oom) }.ok()
    }
    pub fn swappiness(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.swappiness) }.ok()
    }
    pub fn oom_kill_disable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.oom_kill_disable) }.ok()
    }
    pub fn events_file(&self) -> Option<cgroup_file> {
        unsafe { crate::bpf_probe_read(&self.events_file) }.ok()
    }
    pub fn events_local_file(&self) -> Option<cgroup_file> {
        unsafe { crate::bpf_probe_read(&self.events_local_file) }.ok()
    }
    pub fn swap_events_file(&self) -> Option<cgroup_file> {
        unsafe { crate::bpf_probe_read(&self.swap_events_file) }.ok()
    }
    pub fn thresholds_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.thresholds_lock) }.ok()
    }
    pub fn thresholds(&self) -> Option<mem_cgroup_thresholds> {
        unsafe { crate::bpf_probe_read(&self.thresholds) }.ok()
    }
    pub fn memsw_thresholds(&self) -> Option<mem_cgroup_thresholds> {
        unsafe { crate::bpf_probe_read(&self.memsw_thresholds) }.ok()
    }
    pub fn oom_notify(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.oom_notify) }.ok()
    }
    pub fn move_charge_at_immigrate(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.move_charge_at_immigrate) }.ok()
    }
    pub fn move_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.move_lock) }.ok()
    }
    pub fn move_lock_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.move_lock_flags) }.ok()
    }
    pub fn _pad1_(&self) -> Option<memcg_padding> {
        unsafe { crate::bpf_probe_read(&self._pad1_) }.ok()
    }
    pub fn vmstats(&self) -> Option<[atomic_long_t; 41usize]> {
        unsafe { crate::bpf_probe_read(&self.vmstats) }.ok()
    }
    pub fn vmevents(&self) -> Option<[atomic_long_t; 96usize]> {
        unsafe { crate::bpf_probe_read(&self.vmevents) }.ok()
    }
    pub fn memory_events(&self) -> Option<[atomic_long_t; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.memory_events) }.ok()
    }
    pub fn memory_events_local(&self) -> Option<[atomic_long_t; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.memory_events_local) }.ok()
    }
    pub fn socket_pressure(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.socket_pressure) }.ok()
    }
    pub fn tcpmem_active(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tcpmem_active) }.ok()
    }
    pub fn tcpmem_pressure(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tcpmem_pressure) }.ok()
    }
    pub fn kmemcg_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.kmemcg_id) }.ok()
    }
    pub fn kmem_state(&self) -> Option<memcg_kmem_state::Type> {
        unsafe { crate::bpf_probe_read(&self.kmem_state) }.ok()
    }
    pub fn objcg(&self) -> Option<*mut obj_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.objcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn objcg_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.objcg_list) }.ok()
    }
    pub fn _pad2_(&self) -> Option<memcg_padding> {
        unsafe { crate::bpf_probe_read(&self._pad2_) }.ok()
    }
    pub fn moving_account(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.moving_account) }.ok()
    }
    pub fn move_lock_task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.move_lock_task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vmstats_local(&self) -> Option<*mut memcg_vmstats_percpu> {
        let v = unsafe { crate::bpf_probe_read(&self.vmstats_local) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vmstats_percpu(&self) -> Option<*mut memcg_vmstats_percpu> {
        let v = unsafe { crate::bpf_probe_read(&self.vmstats_percpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cgwb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cgwb_list) }.ok()
    }
    pub fn cgwb_domain(&self) -> Option<wb_domain> {
        unsafe { crate::bpf_probe_read(&self.cgwb_domain) }.ok()
    }
    pub fn cgwb_frn(&self) -> Option<[memcg_cgwb_frn; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.cgwb_frn) }.ok()
    }
    pub fn event_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.event_list) }.ok()
    }
    pub fn event_list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.event_list_lock) }.ok()
    }
    pub fn deferred_split_queue(&self) -> Option<deferred_split> {
        unsafe { crate::bpf_probe_read(&self.deferred_split_queue) }.ok()
    }
    pub fn nodeinfo(&self) -> Option<__IncompleteArrayField<*mut mem_cgroup_per_node>> {
        unsafe { crate::bpf_probe_read(&self.nodeinfo) }.ok()
    }
}
impl mem_cgroup__bindgen_ty_1 {
    pub fn swap(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.swap) }.ok()
    }
    pub fn memsw(&self) -> Option<page_counter> {
        unsafe { crate::bpf_probe_read(&self.memsw) }.ok()
    }
}
impl pid_namespace {
    pub fn idr(&self) -> Option<idr> {
        unsafe { crate::bpf_probe_read(&self.idr) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn pid_allocated(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.pid_allocated) }.ok()
    }
    pub fn child_reaper(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.child_reaper) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pid_cachep(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.pid_cachep) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn level(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn parent(&self) -> Option<*mut pid_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bacct(&self) -> Option<*mut fs_pin> {
        let v = unsafe { crate::bpf_probe_read(&self.bacct) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reboot(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.reboot) }.ok()
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
}
impl task_cputime {
    pub fn stime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stime) }.ok()
    }
    pub fn utime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.utime) }.ok()
    }
    pub fn sum_exec_runtime(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.sum_exec_runtime) }.ok()
    }
}
impl nsproxy {
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn uts_ns(&self) -> Option<*mut uts_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.uts_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipc_ns(&self) -> Option<*mut ipc_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.ipc_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_ns(&self) -> Option<*mut mnt_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pid_ns_for_children(&self) -> Option<*mut pid_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.pid_ns_for_children) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net_ns(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn time_ns(&self) -> Option<*mut time_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.time_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn time_ns_for_children(&self) -> Option<*mut time_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.time_ns_for_children) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cgroup_ns(&self) -> Option<*mut cgroup_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.cgroup_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bio_list {
    pub fn head(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_plug {
    pub fn mq_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mq_list) }.ok()
    }
    pub fn cb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cb_list) }.ok()
    }
    pub fn rq_count(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.rq_count) }.ok()
    }
    pub fn multiple_queues(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.multiple_queues) }.ok()
    }
    pub fn nowait(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.nowait) }.ok()
    }
}
impl reclaim_state {
    pub fn reclaimed_slab(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reclaimed_slab) }.ok()
    }
}
impl fprop_local_percpu {
    pub fn events(&self) -> Option<percpu_counter> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn period(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.period) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl bdi_writeback {
    pub fn bdi(&self) -> Option<*mut backing_dev_info> {
        let v = unsafe { crate::bpf_probe_read(&self.bdi) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn last_old_flush(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_old_flush) }.ok()
    }
    pub fn b_dirty(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.b_dirty) }.ok()
    }
    pub fn b_io(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.b_io) }.ok()
    }
    pub fn b_more_io(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.b_more_io) }.ok()
    }
    pub fn b_dirty_time(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.b_dirty_time) }.ok()
    }
    pub fn list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.list_lock) }.ok()
    }
    pub fn stat(&self) -> Option<[percpu_counter; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.stat) }.ok()
    }
    pub fn congested(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.congested) }.ok()
    }
    pub fn bw_time_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.bw_time_stamp) }.ok()
    }
    pub fn dirtied_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirtied_stamp) }.ok()
    }
    pub fn written_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.written_stamp) }.ok()
    }
    pub fn write_bandwidth(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.write_bandwidth) }.ok()
    }
    pub fn avg_write_bandwidth(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.avg_write_bandwidth) }.ok()
    }
    pub fn dirty_ratelimit(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirty_ratelimit) }.ok()
    }
    pub fn balanced_dirty_ratelimit(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.balanced_dirty_ratelimit) }.ok()
    }
    pub fn completions(&self) -> Option<fprop_local_percpu> {
        unsafe { crate::bpf_probe_read(&self.completions) }.ok()
    }
    pub fn dirty_exceeded(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dirty_exceeded) }.ok()
    }
    pub fn start_all_reason(&self) -> Option<wb_reason::Type> {
        unsafe { crate::bpf_probe_read(&self.start_all_reason) }.ok()
    }
    pub fn work_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.work_lock) }.ok()
    }
    pub fn work_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.work_list) }.ok()
    }
    pub fn dwork(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.dwork) }.ok()
    }
    pub fn dirty_sleep(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dirty_sleep) }.ok()
    }
    pub fn bdi_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.bdi_node) }.ok()
    }
    pub fn refcnt(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn memcg_completions(&self) -> Option<fprop_local_percpu> {
        unsafe { crate::bpf_probe_read(&self.memcg_completions) }.ok()
    }
    pub fn memcg_css(&self) -> Option<*mut cgroup_subsys_state> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg_css) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blkcg_css(&self) -> Option<*mut cgroup_subsys_state> {
        let v = unsafe { crate::bpf_probe_read(&self.blkcg_css) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn memcg_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.memcg_node) }.ok()
    }
    pub fn blkcg_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.blkcg_node) }.ok()
    }
    pub fn release_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.release_work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
}
impl bdi_writeback__bindgen_ty_1 {
    pub fn release_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.release_work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl backing_dev_info {
    pub fn id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()
    }
    pub fn bdi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.bdi_list) }.ok()
    }
    pub fn ra_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ra_pages) }.ok()
    }
    pub fn io_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.io_pages) }.ok()
    }
    pub fn refcnt(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn capabilities(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.capabilities) }.ok()
    }
    pub fn min_ratio(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.min_ratio) }.ok()
    }
    pub fn max_ratio(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_ratio) }.ok()
    }
    pub fn max_prop_frac(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_prop_frac) }.ok()
    }
    pub fn tot_write_bandwidth(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.tot_write_bandwidth) }.ok()
    }
    pub fn wb(&self) -> Option<bdi_writeback> {
        unsafe { crate::bpf_probe_read(&self.wb) }.ok()
    }
    pub fn wb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.wb_list) }.ok()
    }
    pub fn cgwb_tree(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.cgwb_tree) }.ok()
    }
    pub fn cgwb_release_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.cgwb_release_mutex) }.ok()
    }
    pub fn wb_switch_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.wb_switch_rwsem) }.ok()
    }
    pub fn wb_waitq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wb_waitq) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.dev_name) }.ok()
    }
    pub fn owner(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn laptop_mode_wb_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.laptop_mode_wb_timer) }.ok()
    }
    pub fn debug_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.debug_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl css_set {
    pub fn subsys(&self) -> Option<[*mut cgroup_subsys_state; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.subsys) }.ok()
    }
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn dom_cset(&self) -> Option<*mut css_set> {
        let v = unsafe { crate::bpf_probe_read(&self.dom_cset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dfl_cgrp(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.dfl_cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_tasks(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_tasks) }.ok()
    }
    pub fn tasks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tasks) }.ok()
    }
    pub fn mg_tasks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mg_tasks) }.ok()
    }
    pub fn dying_tasks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dying_tasks) }.ok()
    }
    pub fn task_iters(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.task_iters) }.ok()
    }
    pub fn e_cset_node(&self) -> Option<[list_head; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.e_cset_node) }.ok()
    }
    pub fn threaded_csets(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.threaded_csets) }.ok()
    }
    pub fn threaded_csets_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.threaded_csets_node) }.ok()
    }
    pub fn hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hlist) }.ok()
    }
    pub fn cgrp_links(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cgrp_links) }.ok()
    }
    pub fn mg_preload_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mg_preload_node) }.ok()
    }
    pub fn mg_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mg_node) }.ok()
    }
    pub fn mg_src_cgrp(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.mg_src_cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mg_dst_cgrp(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.mg_dst_cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mg_dst_cset(&self) -> Option<*mut css_set> {
        let v = unsafe { crate::bpf_probe_read(&self.mg_dst_cset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dead(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
}
impl compat_robust_list {
    pub fn next(&self) -> Option<compat_uptr_t> {
        unsafe { crate::bpf_probe_read(&self.next) }.ok()
    }
}
impl compat_robust_list_head {
    pub fn list(&self) -> Option<compat_robust_list> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn futex_offset(&self) -> Option<compat_long_t> {
        unsafe { crate::bpf_probe_read(&self.futex_offset) }.ok()
    }
    pub fn list_op_pending(&self) -> Option<compat_uptr_t> {
        unsafe { crate::bpf_probe_read(&self.list_op_pending) }.ok()
    }
}
impl perf_event_groups {
    pub fn tree(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.tree) }.ok()
    }
    pub fn index(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
}
impl perf_event_context {
    pub fn pmu(&self) -> Option<*mut pmu> {
        let v = unsafe { crate::bpf_probe_read(&self.pmu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn active_ctx_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.active_ctx_list) }.ok()
    }
    pub fn pinned_groups(&self) -> Option<perf_event_groups> {
        unsafe { crate::bpf_probe_read(&self.pinned_groups) }.ok()
    }
    pub fn flexible_groups(&self) -> Option<perf_event_groups> {
        unsafe { crate::bpf_probe_read(&self.flexible_groups) }.ok()
    }
    pub fn event_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.event_list) }.ok()
    }
    pub fn pinned_active(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pinned_active) }.ok()
    }
    pub fn flexible_active(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flexible_active) }.ok()
    }
    pub fn nr_events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_events) }.ok()
    }
    pub fn nr_active(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_active) }.ok()
    }
    pub fn is_active(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.is_active) }.ok()
    }
    pub fn nr_stat(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_stat) }.ok()
    }
    pub fn nr_freq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_freq) }.ok()
    }
    pub fn rotate_disable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rotate_disable) }.ok()
    }
    pub fn rotate_necessary(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rotate_necessary) }.ok()
    }
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
    pub fn timestamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.timestamp) }.ok()
    }
    pub fn parent_ctx(&self) -> Option<*mut perf_event_context> {
        let v = unsafe { crate::bpf_probe_read(&self.parent_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent_gen(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.parent_gen) }.ok()
    }
    pub fn generation(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.generation) }.ok()
    }
    pub fn pin_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pin_count) }.ok()
    }
    pub fn nr_cgroups(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_cgroups) }.ok()
    }
    pub fn task_ctx_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.task_ctx_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
}
impl task_delay_info {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn blkio_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.blkio_start) }.ok()
    }
    pub fn blkio_delay(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.blkio_delay) }.ok()
    }
    pub fn swapin_delay(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.swapin_delay) }.ok()
    }
    pub fn blkio_count(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.blkio_count) }.ok()
    }
    pub fn swapin_count(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.swapin_count) }.ok()
    }
    pub fn freepages_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.freepages_start) }.ok()
    }
    pub fn freepages_delay(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.freepages_delay) }.ok()
    }
    pub fn thrashing_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.thrashing_start) }.ok()
    }
    pub fn thrashing_delay(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.thrashing_delay) }.ok()
    }
    pub fn freepages_count(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.freepages_count) }.ok()
    }
    pub fn thrashing_count(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.thrashing_count) }.ok()
    }
}
impl ftrace_ret_stack {
    pub fn ret(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ret) }.ok()
    }
    pub fn func(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn calltime(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.calltime) }.ok()
    }
    pub fn subtime(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.subtime) }.ok()
    }
    pub fn retp(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.retp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_integrity {
    pub fn profile(&self) -> Option<*const blk_integrity_profile> {
        let v = unsafe { crate::bpf_probe_read(&self.profile) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn tuple_size(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tuple_size) }.ok()
    }
    pub fn interval_exp(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.interval_exp) }.ok()
    }
    pub fn tag_size(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tag_size) }.ok()
    }
}
impl blk_rq_stat {
    pub fn mean(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.mean) }.ok()
    }
    pub fn min(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn nr_samples(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nr_samples) }.ok()
    }
    pub fn batch(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.batch) }.ok()
    }
}
impl queue_limits {
    pub fn bounce_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.bounce_pfn) }.ok()
    }
    pub fn seg_boundary_mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.seg_boundary_mask) }.ok()
    }
    pub fn virt_boundary_mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.virt_boundary_mask) }.ok()
    }
    pub fn max_hw_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_hw_sectors) }.ok()
    }
    pub fn max_dev_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_dev_sectors) }.ok()
    }
    pub fn chunk_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.chunk_sectors) }.ok()
    }
    pub fn max_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_sectors) }.ok()
    }
    pub fn max_segment_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_segment_size) }.ok()
    }
    pub fn physical_block_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.physical_block_size) }.ok()
    }
    pub fn logical_block_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.logical_block_size) }.ok()
    }
    pub fn alignment_offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alignment_offset) }.ok()
    }
    pub fn io_min(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.io_min) }.ok()
    }
    pub fn io_opt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.io_opt) }.ok()
    }
    pub fn max_discard_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_discard_sectors) }.ok()
    }
    pub fn max_hw_discard_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_hw_discard_sectors) }.ok()
    }
    pub fn max_write_same_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_write_same_sectors) }.ok()
    }
    pub fn max_write_zeroes_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_write_zeroes_sectors) }.ok()
    }
    pub fn max_zone_append_sectors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_zone_append_sectors) }.ok()
    }
    pub fn discard_granularity(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.discard_granularity) }.ok()
    }
    pub fn discard_alignment(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.discard_alignment) }.ok()
    }
    pub fn max_segments(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.max_segments) }.ok()
    }
    pub fn max_integrity_segments(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.max_integrity_segments) }.ok()
    }
    pub fn max_discard_segments(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.max_discard_segments) }.ok()
    }
    pub fn misaligned(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.misaligned) }.ok()
    }
    pub fn discard_misaligned(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.discard_misaligned) }.ok()
    }
    pub fn raid_partial_stripes_expensive(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.raid_partial_stripes_expensive) }.ok()
    }
    pub fn zoned(&self) -> Option<blk_zoned_model::Type> {
        unsafe { crate::bpf_probe_read(&self.zoned) }.ok()
    }
}
impl bsg_class_device {
    pub fn class_dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.class_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn minor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.minor) }.ok()
    }
    pub fn queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const bsg_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl mempool_s {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn min_nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.min_nr) }.ok()
    }
    pub fn curr_nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.curr_nr) }.ok()
    }
    pub fn elements(&self) -> Option<*mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.elements) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pool_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.pool_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn alloc(&self) -> Option<mempool_alloc_t> {
        unsafe { crate::bpf_probe_read(&self.alloc) }.ok()
    }
    pub fn free(&self) -> Option<mempool_free_t> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl bio_set {
    pub fn bio_slab(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.bio_slab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn front_pad(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.front_pad) }.ok()
    }
    pub fn bio_pool(&self) -> Option<mempool_t> {
        unsafe { crate::bpf_probe_read(&self.bio_pool) }.ok()
    }
    pub fn bvec_pool(&self) -> Option<mempool_t> {
        unsafe { crate::bpf_probe_read(&self.bvec_pool) }.ok()
    }
    pub fn bio_integrity_pool(&self) -> Option<mempool_t> {
        unsafe { crate::bpf_probe_read(&self.bio_integrity_pool) }.ok()
    }
    pub fn bvec_integrity_pool(&self) -> Option<mempool_t> {
        unsafe { crate::bpf_probe_read(&self.bvec_integrity_pool) }.ok()
    }
    pub fn rescue_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rescue_lock) }.ok()
    }
    pub fn rescue_list(&self) -> Option<bio_list> {
        unsafe { crate::bpf_probe_read(&self.rescue_list) }.ok()
    }
    pub fn rescue_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.rescue_work) }.ok()
    }
    pub fn rescue_workqueue(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.rescue_workqueue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl request_queue {
    pub fn last_merge(&self) -> Option<*mut request> {
        let v = unsafe { crate::bpf_probe_read(&self.last_merge) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elevator(&self) -> Option<*mut elevator_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn q_usage_counter(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.q_usage_counter) }.ok()
    }
    pub fn stats(&self) -> Option<*mut blk_queue_stats> {
        let v = unsafe { crate::bpf_probe_read(&self.stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rq_qos(&self) -> Option<*mut rq_qos> {
        let v = unsafe { crate::bpf_probe_read(&self.rq_qos) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_ops(&self) -> Option<*const blk_mq_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_ctx(&self) -> Option<*mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.queue_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.queue_depth) }.ok()
    }
    pub fn queue_hw_ctx(&self) -> Option<*mut *mut blk_mq_hw_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.queue_hw_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_hw_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_hw_queues) }.ok()
    }
    pub fn backing_dev_info(&self) -> Option<*mut backing_dev_info> {
        let v = unsafe { crate::bpf_probe_read(&self.backing_dev_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queuedata(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.queuedata) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.queue_flags) }.ok()
    }
    pub fn pm_only(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.pm_only) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn bounce_gfp(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.bounce_gfp) }.ok()
    }
    pub fn queue_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.queue_lock) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn mq_kobj(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_kobj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn integrity(&self) -> Option<blk_integrity> {
        unsafe { crate::bpf_probe_read(&self.integrity) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rpm_status(&self) -> Option<rpm_status::Type> {
        unsafe { crate::bpf_probe_read(&self.rpm_status) }.ok()
    }
    pub fn nr_pending(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_pending) }.ok()
    }
    pub fn nr_requests(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_requests) }.ok()
    }
    pub fn dma_pad_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dma_pad_mask) }.ok()
    }
    pub fn dma_alignment(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dma_alignment) }.ok()
    }
    pub fn ksm(&self) -> Option<*mut blk_keyslot_manager> {
        let v = unsafe { crate::bpf_probe_read(&self.ksm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rq_timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rq_timeout) }.ok()
    }
    pub fn poll_nsec(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.poll_nsec) }.ok()
    }
    pub fn poll_cb(&self) -> Option<*mut blk_stat_callback> {
        let v = unsafe { crate::bpf_probe_read(&self.poll_cb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn poll_stat(&self) -> Option<[blk_rq_stat; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.poll_stat) }.ok()
    }
    pub fn timeout(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn timeout_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.timeout_work) }.ok()
    }
    pub fn nr_active_requests_shared_sbitmap(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_active_requests_shared_sbitmap) }.ok()
    }
    pub fn icq_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.icq_list) }.ok()
    }
    pub fn blkcg_pols(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.blkcg_pols) }.ok()
    }
    pub fn root_blkg(&self) -> Option<*mut blkcg_gq> {
        let v = unsafe { crate::bpf_probe_read(&self.root_blkg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blkg_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.blkg_list) }.ok()
    }
    pub fn limits(&self) -> Option<queue_limits> {
        unsafe { crate::bpf_probe_read(&self.limits) }.ok()
    }
    pub fn required_elevator_features(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.required_elevator_features) }.ok()
    }
    pub fn nr_zones(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_zones) }.ok()
    }
    pub fn conv_zones_bitmap(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.conv_zones_bitmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq_zones_wlock(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.seq_zones_wlock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn max_open_zones(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_open_zones) }.ok()
    }
    pub fn max_active_zones(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_active_zones) }.ok()
    }
    pub fn sg_timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sg_timeout) }.ok()
    }
    pub fn sg_reserved_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sg_reserved_size) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn debugfs_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.debugfs_mutex) }.ok()
    }
    pub fn blk_trace(&self) -> Option<*mut blk_trace> {
        let v = unsafe { crate::bpf_probe_read(&self.blk_trace) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fq(&self) -> Option<*mut blk_flush_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.fq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn requeue_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.requeue_list) }.ok()
    }
    pub fn requeue_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.requeue_lock) }.ok()
    }
    pub fn requeue_work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.requeue_work) }.ok()
    }
    pub fn sysfs_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.sysfs_lock) }.ok()
    }
    pub fn sysfs_dir_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.sysfs_dir_lock) }.ok()
    }
    pub fn unused_hctx_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.unused_hctx_list) }.ok()
    }
    pub fn unused_hctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.unused_hctx_lock) }.ok()
    }
    pub fn mq_freeze_depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mq_freeze_depth) }.ok()
    }
    pub fn bsg_dev(&self) -> Option<bsg_class_device> {
        unsafe { crate::bpf_probe_read(&self.bsg_dev) }.ok()
    }
    pub fn td(&self) -> Option<*mut throtl_data> {
        let v = unsafe { crate::bpf_probe_read(&self.td) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn mq_freeze_wq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.mq_freeze_wq) }.ok()
    }
    pub fn mq_freeze_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mq_freeze_lock) }.ok()
    }
    pub fn tag_set(&self) -> Option<*mut blk_mq_tag_set> {
        let v = unsafe { crate::bpf_probe_read(&self.tag_set) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tag_set_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tag_set_list) }.ok()
    }
    pub fn bio_split(&self) -> Option<bio_set> {
        unsafe { crate::bpf_probe_read(&self.bio_split) }.ok()
    }
    pub fn debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sched_debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rqos_debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.rqos_debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_sysfs_init_done(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.mq_sysfs_init_done) }.ok()
    }
    pub fn cmd_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.cmd_size) }.ok()
    }
    pub fn write_hints(&self) -> Option<[u64_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.write_hints) }.ok()
    }
}
impl cgroup_base_stat {
    pub fn cputime(&self) -> Option<task_cputime> {
        unsafe { crate::bpf_probe_read(&self.cputime) }.ok()
    }
}
impl psi_group {
    pub fn avgs_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.avgs_lock) }.ok()
    }
    pub fn pcpu(&self) -> Option<*mut psi_group_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.pcpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn avg_total(&self) -> Option<[u64_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.avg_total) }.ok()
    }
    pub fn avg_last_update(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avg_last_update) }.ok()
    }
    pub fn avg_next_update(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avg_next_update) }.ok()
    }
    pub fn avgs_work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.avgs_work) }.ok()
    }
    pub fn total(&self) -> Option<[u64_; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.total) }.ok()
    }
    pub fn avg(&self) -> Option<[::aya_bpf_cty::c_ulong; 15usize]> {
        unsafe { crate::bpf_probe_read(&self.avg) }.ok()
    }
    pub fn poll_task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.poll_task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn poll_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.poll_timer) }.ok()
    }
    pub fn poll_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.poll_wait) }.ok()
    }
    pub fn poll_wakeup(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.poll_wakeup) }.ok()
    }
    pub fn trigger_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.trigger_lock) }.ok()
    }
    pub fn triggers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.triggers) }.ok()
    }
    pub fn nr_triggers(&self) -> Option<[u32_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.nr_triggers) }.ok()
    }
    pub fn poll_states(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.poll_states) }.ok()
    }
    pub fn poll_min_period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.poll_min_period) }.ok()
    }
    pub fn polling_total(&self) -> Option<[u64_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.polling_total) }.ok()
    }
    pub fn polling_next_update(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.polling_next_update) }.ok()
    }
    pub fn polling_until(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.polling_until) }.ok()
    }
}
impl cgroup_bpf {
    pub fn effective(&self) -> Option<[*mut bpf_prog_array; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.effective) }.ok()
    }
    pub fn progs(&self) -> Option<[list_head; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.progs) }.ok()
    }
    pub fn flags(&self) -> Option<[u32_; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn storages(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.storages) }.ok()
    }
    pub fn inactive(&self) -> Option<*mut bpf_prog_array> {
        let v = unsafe { crate::bpf_probe_read(&self.inactive) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn release_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.release_work) }.ok()
    }
}
impl cgroup_freezer_state {
    pub fn freeze(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.freeze) }.ok()
    }
    pub fn e_freeze(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.e_freeze) }.ok()
    }
    pub fn nr_frozen_descendants(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_frozen_descendants) }.ok()
    }
    pub fn nr_frozen_tasks(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_frozen_tasks) }.ok()
    }
}
impl cgroup {
    pub fn self_(&self) -> Option<cgroup_subsys_state> {
        unsafe { crate::bpf_probe_read(&self.self_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn level(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn max_depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_depth) }.ok()
    }
    pub fn nr_descendants(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_descendants) }.ok()
    }
    pub fn nr_dying_descendants(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_dying_descendants) }.ok()
    }
    pub fn max_descendants(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_descendants) }.ok()
    }
    pub fn nr_populated_csets(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_populated_csets) }.ok()
    }
    pub fn nr_populated_domain_children(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_populated_domain_children) }.ok()
    }
    pub fn nr_populated_threaded_children(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_populated_threaded_children) }.ok()
    }
    pub fn nr_threaded_children(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_threaded_children) }.ok()
    }
    pub fn kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn procs_file(&self) -> Option<cgroup_file> {
        unsafe { crate::bpf_probe_read(&self.procs_file) }.ok()
    }
    pub fn events_file(&self) -> Option<cgroup_file> {
        unsafe { crate::bpf_probe_read(&self.events_file) }.ok()
    }
    pub fn subtree_control(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.subtree_control) }.ok()
    }
    pub fn subtree_ss_mask(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.subtree_ss_mask) }.ok()
    }
    pub fn old_subtree_control(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.old_subtree_control) }.ok()
    }
    pub fn old_subtree_ss_mask(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.old_subtree_ss_mask) }.ok()
    }
    pub fn subsys(&self) -> Option<[*mut cgroup_subsys_state; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.subsys) }.ok()
    }
    pub fn root(&self) -> Option<*mut cgroup_root> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cset_links(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cset_links) }.ok()
    }
    pub fn e_csets(&self) -> Option<[list_head; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.e_csets) }.ok()
    }
    pub fn dom_cgrp(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.dom_cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn old_dom_cgrp(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.old_dom_cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rstat_cpu(&self) -> Option<*mut cgroup_rstat_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.rstat_cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rstat_css_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rstat_css_list) }.ok()
    }
    pub fn last_bstat(&self) -> Option<cgroup_base_stat> {
        unsafe { crate::bpf_probe_read(&self.last_bstat) }.ok()
    }
    pub fn bstat(&self) -> Option<cgroup_base_stat> {
        unsafe { crate::bpf_probe_read(&self.bstat) }.ok()
    }
    pub fn prev_cputime(&self) -> Option<prev_cputime> {
        unsafe { crate::bpf_probe_read(&self.prev_cputime) }.ok()
    }
    pub fn pidlists(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pidlists) }.ok()
    }
    pub fn pidlist_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.pidlist_mutex) }.ok()
    }
    pub fn offline_waitq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.offline_waitq) }.ok()
    }
    pub fn release_agent_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.release_agent_work) }.ok()
    }
    pub fn psi(&self) -> Option<psi_group> {
        unsafe { crate::bpf_probe_read(&self.psi) }.ok()
    }
    pub fn bpf(&self) -> Option<cgroup_bpf> {
        unsafe { crate::bpf_probe_read(&self.bpf) }.ok()
    }
    pub fn congestion_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.congestion_count) }.ok()
    }
    pub fn freezer(&self) -> Option<cgroup_freezer_state> {
        unsafe { crate::bpf_probe_read(&self.freezer) }.ok()
    }
    pub fn ancestor_ids(&self) -> Option<__IncompleteArrayField<u64_>> {
        unsafe { crate::bpf_probe_read(&self.ancestor_ids) }.ok()
    }
}
impl taskstats {
    pub fn version(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn ac_exitcode(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_exitcode) }.ok()
    }
    pub fn ac_flag(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ac_flag) }.ok()
    }
    pub fn ac_nice(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ac_nice) }.ok()
    }
    pub fn cpu_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cpu_count) }.ok()
    }
    pub fn cpu_delay_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cpu_delay_total) }.ok()
    }
    pub fn blkio_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.blkio_count) }.ok()
    }
    pub fn blkio_delay_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.blkio_delay_total) }.ok()
    }
    pub fn swapin_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.swapin_count) }.ok()
    }
    pub fn swapin_delay_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.swapin_delay_total) }.ok()
    }
    pub fn cpu_run_real_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cpu_run_real_total) }.ok()
    }
    pub fn cpu_run_virtual_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cpu_run_virtual_total) }.ok()
    }
    pub fn ac_comm(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.ac_comm) }.ok()
    }
    pub fn ac_sched(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ac_sched) }.ok()
    }
    pub fn ac_pad(&self) -> Option<[__u8; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.ac_pad) }.ok()
    }
    pub fn ac_uid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_uid) }.ok()
    }
    pub fn ac_gid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_gid) }.ok()
    }
    pub fn ac_pid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_pid) }.ok()
    }
    pub fn ac_ppid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_ppid) }.ok()
    }
    pub fn ac_btime(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ac_btime) }.ok()
    }
    pub fn ac_etime(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_etime) }.ok()
    }
    pub fn ac_utime(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_utime) }.ok()
    }
    pub fn ac_stime(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_stime) }.ok()
    }
    pub fn ac_minflt(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_minflt) }.ok()
    }
    pub fn ac_majflt(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_majflt) }.ok()
    }
    pub fn coremem(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.coremem) }.ok()
    }
    pub fn virtmem(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.virtmem) }.ok()
    }
    pub fn hiwater_rss(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hiwater_rss) }.ok()
    }
    pub fn hiwater_vm(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hiwater_vm) }.ok()
    }
    pub fn read_char(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.read_char) }.ok()
    }
    pub fn write_char(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.write_char) }.ok()
    }
    pub fn read_syscalls(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.read_syscalls) }.ok()
    }
    pub fn write_syscalls(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.write_syscalls) }.ok()
    }
    pub fn read_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.read_bytes) }.ok()
    }
    pub fn write_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.write_bytes) }.ok()
    }
    pub fn cancelled_write_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cancelled_write_bytes) }.ok()
    }
    pub fn nvcsw(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.nvcsw) }.ok()
    }
    pub fn nivcsw(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.nivcsw) }.ok()
    }
    pub fn ac_utimescaled(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_utimescaled) }.ok()
    }
    pub fn ac_stimescaled(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_stimescaled) }.ok()
    }
    pub fn cpu_scaled_run_real_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cpu_scaled_run_real_total) }.ok()
    }
    pub fn freepages_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.freepages_count) }.ok()
    }
    pub fn freepages_delay_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.freepages_delay_total) }.ok()
    }
    pub fn thrashing_count(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.thrashing_count) }.ok()
    }
    pub fn thrashing_delay_total(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.thrashing_delay_total) }.ok()
    }
    pub fn ac_btime64(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ac_btime64) }.ok()
    }
}
impl wait_page_queue {
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bit_nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bit_nr) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_entry_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl writeback_control {
    pub fn nr_to_write(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.nr_to_write) }.ok()
    }
    pub fn pages_skipped(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.pages_skipped) }.ok()
    }
    pub fn range_start(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.range_start) }.ok()
    }
    pub fn range_end(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.range_end) }.ok()
    }
    pub fn sync_mode(&self) -> Option<writeback_sync_modes::Type> {
        unsafe { crate::bpf_probe_read(&self.sync_mode) }.ok()
    }
    pub fn wb(&self) -> Option<*mut bdi_writeback> {
        let v = unsafe { crate::bpf_probe_read(&self.wb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wb_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wb_id) }.ok()
    }
    pub fn wb_lcand_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wb_lcand_id) }.ok()
    }
    pub fn wb_tcand_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wb_tcand_id) }.ok()
    }
    pub fn wb_bytes(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.wb_bytes) }.ok()
    }
    pub fn wb_lcand_bytes(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.wb_lcand_bytes) }.ok()
    }
    pub fn wb_tcand_bytes(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.wb_tcand_bytes) }.ok()
    }
}
impl readahead_control {
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mapping(&self) -> Option<*mut address_space> {
        let v = unsafe { crate::bpf_probe_read(&self.mapping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _index(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._index) }.ok()
    }
    pub fn _nr_pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self._nr_pages) }.ok()
    }
    pub fn _batch_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self._batch_count) }.ok()
    }
}
impl iov_iter {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn iov_offset(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.iov_offset) }.ok()
    }
    pub fn count(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn iov(&self) -> Option<*const iovec> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.iov) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kvec(&self) -> Option<*const kvec> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.kvec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bvec(&self) -> Option<*const bio_vec> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bvec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_segs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.nr_segs) }.ok()
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.head) }.ok()
    }
    pub fn start_head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.start_head) }.ok()
    }
}
impl iov_iter__bindgen_ty_1 {
    pub fn iov(&self) -> Option<*const iovec> {
        let v = unsafe { crate::bpf_probe_read(&self.iov) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kvec(&self) -> Option<*const kvec> {
        let v = unsafe { crate::bpf_probe_read(&self.kvec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bvec(&self) -> Option<*const bio_vec> {
        let v = unsafe { crate::bpf_probe_read(&self.bvec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iov_iter__bindgen_ty_2 {
    pub fn nr_segs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_segs) }.ok()
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.head) }.ok()
    }
    pub fn start_head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_head) }.ok()
    }
}
impl iov_iter__bindgen_ty_2__bindgen_ty_1 {
    pub fn head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn start_head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.start_head) }.ok()
    }
}
impl swap_cluster_info {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl swap_cluster_list {
    pub fn head(&self) -> Option<swap_cluster_info> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn tail(&self) -> Option<swap_cluster_info> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
}
impl swap_info_struct {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn prio(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn list(&self) -> Option<plist_node> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_schar> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn swap_map(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.swap_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cluster_info(&self) -> Option<*mut swap_cluster_info> {
        let v = unsafe { crate::bpf_probe_read(&self.cluster_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free_clusters(&self) -> Option<swap_cluster_list> {
        unsafe { crate::bpf_probe_read(&self.free_clusters) }.ok()
    }
    pub fn lowest_bit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lowest_bit) }.ok()
    }
    pub fn highest_bit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.highest_bit) }.ok()
    }
    pub fn pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.pages) }.ok()
    }
    pub fn inuse_pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.inuse_pages) }.ok()
    }
    pub fn cluster_next(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cluster_next) }.ok()
    }
    pub fn cluster_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cluster_nr) }.ok()
    }
    pub fn cluster_next_cpu(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.cluster_next_cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_cluster(&self) -> Option<*mut percpu_cluster> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_cluster) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn swap_extent_root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.swap_extent_root) }.ok()
    }
    pub fn bdev(&self) -> Option<*mut block_device> {
        let v = unsafe { crate::bpf_probe_read(&self.bdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn swap_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.swap_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn old_block_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.old_block_size) }.ok()
    }
    pub fn frontswap_map(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.frontswap_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frontswap_pages(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.frontswap_pages) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn cont_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.cont_lock) }.ok()
    }
    pub fn discard_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.discard_work) }.ok()
    }
    pub fn discard_clusters(&self) -> Option<swap_cluster_list> {
        unsafe { crate::bpf_probe_read(&self.discard_clusters) }.ok()
    }
    pub fn avail_lists(&self) -> Option<__IncompleteArrayField<plist_node>> {
        unsafe { crate::bpf_probe_read(&self.avail_lists) }.ok()
    }
}
impl cdev {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl dev_links_info {
    pub fn suppliers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.suppliers) }.ok()
    }
    pub fn consumers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.consumers) }.ok()
    }
    pub fn defer_sync(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.defer_sync) }.ok()
    }
    pub fn status(&self) -> Option<dl_dev_state::Type> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
}
impl pm_message {
    pub fn event(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
}
impl dev_pm_info {
    pub fn power_state(&self) -> Option<pm_message_t> {
        unsafe { crate::bpf_probe_read(&self.power_state) }.ok()
    }
    pub fn driver_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.driver_flags) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn completion(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.completion) }.ok()
    }
    pub fn wakeup(&self) -> Option<*mut wakeup_source> {
        let v = unsafe { crate::bpf_probe_read(&self.wakeup) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn suspend_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.suspend_timer) }.ok()
    }
    pub fn timer_expires(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.timer_expires) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn wait_queue(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait_queue) }.ok()
    }
    pub fn wakeirq(&self) -> Option<*mut wake_irq> {
        let v = unsafe { crate::bpf_probe_read(&self.wakeirq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn usage_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.usage_count) }.ok()
    }
    pub fn child_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.child_count) }.ok()
    }
    pub fn links_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.links_count) }.ok()
    }
    pub fn request(&self) -> Option<rpm_request::Type> {
        unsafe { crate::bpf_probe_read(&self.request) }.ok()
    }
    pub fn runtime_status(&self) -> Option<rpm_status::Type> {
        unsafe { crate::bpf_probe_read(&self.runtime_status) }.ok()
    }
    pub fn runtime_error(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.runtime_error) }.ok()
    }
    pub fn autosuspend_delay(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.autosuspend_delay) }.ok()
    }
    pub fn last_busy(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_busy) }.ok()
    }
    pub fn active_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.active_time) }.ok()
    }
    pub fn suspended_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.suspended_time) }.ok()
    }
    pub fn accounting_timestamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.accounting_timestamp) }.ok()
    }
    pub fn subsys_data(&self) -> Option<*mut pm_subsys_data> {
        let v = unsafe { crate::bpf_probe_read(&self.subsys_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn set_latency_tolerance(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>> {
        unsafe { crate::bpf_probe_read(&self.set_latency_tolerance) }.ok()
    }
    pub fn qos(&self) -> Option<*mut dev_pm_qos> {
        let v = unsafe { crate::bpf_probe_read(&self.qos) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl dev_archdata {}
impl device {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn parent(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn p(&self) -> Option<*mut device_private> {
        let v = unsafe { crate::bpf_probe_read(&self.p) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.init_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<*const device_type> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bus(&self) -> Option<*mut bus_type> {
        let v = unsafe { crate::bpf_probe_read(&self.bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver(&self) -> Option<*mut device_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.driver) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn platform_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.platform_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn links(&self) -> Option<dev_links_info> {
        unsafe { crate::bpf_probe_read(&self.links) }.ok()
    }
    pub fn power(&self) -> Option<dev_pm_info> {
        unsafe { crate::bpf_probe_read(&self.power) }.ok()
    }
    pub fn pm_domain(&self) -> Option<*mut dev_pm_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.pm_domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn em_pd(&self) -> Option<*mut em_perf_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.em_pd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msi_domain(&self) -> Option<*mut irq_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.msi_domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pins(&self) -> Option<*mut dev_pin_info> {
        let v = unsafe { crate::bpf_probe_read(&self.pins) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.msi_list) }.ok()
    }
    pub fn dma_ops(&self) -> Option<*const dma_map_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.dma_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dma_mask(&self) -> Option<*mut u64_> {
        let v = unsafe { crate::bpf_probe_read(&self.dma_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn coherent_dma_mask(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.coherent_dma_mask) }.ok()
    }
    pub fn bus_dma_limit(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bus_dma_limit) }.ok()
    }
    pub fn dma_range_map(&self) -> Option<*const bus_dma_region> {
        let v = unsafe { crate::bpf_probe_read(&self.dma_range_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dma_parms(&self) -> Option<*mut device_dma_parameters> {
        let v = unsafe { crate::bpf_probe_read(&self.dma_parms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dma_pools(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dma_pools) }.ok()
    }
    pub fn archdata(&self) -> Option<dev_archdata> {
        unsafe { crate::bpf_probe_read(&self.archdata) }.ok()
    }
    pub fn of_node(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.of_node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn numa_node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn devt(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.devt) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn devres_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.devres_lock) }.ok()
    }
    pub fn devres_head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.devres_head) }.ok()
    }
    pub fn class(&self) -> Option<*mut class> {
        let v = unsafe { crate::bpf_probe_read(&self.class) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn iommu_group(&self) -> Option<*mut iommu_group> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_group) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu(&self) -> Option<*mut dev_iommu> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl block_device {
    pub fn bd_start_sect(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.bd_start_sect) }.ok()
    }
    pub fn bd_stats(&self) -> Option<*mut disk_stats> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.bd_stamp) }.ok()
    }
    pub fn bd_read_only(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bd_read_only) }.ok()
    }
    pub fn bd_dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.bd_dev) }.ok()
    }
    pub fn bd_openers(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bd_openers) }.ok()
    }
    pub fn bd_inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_super(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_super) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.bd_mutex) }.ok()
    }
    pub fn bd_claiming(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_claiming) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_device(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.bd_device) }.ok()
    }
    pub fn bd_holder(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_holder) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_holders(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bd_holders) }.ok()
    }
    pub fn bd_write_holder(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bd_write_holder) }.ok()
    }
    pub fn bd_holder_disks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.bd_holder_disks) }.ok()
    }
    pub fn bd_holder_dir(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_holder_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_partno(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.bd_partno) }.ok()
    }
    pub fn bd_part_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bd_part_count) }.ok()
    }
    pub fn bd_size_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.bd_size_lock) }.ok()
    }
    pub fn bd_disk(&self) -> Option<*mut gendisk> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_disk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_bdi(&self) -> Option<*mut backing_dev_info> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_bdi) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_fsfreeze_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bd_fsfreeze_count) }.ok()
    }
    pub fn bd_fsfreeze_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.bd_fsfreeze_mutex) }.ok()
    }
    pub fn bd_fsfreeze_sb(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_fsfreeze_sb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bd_meta_info(&self) -> Option<*mut partition_meta_info> {
        let v = unsafe { crate::bpf_probe_read(&self.bd_meta_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl p_log {
    pub fn prefix(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.prefix) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn log(&self) -> Option<*mut fc_log> {
        let v = unsafe { crate::bpf_probe_read(&self.log) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fs_context {
    pub fn ops(&self) -> Option<*const fs_context_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uapi_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.uapi_mutex) }.ok()
    }
    pub fn fs_type(&self) -> Option<*mut file_system_type> {
        let v = unsafe { crate::bpf_probe_read(&self.fs_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fs_private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.fs_private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sget_key(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sget_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net_ns(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn log(&self) -> Option<p_log> {
        unsafe { crate::bpf_probe_read(&self.log) }.ok()
    }
    pub fn source(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.source) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn s_fs_info(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.s_fs_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sb_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sb_flags) }.ok()
    }
    pub fn sb_flags_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sb_flags_mask) }.ok()
    }
    pub fn s_iflags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.s_iflags) }.ok()
    }
    pub fn lsm_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lsm_flags) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl filename {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uptr(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.uptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn aname(&self) -> Option<*mut audit_names> {
        let v = unsafe { crate::bpf_probe_read(&self.aname) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iname(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.iname) }.ok()
    }
}
impl bvec_iter {
    pub fn bi_sector(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.bi_sector) }.ok()
    }
    pub fn bi_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bi_size) }.ok()
    }
    pub fn bi_idx(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bi_idx) }.ok()
    }
    pub fn bi_bvec_done(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bi_bvec_done) }.ok()
    }
}
impl bio_issue {
    pub fn value(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.value) }.ok()
    }
}
impl bio_vec {
    pub fn bv_page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.bv_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bv_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bv_len) }.ok()
    }
    pub fn bv_offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bv_offset) }.ok()
    }
}
impl bio {
    pub fn bi_next(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_disk(&self) -> Option<*mut gendisk> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_disk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_opf(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bi_opf) }.ok()
    }
    pub fn bi_flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bi_flags) }.ok()
    }
    pub fn bi_ioprio(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bi_ioprio) }.ok()
    }
    pub fn bi_write_hint(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bi_write_hint) }.ok()
    }
    pub fn bi_status(&self) -> Option<blk_status_t> {
        unsafe { crate::bpf_probe_read(&self.bi_status) }.ok()
    }
    pub fn bi_partno(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.bi_partno) }.ok()
    }
    pub fn __bi_remaining(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bi_remaining) }.ok()
    }
    pub fn bi_iter(&self) -> Option<bvec_iter> {
        unsafe { crate::bpf_probe_read(&self.bi_iter) }.ok()
    }
    pub fn bi_end_io(&self) -> Option<bio_end_io_t> {
        unsafe { crate::bpf_probe_read(&self.bi_end_io) }.ok()
    }
    pub fn bi_private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_blkg(&self) -> Option<*mut blkcg_gq> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_blkg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_issue(&self) -> Option<bio_issue> {
        unsafe { crate::bpf_probe_read(&self.bi_issue) }.ok()
    }
    pub fn bi_iocost_cost(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bi_iocost_cost) }.ok()
    }
    pub fn bi_crypt_context(&self) -> Option<*mut bio_crypt_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_crypt_context) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_integrity(&self) -> Option<*mut bio_integrity_payload> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bi_integrity) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_vcnt(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bi_vcnt) }.ok()
    }
    pub fn bi_max_vecs(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bi_max_vecs) }.ok()
    }
    pub fn __bi_cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bi_cnt) }.ok()
    }
    pub fn bi_io_vec(&self) -> Option<*mut bio_vec> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_io_vec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_pool(&self) -> Option<*mut bio_set> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bi_inline_vecs(&self) -> Option<__IncompleteArrayField<bio_vec>> {
        unsafe { crate::bpf_probe_read(&self.bi_inline_vecs) }.ok()
    }
}
impl bio__bindgen_ty_1 {
    pub fn bi_integrity(&self) -> Option<*mut bio_integrity_payload> {
        let v = unsafe { crate::bpf_probe_read(&self.bi_integrity) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl linux_binprm {
    pub fn vma(&self) -> Option<*mut vm_area_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.vma) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vma_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vma_pages) }.ok()
    }
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn p(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.p) }.ok()
    }
    pub fn argmin(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.argmin) }.ok()
    }
    pub fn executable(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.executable) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn interpreter(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.interpreter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cred(&self) -> Option<*mut cred> {
        let v = unsafe { crate::bpf_probe_read(&self.cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn unsafe_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.unsafe_) }.ok()
    }
    pub fn per_clear(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.per_clear) }.ok()
    }
    pub fn argc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.argc) }.ok()
    }
    pub fn envc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.envc) }.ok()
    }
    pub fn filename(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.filename) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn interp(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.interp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fdpath(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.fdpath) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn interp_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.interp_flags) }.ok()
    }
    pub fn execfd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.execfd) }.ok()
    }
    pub fn loader(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.loader) }.ok()
    }
    pub fn exec(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.exec) }.ok()
    }
    pub fn rlim_stack(&self) -> Option<rlimit> {
        unsafe { crate::bpf_probe_read(&self.rlim_stack) }.ok()
    }
    pub fn buf(&self) -> Option<[::aya_bpf_cty::c_char; 256usize]> {
        unsafe { crate::bpf_probe_read(&self.buf) }.ok()
    }
}
impl coredump_params {
    pub fn siginfo(&self) -> Option<*const kernel_siginfo_t> {
        let v = unsafe { crate::bpf_probe_read(&self.siginfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn regs(&self) -> Option<*mut pt_regs> {
        let v = unsafe { crate::bpf_probe_read(&self.regs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn limit(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.limit) }.ok()
    }
    pub fn mm_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mm_flags) }.ok()
    }
    pub fn written(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.written) }.ok()
    }
    pub fn pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.pos) }.ok()
    }
}
impl em_perf_state {
    pub fn frequency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.frequency) }.ok()
    }
    pub fn power(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.power) }.ok()
    }
    pub fn cost(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cost) }.ok()
    }
}
impl em_perf_domain {
    pub fn table(&self) -> Option<*mut em_perf_state> {
        let v = unsafe { crate::bpf_probe_read(&self.table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_perf_states(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_perf_states) }.ok()
    }
    pub fn milliwatts(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.milliwatts) }.ok()
    }
    pub fn cpus(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.cpus) }.ok()
    }
}
impl dev_pm_ops {
    pub fn prepare(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.prepare) }.ok()
    }
    pub fn complete(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.complete) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn freeze(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.freeze) }.ok()
    }
    pub fn thaw(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.thaw) }.ok()
    }
    pub fn poweroff(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.poweroff) }.ok()
    }
    pub fn restore(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.restore) }.ok()
    }
    pub fn suspend_late(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend_late) }.ok()
    }
    pub fn resume_early(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume_early) }.ok()
    }
    pub fn freeze_late(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.freeze_late) }.ok()
    }
    pub fn thaw_early(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.thaw_early) }.ok()
    }
    pub fn poweroff_late(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.poweroff_late) }.ok()
    }
    pub fn restore_early(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.restore_early) }.ok()
    }
    pub fn suspend_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend_noirq) }.ok()
    }
    pub fn resume_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume_noirq) }.ok()
    }
    pub fn freeze_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.freeze_noirq) }.ok()
    }
    pub fn thaw_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.thaw_noirq) }.ok()
    }
    pub fn poweroff_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.poweroff_noirq) }.ok()
    }
    pub fn restore_noirq(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.restore_noirq) }.ok()
    }
    pub fn runtime_suspend(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.runtime_suspend) }.ok()
    }
    pub fn runtime_resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.runtime_resume) }.ok()
    }
    pub fn runtime_idle(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.runtime_idle) }.ok()
    }
}
impl pm_subsys_data {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn refcount(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn clock_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.clock_list) }.ok()
    }
    pub fn domain_data(&self) -> Option<*mut pm_domain_data> {
        let v = unsafe { crate::bpf_probe_read(&self.domain_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl wakeup_source {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn wakeirq(&self) -> Option<*mut wake_irq> {
        let v = unsafe { crate::bpf_probe_read(&self.wakeirq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn timer_expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.timer_expires) }.ok()
    }
    pub fn total_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.total_time) }.ok()
    }
    pub fn max_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.max_time) }.ok()
    }
    pub fn last_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.last_time) }.ok()
    }
    pub fn start_prevent_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.start_prevent_time) }.ok()
    }
    pub fn prevent_sleep_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.prevent_sleep_time) }.ok()
    }
    pub fn event_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.event_count) }.ok()
    }
    pub fn active_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.active_count) }.ok()
    }
    pub fn relax_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.relax_count) }.ok()
    }
    pub fn expire_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.expire_count) }.ok()
    }
    pub fn wakeup_count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.wakeup_count) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl dev_pm_domain {
    pub fn ops(&self) -> Option<dev_pm_ops> {
        unsafe { crate::bpf_probe_read(&self.ops) }.ok()
    }
    pub fn start(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn detach(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: bool_)>> {
        unsafe { crate::bpf_probe_read(&self.detach) }.ok()
    }
    pub fn activate(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.activate) }.ok()
    }
    pub fn sync(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.sync) }.ok()
    }
    pub fn dismiss(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.dismiss) }.ok()
    }
}
impl bus_type {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_root(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bus_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.bus_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn drv_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.drv_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn match_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut device_driver,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.match_) }.ok()
    }
    pub fn uevent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut kobj_uevent_env,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.uevent) }.ok()
    }
    pub fn probe(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.probe) }.ok()
    }
    pub fn sync_state(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.sync_state) }.ok()
    }
    pub fn remove(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.remove) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn online(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.online) }.ok()
    }
    pub fn offline(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.offline) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn num_vf(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.num_vf) }.ok()
    }
    pub fn dma_configure(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.dma_configure) }.ok()
    }
    pub fn pm(&self) -> Option<*const dev_pm_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.pm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu_ops(&self) -> Option<*const iommu_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn p(&self) -> Option<*mut subsys_private> {
        let v = unsafe { crate::bpf_probe_read(&self.p) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.lock_key) }.ok()
    }
    pub fn need_parent_lock(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.need_parent_lock) }.ok()
    }
}
impl device_driver {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bus(&self) -> Option<*mut bus_type> {
        let v = unsafe { crate::bpf_probe_read(&self.bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mod_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn suppress_bind_attrs(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.suppress_bind_attrs) }.ok()
    }
    pub fn probe_type(&self) -> Option<probe_type::Type> {
        unsafe { crate::bpf_probe_read(&self.probe_type) }.ok()
    }
    pub fn of_match_table(&self) -> Option<*const of_device_id> {
        let v = unsafe { crate::bpf_probe_read(&self.of_match_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn acpi_match_table(&self) -> Option<*const acpi_device_id> {
        let v = unsafe { crate::bpf_probe_read(&self.acpi_match_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn probe(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.probe) }.ok()
    }
    pub fn sync_state(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.sync_state) }.ok()
    }
    pub fn remove(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.remove) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pm(&self) -> Option<*const dev_pm_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.pm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn coredump(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.coredump) }.ok()
    }
    pub fn p(&self) -> Option<*mut driver_private> {
        let v = unsafe { crate::bpf_probe_read(&self.p) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iommu_ops {
    pub fn capable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: iommu_cap::Type) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.capable) }.ok()
    }
    pub fn domain_alloc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_uint) -> *mut iommu_domain,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.domain_alloc) }.ok()
    }
    pub fn domain_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>> {
        unsafe { crate::bpf_probe_read(&self.domain_free) }.ok()
    }
    pub fn attach_dev(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: *mut device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.attach_dev) }.ok()
    }
    pub fn detach_dev(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device)>,
    > {
        unsafe { crate::bpf_probe_read(&self.detach_dev) }.ok()
    }
    pub fn map(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: phys_addr_t,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_int,
                arg6: gfp_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn unmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: size_t,
                arg4: *mut iommu_iotlb_gather,
            ) -> size_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unmap) }.ok()
    }
    pub fn flush_iotlb_all(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>> {
        unsafe { crate::bpf_probe_read(&self.flush_iotlb_all) }.ok()
    }
    pub fn iotlb_sync_map(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>> {
        unsafe { crate::bpf_probe_read(&self.iotlb_sync_map) }.ok()
    }
    pub fn iotlb_sync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut iommu_iotlb_gather),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.iotlb_sync) }.ok()
    }
    pub fn iova_to_phys(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: dma_addr_t) -> phys_addr_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.iova_to_phys) }.ok()
    }
    pub fn probe_device(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_device>>
    {
        unsafe { crate::bpf_probe_read(&self.probe_device) }.ok()
    }
    pub fn release_device(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.release_device) }.ok()
    }
    pub fn probe_finalize(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.probe_finalize) }.ok()
    }
    pub fn device_group(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_group>>
    {
        unsafe { crate::bpf_probe_read(&self.device_group) }.ok()
    }
    pub fn domain_get_attr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: iommu_attr::Type,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.domain_get_attr) }.ok()
    }
    pub fn domain_set_attr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: iommu_attr::Type,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.domain_set_attr) }.ok()
    }
    pub fn get_resv_regions(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut list_head)>>
    {
        unsafe { crate::bpf_probe_read(&self.get_resv_regions) }.ok()
    }
    pub fn put_resv_regions(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut list_head)>>
    {
        unsafe { crate::bpf_probe_read(&self.put_resv_regions) }.ok()
    }
    pub fn apply_resv_region(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut iommu_domain,
                arg3: *mut iommu_resv_region,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.apply_resv_region) }.ok()
    }
    pub fn domain_window_enable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: u32_,
                arg3: phys_addr_t,
                arg4: u64_,
                arg5: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.domain_window_enable) }.ok()
    }
    pub fn domain_window_disable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: u32_)>>
    {
        unsafe { crate::bpf_probe_read(&self.domain_window_disable) }.ok()
    }
    pub fn of_xlate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut of_phandle_args,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.of_xlate) }.ok()
    }
    pub fn is_attach_deferred(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_attach_deferred) }.ok()
    }
    pub fn dev_has_feat(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: iommu_dev_features::Type) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dev_has_feat) }.ok()
    }
    pub fn dev_feat_enabled(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: iommu_dev_features::Type) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dev_feat_enabled) }.ok()
    }
    pub fn dev_enable_feat(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: iommu_dev_features::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dev_enable_feat) }.ok()
    }
    pub fn dev_disable_feat(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: iommu_dev_features::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dev_disable_feat) }.ok()
    }
    pub fn aux_attach_dev(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: *mut device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.aux_attach_dev) }.ok()
    }
    pub fn aux_detach_dev(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device)>,
    > {
        unsafe { crate::bpf_probe_read(&self.aux_detach_dev) }.ok()
    }
    pub fn aux_get_pasid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: *mut device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.aux_get_pasid) }.ok()
    }
    pub fn sva_bind(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut mm_struct,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> *mut iommu_sva,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sva_bind) }.ok()
    }
    pub fn sva_unbind(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_sva)>> {
        unsafe { crate::bpf_probe_read(&self.sva_unbind) }.ok()
    }
    pub fn sva_get_pasid(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_sva) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.sva_get_pasid) }.ok()
    }
    pub fn page_response(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut iommu_fault_event,
                arg3: *mut iommu_page_response,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.page_response) }.ok()
    }
    pub fn cache_invalidate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: *mut device,
                arg3: *mut iommu_cache_invalidate_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cache_invalidate) }.ok()
    }
    pub fn sva_bind_gpasid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut iommu_domain,
                arg2: *mut device,
                arg3: *mut iommu_gpasid_bind_data,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sva_bind_gpasid) }.ok()
    }
    pub fn sva_unbind_gpasid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: u32_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sva_unbind_gpasid) }.ok()
    }
    pub fn def_domain_type(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.def_domain_type) }.ok()
    }
    pub fn pgsize_bitmap(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pgsize_bitmap) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl device_type {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uevent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut kobj_uevent_env,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.uevent) }.ok()
    }
    pub fn devnode(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut umode_t,
                arg3: *mut kuid_t,
                arg4: *mut kgid_t,
            ) -> *mut ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devnode) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn pm(&self) -> Option<*const dev_pm_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.pm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl class {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn class_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.class_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_kobj(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_kobj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_uevent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut kobj_uevent_env,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dev_uevent) }.ok()
    }
    pub fn devnode(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut umode_t,
            ) -> *mut ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devnode) }.ok()
    }
    pub fn class_release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut class)>> {
        unsafe { crate::bpf_probe_read(&self.class_release) }.ok()
    }
    pub fn dev_release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>> {
        unsafe { crate::bpf_probe_read(&self.dev_release) }.ok()
    }
    pub fn shutdown_pre(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.shutdown_pre) }.ok()
    }
    pub fn ns_type(&self) -> Option<*const kobj_ns_type_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ns_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn namespace(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device) -> *const ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.namespace) }.ok()
    }
    pub fn get_ownership(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: *mut kuid_t, arg3: *mut kgid_t),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ownership) }.ok()
    }
    pub fn pm(&self) -> Option<*const dev_pm_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.pm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn p(&self) -> Option<*mut subsys_private> {
        let v = unsafe { crate::bpf_probe_read(&self.p) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl of_device_id {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn type_(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn compatible(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.compatible) }.ok()
    }
    pub fn data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl acpi_device_id {
    pub fn id(&self) -> Option<[__u8; 9usize]> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn driver_data(&self) -> Option<kernel_ulong_t> {
        unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()
    }
    pub fn cls(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cls) }.ok()
    }
    pub fn cls_msk(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cls_msk) }.ok()
    }
}
impl device_dma_parameters {
    pub fn max_segment_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_segment_size) }.ok()
    }
    pub fn min_align_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.min_align_mask) }.ok()
    }
    pub fn segment_boundary_mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.segment_boundary_mask) }.ok()
    }
}
impl dma_map_ops {
    pub fn alloc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut dma_addr_t,
                arg4: gfp_t,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.alloc) }.ok()
    }
    pub fn free(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: dma_addr_t,
                arg5: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn alloc_pages(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut dma_addr_t,
                arg4: dma_data_direction::Type,
                arg5: gfp_t,
            ) -> *mut page,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.alloc_pages) }.ok()
    }
    pub fn free_pages(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut page,
                arg4: dma_addr_t,
                arg5: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free_pages) }.ok()
    }
    pub fn alloc_noncoherent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut dma_addr_t,
                arg4: dma_data_direction::Type,
                arg5: gfp_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.alloc_noncoherent) }.ok()
    }
    pub fn free_noncoherent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: size_t,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: dma_addr_t,
                arg5: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free_noncoherent) }.ok()
    }
    pub fn mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut vm_area_struct,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: dma_addr_t,
                arg5: size_t,
                arg6: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
    pub fn get_sgtable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut sg_table,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: dma_addr_t,
                arg5: size_t,
                arg6: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sgtable) }.ok()
    }
    pub fn map_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut page,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: size_t,
                arg5: dma_data_direction::Type,
                arg6: ::aya_bpf_cty::c_ulong,
            ) -> dma_addr_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_page) }.ok()
    }
    pub fn unmap_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: dma_addr_t,
                arg3: size_t,
                arg4: dma_data_direction::Type,
                arg5: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unmap_page) }.ok()
    }
    pub fn map_sg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut scatterlist,
                arg3: ::aya_bpf_cty::c_int,
                arg4: dma_data_direction::Type,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_sg) }.ok()
    }
    pub fn unmap_sg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut scatterlist,
                arg3: ::aya_bpf_cty::c_int,
                arg4: dma_data_direction::Type,
                arg5: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unmap_sg) }.ok()
    }
    pub fn map_resource(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: phys_addr_t,
                arg3: size_t,
                arg4: dma_data_direction::Type,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> dma_addr_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_resource) }.ok()
    }
    pub fn unmap_resource(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: dma_addr_t,
                arg3: size_t,
                arg4: dma_data_direction::Type,
                arg5: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unmap_resource) }.ok()
    }
    pub fn sync_single_for_cpu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: dma_addr_t,
                arg3: size_t,
                arg4: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_single_for_cpu) }.ok()
    }
    pub fn sync_single_for_device(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: dma_addr_t,
                arg3: size_t,
                arg4: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_single_for_device) }.ok()
    }
    pub fn sync_sg_for_cpu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut scatterlist,
                arg3: ::aya_bpf_cty::c_int,
                arg4: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_sg_for_cpu) }.ok()
    }
    pub fn sync_sg_for_device(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut scatterlist,
                arg3: ::aya_bpf_cty::c_int,
                arg4: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_sg_for_device) }.ok()
    }
    pub fn cache_sync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: size_t,
                arg4: dma_data_direction::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cache_sync) }.ok()
    }
    pub fn dma_supported(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut device, arg2: u64_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dma_supported) }.ok()
    }
    pub fn get_required_mask(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> u64_>> {
        unsafe { crate::bpf_probe_read(&self.get_required_mask) }.ok()
    }
    pub fn max_mapping_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> size_t>> {
        unsafe { crate::bpf_probe_read(&self.max_mapping_size) }.ok()
    }
    pub fn get_merge_boundary(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf_cty::c_ulong>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_merge_boundary) }.ok()
    }
}
impl bus_dma_region {
    pub fn cpu_start(&self) -> Option<phys_addr_t> {
        unsafe { crate::bpf_probe_read(&self.cpu_start) }.ok()
    }
    pub fn dma_start(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.dma_start) }.ok()
    }
    pub fn size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn offset(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl fwnode_handle {
    pub fn secondary(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.secondary) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const fwnode_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn suppliers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.suppliers) }.ok()
    }
    pub fn consumers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.consumers) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl device_node {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phandle(&self) -> Option<phandle> {
        unsafe { crate::bpf_probe_read(&self.phandle) }.ok()
    }
    pub fn full_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.full_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fwnode(&self) -> Option<fwnode_handle> {
        unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()
    }
    pub fn properties(&self) -> Option<*mut property> {
        let v = unsafe { crate::bpf_probe_read(&self.properties) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn deadprops(&self) -> Option<*mut property> {
        let v = unsafe { crate::bpf_probe_read(&self.deadprops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn child(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.child) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sibling(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.sibling) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._flags) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl static_call_mod {
    pub fn next(&self) -> Option<*mut static_call_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sites(&self) -> Option<*mut static_call_site> {
        let v = unsafe { crate::bpf_probe_read(&self.sites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ring_buffer_event {
    pub fn array(&self) -> Option<__IncompleteArrayField<u32_>> {
        unsafe { crate::bpf_probe_read(&self.array) }.ok()
    }
}
impl seq_buf {
    pub fn buffer(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn readpos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.readpos) }.ok()
    }
}
impl trace_seq {
    pub fn buffer(&self) -> Option<[::aya_bpf_cty::c_char; 4096usize]> {
        unsafe { crate::bpf_probe_read(&self.buffer) }.ok()
    }
    pub fn seq(&self) -> Option<seq_buf> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn full(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.full) }.ok()
    }
}
impl perf_mem_data_src {
    pub fn val(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl perf_mem_data_src__bindgen_ty_1 {}
impl perf_branch_entry {
    pub fn from(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.from) }.ok()
    }
    pub fn to(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.to) }.ok()
    }
}
impl new_utsname {
    pub fn sysname(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.sysname) }.ok()
    }
    pub fn nodename(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.nodename) }.ok()
    }
    pub fn release(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn version(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn machine(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.machine) }.ok()
    }
    pub fn domainname(&self) -> Option<[::aya_bpf_cty::c_char; 65usize]> {
        unsafe { crate::bpf_probe_read(&self.domainname) }.ok()
    }
}
impl uts_namespace {
    pub fn name(&self) -> Option<new_utsname> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
}
impl cgroup_namespace {
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root_cset(&self) -> Option<*mut css_set> {
        let v = unsafe { crate::bpf_probe_read(&self.root_cset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nsset {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn nsproxy(&self) -> Option<*mut nsproxy> {
        let v = unsafe { crate::bpf_probe_read(&self.nsproxy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fs(&self) -> Option<*mut fs_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl proc_ns_operations {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn real_ns_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.real_ns_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct) -> *mut ns_common>,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn put(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common)>> {
        unsafe { crate::bpf_probe_read(&self.put) }.ok()
    }
    pub fn install(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut nsset, arg2: *mut ns_common) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.install) }.ok()
    }
    pub fn owner(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut user_namespace>,
    > {
        unsafe { crate::bpf_probe_read(&self.owner) }.ok()
    }
    pub fn get_parent(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut ns_common>>
    {
        unsafe { crate::bpf_probe_read(&self.get_parent) }.ok()
    }
}
impl ucounts {
    pub fn node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn ucount(&self) -> Option<[atomic_t; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.ucount) }.ok()
    }
}
impl pmu {
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn module(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.module) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn attr_groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.attr_groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn attr_update(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.attr_update) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn capabilities(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.capabilities) }.ok()
    }
    pub fn pmu_disable_count(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.pmu_disable_count) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pmu_cpu_context(&self) -> Option<*mut perf_cpu_context> {
        let v = unsafe { crate::bpf_probe_read(&self.pmu_cpu_context) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn exclusive_cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.exclusive_cnt) }.ok()
    }
    pub fn task_ctx_nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.task_ctx_nr) }.ok()
    }
    pub fn hrtimer_interval_ms(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.hrtimer_interval_ms) }.ok()
    }
    pub fn nr_addr_filters(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_addr_filters) }.ok()
    }
    pub fn pmu_enable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>> {
        unsafe { crate::bpf_probe_read(&self.pmu_enable) }.ok()
    }
    pub fn pmu_disable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>> {
        unsafe { crate::bpf_probe_read(&self.pmu_disable) }.ok()
    }
    pub fn event_init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.event_init) }.ok()
    }
    pub fn event_mapped(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    > {
        unsafe { crate::bpf_probe_read(&self.event_mapped) }.ok()
    }
    pub fn event_unmapped(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    > {
        unsafe { crate::bpf_probe_read(&self.event_unmapped) }.ok()
    }
    pub fn add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut perf_event,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.add) }.ok()
    }
    pub fn del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.del) }.ok()
    }
    pub fn start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn stop(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>> {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn start_txn(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu, arg2: ::aya_bpf_cty::c_uint)>,
    > {
        unsafe { crate::bpf_probe_read(&self.start_txn) }.ok()
    }
    pub fn commit_txn(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.commit_txn) }.ok()
    }
    pub fn cancel_txn(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>> {
        unsafe { crate::bpf_probe_read(&self.cancel_txn) }.ok()
    }
    pub fn event_idx(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.event_idx) }.ok()
    }
    pub fn sched_task(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event_context, arg2: bool_)>,
    > {
        unsafe { crate::bpf_probe_read(&self.sched_task) }.ok()
    }
    pub fn task_ctx_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.task_ctx_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn swap_task_ctx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut perf_event_context, arg2: *mut perf_event_context),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.swap_task_ctx) }.ok()
    }
    pub fn setup_aux(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut perf_event,
                arg2: *mut *mut ::aya_bpf_cty::c_void,
                arg3: ::aya_bpf_cty::c_int,
                arg4: bool_,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setup_aux) }.ok()
    }
    pub fn free_aux(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.free_aux) }.ok()
    }
    pub fn snapshot_aux(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut perf_event,
                arg2: *mut perf_output_handle,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.snapshot_aux) }.ok()
    }
    pub fn addr_filters_validate(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut list_head) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.addr_filters_validate) }.ok()
    }
    pub fn addr_filters_sync(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>> {
        unsafe { crate::bpf_probe_read(&self.addr_filters_sync) }.ok()
    }
    pub fn aux_output_match(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.aux_output_match) }.ok()
    }
    pub fn filter_match(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.filter_match) }.ok()
    }
    pub fn check_period(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut perf_event, arg2: u64_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_period) }.ok()
    }
}
impl ftrace_regs {
    pub fn regs(&self) -> Option<pt_regs> {
        unsafe { crate::bpf_probe_read(&self.regs) }.ok()
    }
}
impl iovec {
    pub fn iov_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iov_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iov_len(&self) -> Option<__kernel_size_t> {
        unsafe { crate::bpf_probe_read(&self.iov_len) }.ok()
    }
}
impl kvec {
    pub fn iov_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iov_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iov_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.iov_len) }.ok()
    }
}
impl perf_regs {
    pub fn abi(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.abi) }.ok()
    }
    pub fn regs(&self) -> Option<*mut pt_regs> {
        let v = unsafe { crate::bpf_probe_read(&self.regs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl u64_stats_sync {}
impl bpf_cgroup_storage_key {
    pub fn cgroup_inode_id(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cgroup_inode_id) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
}
impl bpf_prog_array_item {
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cgroup_storage(&self) -> Option<[*mut bpf_cgroup_storage; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.cgroup_storage) }.ok()
    }
}
impl bpf_cgroup_storage {
    pub fn buf(&self) -> Option<*mut bpf_storage_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_buf(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.percpu_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn map(&self) -> Option<*mut bpf_cgroup_storage_map> {
        let v = unsafe { crate::bpf_probe_read(&self.map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key(&self) -> Option<bpf_cgroup_storage_key> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn list_map(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list_map) }.ok()
    }
    pub fn list_cg(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list_cg) }.ok()
    }
    pub fn node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl bpf_cgroup_storage__bindgen_ty_1 {
    pub fn buf(&self) -> Option<*mut bpf_storage_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_buf(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_prog_array {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn items(&self) -> Option<__IncompleteArrayField<bpf_prog_array_item>> {
        unsafe { crate::bpf_probe_read(&self.items) }.ok()
    }
}
impl bpf_storage_buffer {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl psi_group_cpu {
    pub fn seq(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn tasks(&self) -> Option<[::aya_bpf_cty::c_uint; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.tasks) }.ok()
    }
    pub fn state_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.state_mask) }.ok()
    }
    pub fn times(&self) -> Option<[u32_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.times) }.ok()
    }
    pub fn state_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.state_start) }.ok()
    }
    pub fn times_prev(&self) -> Option<[u32_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.times_prev) }.ok()
    }
}
impl cgroup_subsys {
    pub fn css_alloc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.css_alloc) }.ok()
    }
    pub fn css_online(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.css_online) }.ok()
    }
    pub fn css_offline(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>> {
        unsafe { crate::bpf_probe_read(&self.css_offline) }.ok()
    }
    pub fn css_released(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>> {
        unsafe { crate::bpf_probe_read(&self.css_released) }.ok()
    }
    pub fn css_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>> {
        unsafe { crate::bpf_probe_read(&self.css_free) }.ok()
    }
    pub fn css_reset(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>> {
        unsafe { crate::bpf_probe_read(&self.css_reset) }.ok()
    }
    pub fn css_rstat_flush(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.css_rstat_flush) }.ok()
    }
    pub fn css_extra_stat_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut cgroup_subsys_state,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.css_extra_stat_show) }.ok()
    }
    pub fn can_attach(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_taskset) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.can_attach) }.ok()
    }
    pub fn cancel_attach(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>> {
        unsafe { crate::bpf_probe_read(&self.cancel_attach) }.ok()
    }
    pub fn attach(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>> {
        unsafe { crate::bpf_probe_read(&self.attach) }.ok()
    }
    pub fn post_attach(&self) -> Option<::core::option::Option<unsafe extern "C" fn()>> {
        unsafe { crate::bpf_probe_read(&self.post_attach) }.ok()
    }
    pub fn can_fork(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut task_struct,
                arg2: *mut css_set,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.can_fork) }.ok()
    }
    pub fn cancel_fork(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut css_set)>,
    > {
        unsafe { crate::bpf_probe_read(&self.cancel_fork) }.ok()
    }
    pub fn fork(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>> {
        unsafe { crate::bpf_probe_read(&self.fork) }.ok()
    }
    pub fn exit(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>> {
        unsafe { crate::bpf_probe_read(&self.exit) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn bind(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>> {
        unsafe { crate::bpf_probe_read(&self.bind) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn legacy_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.legacy_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root(&self) -> Option<*mut cgroup_root> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn css_idr(&self) -> Option<idr> {
        unsafe { crate::bpf_probe_read(&self.css_idr) }.ok()
    }
    pub fn cfts(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cfts) }.ok()
    }
    pub fn dfl_cftypes(&self) -> Option<*mut cftype> {
        let v = unsafe { crate::bpf_probe_read(&self.dfl_cftypes) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn legacy_cftypes(&self) -> Option<*mut cftype> {
        let v = unsafe { crate::bpf_probe_read(&self.legacy_cftypes) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn depends_on(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.depends_on) }.ok()
    }
}
impl cgroup_rstat_cpu {
    pub fn bsync(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.bsync) }.ok()
    }
    pub fn bstat(&self) -> Option<cgroup_base_stat> {
        unsafe { crate::bpf_probe_read(&self.bstat) }.ok()
    }
    pub fn last_bstat(&self) -> Option<cgroup_base_stat> {
        unsafe { crate::bpf_probe_read(&self.last_bstat) }.ok()
    }
    pub fn updated_children(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.updated_children) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn updated_next(&self) -> Option<*mut cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.updated_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cgroup_root {
    pub fn kf_root(&self) -> Option<*mut kernfs_root> {
        let v = unsafe { crate::bpf_probe_read(&self.kf_root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn subsys_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.subsys_mask) }.ok()
    }
    pub fn hierarchy_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.hierarchy_id) }.ok()
    }
    pub fn cgrp(&self) -> Option<cgroup> {
        unsafe { crate::bpf_probe_read(&self.cgrp) }.ok()
    }
    pub fn cgrp_ancestor_id_storage(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cgrp_ancestor_id_storage) }.ok()
    }
    pub fn nr_cgrps(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_cgrps) }.ok()
    }
    pub fn root_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.root_list) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn release_agent_path(&self) -> Option<[::aya_bpf_cty::c_char; 4096usize]> {
        unsafe { crate::bpf_probe_read(&self.release_agent_path) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
}
impl cftype {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn private(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.private) }.ok()
    }
    pub fn max_write_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.max_write_len) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn file_offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.file_offset) }.ok()
    }
    pub fn ss(&self) -> Option<*mut cgroup_subsys> {
        let v = unsafe { crate::bpf_probe_read(&self.ss) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn kf_ops(&self) -> Option<*mut kernfs_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.kf_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn read_u64(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> u64_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_u64) }.ok()
    }
    pub fn read_s64(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> s64,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_s64) }.ok()
    }
    pub fn seq_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_show) }.ok()
    }
    pub fn seq_start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_start) }.ok()
    }
    pub fn seq_next(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut loff_t,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_next) }.ok()
    }
    pub fn seq_stop(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.seq_stop) }.ok()
    }
    pub fn write_u64(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cgroup_subsys_state,
                arg2: *mut cftype,
                arg3: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_u64) }.ok()
    }
    pub fn write_s64(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cgroup_subsys_state,
                arg2: *mut cftype,
                arg3: s64,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_s64) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kernfs_open_file,
                arg2: *mut poll_table_struct,
            ) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
}
impl perf_callchain_entry {
    pub fn nr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.nr) }.ok()
    }
    pub fn ip(&self) -> Option<__IncompleteArrayField<__u64>> {
        unsafe { crate::bpf_probe_read(&self.ip) }.ok()
    }
}
impl perf_raw_frag {
    pub fn next(&self) -> Option<*mut perf_raw_frag> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pad(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pad) }.ok()
    }
    pub fn copy(&self) -> Option<perf_copy_f> {
        unsafe { crate::bpf_probe_read(&self.copy) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl perf_raw_frag__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut perf_raw_frag> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pad(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pad) }.ok()
    }
}
impl perf_raw_record {
    pub fn frag(&self) -> Option<perf_raw_frag> {
        unsafe { crate::bpf_probe_read(&self.frag) }.ok()
    }
    pub fn size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl perf_branch_stack {
    pub fn nr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.nr) }.ok()
    }
    pub fn hw_idx(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hw_idx) }.ok()
    }
    pub fn entries(&self) -> Option<__IncompleteArrayField<perf_branch_entry>> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
}
impl perf_cpu_context {
    pub fn ctx(&self) -> Option<perf_event_context> {
        unsafe { crate::bpf_probe_read(&self.ctx) }.ok()
    }
    pub fn task_ctx(&self) -> Option<*mut perf_event_context> {
        let v = unsafe { crate::bpf_probe_read(&self.task_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn active_oncpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.active_oncpu) }.ok()
    }
    pub fn exclusive(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.exclusive) }.ok()
    }
    pub fn hrtimer_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.hrtimer_lock) }.ok()
    }
    pub fn hrtimer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.hrtimer) }.ok()
    }
    pub fn hrtimer_interval(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.hrtimer_interval) }.ok()
    }
    pub fn hrtimer_active(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hrtimer_active) }.ok()
    }
    pub fn cgrp(&self) -> Option<*mut perf_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.cgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cgrp_cpuctx_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cgrp_cpuctx_entry) }.ok()
    }
    pub fn sched_cb_entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sched_cb_entry) }.ok()
    }
    pub fn sched_cb_usage(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sched_cb_usage) }.ok()
    }
    pub fn online(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.online) }.ok()
    }
    pub fn heap_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.heap_size) }.ok()
    }
    pub fn heap(&self) -> Option<*mut *mut perf_event> {
        let v = unsafe { crate::bpf_probe_read(&self.heap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn heap_default(&self) -> Option<[*mut perf_event; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.heap_default) }.ok()
    }
}
impl perf_output_handle {
    pub fn event(&self) -> Option<*mut perf_event> {
        let v = unsafe { crate::bpf_probe_read(&self.event) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rb(&self) -> Option<*mut perf_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.rb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wakeup(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.wakeup) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn aux_flags(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.aux_flags) }.ok()
    }
    pub fn addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.head) }.ok()
    }
    pub fn page(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.page) }.ok()
    }
}
impl perf_output_handle__bindgen_ty_1 {
    pub fn addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
}
impl perf_addr_filter_range {
    pub fn start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl perf_sample_data {
    pub fn addr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn raw(&self) -> Option<*mut perf_raw_record> {
        let v = unsafe { crate::bpf_probe_read(&self.raw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn br_stack(&self) -> Option<*mut perf_branch_stack> {
        let v = unsafe { crate::bpf_probe_read(&self.br_stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn period(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.period) }.ok()
    }
    pub fn weight(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.weight) }.ok()
    }
    pub fn txn(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.txn) }.ok()
    }
    pub fn data_src(&self) -> Option<perf_mem_data_src> {
        unsafe { crate::bpf_probe_read(&self.data_src) }.ok()
    }
    pub fn type_(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn ip(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ip) }.ok()
    }
    pub fn tid_entry(&self) -> Option<perf_sample_data__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.tid_entry) }.ok()
    }
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
    pub fn id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn stream_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stream_id) }.ok()
    }
    pub fn cpu_entry(&self) -> Option<perf_sample_data__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.cpu_entry) }.ok()
    }
    pub fn callchain(&self) -> Option<*mut perf_callchain_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.callchain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aux_size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.aux_size) }.ok()
    }
    pub fn regs_user(&self) -> Option<perf_regs> {
        unsafe { crate::bpf_probe_read(&self.regs_user) }.ok()
    }
    pub fn regs_intr(&self) -> Option<perf_regs> {
        unsafe { crate::bpf_probe_read(&self.regs_intr) }.ok()
    }
    pub fn stack_user_size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.stack_user_size) }.ok()
    }
    pub fn phys_addr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.phys_addr) }.ok()
    }
    pub fn cgroup(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cgroup) }.ok()
    }
    pub fn data_page_size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.data_page_size) }.ok()
    }
    pub fn code_page_size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.code_page_size) }.ok()
    }
}
impl perf_sample_data__bindgen_ty_1 {
    pub fn pid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn tid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tid) }.ok()
    }
}
impl perf_sample_data__bindgen_ty_2 {
    pub fn cpu(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn reserved(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl perf_cgroup {
    pub fn css(&self) -> Option<cgroup_subsys_state> {
        unsafe { crate::bpf_probe_read(&self.css) }.ok()
    }
    pub fn info(&self) -> Option<*mut perf_cgroup_info> {
        let v = unsafe { crate::bpf_probe_read(&self.info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl perf_cgroup_info {
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
    pub fn timestamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.timestamp) }.ok()
    }
}
impl trace_entry {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn preempt_count(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.preempt_count) }.ok()
    }
    pub fn pid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
}
impl trace_iterator {
    pub fn tr(&self) -> Option<*mut trace_array> {
        let v = unsafe { crate::bpf_probe_read(&self.tr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trace(&self) -> Option<*mut tracer> {
        let v = unsafe { crate::bpf_probe_read(&self.trace) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn array_buffer(&self) -> Option<*mut array_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.array_buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_file(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu_file) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn buffer_iter(&self) -> Option<*mut *mut ring_buffer_iter> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer_iter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iter_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.iter_flags) }.ok()
    }
    pub fn temp(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.temp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn temp_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.temp_size) }.ok()
    }
    pub fn tmp_seq(&self) -> Option<trace_seq> {
        unsafe { crate::bpf_probe_read(&self.tmp_seq) }.ok()
    }
    pub fn started(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.started) }.ok()
    }
    pub fn snapshot(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.snapshot) }.ok()
    }
    pub fn seq(&self) -> Option<trace_seq> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn ent(&self) -> Option<*mut trace_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.ent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lost_events(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lost_events) }.ok()
    }
    pub fn leftover(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.leftover) }.ok()
    }
    pub fn ent_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ent_size) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn ts(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ts) }.ok()
    }
    pub fn pos(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.pos) }.ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.idx) }.ok()
    }
}
impl trace_event_functions {
    pub fn trace(&self) -> Option<trace_print_func> {
        unsafe { crate::bpf_probe_read(&self.trace) }.ok()
    }
    pub fn raw(&self) -> Option<trace_print_func> {
        unsafe { crate::bpf_probe_read(&self.raw) }.ok()
    }
    pub fn hex(&self) -> Option<trace_print_func> {
        unsafe { crate::bpf_probe_read(&self.hex) }.ok()
    }
    pub fn binary(&self) -> Option<trace_print_func> {
        unsafe { crate::bpf_probe_read(&self.binary) }.ok()
    }
}
impl trace_event_fields {
    pub fn type_(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.size) }.ok()
    }
    pub fn align(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.align) }.ok()
    }
    pub fn is_signed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.is_signed) }.ok()
    }
    pub fn filter_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.filter_type) }.ok()
    }
    pub fn define_fields(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.define_fields) }.ok()
    }
}
impl trace_event_fields__bindgen_ty_1 {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.size) }.ok()
    }
    pub fn align(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.align) }.ok()
    }
    pub fn is_signed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.is_signed) }.ok()
    }
    pub fn filter_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.filter_type) }.ok()
    }
    pub fn define_fields(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.define_fields) }.ok()
    }
}
impl trace_event_fields__bindgen_ty_1__bindgen_ty_1 {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn align(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.align) }.ok()
    }
    pub fn is_signed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.is_signed) }.ok()
    }
    pub fn filter_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.filter_type) }.ok()
    }
}
impl trace_event_class {
    pub fn system(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.system) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn probe(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.probe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn perf_probe(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.perf_probe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_event_call,
                arg2: trace_reg::Type,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reg) }.ok()
    }
    pub fn fields_array(&self) -> Option<*mut trace_event_fields> {
        let v = unsafe { crate::bpf_probe_read(&self.fields_array) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn get_fields(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_event_call) -> *mut list_head>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_fields) }.ok()
    }
    pub fn fields(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fields) }.ok()
    }
    pub fn raw_init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.raw_init) }.ok()
    }
}
impl trace_buffer {}
impl trace_event_file {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn event_call(&self) -> Option<*mut trace_event_call> {
        let v = unsafe { crate::bpf_probe_read(&self.event_call) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter(&self) -> Option<*mut event_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tr(&self) -> Option<*mut trace_array> {
        let v = unsafe { crate::bpf_probe_read(&self.tr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn system(&self) -> Option<*mut trace_subsystem_dir> {
        let v = unsafe { crate::bpf_probe_read(&self.system) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn triggers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.triggers) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn sm_ref(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sm_ref) }.ok()
    }
    pub fn tm_ref(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tm_ref) }.ok()
    }
}
impl fwnode_operations {
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn put(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut fwnode_handle)>> {
        unsafe { crate::bpf_probe_read(&self.put) }.ok()
    }
    pub fn device_is_available(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const fwnode_handle) -> bool_>>
    {
        unsafe { crate::bpf_probe_read(&self.device_is_available) }.ok()
    }
    pub fn device_get_match_data(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const device,
            ) -> *const ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.device_get_match_data) }.ok()
    }
    pub fn property_present(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const ::aya_bpf_cty::c_char,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.property_present) }.ok()
    }
    pub fn property_read_int_array(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut ::aya_bpf_cty::c_void,
                arg5: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.property_read_int_array) }.ok()
    }
    pub fn property_read_string_array(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: *mut *const ::aya_bpf_cty::c_char,
                arg4: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.property_read_string_array) }.ok()
    }
    pub fn get_name(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_name) }.ok()
    }
    pub fn get_name_prefix(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_name_prefix) }.ok()
    }
    pub fn get_parent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_parent) }.ok()
    }
    pub fn get_next_child_node(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *mut fwnode_handle,
            ) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_next_child_node) }.ok()
    }
    pub fn get_named_child_node(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const ::aya_bpf_cty::c_char,
            ) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_named_child_node) }.ok()
    }
    pub fn get_reference_args(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: *const ::aya_bpf_cty::c_char,
                arg4: ::aya_bpf_cty::c_uint,
                arg5: ::aya_bpf_cty::c_uint,
                arg6: *mut fwnode_reference_args,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_reference_args) }.ok()
    }
    pub fn graph_get_next_endpoint(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *mut fwnode_handle,
            ) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.graph_get_next_endpoint) }.ok()
    }
    pub fn graph_get_remote_endpoint(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.graph_get_remote_endpoint) }.ok()
    }
    pub fn graph_get_port_parent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.graph_get_port_parent) }.ok()
    }
    pub fn graph_parse_endpoint(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const fwnode_handle,
                arg2: *mut fwnode_endpoint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.graph_parse_endpoint) }.ok()
    }
    pub fn add_links(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut fwnode_handle) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.add_links) }.ok()
    }
}
impl fwnode_endpoint {
    pub fn port(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn local_fwnode(&self) -> Option<*const fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.local_fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fwnode_reference_args {
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nargs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nargs) }.ok()
    }
    pub fn args(&self) -> Option<[u64_; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.args) }.ok()
    }
}
impl property {
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn length(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn value(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.value) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut property> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_fwspec {
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn param_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.param_count) }.ok()
    }
    pub fn param(&self) -> Option<[u32_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.param) }.ok()
    }
}
impl irq_domain_ops {
    pub fn match_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: *mut device_node,
                arg3: irq_domain_bus_token::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.match_) }.ok()
    }
    pub fn select(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: *mut irq_fwspec,
                arg3: irq_domain_bus_token::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.select) }.ok()
    }
    pub fn map(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: irq_hw_number_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn unmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut irq_domain, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unmap) }.ok()
    }
    pub fn xlate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: *mut device_node,
                arg3: *const u32_,
                arg4: ::aya_bpf_cty::c_uint,
                arg5: *mut ::aya_bpf_cty::c_ulong,
                arg6: *mut ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.xlate) }.ok()
    }
    pub fn alloc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.alloc) }.ok()
    }
    pub fn free(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn activate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: *mut irq_data,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.activate) }.ok()
    }
    pub fn deactivate(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_domain, arg2: *mut irq_data)>,
    > {
        unsafe { crate::bpf_probe_read(&self.deactivate) }.ok()
    }
    pub fn translate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_domain,
                arg2: *mut irq_fwspec,
                arg3: *mut ::aya_bpf_cty::c_ulong,
                arg4: *mut ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.translate) }.ok()
    }
}
impl gendisk {
    pub fn major(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.major) }.ok()
    }
    pub fn first_minor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.first_minor) }.ok()
    }
    pub fn minors(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.minors) }.ok()
    }
    pub fn disk_name(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.disk_name) }.ok()
    }
    pub fn events(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn event_flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.event_flags) }.ok()
    }
    pub fn part_tbl(&self) -> Option<*mut disk_part_tbl> {
        let v = unsafe { crate::bpf_probe_read(&self.part_tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn part0(&self) -> Option<*mut block_device> {
        let v = unsafe { crate::bpf_probe_read(&self.part0) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fops(&self) -> Option<*const block_device_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.fops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn slave_dir(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.slave_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn random(&self) -> Option<*mut timer_rand_state> {
        let v = unsafe { crate::bpf_probe_read(&self.random) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sync_io(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sync_io) }.ok()
    }
    pub fn ev(&self) -> Option<*mut disk_events> {
        let v = unsafe { crate::bpf_probe_read(&self.ev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn integrity_kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.integrity_kobj) }.ok()
    }
    pub fn cdi(&self) -> Option<*mut cdrom_device_info> {
        let v = unsafe { crate::bpf_probe_read(&self.cdi) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node_id) }.ok()
    }
    pub fn bb(&self) -> Option<*mut badblocks> {
        let v = unsafe { crate::bpf_probe_read(&self.bb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lockdep_map(&self) -> Option<lockdep_map> {
        unsafe { crate::bpf_probe_read(&self.lockdep_map) }.ok()
    }
}
impl partition_meta_info {
    pub fn uuid(&self) -> Option<[::aya_bpf_cty::c_char; 37usize]> {
        unsafe { crate::bpf_probe_read(&self.uuid) }.ok()
    }
    pub fn volname(&self) -> Option<[u8_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.volname) }.ok()
    }
}
impl bio_integrity_payload {
    pub fn bip_bio(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.bip_bio) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bip_iter(&self) -> Option<bvec_iter> {
        unsafe { crate::bpf_probe_read(&self.bip_iter) }.ok()
    }
    pub fn bip_slab(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bip_slab) }.ok()
    }
    pub fn bip_vcnt(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bip_vcnt) }.ok()
    }
    pub fn bip_max_vcnt(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bip_max_vcnt) }.ok()
    }
    pub fn bip_flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.bip_flags) }.ok()
    }
    pub fn bio_iter(&self) -> Option<bvec_iter> {
        unsafe { crate::bpf_probe_read(&self.bio_iter) }.ok()
    }
    pub fn bip_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.bip_work) }.ok()
    }
    pub fn bip_vec(&self) -> Option<*mut bio_vec> {
        let v = unsafe { crate::bpf_probe_read(&self.bip_vec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bip_inline_vecs(&self) -> Option<__IncompleteArrayField<bio_vec>> {
        unsafe { crate::bpf_probe_read(&self.bip_inline_vecs) }.ok()
    }
}
impl blkg_iostat {
    pub fn bytes(&self) -> Option<[u64_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn ios(&self) -> Option<[u64_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.ios) }.ok()
    }
}
impl blkg_iostat_set {
    pub fn sync(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.sync) }.ok()
    }
    pub fn cur(&self) -> Option<blkg_iostat> {
        unsafe { crate::bpf_probe_read(&self.cur) }.ok()
    }
    pub fn last(&self) -> Option<blkg_iostat> {
        unsafe { crate::bpf_probe_read(&self.last) }.ok()
    }
}
impl blkcg_gq {
    pub fn q(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn q_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.q_node) }.ok()
    }
    pub fn blkcg_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.blkcg_node) }.ok()
    }
    pub fn blkcg(&self) -> Option<*mut blkcg> {
        let v = unsafe { crate::bpf_probe_read(&self.blkcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent(&self) -> Option<*mut blkcg_gq> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn online(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.online) }.ok()
    }
    pub fn iostat_cpu(&self) -> Option<*mut blkg_iostat_set> {
        let v = unsafe { crate::bpf_probe_read(&self.iostat_cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iostat(&self) -> Option<blkg_iostat_set> {
        unsafe { crate::bpf_probe_read(&self.iostat) }.ok()
    }
    pub fn pd(&self) -> Option<[*mut blkg_policy_data; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.pd) }.ok()
    }
    pub fn async_bio_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.async_bio_lock) }.ok()
    }
    pub fn async_bios(&self) -> Option<bio_list> {
        unsafe { crate::bpf_probe_read(&self.async_bios) }.ok()
    }
    pub fn async_bio_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.async_bio_work) }.ok()
    }
    pub fn use_delay(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.use_delay) }.ok()
    }
    pub fn delay_nsec(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.delay_nsec) }.ok()
    }
    pub fn delay_start(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.delay_start) }.ok()
    }
    pub fn last_delay(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_delay) }.ok()
    }
    pub fn last_use(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.last_use) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
}
impl disk_part_tbl {
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn last_lookup(&self) -> Option<*mut block_device> {
        let v = unsafe { crate::bpf_probe_read(&self.last_lookup) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn part(&self) -> Option<__IncompleteArrayField<*mut block_device>> {
        unsafe { crate::bpf_probe_read(&self.part) }.ok()
    }
}
impl blk_integrity_profile {
    pub fn generate_fn(&self) -> Option<integrity_processing_fn> {
        unsafe { crate::bpf_probe_read(&self.generate_fn) }.ok()
    }
    pub fn verify_fn(&self) -> Option<integrity_processing_fn> {
        unsafe { crate::bpf_probe_read(&self.verify_fn) }.ok()
    }
    pub fn prepare_fn(&self) -> Option<integrity_prepare_fn> {
        unsafe { crate::bpf_probe_read(&self.prepare_fn) }.ok()
    }
    pub fn complete_fn(&self) -> Option<integrity_complete_fn> {
        unsafe { crate::bpf_probe_read(&self.complete_fn) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl block_device_operations {
    pub fn submit_bio(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bio) -> blk_qc_t>> {
        unsafe { crate::bpf_probe_read(&self.submit_bio) }.ok()
    }
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut block_device, arg2: fmode_t) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk, arg2: fmode_t)>>
    {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn rw_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: sector_t,
                arg3: *mut page,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rw_page) }.ok()
    }
    pub fn ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: fmode_t,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ioctl) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: fmode_t,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn check_events(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut gendisk,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_events) }.ok()
    }
    pub fn unlock_native_capacity(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>> {
        unsafe { crate::bpf_probe_read(&self.unlock_native_capacity) }.ok()
    }
    pub fn revalidate_disk(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.revalidate_disk) }.ok()
    }
    pub fn getgeo(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: *mut hd_geometry,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getgeo) }.ok()
    }
    pub fn set_read_only(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut block_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_read_only) }.ok()
    }
    pub fn swap_slot_free_notify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut block_device, arg2: ::aya_bpf_cty::c_ulong),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.swap_slot_free_notify) }.ok()
    }
    pub fn report_zones(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut gendisk,
                arg2: sector_t,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: report_zones_cb,
                arg5: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.report_zones) }.ok()
    }
    pub fn devnode(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut gendisk,
                arg2: *mut umode_t,
            ) -> *mut ::aya_bpf_cty::c_char,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devnode) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pr_ops(&self) -> Option<*const pr_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.pr_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sg_io_v4 {
    pub fn guard(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.guard) }.ok()
    }
    pub fn protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn subprotocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.subprotocol) }.ok()
    }
    pub fn request_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.request_len) }.ok()
    }
    pub fn request(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.request) }.ok()
    }
    pub fn request_tag(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.request_tag) }.ok()
    }
    pub fn request_attr(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.request_attr) }.ok()
    }
    pub fn request_priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.request_priority) }.ok()
    }
    pub fn request_extra(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.request_extra) }.ok()
    }
    pub fn max_response_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_response_len) }.ok()
    }
    pub fn response(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.response) }.ok()
    }
    pub fn dout_iovec_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dout_iovec_count) }.ok()
    }
    pub fn dout_xfer_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dout_xfer_len) }.ok()
    }
    pub fn din_iovec_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.din_iovec_count) }.ok()
    }
    pub fn din_xfer_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.din_xfer_len) }.ok()
    }
    pub fn dout_xferp(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.dout_xferp) }.ok()
    }
    pub fn din_xferp(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.din_xferp) }.ok()
    }
    pub fn timeout(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn usr_ptr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.usr_ptr) }.ok()
    }
    pub fn spare_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.spare_in) }.ok()
    }
    pub fn driver_status(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.driver_status) }.ok()
    }
    pub fn transport_status(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.transport_status) }.ok()
    }
    pub fn device_status(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.device_status) }.ok()
    }
    pub fn retry_delay(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.retry_delay) }.ok()
    }
    pub fn info(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn duration(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.duration) }.ok()
    }
    pub fn response_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.response_len) }.ok()
    }
    pub fn din_resid(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.din_resid) }.ok()
    }
    pub fn dout_resid(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.dout_resid) }.ok()
    }
    pub fn generated_tag(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.generated_tag) }.ok()
    }
    pub fn spare_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.spare_out) }.ok()
    }
    pub fn padding(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
}
impl bsg_ops {
    pub fn check_proto(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sg_io_v4) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.check_proto) }.ok()
    }
    pub fn fill_hdr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut request,
                arg2: *mut sg_io_v4,
                arg3: fmode_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_hdr) }.ok()
    }
    pub fn complete_rq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut request, arg2: *mut sg_io_v4) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.complete_rq) }.ok()
    }
    pub fn free_rq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.free_rq) }.ok()
    }
}
impl request {
    pub fn q(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_ctx(&self) -> Option<*mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_hctx(&self) -> Option<*mut blk_mq_hw_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_hctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cmd_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cmd_flags) }.ok()
    }
    pub fn rq_flags(&self) -> Option<req_flags_t> {
        unsafe { crate::bpf_probe_read(&self.rq_flags) }.ok()
    }
    pub fn tag(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tag) }.ok()
    }
    pub fn internal_tag(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.internal_tag) }.ok()
    }
    pub fn __data_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__data_len) }.ok()
    }
    pub fn __sector(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.__sector) }.ok()
    }
    pub fn bio(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.bio) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn biotail(&self) -> Option<*mut bio> {
        let v = unsafe { crate::bpf_probe_read(&self.biotail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queuelist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.queuelist) }.ok()
    }
    pub fn hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hash) }.ok()
    }
    pub fn ipi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipi_list) }.ok()
    }
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.rb_node) }.ok()
    }
    pub fn special_vec(&self) -> Option<bio_vec> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.special_vec) }.ok()
    }
    pub fn completion_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.completion_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn error_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.error_count) }.ok()
    }
    pub fn elv(&self) -> Option<request__bindgen_ty_3__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.elv) }.ok()
    }
    pub fn flush(&self) -> Option<request__bindgen_ty_3__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.flush) }.ok()
    }
    pub fn rq_disk(&self) -> Option<*mut gendisk> {
        let v = unsafe { crate::bpf_probe_read(&self.rq_disk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn part(&self) -> Option<*mut block_device> {
        let v = unsafe { crate::bpf_probe_read(&self.part) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn alloc_time_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.alloc_time_ns) }.ok()
    }
    pub fn start_time_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.start_time_ns) }.ok()
    }
    pub fn io_start_time_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.io_start_time_ns) }.ok()
    }
    pub fn wbt_flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.wbt_flags) }.ok()
    }
    pub fn stats_sectors(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.stats_sectors) }.ok()
    }
    pub fn nr_phys_segments(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.nr_phys_segments) }.ok()
    }
    pub fn nr_integrity_segments(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.nr_integrity_segments) }.ok()
    }
    pub fn crypt_ctx(&self) -> Option<*mut bio_crypt_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.crypt_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn crypt_keyslot(&self) -> Option<*mut blk_ksm_keyslot> {
        let v = unsafe { crate::bpf_probe_read(&self.crypt_keyslot) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn write_hint(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.write_hint) }.ok()
    }
    pub fn ioprio(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ioprio) }.ok()
    }
    pub fn state(&self) -> Option<mq_rq_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn ref_(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn deadline(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.deadline) }.ok()
    }
    pub fn csd(&self) -> Option<__call_single_data> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.csd) }.ok()
    }
    pub fn fifo_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.fifo_time) }.ok()
    }
    pub fn end_io(&self) -> Option<rq_end_io_fn> {
        unsafe { crate::bpf_probe_read(&self.end_io) }.ok()
    }
    pub fn end_io_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.end_io_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl request__bindgen_ty_1 {
    pub fn hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn ipi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ipi_list) }.ok()
    }
}
impl request__bindgen_ty_2 {
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()
    }
    pub fn special_vec(&self) -> Option<bio_vec> {
        unsafe { crate::bpf_probe_read(&self.special_vec) }.ok()
    }
    pub fn completion_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.completion_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn error_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.error_count) }.ok()
    }
}
impl request__bindgen_ty_3 {
    pub fn elv(&self) -> Option<request__bindgen_ty_3__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.elv) }.ok()
    }
    pub fn flush(&self) -> Option<request__bindgen_ty_3__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.flush) }.ok()
    }
}
impl request__bindgen_ty_3__bindgen_ty_1 {
    pub fn icq(&self) -> Option<*mut io_cq> {
        let v = unsafe { crate::bpf_probe_read(&self.icq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<[*mut ::aya_bpf_cty::c_void; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.priv_) }.ok()
    }
}
impl request__bindgen_ty_3__bindgen_ty_2 {
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn saved_end_io(&self) -> Option<rq_end_io_fn> {
        unsafe { crate::bpf_probe_read(&self.saved_end_io) }.ok()
    }
}
impl request__bindgen_ty_4 {
    pub fn csd(&self) -> Option<__call_single_data> {
        unsafe { crate::bpf_probe_read(&self.csd) }.ok()
    }
    pub fn fifo_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.fifo_time) }.ok()
    }
}
impl blk_zone {
    pub fn start(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn len(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn wp(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.wp) }.ok()
    }
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn cond(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.cond) }.ok()
    }
    pub fn non_seq(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.non_seq) }.ok()
    }
    pub fn reset(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn resv(&self) -> Option<[__u8; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.resv) }.ok()
    }
    pub fn capacity(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.capacity) }.ok()
    }
    pub fn reserved(&self) -> Option<[__u8; 24usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl elevator_mq_ops {
    pub fn init_sched(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut request_queue,
                arg2: *mut elevator_type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init_sched) }.ok()
    }
    pub fn exit_sched(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>> {
        unsafe { crate::bpf_probe_read(&self.exit_sched) }.ok()
    }
    pub fn init_hctx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_hw_ctx,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init_hctx) }.ok()
    }
    pub fn exit_hctx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.exit_hctx) }.ok()
    }
    pub fn depth_updated(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>> {
        unsafe { crate::bpf_probe_read(&self.depth_updated) }.ok()
    }
    pub fn allow_merge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut request_queue,
                arg2: *mut request,
                arg3: *mut bio,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.allow_merge) }.ok()
    }
    pub fn bio_merge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_hw_ctx,
                arg2: *mut bio,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bio_merge) }.ok()
    }
    pub fn request_merge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut request_queue,
                arg2: *mut *mut request,
                arg3: *mut bio,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.request_merge) }.ok()
    }
    pub fn request_merged(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut request_queue,
                arg2: *mut request,
                arg3: elv_merge::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.request_merged) }.ok()
    }
    pub fn requests_merged(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.requests_merged) }.ok()
    }
    pub fn limit_depth(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: ::aya_bpf_cty::c_uint, arg2: *mut blk_mq_alloc_data),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.limit_depth) }.ok()
    }
    pub fn prepare_request(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.prepare_request) }.ok()
    }
    pub fn finish_request(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.finish_request) }.ok()
    }
    pub fn insert_requests(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut list_head, arg3: bool_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.insert_requests) }.ok()
    }
    pub fn dispatch_request(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> *mut request>,
    > {
        unsafe { crate::bpf_probe_read(&self.dispatch_request) }.ok()
    }
    pub fn has_work(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>>
    {
        unsafe { crate::bpf_probe_read(&self.has_work) }.ok()
    }
    pub fn completed_request(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: u64_)>> {
        unsafe { crate::bpf_probe_read(&self.completed_request) }.ok()
    }
    pub fn requeue_request(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.requeue_request) }.ok()
    }
    pub fn former_request(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.former_request) }.ok()
    }
    pub fn next_request(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.next_request) }.ok()
    }
    pub fn init_icq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>> {
        unsafe { crate::bpf_probe_read(&self.init_icq) }.ok()
    }
    pub fn exit_icq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>> {
        unsafe { crate::bpf_probe_read(&self.exit_icq) }.ok()
    }
}
impl elevator_type {
    pub fn icq_cache(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.icq_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<elevator_mq_ops> {
        unsafe { crate::bpf_probe_read(&self.ops) }.ok()
    }
    pub fn icq_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.icq_size) }.ok()
    }
    pub fn icq_align(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.icq_align) }.ok()
    }
    pub fn elevator_attrs(&self) -> Option<*mut elv_fs_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elevator_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elevator_alias(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator_alias) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elevator_features(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.elevator_features) }.ok()
    }
    pub fn elevator_owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator_owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_debugfs_attrs(&self) -> Option<*const blk_mq_debugfs_attr> {
        let v = unsafe { crate::bpf_probe_read(&self.queue_debugfs_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hctx_debugfs_attrs(&self) -> Option<*const blk_mq_debugfs_attr> {
        let v = unsafe { crate::bpf_probe_read(&self.hctx_debugfs_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icq_cache_name(&self) -> Option<[::aya_bpf_cty::c_char; 22usize]> {
        unsafe { crate::bpf_probe_read(&self.icq_cache_name) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl elevator_queue {
    pub fn type_(&self) -> Option<*mut elevator_type> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn elevator_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.elevator_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn sysfs_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.sysfs_lock) }.ok()
    }
    pub fn hash(&self) -> Option<[hlist_head; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
}
impl elv_fs_entry {
    pub fn attr(&self) -> Option<attribute> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut elevator_queue,
                arg2: *mut ::aya_bpf_cty::c_char,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
    pub fn store(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut elevator_queue,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.store) }.ok()
    }
}
impl blk_mq_debugfs_attr {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_void,
                arg2: *mut seq_file,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_void,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn seq_ops(&self) -> Option<*const seq_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.seq_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_mq_ops {
    pub fn queue_rq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_hw_ctx,
                arg2: *const blk_mq_queue_data,
            ) -> blk_status_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.queue_rq) }.ok()
    }
    pub fn commit_rqs(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>> {
        unsafe { crate::bpf_probe_read(&self.commit_rqs) }.ok()
    }
    pub fn get_budget(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>>
    {
        unsafe { crate::bpf_probe_read(&self.get_budget) }.ok()
    }
    pub fn put_budget(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue)>> {
        unsafe { crate::bpf_probe_read(&self.put_budget) }.ok()
    }
    pub fn timeout(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut request, arg2: bool_) -> blk_eh_timer_return::Type,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn complete(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.complete) }.ok()
    }
    pub fn init_hctx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_hw_ctx,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init_hctx) }.ok()
    }
    pub fn exit_hctx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.exit_hctx) }.ok()
    }
    pub fn init_request(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_tag_set,
                arg2: *mut request,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init_request) }.ok()
    }
    pub fn exit_request(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_mq_tag_set,
                arg2: *mut request,
                arg3: ::aya_bpf_cty::c_uint,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.exit_request) }.ok()
    }
    pub fn initialize_rq_fn(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.initialize_rq_fn) }.ok()
    }
    pub fn cleanup_rq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>> {
        unsafe { crate::bpf_probe_read(&self.cleanup_rq) }.ok()
    }
    pub fn busy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>>
    {
        unsafe { crate::bpf_probe_read(&self.busy) }.ok()
    }
    pub fn map_queues(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut blk_mq_tag_set) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_queues) }.ok()
    }
    pub fn show_rq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut request)>>
    {
        unsafe { crate::bpf_probe_read(&self.show_rq) }.ok()
    }
}
impl blk_integrity_iter {
    pub fn prot_buf(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.prot_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_buf(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seed(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.seed) }.ok()
    }
    pub fn data_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.data_size) }.ok()
    }
    pub fn interval(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.interval) }.ok()
    }
    pub fn disk_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.disk_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl pr_ops {
    pub fn pr_register(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: u64_,
                arg3: u64_,
                arg4: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pr_register) }.ok()
    }
    pub fn pr_reserve(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: u64_,
                arg3: pr_type::Type,
                arg4: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pr_reserve) }.ok()
    }
    pub fn pr_release(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: u64_,
                arg3: pr_type::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pr_release) }.ok()
    }
    pub fn pr_preempt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut block_device,
                arg2: u64_,
                arg3: u64_,
                arg4: pr_type::Type,
                arg5: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pr_preempt) }.ok()
    }
    pub fn pr_clear(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut block_device, arg2: u64_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pr_clear) }.ok()
    }
}
impl blkcg {
    pub fn css(&self) -> Option<cgroup_subsys_state> {
        unsafe { crate::bpf_probe_read(&self.css) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn online_pin(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.online_pin) }.ok()
    }
    pub fn blkg_tree(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.blkg_tree) }.ok()
    }
    pub fn blkg_hint(&self) -> Option<*mut blkcg_gq> {
        let v = unsafe { crate::bpf_probe_read(&self.blkg_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blkg_list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.blkg_list) }.ok()
    }
    pub fn cpd(&self) -> Option<[*mut blkcg_policy_data; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.cpd) }.ok()
    }
    pub fn all_blkcgs_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.all_blkcgs_node) }.ok()
    }
    pub fn cgwb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cgwb_list) }.ok()
    }
}
impl blkcg_policy_data {
    pub fn blkcg(&self) -> Option<*mut blkcg> {
        let v = unsafe { crate::bpf_probe_read(&self.blkcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn plid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.plid) }.ok()
    }
}
impl blkg_policy_data {
    pub fn blkg(&self) -> Option<*mut blkcg_gq> {
        let v = unsafe { crate::bpf_probe_read(&self.blkg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn plid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.plid) }.ok()
    }
}
impl memcg_vmstats_percpu {
    pub fn stat(&self) -> Option<[::aya_bpf_cty::c_long; 41usize]> {
        unsafe { crate::bpf_probe_read(&self.stat) }.ok()
    }
    pub fn events(&self) -> Option<[::aya_bpf_cty::c_ulong; 96usize]> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn nr_page_events(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_page_events) }.ok()
    }
    pub fn targets(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.targets) }.ok()
    }
}
impl mem_cgroup_reclaim_iter {
    pub fn position(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.position) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn generation(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.generation) }.ok()
    }
}
impl lruvec_stat {
    pub fn count(&self) -> Option<[::aya_bpf_cty::c_long; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl memcg_shrinker_map {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn map(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
}
impl mem_cgroup_per_node {
    pub fn lruvec(&self) -> Option<lruvec> {
        unsafe { crate::bpf_probe_read(&self.lruvec) }.ok()
    }
    pub fn lruvec_stat_local(&self) -> Option<*mut lruvec_stat> {
        let v = unsafe { crate::bpf_probe_read(&self.lruvec_stat_local) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lruvec_stat_cpu(&self) -> Option<*mut lruvec_stat> {
        let v = unsafe { crate::bpf_probe_read(&self.lruvec_stat_cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lruvec_stat(&self) -> Option<[atomic_long_t; 38usize]> {
        unsafe { crate::bpf_probe_read(&self.lruvec_stat) }.ok()
    }
    pub fn lru_zone_size(&self) -> Option<[::aya_bpf_cty::c_ulong; 25usize]> {
        unsafe { crate::bpf_probe_read(&self.lru_zone_size) }.ok()
    }
    pub fn iter(&self) -> Option<mem_cgroup_reclaim_iter> {
        unsafe { crate::bpf_probe_read(&self.iter) }.ok()
    }
    pub fn shrinker_map(&self) -> Option<*mut memcg_shrinker_map> {
        let v = unsafe { crate::bpf_probe_read(&self.shrinker_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tree_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.tree_node) }.ok()
    }
    pub fn usage_in_excess(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.usage_in_excess) }.ok()
    }
    pub fn on_tree(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.on_tree) }.ok()
    }
    pub fn memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl eventfd_ctx {}
impl mem_cgroup_threshold {
    pub fn eventfd(&self) -> Option<*mut eventfd_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.eventfd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn threshold(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.threshold) }.ok()
    }
}
impl mem_cgroup_threshold_ary {
    pub fn current_threshold(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.current_threshold) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn entries(&self) -> Option<__IncompleteArrayField<mem_cgroup_threshold>> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
}
impl obj_cgroup {
    pub fn refcnt(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_charged_bytes(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_charged_bytes) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.list) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
}
impl obj_cgroup__bindgen_ty_1 {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl percpu_cluster {
    pub fn index(&self) -> Option<swap_cluster_info> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn next(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.next) }.ok()
    }
}
impl fs_parameter {
    pub fn key(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn string(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.string) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blob(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.blob) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*mut filename> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn dirfd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dirfd) }.ok()
    }
}
impl fs_parameter__bindgen_ty_1 {
    pub fn string(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.string) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blob(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.blob) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*mut filename> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fc_log {
    pub fn usage(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn head(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn tail(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
    pub fn need_free(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.need_free) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn buffer(&self) -> Option<[*mut ::aya_bpf_cty::c_char; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.buffer) }.ok()
    }
}
impl fs_context_operations {
    pub fn free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context)>> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn dup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fs_context,
                arg2: *mut fs_context,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dup) }.ok()
    }
    pub fn parse_param(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fs_context,
                arg2: *mut fs_parameter,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.parse_param) }.ok()
    }
    pub fn parse_monolithic(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fs_context,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.parse_monolithic) }.ok()
    }
    pub fn get_tree(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_tree) }.ok()
    }
    pub fn reconfigure(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.reconfigure) }.ok()
    }
}
impl fs_parse_result {
    pub fn negated(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.negated) }.ok()
    }
    pub fn boolean(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.boolean) }.ok()
    }
    pub fn int_32(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.int_32) }.ok()
    }
    pub fn uint_32(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.uint_32) }.ok()
    }
    pub fn uint_64(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.uint_64) }.ok()
    }
}
impl fs_parse_result__bindgen_ty_1 {
    pub fn boolean(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.boolean) }.ok()
    }
    pub fn int_32(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.int_32) }.ok()
    }
    pub fn uint_32(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.uint_32) }.ok()
    }
    pub fn uint_64(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.uint_64) }.ok()
    }
}
impl notifier_block {
    pub fn notifier_call(&self) -> Option<notifier_fn_t> {
        unsafe { crate::bpf_probe_read(&self.notifier_call) }.ok()
    }
    pub fn next(&self) -> Option<*mut notifier_block> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priority(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
}
impl blocking_notifier_head {
    pub fn rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.rwsem) }.ok()
    }
    pub fn head(&self) -> Option<*mut notifier_block> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl raw_notifier_head {
    pub fn head(&self) -> Option<*mut notifier_block> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl possible_net_t {
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl in6_addr {
    pub fn in6_u(&self) -> Option<in6_addr__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.in6_u) }.ok()
    }
}
impl in6_addr__bindgen_ty_1 {
    pub fn u6_addr8(&self) -> Option<[__u8; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.u6_addr8) }.ok()
    }
    pub fn u6_addr16(&self) -> Option<[__be16; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.u6_addr16) }.ok()
    }
    pub fn u6_addr32(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.u6_addr32) }.ok()
    }
}
impl hlist_nulls_node {
    pub fn next(&self) -> Option<*mut hlist_nulls_node> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pprev(&self) -> Option<*mut *mut hlist_nulls_node> {
        let v = unsafe { crate::bpf_probe_read(&self.pprev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sock_common {
    pub fn skc_addrpair(&self) -> Option<__addrpair> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.skc_addrpair) }.ok()
    }
    pub fn skc_daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.skc_daddr) }.ok()
    }
    pub fn skc_rcv_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.skc_rcv_saddr) }.ok()
    }
    pub fn skc_hash(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.skc_hash) }.ok()
    }
    pub fn skc_u16hashes(&self) -> Option<[__u16; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.skc_u16hashes) }.ok()
    }
    pub fn skc_portpair(&self) -> Option<__portpair> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.skc_portpair) }.ok()
    }
    pub fn skc_dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.skc_dport) }.ok()
    }
    pub fn skc_num(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.skc_num) }.ok()
    }
    pub fn skc_family(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.skc_family) }.ok()
    }
    pub fn skc_state(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.skc_state) }.ok()
    }
    pub fn skc_bound_dev_if(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.skc_bound_dev_if) }.ok()
    }
    pub fn skc_bind_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.skc_bind_node) }.ok()
    }
    pub fn skc_portaddr_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.skc_portaddr_node) }.ok()
    }
    pub fn skc_prot(&self) -> Option<*mut proto> {
        let v = unsafe { crate::bpf_probe_read(&self.skc_prot) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skc_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.skc_net) }.ok()
    }
    pub fn skc_v6_daddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.skc_v6_daddr) }.ok()
    }
    pub fn skc_v6_rcv_saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.skc_v6_rcv_saddr) }.ok()
    }
    pub fn skc_cookie(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.skc_cookie) }.ok()
    }
    pub fn skc_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.skc_flags) }.ok()
    }
    pub fn skc_listener(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.skc_listener) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skc_tw_dr(&self) -> Option<*mut inet_timewait_death_row> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.skc_tw_dr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skc_dontcopy_begin(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_int>> {
        unsafe { crate::bpf_probe_read(&self.skc_dontcopy_begin) }.ok()
    }
    pub fn skc_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.skc_node) }.ok()
    }
    pub fn skc_nulls_node(&self) -> Option<hlist_nulls_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.skc_nulls_node) }.ok()
    }
    pub fn skc_tx_queue_mapping(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.skc_tx_queue_mapping) }.ok()
    }
    pub fn skc_rx_queue_mapping(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.skc_rx_queue_mapping) }.ok()
    }
    pub fn skc_incoming_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.skc_incoming_cpu) }.ok()
    }
    pub fn skc_rcv_wnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.skc_rcv_wnd) }.ok()
    }
    pub fn skc_tw_rcv_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.skc_tw_rcv_nxt) }.ok()
    }
    pub fn skc_refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.skc_refcnt) }.ok()
    }
    pub fn skc_dontcopy_end(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_int>> {
        unsafe { crate::bpf_probe_read(&self.skc_dontcopy_end) }.ok()
    }
    pub fn skc_rxhash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_8.skc_rxhash) }.ok()
    }
    pub fn skc_window_clamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_8.skc_window_clamp) }.ok()
    }
    pub fn skc_tw_snd_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_8.skc_tw_snd_nxt) }.ok()
    }
}
impl sock_common__bindgen_ty_1 {
    pub fn skc_addrpair(&self) -> Option<__addrpair> {
        unsafe { crate::bpf_probe_read(&self.skc_addrpair) }.ok()
    }
    pub fn skc_daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.skc_daddr) }.ok()
    }
    pub fn skc_rcv_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.skc_rcv_saddr) }.ok()
    }
}
impl sock_common__bindgen_ty_1__bindgen_ty_1 {
    pub fn skc_daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.skc_daddr) }.ok()
    }
    pub fn skc_rcv_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.skc_rcv_saddr) }.ok()
    }
}
impl sock_common__bindgen_ty_2 {
    pub fn skc_hash(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.skc_hash) }.ok()
    }
    pub fn skc_u16hashes(&self) -> Option<[__u16; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.skc_u16hashes) }.ok()
    }
}
impl sock_common__bindgen_ty_3 {
    pub fn skc_portpair(&self) -> Option<__portpair> {
        unsafe { crate::bpf_probe_read(&self.skc_portpair) }.ok()
    }
    pub fn skc_dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.skc_dport) }.ok()
    }
    pub fn skc_num(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.skc_num) }.ok()
    }
}
impl sock_common__bindgen_ty_3__bindgen_ty_1 {
    pub fn skc_dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.skc_dport) }.ok()
    }
    pub fn skc_num(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.skc_num) }.ok()
    }
}
impl sock_common__bindgen_ty_4 {
    pub fn skc_bind_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.skc_bind_node) }.ok()
    }
    pub fn skc_portaddr_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.skc_portaddr_node) }.ok()
    }
}
impl sock_common__bindgen_ty_5 {
    pub fn skc_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.skc_flags) }.ok()
    }
    pub fn skc_listener(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.skc_listener) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skc_tw_dr(&self) -> Option<*mut inet_timewait_death_row> {
        let v = unsafe { crate::bpf_probe_read(&self.skc_tw_dr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sock_common__bindgen_ty_6 {
    pub fn skc_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.skc_node) }.ok()
    }
    pub fn skc_nulls_node(&self) -> Option<hlist_nulls_node> {
        unsafe { crate::bpf_probe_read(&self.skc_nulls_node) }.ok()
    }
}
impl sock_common__bindgen_ty_7 {
    pub fn skc_incoming_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.skc_incoming_cpu) }.ok()
    }
    pub fn skc_rcv_wnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.skc_rcv_wnd) }.ok()
    }
    pub fn skc_tw_rcv_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.skc_tw_rcv_nxt) }.ok()
    }
}
impl sock_common__bindgen_ty_8 {
    pub fn skc_rxhash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.skc_rxhash) }.ok()
    }
    pub fn skc_window_clamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.skc_window_clamp) }.ok()
    }
    pub fn skc_tw_snd_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.skc_tw_snd_nxt) }.ok()
    }
}
impl socket_lock_t {
    pub fn slock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.slock) }.ok()
    }
    pub fn owned(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.owned) }.ok()
    }
    pub fn wq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wq) }.ok()
    }
}
impl sk_buff_head {
    pub fn next(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qlen(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl sock_cgroup_data {
    pub fn padding(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.padding) }.ok()
    }
    pub fn prioidx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.prioidx) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.classid) }.ok()
    }
    pub fn val(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.val) }.ok()
    }
}
impl sock_cgroup_data__bindgen_ty_1 {
    pub fn padding(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.padding) }.ok()
    }
    pub fn prioidx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.prioidx) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.classid) }.ok()
    }
    pub fn val(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl sock_cgroup_data__bindgen_ty_1__bindgen_ty_1 {
    pub fn padding(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn prioidx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.prioidx) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.classid) }.ok()
    }
}
impl sock {
    pub fn __sk_common(&self) -> Option<sock_common> {
        unsafe { crate::bpf_probe_read(&self.__sk_common) }.ok()
    }
    pub fn sk_lock(&self) -> Option<socket_lock_t> {
        unsafe { crate::bpf_probe_read(&self.sk_lock) }.ok()
    }
    pub fn sk_drops(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sk_drops) }.ok()
    }
    pub fn sk_rcvlowat(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_rcvlowat) }.ok()
    }
    pub fn sk_error_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.sk_error_queue) }.ok()
    }
    pub fn sk_rx_skb_cache(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_rx_skb_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_receive_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.sk_receive_queue) }.ok()
    }
    pub fn sk_backlog(&self) -> Option<sock__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.sk_backlog) }.ok()
    }
    pub fn sk_forward_alloc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_forward_alloc) }.ok()
    }
    pub fn sk_ll_usec(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sk_ll_usec) }.ok()
    }
    pub fn sk_napi_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sk_napi_id) }.ok()
    }
    pub fn sk_rcvbuf(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_rcvbuf) }.ok()
    }
    pub fn sk_filter(&self) -> Option<*mut sk_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_wq(&self) -> Option<*mut socket_wq> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sk_wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_wq_raw(&self) -> Option<*mut socket_wq> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sk_wq_raw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_policy(&self) -> Option<[*mut xfrm_policy; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.sk_policy) }.ok()
    }
    pub fn sk_rx_dst(&self) -> Option<*mut dst_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_rx_dst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_dst_cache(&self) -> Option<*mut dst_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_dst_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_omem_alloc(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sk_omem_alloc) }.ok()
    }
    pub fn sk_sndbuf(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_sndbuf) }.ok()
    }
    pub fn sk_wmem_queued(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_wmem_queued) }.ok()
    }
    pub fn sk_wmem_alloc(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.sk_wmem_alloc) }.ok()
    }
    pub fn sk_tsq_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sk_tsq_flags) }.ok()
    }
    pub fn sk_send_head(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.sk_send_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_rtx_queue(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.tcp_rtx_queue) }.ok()
    }
    pub fn sk_tx_skb_cache(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_tx_skb_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_write_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.sk_write_queue) }.ok()
    }
    pub fn sk_peek_off(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.sk_peek_off) }.ok()
    }
    pub fn sk_write_pending(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_write_pending) }.ok()
    }
    pub fn sk_dst_pending_confirm(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sk_dst_pending_confirm) }.ok()
    }
    pub fn sk_pacing_status(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sk_pacing_status) }.ok()
    }
    pub fn sk_sndtimeo(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sk_sndtimeo) }.ok()
    }
    pub fn sk_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.sk_timer) }.ok()
    }
    pub fn sk_priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sk_priority) }.ok()
    }
    pub fn sk_mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sk_mark) }.ok()
    }
    pub fn sk_pacing_rate(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sk_pacing_rate) }.ok()
    }
    pub fn sk_max_pacing_rate(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sk_max_pacing_rate) }.ok()
    }
    pub fn sk_frag(&self) -> Option<page_frag> {
        unsafe { crate::bpf_probe_read(&self.sk_frag) }.ok()
    }
    pub fn sk_route_caps(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.sk_route_caps) }.ok()
    }
    pub fn sk_route_nocaps(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.sk_route_nocaps) }.ok()
    }
    pub fn sk_route_forced_caps(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.sk_route_forced_caps) }.ok()
    }
    pub fn sk_gso_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_gso_type) }.ok()
    }
    pub fn sk_gso_max_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sk_gso_max_size) }.ok()
    }
    pub fn sk_allocation(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.sk_allocation) }.ok()
    }
    pub fn sk_txhash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sk_txhash) }.ok()
    }
    pub fn sk_pacing_shift(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sk_pacing_shift) }.ok()
    }
    pub fn sk_type(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sk_type) }.ok()
    }
    pub fn sk_protocol(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sk_protocol) }.ok()
    }
    pub fn sk_gso_max_segs(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sk_gso_max_segs) }.ok()
    }
    pub fn sk_lingertime(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sk_lingertime) }.ok()
    }
    pub fn sk_prot_creator(&self) -> Option<*mut proto> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_prot_creator) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_callback_lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.sk_callback_lock) }.ok()
    }
    pub fn sk_err(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_err) }.ok()
    }
    pub fn sk_err_soft(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sk_err_soft) }.ok()
    }
    pub fn sk_ack_backlog(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sk_ack_backlog) }.ok()
    }
    pub fn sk_max_ack_backlog(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sk_max_ack_backlog) }.ok()
    }
    pub fn sk_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.sk_uid) }.ok()
    }
    pub fn sk_prefer_busy_poll(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sk_prefer_busy_poll) }.ok()
    }
    pub fn sk_busy_poll_budget(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sk_busy_poll_budget) }.ok()
    }
    pub fn sk_peer_pid(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_peer_pid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_peer_cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_peer_cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_rcvtimeo(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.sk_rcvtimeo) }.ok()
    }
    pub fn sk_stamp(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.sk_stamp) }.ok()
    }
    pub fn sk_tsflags(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sk_tsflags) }.ok()
    }
    pub fn sk_shutdown(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sk_shutdown) }.ok()
    }
    pub fn sk_tskey(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sk_tskey) }.ok()
    }
    pub fn sk_zckey(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.sk_zckey) }.ok()
    }
    pub fn sk_clockid(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sk_clockid) }.ok()
    }
    pub fn sk_socket(&self) -> Option<*mut socket> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_socket) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_user_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_user_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_cgrp_data(&self) -> Option<sock_cgroup_data> {
        unsafe { crate::bpf_probe_read(&self.sk_cgrp_data) }.ok()
    }
    pub fn sk_memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_state_change(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_state_change) }.ok()
    }
    pub fn sk_data_ready(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_data_ready) }.ok()
    }
    pub fn sk_write_space(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_write_space) }.ok()
    }
    pub fn sk_error_report(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_error_report) }.ok()
    }
    pub fn sk_backlog_rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sk_backlog_rcv) }.ok()
    }
    pub fn sk_validate_xmit_skb(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut net_device,
                arg3: *mut sk_buff,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sk_validate_xmit_skb) }.ok()
    }
    pub fn sk_destruct(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_destruct) }.ok()
    }
    pub fn sk_reuseport_cb(&self) -> Option<*mut sock_reuseport> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_reuseport_cb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_bpf_storage(&self) -> Option<*mut bpf_local_storage> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_bpf_storage) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.sk_rcu) }.ok()
    }
}
impl sock__bindgen_ty_1 {
    pub fn rmem_alloc(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.rmem_alloc) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn head(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sock__bindgen_ty_2 {
    pub fn sk_wq(&self) -> Option<*mut socket_wq> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_wq_raw(&self) -> Option<*mut socket_wq> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_wq_raw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sock__bindgen_ty_3 {
    pub fn sk_send_head(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_send_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_rtx_queue(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.tcp_rtx_queue) }.ok()
    }
}
impl rhash_head {
    pub fn next(&self) -> Option<*mut rhash_head> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rhashtable_compare_arg {
    pub fn ht(&self) -> Option<*mut rhashtable> {
        let v = unsafe { crate::bpf_probe_read(&self.ht) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rhashtable_params {
    pub fn nelem_hint(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.nelem_hint) }.ok()
    }
    pub fn key_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.key_len) }.ok()
    }
    pub fn key_offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.key_offset) }.ok()
    }
    pub fn head_offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.head_offset) }.ok()
    }
    pub fn max_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_size) }.ok()
    }
    pub fn min_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.min_size) }.ok()
    }
    pub fn automatic_shrinking(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.automatic_shrinking) }.ok()
    }
    pub fn hashfn(&self) -> Option<rht_hashfn_t> {
        unsafe { crate::bpf_probe_read(&self.hashfn) }.ok()
    }
    pub fn obj_hashfn(&self) -> Option<rht_obj_hashfn_t> {
        unsafe { crate::bpf_probe_read(&self.obj_hashfn) }.ok()
    }
    pub fn obj_cmpfn(&self) -> Option<rht_obj_cmpfn_t> {
        unsafe { crate::bpf_probe_read(&self.obj_cmpfn) }.ok()
    }
}
impl rhashtable {
    pub fn tbl(&self) -> Option<*mut bucket_table> {
        let v = unsafe { crate::bpf_probe_read(&self.tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.key_len) }.ok()
    }
    pub fn max_elems(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_elems) }.ok()
    }
    pub fn p(&self) -> Option<rhashtable_params> {
        unsafe { crate::bpf_probe_read(&self.p) }.ok()
    }
    pub fn rhlist(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.rhlist) }.ok()
    }
    pub fn run_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.run_work) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nelems(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nelems) }.ok()
    }
}
impl fs_struct {
    pub fn users(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn seq(&self) -> Option<seqcount_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn umask(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.umask) }.ok()
    }
    pub fn in_exec(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.in_exec) }.ok()
    }
    pub fn root(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.root) }.ok()
    }
    pub fn pwd(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.pwd) }.ok()
    }
}
impl pipe_inode_info {
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn rd_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.rd_wait) }.ok()
    }
    pub fn wr_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wr_wait) }.ok()
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn tail(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
    pub fn max_usage(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_usage) }.ok()
    }
    pub fn ring_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ring_size) }.ok()
    }
    pub fn note_loss(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.note_loss) }.ok()
    }
    pub fn nr_accounted(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_accounted) }.ok()
    }
    pub fn readers(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.readers) }.ok()
    }
    pub fn writers(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.writers) }.ok()
    }
    pub fn files(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.files) }.ok()
    }
    pub fn r_counter(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.r_counter) }.ok()
    }
    pub fn w_counter(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.w_counter) }.ok()
    }
    pub fn tmp_page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.tmp_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fasync_readers(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fasync_readers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fasync_writers(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fasync_writers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bufs(&self) -> Option<*mut pipe_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.bufs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn watch_queue(&self) -> Option<*mut watch_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.watch_queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sockaddr {
    pub fn sa_family(&self) -> Option<sa_family_t> {
        unsafe { crate::bpf_probe_read(&self.sa_family) }.ok()
    }
    pub fn sa_data(&self) -> Option<[::aya_bpf_cty::c_char; 14usize]> {
        unsafe { crate::bpf_probe_read(&self.sa_data) }.ok()
    }
}
impl msghdr {
    pub fn msg_name(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_namelen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.msg_namelen) }.ok()
    }
    pub fn msg_iter(&self) -> Option<iov_iter> {
        unsafe { crate::bpf_probe_read(&self.msg_iter) }.ok()
    }
    pub fn msg_control(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.msg_control) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_control_user(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.msg_control_user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_controllen(&self) -> Option<__kernel_size_t> {
        unsafe { crate::bpf_probe_read(&self.msg_controllen) }.ok()
    }
    pub fn msg_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.msg_flags) }.ok()
    }
    pub fn msg_iocb(&self) -> Option<*mut kiocb> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_iocb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl msghdr__bindgen_ty_1 {
    pub fn msg_control(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_control) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_control_user(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_control_user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sync_serial_settings {
    pub fn clock_rate(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_rate) }.ok()
    }
    pub fn clock_type(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_type) }.ok()
    }
    pub fn loopback(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.loopback) }.ok()
    }
}
impl te1_settings {
    pub fn clock_rate(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_rate) }.ok()
    }
    pub fn clock_type(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_type) }.ok()
    }
    pub fn loopback(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.loopback) }.ok()
    }
    pub fn slot_map(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.slot_map) }.ok()
    }
}
impl raw_hdlc_proto {
    pub fn encoding(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.encoding) }.ok()
    }
    pub fn parity(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.parity) }.ok()
    }
}
impl fr_proto {
    pub fn t391(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.t391) }.ok()
    }
    pub fn t392(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.t392) }.ok()
    }
    pub fn n391(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n391) }.ok()
    }
    pub fn n392(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n392) }.ok()
    }
    pub fn n393(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n393) }.ok()
    }
    pub fn lmi(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.lmi) }.ok()
    }
    pub fn dce(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.dce) }.ok()
    }
}
impl fr_proto_pvc {
    pub fn dlci(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dlci) }.ok()
    }
}
impl fr_proto_pvc_info {
    pub fn dlci(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dlci) }.ok()
    }
    pub fn master(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.master) }.ok()
    }
}
impl cisco_proto {
    pub fn interval(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.interval) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
}
impl x25_hdlc_proto {
    pub fn dce(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.dce) }.ok()
    }
    pub fn modulo(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.modulo) }.ok()
    }
    pub fn window(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.window) }.ok()
    }
    pub fn t1(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.t1) }.ok()
    }
    pub fn t2(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.t2) }.ok()
    }
    pub fn n2(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n2) }.ok()
    }
}
impl ifmap {
    pub fn mem_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mem_start) }.ok()
    }
    pub fn mem_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mem_end) }.ok()
    }
    pub fn base_addr(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.base_addr) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn dma(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.dma) }.ok()
    }
    pub fn port(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl if_settings {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn ifs_ifsu(&self) -> Option<if_settings__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ifs_ifsu) }.ok()
    }
}
impl if_settings__bindgen_ty_1 {
    pub fn raw_hdlc(&self) -> Option<*mut raw_hdlc_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.raw_hdlc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cisco(&self) -> Option<*mut cisco_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.cisco) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fr(&self) -> Option<*mut fr_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.fr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fr_pvc(&self) -> Option<*mut fr_proto_pvc> {
        let v = unsafe { crate::bpf_probe_read(&self.fr_pvc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fr_pvc_info(&self) -> Option<*mut fr_proto_pvc_info> {
        let v = unsafe { crate::bpf_probe_read(&self.fr_pvc_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn x25(&self) -> Option<*mut x25_hdlc_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.x25) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sync(&self) -> Option<*mut sync_serial_settings> {
        let v = unsafe { crate::bpf_probe_read(&self.sync) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn te1(&self) -> Option<*mut te1_settings> {
        let v = unsafe { crate::bpf_probe_read(&self.te1) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ifreq {
    pub fn ifr_ifrn(&self) -> Option<ifreq__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ifr_ifrn) }.ok()
    }
    pub fn ifr_ifru(&self) -> Option<ifreq__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.ifr_ifru) }.ok()
    }
}
impl ifreq__bindgen_ty_1 {
    pub fn ifrn_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ifrn_name) }.ok()
    }
}
impl ifreq__bindgen_ty_2 {
    pub fn ifru_addr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ifru_addr) }.ok()
    }
    pub fn ifru_dstaddr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ifru_dstaddr) }.ok()
    }
    pub fn ifru_broadaddr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ifru_broadaddr) }.ok()
    }
    pub fn ifru_netmask(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ifru_netmask) }.ok()
    }
    pub fn ifru_hwaddr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ifru_hwaddr) }.ok()
    }
    pub fn ifru_flags(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.ifru_flags) }.ok()
    }
    pub fn ifru_ivalue(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifru_ivalue) }.ok()
    }
    pub fn ifru_mtu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifru_mtu) }.ok()
    }
    pub fn ifru_map(&self) -> Option<ifmap> {
        unsafe { crate::bpf_probe_read(&self.ifru_map) }.ok()
    }
    pub fn ifru_slave(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ifru_slave) }.ok()
    }
    pub fn ifru_newname(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ifru_newname) }.ok()
    }
    pub fn ifru_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ifru_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ifru_settings(&self) -> Option<if_settings> {
        unsafe { crate::bpf_probe_read(&self.ifru_settings) }.ok()
    }
}
impl vfsmount {
    pub fn mnt_root(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_sb(&self) -> Option<*mut super_block> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_sb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_flags) }.ok()
    }
}
impl ld_semaphore {
    pub fn count(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn wait_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.wait_lock) }.ok()
    }
    pub fn wait_readers(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.wait_readers) }.ok()
    }
    pub fn read_wait(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.read_wait) }.ok()
    }
    pub fn write_wait(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.write_wait) }.ok()
    }
}
impl ktermios {
    pub fn c_iflag(&self) -> Option<tcflag_t> {
        unsafe { crate::bpf_probe_read(&self.c_iflag) }.ok()
    }
    pub fn c_oflag(&self) -> Option<tcflag_t> {
        unsafe { crate::bpf_probe_read(&self.c_oflag) }.ok()
    }
    pub fn c_cflag(&self) -> Option<tcflag_t> {
        unsafe { crate::bpf_probe_read(&self.c_cflag) }.ok()
    }
    pub fn c_lflag(&self) -> Option<tcflag_t> {
        unsafe { crate::bpf_probe_read(&self.c_lflag) }.ok()
    }
    pub fn c_line(&self) -> Option<cc_t> {
        unsafe { crate::bpf_probe_read(&self.c_line) }.ok()
    }
    pub fn c_cc(&self) -> Option<[cc_t; 19usize]> {
        unsafe { crate::bpf_probe_read(&self.c_cc) }.ok()
    }
    pub fn c_ispeed(&self) -> Option<speed_t> {
        unsafe { crate::bpf_probe_read(&self.c_ispeed) }.ok()
    }
    pub fn c_ospeed(&self) -> Option<speed_t> {
        unsafe { crate::bpf_probe_read(&self.c_ospeed) }.ok()
    }
}
impl winsize {
    pub fn ws_row(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ws_row) }.ok()
    }
    pub fn ws_col(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ws_col) }.ok()
    }
    pub fn ws_xpixel(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ws_xpixel) }.ok()
    }
    pub fn ws_ypixel(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.ws_ypixel) }.ok()
    }
}
impl tty_struct {
    pub fn magic(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver(&self) -> Option<*mut tty_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.driver) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const tty_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn ldisc_sem(&self) -> Option<ld_semaphore> {
        unsafe { crate::bpf_probe_read(&self.ldisc_sem) }.ok()
    }
    pub fn ldisc(&self) -> Option<*mut tty_ldisc> {
        let v = unsafe { crate::bpf_probe_read(&self.ldisc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn atomic_write_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.atomic_write_lock) }.ok()
    }
    pub fn legacy_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.legacy_mutex) }.ok()
    }
    pub fn throttle_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.throttle_mutex) }.ok()
    }
    pub fn termios_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.termios_rwsem) }.ok()
    }
    pub fn winsize_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.winsize_mutex) }.ok()
    }
    pub fn ctrl_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.ctrl_lock) }.ok()
    }
    pub fn flow_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.flow_lock) }.ok()
    }
    pub fn termios(&self) -> Option<ktermios> {
        unsafe { crate::bpf_probe_read(&self.termios) }.ok()
    }
    pub fn termios_locked(&self) -> Option<ktermios> {
        unsafe { crate::bpf_probe_read(&self.termios_locked) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn pgrp(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.pgrp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn session(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.session) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn winsize(&self) -> Option<winsize> {
        unsafe { crate::bpf_probe_read(&self.winsize) }.ok()
    }
    pub fn hw_stopped(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.hw_stopped) }.ok()
    }
    pub fn receive_room(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.receive_room) }.ok()
    }
    pub fn flow_change(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flow_change) }.ok()
    }
    pub fn link(&self) -> Option<*mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.link) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fasync(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fasync) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn write_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.write_wait) }.ok()
    }
    pub fn read_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.read_wait) }.ok()
    }
    pub fn hangup_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.hangup_work) }.ok()
    }
    pub fn disc_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.disc_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn files_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.files_lock) }.ok()
    }
    pub fn tty_files(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tty_files) }.ok()
    }
    pub fn closing(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.closing) }.ok()
    }
    pub fn write_buf(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.write_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn write_cnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.write_cnt) }.ok()
    }
    pub fn SAK_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.SAK_work) }.ok()
    }
    pub fn port(&self) -> Option<*mut tty_port> {
        let v = unsafe { crate::bpf_probe_read(&self.port) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl read_descriptor_t {
    pub fn written(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.written) }.ok()
    }
    pub fn count(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn arg(&self) -> Option<read_descriptor_t__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.arg) }.ok()
    }
    pub fn error(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
}
impl read_descriptor_t__bindgen_ty_1 {
    pub fn buf(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl posix_acl_entry {
    pub fn e_tag(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.e_tag) }.ok()
    }
    pub fn e_perm(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.e_perm) }.ok()
    }
    pub fn e_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.e_uid) }.ok()
    }
    pub fn e_gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.e_gid) }.ok()
    }
}
impl posix_acl_entry__bindgen_ty_1 {
    pub fn e_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.e_uid) }.ok()
    }
    pub fn e_gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.e_gid) }.ok()
    }
}
impl posix_acl {
    pub fn a_refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.a_refcount) }.ok()
    }
    pub fn a_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.a_rcu) }.ok()
    }
    pub fn a_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.a_count) }.ok()
    }
    pub fn a_entries(&self) -> Option<__IncompleteArrayField<posix_acl_entry>> {
        unsafe { crate::bpf_probe_read(&self.a_entries) }.ok()
    }
}
impl tty_operations {
    pub fn lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_driver,
                arg2: *mut file,
                arg3: ::aya_bpf_cty::c_int,
            ) -> *mut tty_struct,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lookup) }.ok()
    }
    pub fn install(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_driver,
                arg2: *mut tty_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.install) }.ok()
    }
    pub fn remove(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_driver, arg2: *mut tty_struct)>,
    > {
        unsafe { crate::bpf_probe_read(&self.remove) }.ok()
    }
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn close(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file)>>
    {
        unsafe { crate::bpf_probe_read(&self.close) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn cleanup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.cleanup) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *const ::aya_bpf_cty::c_uchar,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn put_char(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: ::aya_bpf_cty::c_uchar,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.put_char) }.ok()
    }
    pub fn flush_chars(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.flush_chars) }.ok()
    }
    pub fn write_room(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.write_room) }.ok()
    }
    pub fn chars_in_buffer(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.chars_in_buffer) }.ok()
    }
    pub fn ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ioctl) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn set_termios(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut ktermios)>,
    > {
        unsafe { crate::bpf_probe_read(&self.set_termios) }.ok()
    }
    pub fn throttle(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.throttle) }.ok()
    }
    pub fn unthrottle(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.unthrottle) }.ok()
    }
    pub fn stop(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn start(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn hangup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.hangup) }.ok()
    }
    pub fn break_ctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.break_ctl) }.ok()
    }
    pub fn flush_buffer(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.flush_buffer) }.ok()
    }
    pub fn set_ldisc(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.set_ldisc) }.ok()
    }
    pub fn wait_until_sent(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.wait_until_sent) }.ok()
    }
    pub fn send_xchar(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_char),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.send_xchar) }.ok()
    }
    pub fn tiocmget(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.tiocmget) }.ok()
    }
    pub fn tiocmset(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tiocmset) }.ok()
    }
    pub fn resize(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut winsize) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.resize) }.ok()
    }
    pub fn get_icount(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut serial_icounter_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_icount) }.ok()
    }
    pub fn get_serial(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut serial_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_serial) }.ok()
    }
    pub fn set_serial(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut serial_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_serial) }.ok()
    }
    pub fn show_fdinfo(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut seq_file)>,
    > {
        unsafe { crate::bpf_probe_read(&self.show_fdinfo) }.ok()
    }
    pub fn poll_init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_driver,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_char,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll_init) }.ok()
    }
    pub fn poll_get_char(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_driver,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll_get_char) }.ok()
    }
    pub fn poll_put_char(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_driver,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_char,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll_put_char) }.ok()
    }
    pub fn proc_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_show) }.ok()
    }
}
impl tty_driver {
    pub fn magic(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn cdevs(&self) -> Option<*mut *mut cdev> {
        let v = unsafe { crate::bpf_probe_read(&self.cdevs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name_base(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.name_base) }.ok()
    }
    pub fn major(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.major) }.ok()
    }
    pub fn minor_start(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.minor_start) }.ok()
    }
    pub fn num(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn subtype(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.subtype) }.ok()
    }
    pub fn init_termios(&self) -> Option<ktermios> {
        unsafe { crate::bpf_probe_read(&self.init_termios) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn proc_entry(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn other(&self) -> Option<*mut tty_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.other) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ttys(&self) -> Option<*mut *mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.ttys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ports(&self) -> Option<*mut *mut tty_port> {
        let v = unsafe { crate::bpf_probe_read(&self.ports) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn termios(&self) -> Option<*mut *mut ktermios> {
        let v = unsafe { crate::bpf_probe_read(&self.termios) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver_state(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const tty_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tty_drivers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tty_drivers) }.ok()
    }
}
impl tty_buffer {
    pub fn next(&self) -> Option<*mut tty_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.free) }.ok()
    }
    pub fn used(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.used) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn commit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.commit) }.ok()
    }
    pub fn read(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl tty_buffer__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut tty_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
}
impl tty_bufhead {
    pub fn head(&self) -> Option<*mut tty_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn priority(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn sentinel(&self) -> Option<tty_buffer> {
        unsafe { crate::bpf_probe_read(&self.sentinel) }.ok()
    }
    pub fn free(&self) -> Option<llist_head> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn mem_used(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.mem_used) }.ok()
    }
    pub fn mem_limit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mem_limit) }.ok()
    }
    pub fn tail(&self) -> Option<*mut tty_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tty_port {
    pub fn buf(&self) -> Option<tty_bufhead> {
        unsafe { crate::bpf_probe_read(&self.buf) }.ok()
    }
    pub fn tty(&self) -> Option<*mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.tty) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn itty(&self) -> Option<*mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.itty) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const tty_port_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn client_ops(&self) -> Option<*const tty_port_client_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.client_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn blocked_open(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.blocked_open) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn open_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.open_wait) }.ok()
    }
    pub fn delta_msr_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.delta_msr_wait) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn iflags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.iflags) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn buf_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.buf_mutex) }.ok()
    }
    pub fn xmit_buf(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.xmit_buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn close_delay(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.close_delay) }.ok()
    }
    pub fn closing_wait(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.closing_wait) }.ok()
    }
    pub fn drain_delay(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.drain_delay) }.ok()
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn client_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.client_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tty_ldisc_ops {
    pub fn magic(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.num) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn close(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.close) }.ok()
    }
    pub fn flush_buffer(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.flush_buffer) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut file,
                arg3: *mut ::aya_bpf_cty::c_uchar,
                arg4: size_t,
                arg5: *mut *mut ::aya_bpf_cty::c_void,
                arg6: ::aya_bpf_cty::c_ulong,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut file,
                arg3: *const ::aya_bpf_cty::c_uchar,
                arg4: size_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut file,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ioctl) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut file,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn set_termios(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut ktermios)>,
    > {
        unsafe { crate::bpf_probe_read(&self.set_termios) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *mut file,
                arg3: *mut poll_table_struct,
            ) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn hangup(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.hangup) }.ok()
    }
    pub fn receive_buf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *const ::aya_bpf_cty::c_uchar,
                arg3: *mut ::aya_bpf_cty::c_char,
                arg4: ::aya_bpf_cty::c_int,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.receive_buf) }.ok()
    }
    pub fn write_wakeup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>> {
        unsafe { crate::bpf_probe_read(&self.write_wakeup) }.ok()
    }
    pub fn dcd_change(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dcd_change) }.ok()
    }
    pub fn receive_buf2(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_struct,
                arg2: *const ::aya_bpf_cty::c_uchar,
                arg3: *mut ::aya_bpf_cty::c_char,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.receive_buf2) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcount(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
}
impl tty_ldisc {
    pub fn ops(&self) -> Option<*mut tty_ldisc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tty(&self) -> Option<*mut tty_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.tty) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tty_port_operations {
    pub fn carrier_raised(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.carrier_raised) }.ok()
    }
    pub fn dtr_rts(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tty_port, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dtr_rts) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>> {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn activate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_port,
                arg2: *mut tty_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.activate) }.ok()
    }
    pub fn destruct(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>> {
        unsafe { crate::bpf_probe_read(&self.destruct) }.ok()
    }
}
impl tty_port_client_operations {
    pub fn receive_buf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tty_port,
                arg2: *const ::aya_bpf_cty::c_uchar,
                arg3: *const ::aya_bpf_cty::c_uchar,
                arg4: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.receive_buf) }.ok()
    }
    pub fn write_wakeup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>> {
        unsafe { crate::bpf_probe_read(&self.write_wakeup) }.ok()
    }
}
impl netns_core {
    pub fn sysctl_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_somaxconn(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_somaxconn) }.ok()
    }
    pub fn sock_inuse(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.sock_inuse) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prot_inuse(&self) -> Option<*mut prot_inuse> {
        let v = unsafe { crate::bpf_probe_read(&self.prot_inuse) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_mib {
    pub fn tcp_statistics(&self) -> Option<*mut tcp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip_statistics(&self) -> Option<*mut ipstats_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.ip_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net_statistics(&self) -> Option<*mut linux_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.net_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_statistics(&self) -> Option<*mut udp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udplite_statistics(&self) -> Option<*mut udp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.udplite_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmp_statistics(&self) -> Option<*mut icmp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.icmp_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmpmsg_statistics(&self) -> Option<*mut icmpmsg_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpmsg_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_net_devsnmp6(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_net_devsnmp6) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_stats_in6(&self) -> Option<*mut udp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_stats_in6) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udplite_stats_in6(&self) -> Option<*mut udp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.udplite_stats_in6) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6_statistics(&self) -> Option<*mut ipstats_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmpv6_statistics(&self) -> Option<*mut icmpv6_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpv6_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmpv6msg_statistics(&self) -> Option<*mut icmpv6msg_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpv6msg_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrm_statistics(&self) -> Option<*mut linux_xfrm_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.xfrm_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tls_statistics(&self) -> Option<*mut linux_tls_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.tls_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mptcp_statistics(&self) -> Option<*mut mptcp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.mptcp_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_packet {
    pub fn sklist_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.sklist_lock) }.ok()
    }
    pub fn sklist(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.sklist) }.ok()
    }
}
impl netns_unix {
    pub fn sysctl_max_dgram_qlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_max_dgram_qlen) }.ok()
    }
    pub fn ctl(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.ctl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_nexthop {
    pub fn rb_root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.rb_root) }.ok()
    }
    pub fn devhash(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.devhash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn last_id_allocated(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_id_allocated) }.ok()
    }
    pub fn notifier_chain(&self) -> Option<blocking_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.notifier_chain) }.ok()
    }
}
impl local_ports {
    pub fn lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn range(&self) -> Option<[::aya_bpf_cty::c_int; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.range) }.ok()
    }
    pub fn warned(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.warned) }.ok()
    }
}
impl inet_timewait_death_row {
    pub fn tw_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tw_count) }.ok()
    }
    pub fn hashinfo(&self) -> Option<*mut inet_hashinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.hashinfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_max_tw_buckets(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_max_tw_buckets) }.ok()
    }
}
impl ping_group_range {
    pub fn lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn range(&self) -> Option<[kgid_t; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.range) }.ok()
    }
}
impl siphash_key_t {
    pub fn key(&self) -> Option<[u64_; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl netns_ipv4 {
    pub fn forw_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.forw_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frags_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.frags_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv4_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv4_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn route_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.route_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrm4_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.xfrm4_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devconf_all(&self) -> Option<*mut ipv4_devconf> {
        let v = unsafe { crate::bpf_probe_read(&self.devconf_all) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devconf_dflt(&self) -> Option<*mut ipv4_devconf> {
        let v = unsafe { crate::bpf_probe_read(&self.devconf_dflt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ra_chain(&self) -> Option<*mut ip_ra_chain> {
        let v = unsafe { crate::bpf_probe_read(&self.ra_chain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ra_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.ra_mutex) }.ok()
    }
    pub fn rules_ops(&self) -> Option<*mut fib_rules_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.rules_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_has_custom_rules(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fib_has_custom_rules) }.ok()
    }
    pub fn fib_rules_require_fldissect(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib_rules_require_fldissect) }.ok()
    }
    pub fn fib_main(&self) -> Option<*mut fib_table> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_main) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_default(&self) -> Option<*mut fib_table> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_default) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_has_custom_local_routes(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fib_has_custom_local_routes) }.ok()
    }
    pub fn fib_num_tclassid_users(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fib_num_tclassid_users) }.ok()
    }
    pub fn fib_table_hash(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_table_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_offload_disabled(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fib_offload_disabled) }.ok()
    }
    pub fn fibnl(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.fibnl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmp_sk(&self) -> Option<*mut *mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.icmp_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_autojoin_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_autojoin_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn peers(&self) -> Option<*mut inet_peer_base> {
        let v = unsafe { crate::bpf_probe_read(&self.peers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_sk(&self) -> Option<*mut *mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fqdir(&self) -> Option<*mut fqdir> {
        let v = unsafe { crate::bpf_probe_read(&self.fqdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iptable_filter(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.iptable_filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iptable_mangle(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.iptable_mangle) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iptable_raw(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.iptable_raw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arptable_filter(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.arptable_filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iptable_security(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.iptable_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nat_table(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.nat_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_icmp_echo_ignore_all(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_echo_ignore_all) }.ok()
    }
    pub fn sysctl_icmp_echo_ignore_broadcasts(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_echo_ignore_broadcasts) }.ok()
    }
    pub fn sysctl_icmp_ignore_bogus_error_responses(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_ignore_bogus_error_responses) }.ok()
    }
    pub fn sysctl_icmp_ratelimit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_ratelimit) }.ok()
    }
    pub fn sysctl_icmp_ratemask(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_ratemask) }.ok()
    }
    pub fn sysctl_icmp_errors_use_inbound_ifaddr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_icmp_errors_use_inbound_ifaddr) }.ok()
    }
    pub fn ip_local_ports(&self) -> Option<local_ports> {
        unsafe { crate::bpf_probe_read(&self.ip_local_ports) }.ok()
    }
    pub fn sysctl_tcp_ecn(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_ecn) }.ok()
    }
    pub fn sysctl_tcp_ecn_fallback(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_ecn_fallback) }.ok()
    }
    pub fn sysctl_ip_default_ttl(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_default_ttl) }.ok()
    }
    pub fn sysctl_ip_no_pmtu_disc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_no_pmtu_disc) }.ok()
    }
    pub fn sysctl_ip_fwd_use_pmtu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_fwd_use_pmtu) }.ok()
    }
    pub fn sysctl_ip_fwd_update_priority(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_fwd_update_priority) }.ok()
    }
    pub fn sysctl_ip_nonlocal_bind(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_nonlocal_bind) }.ok()
    }
    pub fn sysctl_ip_autobind_reuse(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_autobind_reuse) }.ok()
    }
    pub fn sysctl_ip_dynaddr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_dynaddr) }.ok()
    }
    pub fn sysctl_ip_early_demux(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_early_demux) }.ok()
    }
    pub fn sysctl_raw_l3mdev_accept(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_raw_l3mdev_accept) }.ok()
    }
    pub fn sysctl_tcp_early_demux(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_early_demux) }.ok()
    }
    pub fn sysctl_udp_early_demux(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_udp_early_demux) }.ok()
    }
    pub fn sysctl_nexthop_compat_mode(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_nexthop_compat_mode) }.ok()
    }
    pub fn sysctl_fwmark_reflect(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_fwmark_reflect) }.ok()
    }
    pub fn sysctl_tcp_fwmark_accept(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_fwmark_accept) }.ok()
    }
    pub fn sysctl_tcp_l3mdev_accept(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_l3mdev_accept) }.ok()
    }
    pub fn sysctl_tcp_mtu_probing(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_mtu_probing) }.ok()
    }
    pub fn sysctl_tcp_mtu_probe_floor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_mtu_probe_floor) }.ok()
    }
    pub fn sysctl_tcp_base_mss(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_base_mss) }.ok()
    }
    pub fn sysctl_tcp_min_snd_mss(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_min_snd_mss) }.ok()
    }
    pub fn sysctl_tcp_probe_threshold(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_probe_threshold) }.ok()
    }
    pub fn sysctl_tcp_probe_interval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_probe_interval) }.ok()
    }
    pub fn sysctl_tcp_keepalive_time(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_keepalive_time) }.ok()
    }
    pub fn sysctl_tcp_keepalive_probes(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_keepalive_probes) }.ok()
    }
    pub fn sysctl_tcp_keepalive_intvl(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_keepalive_intvl) }.ok()
    }
    pub fn sysctl_tcp_syn_retries(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_syn_retries) }.ok()
    }
    pub fn sysctl_tcp_synack_retries(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_synack_retries) }.ok()
    }
    pub fn sysctl_tcp_syncookies(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_syncookies) }.ok()
    }
    pub fn sysctl_tcp_reordering(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_reordering) }.ok()
    }
    pub fn sysctl_tcp_retries1(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_retries1) }.ok()
    }
    pub fn sysctl_tcp_retries2(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_retries2) }.ok()
    }
    pub fn sysctl_tcp_orphan_retries(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_orphan_retries) }.ok()
    }
    pub fn sysctl_tcp_fin_timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_fin_timeout) }.ok()
    }
    pub fn sysctl_tcp_notsent_lowat(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_notsent_lowat) }.ok()
    }
    pub fn sysctl_tcp_tw_reuse(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_tw_reuse) }.ok()
    }
    pub fn sysctl_tcp_sack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_sack) }.ok()
    }
    pub fn sysctl_tcp_window_scaling(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_window_scaling) }.ok()
    }
    pub fn sysctl_tcp_timestamps(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_timestamps) }.ok()
    }
    pub fn sysctl_tcp_early_retrans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_early_retrans) }.ok()
    }
    pub fn sysctl_tcp_recovery(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_recovery) }.ok()
    }
    pub fn sysctl_tcp_thin_linear_timeouts(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_thin_linear_timeouts) }.ok()
    }
    pub fn sysctl_tcp_slow_start_after_idle(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_slow_start_after_idle) }.ok()
    }
    pub fn sysctl_tcp_retrans_collapse(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_retrans_collapse) }.ok()
    }
    pub fn sysctl_tcp_stdurg(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_stdurg) }.ok()
    }
    pub fn sysctl_tcp_rfc1337(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_rfc1337) }.ok()
    }
    pub fn sysctl_tcp_abort_on_overflow(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_abort_on_overflow) }.ok()
    }
    pub fn sysctl_tcp_fack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_fack) }.ok()
    }
    pub fn sysctl_tcp_max_reordering(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_max_reordering) }.ok()
    }
    pub fn sysctl_tcp_dsack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_dsack) }.ok()
    }
    pub fn sysctl_tcp_app_win(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_app_win) }.ok()
    }
    pub fn sysctl_tcp_adv_win_scale(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_adv_win_scale) }.ok()
    }
    pub fn sysctl_tcp_frto(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_frto) }.ok()
    }
    pub fn sysctl_tcp_nometrics_save(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_nometrics_save) }.ok()
    }
    pub fn sysctl_tcp_no_ssthresh_metrics_save(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_no_ssthresh_metrics_save) }.ok()
    }
    pub fn sysctl_tcp_moderate_rcvbuf(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_moderate_rcvbuf) }.ok()
    }
    pub fn sysctl_tcp_tso_win_divisor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_tso_win_divisor) }.ok()
    }
    pub fn sysctl_tcp_workaround_signed_windows(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_workaround_signed_windows) }.ok()
    }
    pub fn sysctl_tcp_limit_output_bytes(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_limit_output_bytes) }.ok()
    }
    pub fn sysctl_tcp_challenge_ack_limit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_challenge_ack_limit) }.ok()
    }
    pub fn sysctl_tcp_min_tso_segs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_min_tso_segs) }.ok()
    }
    pub fn sysctl_tcp_min_rtt_wlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_min_rtt_wlen) }.ok()
    }
    pub fn sysctl_tcp_autocorking(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_autocorking) }.ok()
    }
    pub fn sysctl_tcp_invalid_ratelimit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_invalid_ratelimit) }.ok()
    }
    pub fn sysctl_tcp_pacing_ss_ratio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_pacing_ss_ratio) }.ok()
    }
    pub fn sysctl_tcp_pacing_ca_ratio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_pacing_ca_ratio) }.ok()
    }
    pub fn sysctl_tcp_wmem(&self) -> Option<[::aya_bpf_cty::c_int; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_wmem) }.ok()
    }
    pub fn sysctl_tcp_rmem(&self) -> Option<[::aya_bpf_cty::c_int; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_rmem) }.ok()
    }
    pub fn sysctl_tcp_comp_sack_nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_comp_sack_nr) }.ok()
    }
    pub fn sysctl_tcp_comp_sack_delay_ns(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_comp_sack_delay_ns) }.ok()
    }
    pub fn sysctl_tcp_comp_sack_slack_ns(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_comp_sack_slack_ns) }.ok()
    }
    pub fn tcp_death_row(&self) -> Option<inet_timewait_death_row> {
        unsafe { crate::bpf_probe_read(&self.tcp_death_row) }.ok()
    }
    pub fn sysctl_max_syn_backlog(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_max_syn_backlog) }.ok()
    }
    pub fn sysctl_tcp_fastopen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_fastopen) }.ok()
    }
    pub fn tcp_congestion_control(&self) -> Option<*const tcp_congestion_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp_congestion_control) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_fastopen_ctx(&self) -> Option<*mut tcp_fastopen_context> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp_fastopen_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_fastopen_ctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.tcp_fastopen_ctx_lock) }.ok()
    }
    pub fn sysctl_tcp_fastopen_blackhole_timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_fastopen_blackhole_timeout) }.ok()
    }
    pub fn tfo_active_disable_times(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tfo_active_disable_times) }.ok()
    }
    pub fn tfo_active_disable_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tfo_active_disable_stamp) }.ok()
    }
    pub fn sysctl_tcp_reflect_tos(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tcp_reflect_tos) }.ok()
    }
    pub fn sysctl_udp_wmem_min(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_udp_wmem_min) }.ok()
    }
    pub fn sysctl_udp_rmem_min(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_udp_rmem_min) }.ok()
    }
    pub fn sysctl_udp_l3mdev_accept(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_udp_l3mdev_accept) }.ok()
    }
    pub fn sysctl_igmp_max_memberships(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_igmp_max_memberships) }.ok()
    }
    pub fn sysctl_igmp_max_msf(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_igmp_max_msf) }.ok()
    }
    pub fn sysctl_igmp_llm_reports(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_igmp_llm_reports) }.ok()
    }
    pub fn sysctl_igmp_qrv(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_igmp_qrv) }.ok()
    }
    pub fn ping_group_range(&self) -> Option<ping_group_range> {
        unsafe { crate::bpf_probe_read(&self.ping_group_range) }.ok()
    }
    pub fn dev_addr_genid(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dev_addr_genid) }.ok()
    }
    pub fn sysctl_local_reserved_ports(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_local_reserved_ports) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_ip_prot_sock(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_ip_prot_sock) }.ok()
    }
    pub fn mr_tables(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mr_tables) }.ok()
    }
    pub fn mr_rules_ops(&self) -> Option<*mut fib_rules_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.mr_rules_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_fib_multipath_use_neigh(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_fib_multipath_use_neigh) }.ok()
    }
    pub fn sysctl_fib_multipath_hash_policy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_fib_multipath_hash_policy) }.ok()
    }
    pub fn notifier_ops(&self) -> Option<*mut fib_notifier_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.notifier_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib_seq) }.ok()
    }
    pub fn ipmr_notifier_ops(&self) -> Option<*mut fib_notifier_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ipmr_notifier_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipmr_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ipmr_seq) }.ok()
    }
    pub fn rt_genid(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.rt_genid) }.ok()
    }
    pub fn ip_id_key(&self) -> Option<siphash_key_t> {
        unsafe { crate::bpf_probe_read(&self.ip_id_key) }.ok()
    }
}
impl netns_sysctl_ipv6 {
    pub fn hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn route_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.route_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmp_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.icmp_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frags_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.frags_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrm6_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.xfrm6_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bindv6only(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bindv6only) }.ok()
    }
    pub fn flush_delay(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flush_delay) }.ok()
    }
    pub fn ip6_rt_max_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_max_size) }.ok()
    }
    pub fn ip6_rt_gc_min_interval(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_gc_min_interval) }.ok()
    }
    pub fn ip6_rt_gc_timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_gc_timeout) }.ok()
    }
    pub fn ip6_rt_gc_interval(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_gc_interval) }.ok()
    }
    pub fn ip6_rt_gc_elasticity(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_gc_elasticity) }.ok()
    }
    pub fn ip6_rt_mtu_expires(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_mtu_expires) }.ok()
    }
    pub fn ip6_rt_min_advmss(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_min_advmss) }.ok()
    }
    pub fn multipath_hash_policy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.multipath_hash_policy) }.ok()
    }
    pub fn flowlabel_consistency(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flowlabel_consistency) }.ok()
    }
    pub fn auto_flowlabels(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.auto_flowlabels) }.ok()
    }
    pub fn icmpv6_time(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.icmpv6_time) }.ok()
    }
    pub fn icmpv6_echo_ignore_all(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.icmpv6_echo_ignore_all) }.ok()
    }
    pub fn icmpv6_echo_ignore_multicast(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.icmpv6_echo_ignore_multicast) }.ok()
    }
    pub fn icmpv6_echo_ignore_anycast(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.icmpv6_echo_ignore_anycast) }.ok()
    }
    pub fn icmpv6_ratemask(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.icmpv6_ratemask) }.ok()
    }
    pub fn icmpv6_ratemask_ptr(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpv6_ratemask_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn anycast_src_echo_reply(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.anycast_src_echo_reply) }.ok()
    }
    pub fn ip_nonlocal_bind(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip_nonlocal_bind) }.ok()
    }
    pub fn fwmark_reflect(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fwmark_reflect) }.ok()
    }
    pub fn idgen_retries(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.idgen_retries) }.ok()
    }
    pub fn idgen_delay(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.idgen_delay) }.ok()
    }
    pub fn flowlabel_state_ranges(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flowlabel_state_ranges) }.ok()
    }
    pub fn flowlabel_reflect(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flowlabel_reflect) }.ok()
    }
    pub fn max_dst_opts_cnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_dst_opts_cnt) }.ok()
    }
    pub fn max_hbh_opts_cnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_hbh_opts_cnt) }.ok()
    }
    pub fn max_dst_opts_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_dst_opts_len) }.ok()
    }
    pub fn max_hbh_opts_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_hbh_opts_len) }.ok()
    }
    pub fn seg6_flowlabel(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.seg6_flowlabel) }.ok()
    }
    pub fn skip_notify_on_dev_down(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.skip_notify_on_dev_down) }.ok()
    }
}
impl dst_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn gc_thresh(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.gc_thresh) }.ok()
    }
    pub fn gc(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_ops) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.gc) }.ok()
    }
    pub fn check(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, arg2: __u32) -> *mut dst_entry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check) }.ok()
    }
    pub fn default_advmss(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.default_advmss) }.ok()
    }
    pub fn mtu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mtu) }.ok()
    }
    pub fn cow_metrics(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, arg2: ::aya_bpf_cty::c_ulong) -> *mut u32_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cow_metrics) }.ok()
    }
    pub fn destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn ifdown(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dst_entry,
                arg2: *mut net_device,
                arg3: ::aya_bpf_cty::c_int,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ifdown) }.ok()
    }
    pub fn negative_advice(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>>
    {
        unsafe { crate::bpf_probe_read(&self.negative_advice) }.ok()
    }
    pub fn link_failure(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>> {
        unsafe { crate::bpf_probe_read(&self.link_failure) }.ok()
    }
    pub fn update_pmtu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dst_entry,
                arg2: *mut sock,
                arg3: *mut sk_buff,
                arg4: u32_,
                arg5: bool_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update_pmtu) }.ok()
    }
    pub fn redirect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, arg2: *mut sock, arg3: *mut sk_buff),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.redirect) }.ok()
    }
    pub fn local_out(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sock,
                arg3: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.local_out) }.ok()
    }
    pub fn neigh_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const dst_entry,
                arg2: *mut sk_buff,
                arg3: *const ::aya_bpf_cty::c_void,
            ) -> *mut neighbour,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.neigh_lookup) }.ok()
    }
    pub fn confirm_neigh(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dst_entry, arg2: *const ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.confirm_neigh) }.ok()
    }
    pub fn kmem_cachep(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.kmem_cachep) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pcpuc_entries(&self) -> Option<percpu_counter> {
        unsafe { crate::bpf_probe_read(&self.pcpuc_entries) }.ok()
    }
}
impl netns_ipv6 {
    pub fn sysctl(&self) -> Option<netns_sysctl_ipv6> {
        unsafe { crate::bpf_probe_read(&self.sysctl) }.ok()
    }
    pub fn devconf_all(&self) -> Option<*mut ipv6_devconf> {
        let v = unsafe { crate::bpf_probe_read(&self.devconf_all) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devconf_dflt(&self) -> Option<*mut ipv6_devconf> {
        let v = unsafe { crate::bpf_probe_read(&self.devconf_dflt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn peers(&self) -> Option<*mut inet_peer_base> {
        let v = unsafe { crate::bpf_probe_read(&self.peers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fqdir(&self) -> Option<*mut fqdir> {
        let v = unsafe { crate::bpf_probe_read(&self.fqdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6table_filter(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6table_filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6table_mangle(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6table_mangle) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6table_raw(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6table_raw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6table_security(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6table_security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6table_nat(&self) -> Option<*mut xt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6table_nat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_null_entry(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_null_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6_null_entry(&self) -> Option<*mut rt6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6_null_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rt6_stats(&self) -> Option<*mut rt6_statistics> {
        let v = unsafe { crate::bpf_probe_read(&self.rt6_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6_fib_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.ip6_fib_timer) }.ok()
    }
    pub fn fib_table_hash(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_table_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_main_tbl(&self) -> Option<*mut fib6_table> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_main_tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_walkers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fib6_walkers) }.ok()
    }
    pub fn ip6_dst_ops(&self) -> Option<dst_ops> {
        unsafe { crate::bpf_probe_read(&self.ip6_dst_ops) }.ok()
    }
    pub fn fib6_walker_lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.fib6_walker_lock) }.ok()
    }
    pub fn fib6_gc_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.fib6_gc_lock) }.ok()
    }
    pub fn ip6_rt_gc_expire(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_gc_expire) }.ok()
    }
    pub fn ip6_rt_last_gc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ip6_rt_last_gc) }.ok()
    }
    pub fn fib6_rules_require_fldissect(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib6_rules_require_fldissect) }.ok()
    }
    pub fn fib6_has_custom_rules(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fib6_has_custom_rules) }.ok()
    }
    pub fn fib6_routes_require_src(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib6_routes_require_src) }.ok()
    }
    pub fn ip6_prohibit_entry(&self) -> Option<*mut rt6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6_prohibit_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6_blk_hole_entry(&self) -> Option<*mut rt6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6_blk_hole_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_local_tbl(&self) -> Option<*mut fib6_table> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_local_tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_rules_ops(&self) -> Option<*mut fib_rules_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_rules_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmp_sk(&self) -> Option<*mut *mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.icmp_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ndisc_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.ndisc_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn igmp_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.igmp_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_autojoin_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_autojoin_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mr6_tables(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mr6_tables) }.ok()
    }
    pub fn mr6_rules_ops(&self) -> Option<*mut fib_rules_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.mr6_rules_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_addr_genid(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dev_addr_genid) }.ok()
    }
    pub fn fib6_sernum(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.fib6_sernum) }.ok()
    }
    pub fn seg6_data(&self) -> Option<*mut seg6_pernet_data> {
        let v = unsafe { crate::bpf_probe_read(&self.seg6_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notifier_ops(&self) -> Option<*mut fib_notifier_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.notifier_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6mr_notifier_ops(&self) -> Option<*mut fib_notifier_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6mr_notifier_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipmr_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ipmr_seq) }.ok()
    }
    pub fn ip6addrlbl_table(&self) -> Option<netns_ipv6__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ip6addrlbl_table) }.ok()
    }
}
impl netns_ipv6__bindgen_ty_1 {
    pub fn head(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
}
impl netns_sysctl_lowpan {
    pub fn frags_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.frags_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_ieee802154_lowpan {
    pub fn sysctl(&self) -> Option<netns_sysctl_lowpan> {
        unsafe { crate::bpf_probe_read(&self.sysctl) }.ok()
    }
    pub fn fqdir(&self) -> Option<*mut fqdir> {
        let v = unsafe { crate::bpf_probe_read(&self.fqdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sctp_mib {}
impl netns_sctp {
    pub fn sctp_statistics(&self) -> Option<*mut sctp_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.sctp_statistics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_net_sctp(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_net_sctp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_header(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_header) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctl_sock(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.ctl_sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp4_sock(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.udp4_sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp6_sock(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.udp6_sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_port(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.udp_port) }.ok()
    }
    pub fn encap_port(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.encap_port) }.ok()
    }
    pub fn local_addr_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.local_addr_list) }.ok()
    }
    pub fn addr_waitq(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.addr_waitq) }.ok()
    }
    pub fn addr_wq_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.addr_wq_timer) }.ok()
    }
    pub fn auto_asconf_splist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.auto_asconf_splist) }.ok()
    }
    pub fn addr_wq_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.addr_wq_lock) }.ok()
    }
    pub fn local_addr_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.local_addr_lock) }.ok()
    }
    pub fn rto_initial(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rto_initial) }.ok()
    }
    pub fn rto_min(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rto_min) }.ok()
    }
    pub fn rto_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rto_max) }.ok()
    }
    pub fn rto_alpha(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rto_alpha) }.ok()
    }
    pub fn rto_beta(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rto_beta) }.ok()
    }
    pub fn max_burst(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_burst) }.ok()
    }
    pub fn cookie_preserve_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cookie_preserve_enable) }.ok()
    }
    pub fn sctp_hmac_alg(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.sctp_hmac_alg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn valid_cookie_life(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.valid_cookie_life) }.ok()
    }
    pub fn sack_timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sack_timeout) }.ok()
    }
    pub fn hb_interval(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hb_interval) }.ok()
    }
    pub fn max_retrans_association(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_retrans_association) }.ok()
    }
    pub fn max_retrans_path(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_retrans_path) }.ok()
    }
    pub fn max_retrans_init(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_retrans_init) }.ok()
    }
    pub fn pf_retrans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pf_retrans) }.ok()
    }
    pub fn ps_retrans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ps_retrans) }.ok()
    }
    pub fn pf_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pf_enable) }.ok()
    }
    pub fn pf_expose(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pf_expose) }.ok()
    }
    pub fn sndbuf_policy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sndbuf_policy) }.ok()
    }
    pub fn rcvbuf_policy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rcvbuf_policy) }.ok()
    }
    pub fn default_auto_asconf(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.default_auto_asconf) }.ok()
    }
    pub fn addip_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.addip_enable) }.ok()
    }
    pub fn addip_noauth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.addip_noauth) }.ok()
    }
    pub fn prsctp_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prsctp_enable) }.ok()
    }
    pub fn reconf_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.reconf_enable) }.ok()
    }
    pub fn auth_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.auth_enable) }.ok()
    }
    pub fn intl_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.intl_enable) }.ok()
    }
    pub fn ecn_enable(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ecn_enable) }.ok()
    }
    pub fn scope_policy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.scope_policy) }.ok()
    }
    pub fn rwnd_upd_shift(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rwnd_upd_shift) }.ok()
    }
    pub fn max_autoclose(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_autoclose) }.ok()
    }
}
impl netns_dccp {
    pub fn v4_ctl_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.v4_ctl_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn v6_ctl_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.v6_ctl_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_nf {
    pub fn proc_netfilter(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_netfilter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_handler(&self) -> Option<*const nf_queue_handler> {
        let v = unsafe { crate::bpf_probe_read(&self.queue_handler) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nf_loggers(&self) -> Option<[*const nf_logger; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.nf_loggers) }.ok()
    }
    pub fn nf_log_dir_header(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.nf_log_dir_header) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hooks_ipv4(&self) -> Option<[*mut nf_hook_entries; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.hooks_ipv4) }.ok()
    }
    pub fn hooks_ipv6(&self) -> Option<[*mut nf_hook_entries; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.hooks_ipv6) }.ok()
    }
    pub fn hooks_arp(&self) -> Option<[*mut nf_hook_entries; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.hooks_arp) }.ok()
    }
    pub fn hooks_bridge(&self) -> Option<[*mut nf_hook_entries; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.hooks_bridge) }.ok()
    }
    pub fn hooks_decnet(&self) -> Option<[*mut nf_hook_entries; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.hooks_decnet) }.ok()
    }
    pub fn defrag_ipv4(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.defrag_ipv4) }.ok()
    }
    pub fn defrag_ipv6(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.defrag_ipv6) }.ok()
    }
}
impl ebt_table {}
impl netns_xt {
    pub fn tables(&self) -> Option<[list_head; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.tables) }.ok()
    }
    pub fn notrack_deprecated_warning(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.notrack_deprecated_warning) }.ok()
    }
    pub fn clusterip_deprecated_warning(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.clusterip_deprecated_warning) }.ok()
    }
    pub fn broute_table(&self) -> Option<*mut ebt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.broute_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frame_filter(&self) -> Option<*mut ebt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.frame_filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frame_nat(&self) -> Option<*mut ebt_table> {
        let v = unsafe { crate::bpf_probe_read(&self.frame_nat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nf_generic_net {
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
}
impl nf_tcp_net {
    pub fn timeouts(&self) -> Option<[::aya_bpf_cty::c_uint; 14usize]> {
        unsafe { crate::bpf_probe_read(&self.timeouts) }.ok()
    }
    pub fn tcp_loose(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tcp_loose) }.ok()
    }
    pub fn tcp_be_liberal(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tcp_be_liberal) }.ok()
    }
    pub fn tcp_max_retrans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tcp_max_retrans) }.ok()
    }
}
impl nf_udp_net {
    pub fn timeouts(&self) -> Option<[::aya_bpf_cty::c_uint; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.timeouts) }.ok()
    }
}
impl nf_icmp_net {
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
}
impl nf_dccp_net {
    pub fn dccp_loose(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dccp_loose) }.ok()
    }
    pub fn dccp_timeout(&self) -> Option<[::aya_bpf_cty::c_uint; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.dccp_timeout) }.ok()
    }
}
impl nf_sctp_net {
    pub fn timeouts(&self) -> Option<[::aya_bpf_cty::c_uint; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.timeouts) }.ok()
    }
}
impl nf_gre_net {
    pub fn keymap_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.keymap_list) }.ok()
    }
    pub fn timeouts(&self) -> Option<[::aya_bpf_cty::c_uint; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.timeouts) }.ok()
    }
}
impl nf_ip_net {
    pub fn generic(&self) -> Option<nf_generic_net> {
        unsafe { crate::bpf_probe_read(&self.generic) }.ok()
    }
    pub fn tcp(&self) -> Option<nf_tcp_net> {
        unsafe { crate::bpf_probe_read(&self.tcp) }.ok()
    }
    pub fn udp(&self) -> Option<nf_udp_net> {
        unsafe { crate::bpf_probe_read(&self.udp) }.ok()
    }
    pub fn icmp(&self) -> Option<nf_icmp_net> {
        unsafe { crate::bpf_probe_read(&self.icmp) }.ok()
    }
    pub fn icmpv6(&self) -> Option<nf_icmp_net> {
        unsafe { crate::bpf_probe_read(&self.icmpv6) }.ok()
    }
    pub fn dccp(&self) -> Option<nf_dccp_net> {
        unsafe { crate::bpf_probe_read(&self.dccp) }.ok()
    }
    pub fn sctp(&self) -> Option<nf_sctp_net> {
        unsafe { crate::bpf_probe_read(&self.sctp) }.ok()
    }
    pub fn gre(&self) -> Option<nf_gre_net> {
        unsafe { crate::bpf_probe_read(&self.gre) }.ok()
    }
}
impl netns_ct {
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn expect_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.expect_count) }.ok()
    }
    pub fn ecache_dwork(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.ecache_dwork) }.ok()
    }
    pub fn ecache_dwork_pending(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ecache_dwork_pending) }.ok()
    }
    pub fn auto_assign_helper_warned(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.auto_assign_helper_warned) }.ok()
    }
    pub fn sysctl_header(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_header) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_log_invalid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sysctl_log_invalid) }.ok()
    }
    pub fn sysctl_events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_events) }.ok()
    }
    pub fn sysctl_acct(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_acct) }.ok()
    }
    pub fn sysctl_auto_assign_helper(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_auto_assign_helper) }.ok()
    }
    pub fn sysctl_tstamp(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_tstamp) }.ok()
    }
    pub fn sysctl_checksum(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_checksum) }.ok()
    }
    pub fn pcpu_lists(&self) -> Option<*mut ct_pcpu> {
        let v = unsafe { crate::bpf_probe_read(&self.pcpu_lists) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stat(&self) -> Option<*mut ip_conntrack_stat> {
        let v = unsafe { crate::bpf_probe_read(&self.stat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nf_conntrack_event_cb(&self) -> Option<*mut nf_ct_event_notifier> {
        let v = unsafe { crate::bpf_probe_read(&self.nf_conntrack_event_cb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nf_expect_event_cb(&self) -> Option<*mut nf_exp_event_notifier> {
        let v = unsafe { crate::bpf_probe_read(&self.nf_expect_event_cb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nf_ct_proto(&self) -> Option<nf_ip_net> {
        unsafe { crate::bpf_probe_read(&self.nf_ct_proto) }.ok()
    }
    pub fn labels_used(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.labels_used) }.ok()
    }
}
impl netns_nftables {
    pub fn tables(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tables) }.ok()
    }
    pub fn commit_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.commit_list) }.ok()
    }
    pub fn module_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.module_list) }.ok()
    }
    pub fn notify_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.notify_list) }.ok()
    }
    pub fn commit_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.commit_mutex) }.ok()
    }
    pub fn base_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.base_seq) }.ok()
    }
    pub fn gencursor(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.gencursor) }.ok()
    }
    pub fn validate_state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.validate_state) }.ok()
    }
}
impl netns_nf_frag {
    pub fn fqdir(&self) -> Option<*mut fqdir> {
        let v = unsafe { crate::bpf_probe_read(&self.fqdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netns_bpf {
    pub fn run_array(&self) -> Option<[*mut bpf_prog_array; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.run_array) }.ok()
    }
    pub fn progs(&self) -> Option<[*mut bpf_prog; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.progs) }.ok()
    }
    pub fn links(&self) -> Option<[list_head; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.links) }.ok()
    }
}
impl xfrm_policy_hash {
    pub fn table(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hmask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hmask) }.ok()
    }
    pub fn dbits4(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.dbits4) }.ok()
    }
    pub fn sbits4(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sbits4) }.ok()
    }
    pub fn dbits6(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.dbits6) }.ok()
    }
    pub fn sbits6(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sbits6) }.ok()
    }
}
impl xfrm_policy_hthresh {
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn lbits4(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.lbits4) }.ok()
    }
    pub fn rbits4(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rbits4) }.ok()
    }
    pub fn lbits6(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.lbits6) }.ok()
    }
    pub fn rbits6(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rbits6) }.ok()
    }
}
impl netns_xfrm {
    pub fn state_all(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.state_all) }.ok()
    }
    pub fn state_bydst(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.state_bydst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_bysrc(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.state_bysrc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_byspi(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.state_byspi) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_hmask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.state_hmask) }.ok()
    }
    pub fn state_num(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.state_num) }.ok()
    }
    pub fn state_hash_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.state_hash_work) }.ok()
    }
    pub fn policy_all(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.policy_all) }.ok()
    }
    pub fn policy_byidx(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.policy_byidx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn policy_idx_hmask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.policy_idx_hmask) }.ok()
    }
    pub fn policy_inexact(&self) -> Option<[hlist_head; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.policy_inexact) }.ok()
    }
    pub fn policy_bydst(&self) -> Option<[xfrm_policy_hash; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.policy_bydst) }.ok()
    }
    pub fn policy_count(&self) -> Option<[::aya_bpf_cty::c_uint; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.policy_count) }.ok()
    }
    pub fn policy_hash_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.policy_hash_work) }.ok()
    }
    pub fn policy_hthresh(&self) -> Option<xfrm_policy_hthresh> {
        unsafe { crate::bpf_probe_read(&self.policy_hthresh) }.ok()
    }
    pub fn inexact_bins(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.inexact_bins) }.ok()
    }
    pub fn nlsk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.nlsk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nlsk_stash(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.nlsk_stash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_aevent_etime(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_aevent_etime) }.ok()
    }
    pub fn sysctl_aevent_rseqth(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_aevent_rseqth) }.ok()
    }
    pub fn sysctl_larval_drop(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sysctl_larval_drop) }.ok()
    }
    pub fn sysctl_acq_expires(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_acq_expires) }.ok()
    }
    pub fn sysctl_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrm4_dst_ops(&self) -> Option<dst_ops> {
        unsafe { crate::bpf_probe_read(&self.xfrm4_dst_ops) }.ok()
    }
    pub fn xfrm6_dst_ops(&self) -> Option<dst_ops> {
        unsafe { crate::bpf_probe_read(&self.xfrm6_dst_ops) }.ok()
    }
    pub fn xfrm_state_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.xfrm_state_lock) }.ok()
    }
    pub fn xfrm_state_hash_generation(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.xfrm_state_hash_generation) }.ok()
    }
    pub fn xfrm_policy_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.xfrm_policy_lock) }.ok()
    }
    pub fn xfrm_cfg_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.xfrm_cfg_mutex) }.ok()
    }
}
impl netns_ipvs {}
impl mpls_route {}
impl netns_mpls {
    pub fn ip_ttl_propagate(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip_ttl_propagate) }.ok()
    }
    pub fn default_ttl(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.default_ttl) }.ok()
    }
    pub fn platform_labels(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.platform_labels) }.ok()
    }
    pub fn platform_label(&self) -> Option<*mut *mut mpls_route> {
        let v = unsafe { crate::bpf_probe_read(&self.platform_label) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctl(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.ctl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl can_dev_rcv_lists {}
impl can_pkg_stats {}
impl can_rcv_lists_stats {}
impl netns_can {
    pub fn proc_dir(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_stats(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_reset_stats(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_reset_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_all(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_all) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_fil(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_fil) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_inv(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_inv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_sff(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_sff) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_eff(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_eff) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pde_rcvlist_err(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_rcvlist_err) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bcmproc_dir(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.bcmproc_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rx_alldev_list(&self) -> Option<*mut can_dev_rcv_lists> {
        let v = unsafe { crate::bpf_probe_read(&self.rx_alldev_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcvlists_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rcvlists_lock) }.ok()
    }
    pub fn stattimer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.stattimer) }.ok()
    }
    pub fn pkg_stats(&self) -> Option<*mut can_pkg_stats> {
        let v = unsafe { crate::bpf_probe_read(&self.pkg_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcv_lists_stats(&self) -> Option<*mut can_rcv_lists_stats> {
        let v = unsafe { crate::bpf_probe_read(&self.rcv_lists_stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cgw_list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.cgw_list) }.ok()
    }
}
impl netns_xdp {
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl net {
    pub fn passive(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.passive) }.ok()
    }
    pub fn rules_mod_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rules_mod_lock) }.ok()
    }
    pub fn dev_unreg_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dev_unreg_count) }.ok()
    }
    pub fn dev_base_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dev_base_seq) }.ok()
    }
    pub fn ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn nsid_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.nsid_lock) }.ok()
    }
    pub fn fnhe_genid(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.fnhe_genid) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn exit_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.exit_list) }.ok()
    }
    pub fn cleanup_list(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.cleanup_list) }.ok()
    }
    pub fn key_domain(&self) -> Option<*mut key_tag> {
        let v = unsafe { crate::bpf_probe_read(&self.key_domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netns_ids(&self) -> Option<idr> {
        unsafe { crate::bpf_probe_read(&self.netns_ids) }.ok()
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
    pub fn dev_base_head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dev_base_head) }.ok()
    }
    pub fn proc_net(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_net_stat(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_net_stat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctls(&self) -> Option<ctl_table_set> {
        unsafe { crate::bpf_probe_read(&self.sysctls) }.ok()
    }
    pub fn rtnl(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.rtnl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn genl_sock(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.genl_sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uevent_sock(&self) -> Option<*mut uevent_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.uevent_sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_name_head(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_name_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_index_head(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_index_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev_chain(&self) -> Option<raw_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.netdev_chain) }.ok()
    }
    pub fn hash_mix(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.hash_mix) }.ok()
    }
    pub fn loopback_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.loopback_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rules_ops(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rules_ops) }.ok()
    }
    pub fn core(&self) -> Option<netns_core> {
        unsafe { crate::bpf_probe_read(&self.core) }.ok()
    }
    pub fn mib(&self) -> Option<netns_mib> {
        unsafe { crate::bpf_probe_read(&self.mib) }.ok()
    }
    pub fn packet(&self) -> Option<netns_packet> {
        unsafe { crate::bpf_probe_read(&self.packet) }.ok()
    }
    pub fn unx(&self) -> Option<netns_unix> {
        unsafe { crate::bpf_probe_read(&self.unx) }.ok()
    }
    pub fn nexthop(&self) -> Option<netns_nexthop> {
        unsafe { crate::bpf_probe_read(&self.nexthop) }.ok()
    }
    pub fn ipv4(&self) -> Option<netns_ipv4> {
        unsafe { crate::bpf_probe_read(&self.ipv4) }.ok()
    }
    pub fn ipv6(&self) -> Option<netns_ipv6> {
        unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()
    }
    pub fn ieee802154_lowpan(&self) -> Option<netns_ieee802154_lowpan> {
        unsafe { crate::bpf_probe_read(&self.ieee802154_lowpan) }.ok()
    }
    pub fn sctp(&self) -> Option<netns_sctp> {
        unsafe { crate::bpf_probe_read(&self.sctp) }.ok()
    }
    pub fn dccp(&self) -> Option<netns_dccp> {
        unsafe { crate::bpf_probe_read(&self.dccp) }.ok()
    }
    pub fn nf(&self) -> Option<netns_nf> {
        unsafe { crate::bpf_probe_read(&self.nf) }.ok()
    }
    pub fn xt(&self) -> Option<netns_xt> {
        unsafe { crate::bpf_probe_read(&self.xt) }.ok()
    }
    pub fn ct(&self) -> Option<netns_ct> {
        unsafe { crate::bpf_probe_read(&self.ct) }.ok()
    }
    pub fn nft(&self) -> Option<netns_nftables> {
        unsafe { crate::bpf_probe_read(&self.nft) }.ok()
    }
    pub fn nf_frag(&self) -> Option<netns_nf_frag> {
        unsafe { crate::bpf_probe_read(&self.nf_frag) }.ok()
    }
    pub fn nf_frag_frags_hdr(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.nf_frag_frags_hdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nfnl(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.nfnl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nfnl_stash(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.nfnl_stash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nfct_timeout_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.nfct_timeout_list) }.ok()
    }
    pub fn wext_nlevents(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.wext_nlevents) }.ok()
    }
    pub fn gen(&self) -> Option<*mut net_generic> {
        let v = unsafe { crate::bpf_probe_read(&self.gen) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bpf(&self) -> Option<netns_bpf> {
        unsafe { crate::bpf_probe_read(&self.bpf) }.ok()
    }
    pub fn xfrm(&self) -> Option<netns_xfrm> {
        unsafe { crate::bpf_probe_read(&self.xfrm) }.ok()
    }
    pub fn net_cookie(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.net_cookie) }.ok()
    }
    pub fn ipvs(&self) -> Option<*mut netns_ipvs> {
        let v = unsafe { crate::bpf_probe_read(&self.ipvs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mpls(&self) -> Option<netns_mpls> {
        unsafe { crate::bpf_probe_read(&self.mpls) }.ok()
    }
    pub fn can(&self) -> Option<netns_can> {
        unsafe { crate::bpf_probe_read(&self.can) }.ok()
    }
    pub fn xdp(&self) -> Option<netns_xdp> {
        unsafe { crate::bpf_probe_read(&self.xdp) }.ok()
    }
    pub fn crypto_nlsk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.crypto_nlsk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn diag_nlsk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.diag_nlsk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl u64_stats_t {
    pub fn v(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.v) }.ok()
    }
}
impl bpf_insn {
    pub fn code(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
    pub fn off(&self) -> Option<__s16> {
        unsafe { crate::bpf_probe_read(&self.off) }.ok()
    }
    pub fn imm(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.imm) }.ok()
    }
}
impl bpf_attr {
    pub fn map_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_type) }.ok()
    }
    pub fn key_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.key_size) }.ok()
    }
    pub fn value_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.value_size) }.ok()
    }
    pub fn max_entries(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.max_entries) }.ok()
    }
    pub fn map_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_flags) }.ok()
    }
    pub fn inner_map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.inner_map_fd) }.ok()
    }
    pub fn numa_node(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.numa_node) }.ok()
    }
    pub fn map_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_name) }.ok()
    }
    pub fn map_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_ifindex) }.ok()
    }
    pub fn btf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_fd) }.ok()
    }
    pub fn btf_key_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_key_type_id) }.ok()
    }
    pub fn btf_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_value_type_id) }.ok()
    }
    pub fn btf_vmlinux_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_vmlinux_value_type_id) }.ok()
    }
    pub fn map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.map_fd) }.ok()
    }
    pub fn key(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.key) }.ok()
    }
    pub fn value(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.value) }.ok()
    }
    pub fn next_key(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.next_key) }.ok()
    }
    pub fn flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.flags) }.ok()
    }
    pub fn batch(&self) -> Option<bpf_attr__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.batch) }.ok()
    }
    pub fn prog_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.prog_type) }.ok()
    }
    pub fn insn_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.insn_cnt) }.ok()
    }
    pub fn insns(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.insns) }.ok()
    }
    pub fn license(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.license) }.ok()
    }
    pub fn log_level(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.log_level) }.ok()
    }
    pub fn log_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.log_size) }.ok()
    }
    pub fn log_buf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.log_buf) }.ok()
    }
    pub fn kern_version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.kern_version) }.ok()
    }
    pub fn prog_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.prog_flags) }.ok()
    }
    pub fn prog_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.prog_name) }.ok()
    }
    pub fn prog_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.prog_ifindex) }.ok()
    }
    pub fn expected_attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.expected_attach_type) }.ok()
    }
    pub fn prog_btf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.prog_btf_fd) }.ok()
    }
    pub fn func_info_rec_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.func_info_rec_size) }.ok()
    }
    pub fn func_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.func_info) }.ok()
    }
    pub fn func_info_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.func_info_cnt) }.ok()
    }
    pub fn line_info_rec_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.line_info_rec_size) }.ok()
    }
    pub fn line_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.line_info) }.ok()
    }
    pub fn line_info_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.line_info_cnt) }.ok()
    }
    pub fn attach_btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.attach_btf_id) }.ok()
    }
    pub fn attach_prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.attach_prog_fd) }
            .ok()
    }
    pub fn attach_btf_obj_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.__bindgen_anon_1.attach_btf_obj_fd) }
            .ok()
    }
    pub fn pathname(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.pathname) }.ok()
    }
    pub fn bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.bpf_fd) }.ok()
    }
    pub fn file_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.file_flags) }.ok()
    }
    pub fn target_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.target_fd) }.ok()
    }
    pub fn attach_bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.attach_bpf_fd) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.attach_type) }.ok()
    }
    pub fn attach_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.attach_flags) }.ok()
    }
    pub fn replace_bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.replace_bpf_fd) }.ok()
    }
    pub fn test(&self) -> Option<bpf_attr__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self.test) }.ok()
    }
    pub fn start_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.start_id) }.ok()
    }
    pub fn prog_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.prog_id) }.ok()
    }
    pub fn map_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.map_id) }.ok()
    }
    pub fn btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn link_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.__bindgen_anon_1.link_id) }.ok()
    }
    pub fn next_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.next_id) }.ok()
    }
    pub fn open_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.open_flags) }.ok()
    }
    pub fn info(&self) -> Option<bpf_attr__bindgen_ty_9> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn query(&self) -> Option<bpf_attr__bindgen_ty_10> {
        unsafe { crate::bpf_probe_read(&self.query) }.ok()
    }
    pub fn raw_tracepoint(&self) -> Option<bpf_attr__bindgen_ty_11> {
        unsafe { crate::bpf_probe_read(&self.raw_tracepoint) }.ok()
    }
    pub fn btf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.btf) }.ok()
    }
    pub fn btf_log_buf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.btf_log_buf) }.ok()
    }
    pub fn btf_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.btf_size) }.ok()
    }
    pub fn btf_log_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.btf_log_size) }.ok()
    }
    pub fn btf_log_level(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.btf_log_level) }.ok()
    }
    pub fn task_fd_query(&self) -> Option<bpf_attr__bindgen_ty_13> {
        unsafe { crate::bpf_probe_read(&self.task_fd_query) }.ok()
    }
    pub fn link_create(&self) -> Option<bpf_attr__bindgen_ty_14> {
        unsafe { crate::bpf_probe_read(&self.link_create) }.ok()
    }
    pub fn link_update(&self) -> Option<bpf_attr__bindgen_ty_15> {
        unsafe { crate::bpf_probe_read(&self.link_update) }.ok()
    }
    pub fn link_detach(&self) -> Option<bpf_attr__bindgen_ty_16> {
        unsafe { crate::bpf_probe_read(&self.link_detach) }.ok()
    }
    pub fn enable_stats(&self) -> Option<bpf_attr__bindgen_ty_17> {
        unsafe { crate::bpf_probe_read(&self.enable_stats) }.ok()
    }
    pub fn iter_create(&self) -> Option<bpf_attr__bindgen_ty_18> {
        unsafe { crate::bpf_probe_read(&self.iter_create) }.ok()
    }
    pub fn prog_bind_map(&self) -> Option<bpf_attr__bindgen_ty_19> {
        unsafe { crate::bpf_probe_read(&self.prog_bind_map) }.ok()
    }
}
impl bpf_attr__bindgen_ty_1 {
    pub fn map_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_type) }.ok()
    }
    pub fn key_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.key_size) }.ok()
    }
    pub fn value_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.value_size) }.ok()
    }
    pub fn max_entries(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_entries) }.ok()
    }
    pub fn map_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_flags) }.ok()
    }
    pub fn inner_map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.inner_map_fd) }.ok()
    }
    pub fn numa_node(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn map_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.map_name) }.ok()
    }
    pub fn map_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_ifindex) }.ok()
    }
    pub fn btf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_fd) }.ok()
    }
    pub fn btf_key_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_key_type_id) }.ok()
    }
    pub fn btf_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_value_type_id) }.ok()
    }
    pub fn btf_vmlinux_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_vmlinux_value_type_id) }.ok()
    }
}
impl bpf_attr__bindgen_ty_2 {
    pub fn map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_fd) }.ok()
    }
    pub fn key(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn value(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.value) }.ok()
    }
    pub fn next_key(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next_key) }.ok()
    }
    pub fn flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub fn value(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.value) }.ok()
    }
    pub fn next_key(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.next_key) }.ok()
    }
}
impl bpf_attr__bindgen_ty_3 {
    pub fn in_batch(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.in_batch) }.ok()
    }
    pub fn out_batch(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.out_batch) }.ok()
    }
    pub fn keys(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.keys) }.ok()
    }
    pub fn values(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.values) }.ok()
    }
    pub fn count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_fd) }.ok()
    }
    pub fn elem_flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.elem_flags) }.ok()
    }
    pub fn flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl bpf_attr__bindgen_ty_4 {
    pub fn prog_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_type) }.ok()
    }
    pub fn insn_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.insn_cnt) }.ok()
    }
    pub fn insns(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.insns) }.ok()
    }
    pub fn license(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.license) }.ok()
    }
    pub fn log_level(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.log_level) }.ok()
    }
    pub fn log_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.log_size) }.ok()
    }
    pub fn log_buf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.log_buf) }.ok()
    }
    pub fn kern_version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.kern_version) }.ok()
    }
    pub fn prog_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_flags) }.ok()
    }
    pub fn prog_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.prog_name) }.ok()
    }
    pub fn prog_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_ifindex) }.ok()
    }
    pub fn expected_attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.expected_attach_type) }.ok()
    }
    pub fn prog_btf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_btf_fd) }.ok()
    }
    pub fn func_info_rec_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.func_info_rec_size) }.ok()
    }
    pub fn func_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.func_info) }.ok()
    }
    pub fn func_info_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.func_info_cnt) }.ok()
    }
    pub fn line_info_rec_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.line_info_rec_size) }.ok()
    }
    pub fn line_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.line_info) }.ok()
    }
    pub fn line_info_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.line_info_cnt) }.ok()
    }
    pub fn attach_btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_btf_id) }.ok()
    }
    pub fn attach_prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.attach_prog_fd) }.ok()
    }
    pub fn attach_btf_obj_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.attach_btf_obj_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    pub fn attach_prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_prog_fd) }.ok()
    }
    pub fn attach_btf_obj_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_btf_obj_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_5 {
    pub fn pathname(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.pathname) }.ok()
    }
    pub fn bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bpf_fd) }.ok()
    }
    pub fn file_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.file_flags) }.ok()
    }
}
impl bpf_attr__bindgen_ty_6 {
    pub fn target_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_fd) }.ok()
    }
    pub fn attach_bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_bpf_fd) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
    pub fn attach_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_flags) }.ok()
    }
    pub fn replace_bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.replace_bpf_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_7 {
    pub fn prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_fd) }.ok()
    }
    pub fn retval(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.retval) }.ok()
    }
    pub fn data_size_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_size_in) }.ok()
    }
    pub fn data_size_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_size_out) }.ok()
    }
    pub fn data_in(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_in) }.ok()
    }
    pub fn data_out(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_out) }.ok()
    }
    pub fn repeat(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.repeat) }.ok()
    }
    pub fn duration(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.duration) }.ok()
    }
    pub fn ctx_size_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ctx_size_in) }.ok()
    }
    pub fn ctx_size_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ctx_size_out) }.ok()
    }
    pub fn ctx_in(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ctx_in) }.ok()
    }
    pub fn ctx_out(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ctx_out) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn cpu(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
}
impl bpf_attr__bindgen_ty_8 {
    pub fn start_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.start_id) }.ok()
    }
    pub fn prog_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.prog_id) }.ok()
    }
    pub fn map_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_id) }.ok()
    }
    pub fn btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn link_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.link_id) }.ok()
    }
    pub fn next_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.next_id) }.ok()
    }
    pub fn open_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.open_flags) }.ok()
    }
}
impl bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub fn start_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.start_id) }.ok()
    }
    pub fn prog_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_id) }.ok()
    }
    pub fn map_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_id) }.ok()
    }
    pub fn btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
    pub fn link_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.link_id) }.ok()
    }
}
impl bpf_attr__bindgen_ty_9 {
    pub fn bpf_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bpf_fd) }.ok()
    }
    pub fn info_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.info_len) }.ok()
    }
    pub fn info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
}
impl bpf_attr__bindgen_ty_10 {
    pub fn target_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_fd) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
    pub fn query_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.query_flags) }.ok()
    }
    pub fn attach_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_flags) }.ok()
    }
    pub fn prog_ids(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.prog_ids) }.ok()
    }
    pub fn prog_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_cnt) }.ok()
    }
}
impl bpf_attr__bindgen_ty_11 {
    pub fn name(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_12 {
    pub fn btf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.btf) }.ok()
    }
    pub fn btf_log_buf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.btf_log_buf) }.ok()
    }
    pub fn btf_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_size) }.ok()
    }
    pub fn btf_log_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_log_size) }.ok()
    }
    pub fn btf_log_level(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_log_level) }.ok()
    }
}
impl bpf_attr__bindgen_ty_13 {
    pub fn pid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fd) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn buf_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.buf_len) }.ok()
    }
    pub fn buf(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.buf) }.ok()
    }
    pub fn prog_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_id) }.ok()
    }
    pub fn fd_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fd_type) }.ok()
    }
    pub fn probe_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.probe_offset) }.ok()
    }
    pub fn probe_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.probe_addr) }.ok()
    }
}
impl bpf_attr__bindgen_ty_14 {
    pub fn prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_fd) }.ok()
    }
    pub fn target_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.target_fd) }.ok()
    }
    pub fn target_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.target_ifindex) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn target_btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.target_btf_id) }.ok()
    }
    pub fn iter_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.iter_info) }.ok()
    }
    pub fn iter_info_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.iter_info_len) }.ok()
    }
}
impl bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub fn target_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_fd) }.ok()
    }
    pub fn target_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_ifindex) }.ok()
    }
}
impl bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub fn target_btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_btf_id) }.ok()
    }
    pub fn iter_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.iter_info) }.ok()
    }
    pub fn iter_info_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.iter_info_len) }.ok()
    }
}
impl bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1 {
    pub fn iter_info(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.iter_info) }.ok()
    }
    pub fn iter_info_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.iter_info_len) }.ok()
    }
}
impl bpf_attr__bindgen_ty_15 {
    pub fn link_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.link_fd) }.ok()
    }
    pub fn new_prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.new_prog_fd) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn old_prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.old_prog_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_16 {
    pub fn link_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.link_fd) }.ok()
    }
}
impl bpf_attr__bindgen_ty_17 {
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl bpf_attr__bindgen_ty_18 {
    pub fn link_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.link_fd) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl bpf_attr__bindgen_ty_19 {
    pub fn prog_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_fd) }.ok()
    }
    pub fn map_fd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_fd) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl bpf_func_info {
    pub fn insn_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.insn_off) }.ok()
    }
    pub fn type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_id) }.ok()
    }
}
impl bpf_line_info {
    pub fn insn_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.insn_off) }.ok()
    }
    pub fn file_name_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.file_name_off) }.ok()
    }
    pub fn line_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.line_off) }.ok()
    }
    pub fn line_col(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.line_col) }.ok()
    }
}
impl bpf_iter_aux_info {
    pub fn map(&self) -> Option<*mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_iter_seq_info {
    pub fn seq_ops(&self) -> Option<*const seq_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.seq_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init_seq_private(&self) -> Option<bpf_iter_init_seq_priv_t> {
        unsafe { crate::bpf_probe_read(&self.init_seq_private) }.ok()
    }
    pub fn fini_seq_private(&self) -> Option<bpf_iter_fini_seq_priv_t> {
        unsafe { crate::bpf_probe_read(&self.fini_seq_private) }.ok()
    }
    pub fn seq_priv_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq_priv_size) }.ok()
    }
}
impl bpf_map_ops {
    pub fn map_alloc_check(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.map_alloc_check) }.ok()
    }
    pub fn map_alloc(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> *mut bpf_map>>
    {
        unsafe { crate::bpf_probe_read(&self.map_alloc) }.ok()
    }
    pub fn map_release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut file)>>
    {
        unsafe { crate::bpf_probe_read(&self.map_release) }.ok()
    }
    pub fn map_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>> {
        unsafe { crate::bpf_probe_read(&self.map_free) }.ok()
    }
    pub fn map_get_next_key(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_get_next_key) }.ok()
    }
    pub fn map_release_uref(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>> {
        unsafe { crate::bpf_probe_read(&self.map_release_uref) }.ok()
    }
    pub fn map_lookup_elem_sys_only(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_lookup_elem_sys_only) }.ok()
    }
    pub fn map_lookup_batch(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *const bpf_attr,
                arg3: *mut bpf_attr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_lookup_batch) }.ok()
    }
    pub fn map_lookup_and_delete_batch(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *const bpf_attr,
                arg3: *mut bpf_attr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_lookup_and_delete_batch) }.ok()
    }
    pub fn map_update_batch(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *const bpf_attr,
                arg3: *mut bpf_attr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_update_batch) }.ok()
    }
    pub fn map_delete_batch(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *const bpf_attr,
                arg3: *mut bpf_attr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_delete_batch) }.ok()
    }
    pub fn map_lookup_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_lookup_elem) }.ok()
    }
    pub fn map_update_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_update_elem) }.ok()
    }
    pub fn map_delete_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_delete_elem) }.ok()
    }
    pub fn map_push_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_push_elem) }.ok()
    }
    pub fn map_pop_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_pop_elem) }.ok()
    }
    pub fn map_peek_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_peek_elem) }.ok()
    }
    pub fn map_fd_get_ptr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut file,
                arg3: ::aya_bpf_cty::c_int,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_fd_get_ptr) }.ok()
    }
    pub fn map_fd_put_ptr(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.map_fd_put_ptr) }.ok()
    }
    pub fn map_gen_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_insn) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_gen_lookup) }.ok()
    }
    pub fn map_fd_sys_lookup_elem(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> u32_>,
    > {
        unsafe { crate::bpf_probe_read(&self.map_fd_sys_lookup_elem) }.ok()
    }
    pub fn map_seq_show_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut seq_file,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_seq_show_elem) }.ok()
    }
    pub fn map_check_btf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const bpf_map,
                arg2: *const btf,
                arg3: *const btf_type,
                arg4: *const btf_type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_check_btf) }.ok()
    }
    pub fn map_poke_track(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut bpf_prog_aux,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_poke_track) }.ok()
    }
    pub fn map_poke_untrack(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_prog_aux)>,
    > {
        unsafe { crate::bpf_probe_read(&self.map_poke_untrack) }.ok()
    }
    pub fn map_poke_run(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: u32_,
                arg3: *mut bpf_prog,
                arg4: *mut bpf_prog,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_poke_run) }.ok()
    }
    pub fn map_direct_value_addr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const bpf_map,
                arg2: *mut u64_,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_direct_value_addr) }.ok()
    }
    pub fn map_direct_value_meta(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const bpf_map,
                arg2: u64_,
                arg3: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_direct_value_meta) }.ok()
    }
    pub fn map_mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_mmap) }.ok()
    }
    pub fn map_poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_map,
                arg2: *mut file,
                arg3: *mut poll_table_struct,
            ) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_poll) }.ok()
    }
    pub fn map_local_storage_charge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_local_storage_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_local_storage_charge) }.ok()
    }
    pub fn map_local_storage_uncharge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_local_storage_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: u32_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_local_storage_uncharge) }.ok()
    }
    pub fn map_owner_storage_ptr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> *mut *mut bpf_local_storage,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_owner_storage_ptr) }.ok()
    }
    pub fn map_meta_equal(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const bpf_map, arg2: *const bpf_map) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_meta_equal) }.ok()
    }
    pub fn map_btf_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.map_btf_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn map_btf_id(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.map_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iter_seq_info(&self) -> Option<*const bpf_iter_seq_info> {
        let v = unsafe { crate::bpf_probe_read(&self.iter_seq_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_map {
    pub fn ops(&self) -> Option<*const bpf_map_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inner_map_meta(&self) -> Option<*mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.inner_map_meta) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn map_type(&self) -> Option<bpf_map_type::Type> {
        unsafe { crate::bpf_probe_read(&self.map_type) }.ok()
    }
    pub fn key_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.key_size) }.ok()
    }
    pub fn value_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.value_size) }.ok()
    }
    pub fn max_entries(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_entries) }.ok()
    }
    pub fn map_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.map_flags) }.ok()
    }
    pub fn spin_lock_off(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.spin_lock_off) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn numa_node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn btf_key_type_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_key_type_id) }.ok()
    }
    pub fn btf_value_type_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_value_type_id) }.ok()
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn memcg(&self) -> Option<*mut mem_cgroup> {
        let v = unsafe { crate::bpf_probe_read(&self.memcg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn btf_vmlinux_value_type_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_vmlinux_value_type_id) }.ok()
    }
    pub fn bypass_spec_v1(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bypass_spec_v1) }.ok()
    }
    pub fn frozen(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.frozen) }.ok()
    }
    pub fn refcnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn usercnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.usercnt) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn freeze_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.freeze_mutex) }.ok()
    }
    pub fn writecnt(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.writecnt) }.ok()
    }
}
impl btf_header {
    pub fn magic(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn version(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn hdr_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.hdr_len) }.ok()
    }
    pub fn type_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_off) }.ok()
    }
    pub fn type_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_len) }.ok()
    }
    pub fn str_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.str_off) }.ok()
    }
    pub fn str_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.str_len) }.ok()
    }
}
impl btf {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn types(&self) -> Option<*mut *mut btf_type> {
        let v = unsafe { crate::bpf_probe_read(&self.types) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn resolved_ids(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.resolved_ids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn resolved_sizes(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.resolved_sizes) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn strings(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.strings) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nohdr_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.nohdr_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hdr(&self) -> Option<btf_header> {
        unsafe { crate::bpf_probe_read(&self.hdr) }.ok()
    }
    pub fn nr_types(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nr_types) }.ok()
    }
    pub fn types_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.types_size) }.ok()
    }
    pub fn data_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_size) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn base_btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.base_btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn start_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start_id) }.ok()
    }
    pub fn start_str_off(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start_str_off) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 56usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn kernel_btf(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.kernel_btf) }.ok()
    }
}
impl btf_type {
    pub fn name_off(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.name_off) }.ok()
    }
    pub fn info(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.size) }.ok()
    }
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.type_) }.ok()
    }
}
impl btf_type__bindgen_ty_1 {
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl bpf_ksym {
    pub fn start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn lnode(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.lnode) }.ok()
    }
    pub fn tnode(&self) -> Option<latch_tree_node> {
        unsafe { crate::bpf_probe_read(&self.tnode) }.ok()
    }
    pub fn prog(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.prog) }.ok()
    }
}
impl bpf_prog_aux {
    pub fn refcnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn used_map_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.used_map_cnt) }.ok()
    }
    pub fn max_ctx_offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_ctx_offset) }.ok()
    }
    pub fn max_pkt_offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_pkt_offset) }.ok()
    }
    pub fn max_tp_access(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_tp_access) }.ok()
    }
    pub fn stack_depth(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.stack_depth) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn func_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.func_cnt) }.ok()
    }
    pub fn func_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.func_idx) }.ok()
    }
    pub fn attach_btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.attach_btf_id) }.ok()
    }
    pub fn ctx_arg_info_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ctx_arg_info_size) }.ok()
    }
    pub fn max_rdonly_access(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_rdonly_access) }.ok()
    }
    pub fn max_rdwr_access(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_rdwr_access) }.ok()
    }
    pub fn attach_btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.attach_btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctx_arg_info(&self) -> Option<*const bpf_ctx_arg_aux> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx_arg_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.dst_mutex) }.ok()
    }
    pub fn dst_prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.dst_prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst_trampoline(&self) -> Option<*mut bpf_trampoline> {
        let v = unsafe { crate::bpf_probe_read(&self.dst_trampoline) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saved_dst_prog_type(&self) -> Option<bpf_prog_type::Type> {
        unsafe { crate::bpf_probe_read(&self.saved_dst_prog_type) }.ok()
    }
    pub fn saved_dst_attach_type(&self) -> Option<bpf_attach_type::Type> {
        unsafe { crate::bpf_probe_read(&self.saved_dst_attach_type) }.ok()
    }
    pub fn verifier_zext(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.verifier_zext) }.ok()
    }
    pub fn offload_requested(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.offload_requested) }.ok()
    }
    pub fn attach_btf_trace(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.attach_btf_trace) }.ok()
    }
    pub fn func_proto_unreliable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.func_proto_unreliable) }.ok()
    }
    pub fn sleepable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.sleepable) }.ok()
    }
    pub fn tail_call_reachable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tail_call_reachable) }.ok()
    }
    pub fn tramp_hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.tramp_hlist) }.ok()
    }
    pub fn attach_func_proto(&self) -> Option<*const btf_type> {
        let v = unsafe { crate::bpf_probe_read(&self.attach_func_proto) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn attach_func_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.attach_func_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func(&self) -> Option<*mut *mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.func) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn jit_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.jit_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn poke_tab(&self) -> Option<*mut bpf_jit_poke_descriptor> {
        let v = unsafe { crate::bpf_probe_read(&self.poke_tab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size_poke_tab(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.size_poke_tab) }.ok()
    }
    pub fn ksym(&self) -> Option<bpf_ksym> {
        unsafe { crate::bpf_probe_read(&self.ksym) }.ok()
    }
    pub fn ops(&self) -> Option<*const bpf_prog_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used_maps(&self) -> Option<*mut *mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.used_maps) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used_maps_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.used_maps_mutex) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn load_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.load_time) }.ok()
    }
    pub fn cgroup_storage(&self) -> Option<[*mut bpf_map; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.cgroup_storage) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn security(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offload(&self) -> Option<*mut bpf_prog_offload> {
        let v = unsafe { crate::bpf_probe_read(&self.offload) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func_info(&self) -> Option<*mut bpf_func_info> {
        let v = unsafe { crate::bpf_probe_read(&self.func_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func_info_aux(&self) -> Option<*mut bpf_func_info_aux> {
        let v = unsafe { crate::bpf_probe_read(&self.func_info_aux) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn linfo(&self) -> Option<*mut bpf_line_info> {
        let v = unsafe { crate::bpf_probe_read(&self.linfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn jited_linfo(&self) -> Option<*mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.jited_linfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func_info_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.func_info_cnt) }.ok()
    }
    pub fn nr_linfo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nr_linfo) }.ok()
    }
    pub fn linfo_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.linfo_idx) }.ok()
    }
    pub fn num_exentries(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_exentries) }.ok()
    }
    pub fn extable(&self) -> Option<*mut exception_table_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.extable) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stats(&self) -> Option<*mut bpf_prog_stats> {
        let v = unsafe { crate::bpf_probe_read(&self.stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
}
impl bpf_prog_aux__bindgen_ty_1 {
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl sock_filter {
    pub fn code(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
    pub fn jt(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.jt) }.ok()
    }
    pub fn jf(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.jf) }.ok()
    }
    pub fn k(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.k) }.ok()
    }
}
impl bpf_prog {
    pub fn pages(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.pages) }.ok()
    }
    pub fn type_(&self) -> Option<bpf_prog_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn expected_attach_type(&self) -> Option<bpf_attach_type::Type> {
        unsafe { crate::bpf_probe_read(&self.expected_attach_type) }.ok()
    }
    pub fn len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn jited_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.jited_len) }.ok()
    }
    pub fn tag(&self) -> Option<[u8_; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tag) }.ok()
    }
    pub fn aux(&self) -> Option<*mut bpf_prog_aux> {
        let v = unsafe { crate::bpf_probe_read(&self.aux) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn orig_prog(&self) -> Option<*mut sock_fprog_kern> {
        let v = unsafe { crate::bpf_probe_read(&self.orig_prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bpf_func(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf_cty::c_void,
                arg2: *const bpf_insn,
            ) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bpf_func) }.ok()
    }
    pub fn insns(&self) -> Option<__IncompleteArrayField<sock_filter>> {
        unsafe { crate::bpf_probe_read(&self.insns) }.ok()
    }
    pub fn insnsi(&self) -> Option<__IncompleteArrayField<bpf_insn>> {
        unsafe { crate::bpf_probe_read(&self.insnsi) }.ok()
    }
}
impl bpf_map_dev_ops {
    pub fn map_get_next_key(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_offloaded_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_get_next_key) }.ok()
    }
    pub fn map_lookup_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_offloaded_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_lookup_elem) }.ok()
    }
    pub fn map_update_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_offloaded_map,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_update_elem) }.ok()
    }
    pub fn map_delete_elem(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_offloaded_map,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.map_delete_elem) }.ok()
    }
}
impl bpf_offloaded_map {
    pub fn map(&self) -> Option<bpf_map> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_ops(&self) -> Option<*const bpf_map_dev_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offloads(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.offloads) }.ok()
    }
}
impl net_device_stats {
    pub fn rx_packets(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_packets) }.ok()
    }
    pub fn tx_packets(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_packets) }.ok()
    }
    pub fn rx_bytes(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_bytes) }.ok()
    }
    pub fn tx_bytes(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_bytes) }.ok()
    }
    pub fn rx_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_errors) }.ok()
    }
    pub fn tx_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_errors) }.ok()
    }
    pub fn rx_dropped(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_dropped) }.ok()
    }
    pub fn tx_dropped(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_dropped) }.ok()
    }
    pub fn multicast(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.multicast) }.ok()
    }
    pub fn collisions(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.collisions) }.ok()
    }
    pub fn rx_length_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_length_errors) }.ok()
    }
    pub fn rx_over_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_over_errors) }.ok()
    }
    pub fn rx_crc_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_crc_errors) }.ok()
    }
    pub fn rx_frame_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_frame_errors) }.ok()
    }
    pub fn rx_fifo_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_fifo_errors) }.ok()
    }
    pub fn rx_missed_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_missed_errors) }.ok()
    }
    pub fn tx_aborted_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_aborted_errors) }.ok()
    }
    pub fn tx_carrier_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_carrier_errors) }.ok()
    }
    pub fn tx_fifo_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_fifo_errors) }.ok()
    }
    pub fn tx_heartbeat_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_heartbeat_errors) }.ok()
    }
    pub fn tx_window_errors(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_window_errors) }.ok()
    }
    pub fn rx_compressed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rx_compressed) }.ok()
    }
    pub fn tx_compressed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_compressed) }.ok()
    }
}
impl netdev_hw_addr_list {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl tipc_bearer {}
impl dn_dev {}
impl mpls_dev {}
impl pcpu_dstats {}
impl garp_port {}
impl mrp_port {}
impl netdev_tc_txq {
    pub fn count(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl macsec_ops {}
impl udp_tunnel_nic {}
impl bpf_xdp_entity {
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn link(&self) -> Option<*mut bpf_xdp_link> {
        let v = unsafe { crate::bpf_probe_read(&self.link) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl net_device {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn name_node(&self) -> Option<*mut netdev_name_node> {
        let v = unsafe { crate::bpf_probe_read(&self.name_node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ifalias(&self) -> Option<*mut dev_ifalias> {
        let v = unsafe { crate::bpf_probe_read(&self.ifalias) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mem_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mem_end) }.ok()
    }
    pub fn mem_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mem_start) }.ok()
    }
    pub fn base_addr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.base_addr) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn dev_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dev_list) }.ok()
    }
    pub fn napi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.napi_list) }.ok()
    }
    pub fn unreg_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.unreg_list) }.ok()
    }
    pub fn close_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.close_list) }.ok()
    }
    pub fn ptype_all(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ptype_all) }.ok()
    }
    pub fn ptype_specific(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ptype_specific) }.ok()
    }
    pub fn adj_list(&self) -> Option<net_device__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.adj_list) }.ok()
    }
    pub fn features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.features) }.ok()
    }
    pub fn hw_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.hw_features) }.ok()
    }
    pub fn wanted_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.wanted_features) }.ok()
    }
    pub fn vlan_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.vlan_features) }.ok()
    }
    pub fn hw_enc_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.hw_enc_features) }.ok()
    }
    pub fn mpls_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.mpls_features) }.ok()
    }
    pub fn gso_partial_features(&self) -> Option<netdev_features_t> {
        unsafe { crate::bpf_probe_read(&self.gso_partial_features) }.ok()
    }
    pub fn ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn group(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.group) }.ok()
    }
    pub fn stats(&self) -> Option<net_device_stats> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn rx_dropped(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.rx_dropped) }.ok()
    }
    pub fn tx_dropped(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.tx_dropped) }.ok()
    }
    pub fn rx_nohandler(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.rx_nohandler) }.ok()
    }
    pub fn carrier_up_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.carrier_up_count) }.ok()
    }
    pub fn carrier_down_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.carrier_down_count) }.ok()
    }
    pub fn wireless_handlers(&self) -> Option<*const iw_handler_def> {
        let v = unsafe { crate::bpf_probe_read(&self.wireless_handlers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wireless_data(&self) -> Option<*mut iw_public_data> {
        let v = unsafe { crate::bpf_probe_read(&self.wireless_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev_ops(&self) -> Option<*const net_device_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ethtool_ops(&self) -> Option<*const ethtool_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ethtool_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn l3mdev_ops(&self) -> Option<*const l3mdev_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.l3mdev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ndisc_ops(&self) -> Option<*const ndisc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ndisc_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrmdev_ops(&self) -> Option<*const xfrmdev_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.xfrmdev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tlsdev_ops(&self) -> Option<*const tlsdev_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.tlsdev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn header_ops(&self) -> Option<*const header_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.header_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn priv_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.priv_flags) }.ok()
    }
    pub fn gflags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.gflags) }.ok()
    }
    pub fn padded(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.padded) }.ok()
    }
    pub fn operstate(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.operstate) }.ok()
    }
    pub fn link_mode(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.link_mode) }.ok()
    }
    pub fn if_port(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.if_port) }.ok()
    }
    pub fn dma(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.dma) }.ok()
    }
    pub fn mtu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mtu) }.ok()
    }
    pub fn min_mtu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.min_mtu) }.ok()
    }
    pub fn max_mtu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_mtu) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn hard_header_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.hard_header_len) }.ok()
    }
    pub fn min_header_len(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.min_header_len) }.ok()
    }
    pub fn name_assign_type(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.name_assign_type) }.ok()
    }
    pub fn needed_headroom(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.needed_headroom) }.ok()
    }
    pub fn needed_tailroom(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.needed_tailroom) }.ok()
    }
    pub fn perm_addr(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.perm_addr) }.ok()
    }
    pub fn addr_assign_type(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.addr_assign_type) }.ok()
    }
    pub fn addr_len(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.addr_len) }.ok()
    }
    pub fn upper_level(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.upper_level) }.ok()
    }
    pub fn lower_level(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.lower_level) }.ok()
    }
    pub fn neigh_priv_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.neigh_priv_len) }.ok()
    }
    pub fn dev_id(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.dev_id) }.ok()
    }
    pub fn dev_port(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.dev_port) }.ok()
    }
    pub fn addr_list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.addr_list_lock) }.ok()
    }
    pub fn uc(&self) -> Option<netdev_hw_addr_list> {
        unsafe { crate::bpf_probe_read(&self.uc) }.ok()
    }
    pub fn mc(&self) -> Option<netdev_hw_addr_list> {
        unsafe { crate::bpf_probe_read(&self.mc) }.ok()
    }
    pub fn dev_addrs(&self) -> Option<netdev_hw_addr_list> {
        unsafe { crate::bpf_probe_read(&self.dev_addrs) }.ok()
    }
    pub fn queues_kset(&self) -> Option<*mut kset> {
        let v = unsafe { crate::bpf_probe_read(&self.queues_kset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn promiscuity(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.promiscuity) }.ok()
    }
    pub fn allmulti(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.allmulti) }.ok()
    }
    pub fn uc_promisc(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.uc_promisc) }.ok()
    }
    pub fn vlan_info(&self) -> Option<*mut vlan_info> {
        let v = unsafe { crate::bpf_probe_read(&self.vlan_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dsa_ptr(&self) -> Option<*mut dsa_port> {
        let v = unsafe { crate::bpf_probe_read(&self.dsa_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tipc_ptr(&self) -> Option<*mut tipc_bearer> {
        let v = unsafe { crate::bpf_probe_read(&self.tipc_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn atalk_ptr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.atalk_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip_ptr(&self) -> Option<*mut in_device> {
        let v = unsafe { crate::bpf_probe_read(&self.ip_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dn_ptr(&self) -> Option<*mut dn_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.dn_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip6_ptr(&self) -> Option<*mut inet6_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.ip6_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ax25_ptr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ax25_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ieee80211_ptr(&self) -> Option<*mut wireless_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.ieee80211_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ieee802154_ptr(&self) -> Option<*mut wpan_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.ieee802154_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mpls_ptr(&self) -> Option<*mut mpls_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.mpls_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_addr(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _rx(&self) -> Option<*mut netdev_rx_queue> {
        let v = unsafe { crate::bpf_probe_read(&self._rx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_rx_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_rx_queues) }.ok()
    }
    pub fn real_num_rx_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.real_num_rx_queues) }.ok()
    }
    pub fn xdp_prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.xdp_prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gro_flush_timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.gro_flush_timeout) }.ok()
    }
    pub fn napi_defer_hard_irqs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.napi_defer_hard_irqs) }.ok()
    }
    pub fn rx_handler(&self) -> Option<rx_handler_func_t> {
        unsafe { crate::bpf_probe_read(&self.rx_handler) }.ok()
    }
    pub fn rx_handler_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.rx_handler_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn miniq_ingress(&self) -> Option<*mut mini_Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.miniq_ingress) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ingress_queue(&self) -> Option<*mut netdev_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.ingress_queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nf_hooks_ingress(&self) -> Option<*mut nf_hook_entries> {
        let v = unsafe { crate::bpf_probe_read(&self.nf_hooks_ingress) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn broadcast(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.broadcast) }.ok()
    }
    pub fn rx_cpu_rmap(&self) -> Option<*mut cpu_rmap> {
        let v = unsafe { crate::bpf_probe_read(&self.rx_cpu_rmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index_hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.index_hlist) }.ok()
    }
    pub fn _tx(&self) -> Option<*mut netdev_queue> {
        let v = unsafe { crate::bpf_probe_read(&self._tx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_tx_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_tx_queues) }.ok()
    }
    pub fn real_num_tx_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.real_num_tx_queues) }.ok()
    }
    pub fn qdisc(&self) -> Option<*mut Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.qdisc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tx_queue_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tx_queue_len) }.ok()
    }
    pub fn tx_global_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.tx_global_lock) }.ok()
    }
    pub fn xdp_bulkq(&self) -> Option<*mut xdp_dev_bulk_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.xdp_bulkq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xps_cpus_map(&self) -> Option<*mut xps_dev_maps> {
        let v = unsafe { crate::bpf_probe_read(&self.xps_cpus_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xps_rxqs_map(&self) -> Option<*mut xps_dev_maps> {
        let v = unsafe { crate::bpf_probe_read(&self.xps_rxqs_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn miniq_egress(&self) -> Option<*mut mini_Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.miniq_egress) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qdisc_hash(&self) -> Option<[hlist_head; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.qdisc_hash) }.ok()
    }
    pub fn watchdog_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.watchdog_timer) }.ok()
    }
    pub fn watchdog_timeo(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.watchdog_timeo) }.ok()
    }
    pub fn proto_down_reason(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.proto_down_reason) }.ok()
    }
    pub fn todo_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.todo_list) }.ok()
    }
    pub fn pcpu_refcnt(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.pcpu_refcnt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn link_watch_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.link_watch_list) }.ok()
    }
    pub fn dismantle(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dismantle) }.ok()
    }
    pub fn needs_free_netdev(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.needs_free_netdev) }.ok()
    }
    pub fn priv_destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.priv_destructor) }.ok()
    }
    pub fn npinfo(&self) -> Option<*mut netpoll_info> {
        let v = unsafe { crate::bpf_probe_read(&self.npinfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nd_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.nd_net) }.ok()
    }
    pub fn ml_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ml_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ml_priv_type(&self) -> Option<netdev_ml_priv_type::Type> {
        unsafe { crate::bpf_probe_read(&self.ml_priv_type) }.ok()
    }
    pub fn lstats(&self) -> Option<*mut pcpu_lstats> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tstats(&self) -> Option<*mut pcpu_sw_netstats> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dstats(&self) -> Option<*mut pcpu_dstats> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn garp_port(&self) -> Option<*mut garp_port> {
        let v = unsafe { crate::bpf_probe_read(&self.garp_port) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mrp_port(&self) -> Option<*mut mrp_port> {
        let v = unsafe { crate::bpf_probe_read(&self.mrp_port) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn sysfs_groups(&self) -> Option<[*const attribute_group; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.sysfs_groups) }.ok()
    }
    pub fn sysfs_rx_queue_group(&self) -> Option<*const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.sysfs_rx_queue_group) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rtnl_link_ops(&self) -> Option<*const rtnl_link_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.rtnl_link_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gso_max_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.gso_max_size) }.ok()
    }
    pub fn gso_max_segs(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.gso_max_segs) }.ok()
    }
    pub fn dcbnl_ops(&self) -> Option<*const dcbnl_rtnl_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.dcbnl_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_tc(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.num_tc) }.ok()
    }
    pub fn tc_to_txq(&self) -> Option<[netdev_tc_txq; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_to_txq) }.ok()
    }
    pub fn prio_tc_map(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.prio_tc_map) }.ok()
    }
    pub fn fcoe_ddp_xid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fcoe_ddp_xid) }.ok()
    }
    pub fn priomap(&self) -> Option<*mut netprio_map> {
        let v = unsafe { crate::bpf_probe_read(&self.priomap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phydev(&self) -> Option<*mut phy_device> {
        let v = unsafe { crate::bpf_probe_read(&self.phydev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sfp_bus(&self) -> Option<*mut sfp_bus> {
        let v = unsafe { crate::bpf_probe_read(&self.sfp_bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qdisc_tx_busylock(&self) -> Option<*mut lock_class_key> {
        let v = unsafe { crate::bpf_probe_read(&self.qdisc_tx_busylock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qdisc_running_key(&self) -> Option<*mut lock_class_key> {
        let v = unsafe { crate::bpf_probe_read(&self.qdisc_running_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proto_down(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.proto_down) }.ok()
    }
    pub fn net_notifier_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.net_notifier_list) }.ok()
    }
    pub fn macsec_ops(&self) -> Option<*const macsec_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.macsec_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_tunnel_nic_info(&self) -> Option<*const udp_tunnel_nic_info> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_tunnel_nic_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_tunnel_nic(&self) -> Option<*mut udp_tunnel_nic> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_tunnel_nic) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xdp_state(&self) -> Option<[bpf_xdp_entity; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.xdp_state) }.ok()
    }
}
impl net_device__bindgen_ty_1 {
    pub fn upper(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.upper) }.ok()
    }
    pub fn lower(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.lower) }.ok()
    }
}
impl net_device__bindgen_ty_4 {
    pub fn lstats(&self) -> Option<*mut pcpu_lstats> {
        let v = unsafe { crate::bpf_probe_read(&self.lstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tstats(&self) -> Option<*mut pcpu_sw_netstats> {
        let v = unsafe { crate::bpf_probe_read(&self.tstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dstats(&self) -> Option<*mut pcpu_dstats> {
        let v = unsafe { crate::bpf_probe_read(&self.dstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_prog_ops {
    pub fn test_run(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_prog,
                arg2: *const bpf_attr,
                arg3: *mut bpf_attr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.test_run) }.ok()
    }
}
impl bpf_prog_offload {
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offdev(&self) -> Option<*mut bpf_offload_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.offdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offloads(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.offloads) }.ok()
    }
    pub fn dev_state(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dev_state) }.ok()
    }
    pub fn opt_failed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.opt_failed) }.ok()
    }
    pub fn jited_image(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.jited_image) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn jited_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.jited_len) }.ok()
    }
}
impl bpf_prog_stats {
    pub fn cnt(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cnt) }.ok()
    }
    pub fn nsecs(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nsecs) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl btf_func_model {
    pub fn ret_size(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ret_size) }.ok()
    }
    pub fn nr_args(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.nr_args) }.ok()
    }
    pub fn arg_size(&self) -> Option<[u8_; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.arg_size) }.ok()
    }
}
impl bpf_tramp_image {
    pub fn image(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.image) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ksym(&self) -> Option<bpf_ksym> {
        unsafe { crate::bpf_probe_read(&self.ksym) }.ok()
    }
    pub fn pcref(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.pcref) }.ok()
    }
    pub fn ip_after_call(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ip_after_call) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip_epilogue(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ip_epilogue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.work) }.ok()
    }
}
impl bpf_tramp_image__bindgen_ty_1 {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
}
impl bpf_trampoline {
    pub fn hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hlist) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn key(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn func(&self) -> Option<bpf_trampoline__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn extension_prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.extension_prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn progs_hlist(&self) -> Option<[hlist_head; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.progs_hlist) }.ok()
    }
    pub fn progs_cnt(&self) -> Option<[::aya_bpf_cty::c_int; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.progs_cnt) }.ok()
    }
    pub fn cur_image(&self) -> Option<*mut bpf_tramp_image> {
        let v = unsafe { crate::bpf_probe_read(&self.cur_image) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn selector(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.selector) }.ok()
    }
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_trampoline__bindgen_ty_1 {
    pub fn model(&self) -> Option<btf_func_model> {
        unsafe { crate::bpf_probe_read(&self.model) }.ok()
    }
    pub fn addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ftrace_managed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ftrace_managed) }.ok()
    }
}
impl bpf_func_info_aux {
    pub fn linkage(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.linkage) }.ok()
    }
    pub fn unreliable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.unreliable) }.ok()
    }
}
impl bpf_jit_poke_descriptor {
    pub fn tailcall_target(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.tailcall_target) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tailcall_bypass(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.tailcall_bypass) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bypass_addr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.bypass_addr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail_call(&self) -> Option<bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tail_call) }.ok()
    }
    pub fn tailcall_target_stable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tailcall_target_stable) }.ok()
    }
    pub fn adj_off(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.adj_off) }.ok()
    }
    pub fn reason(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.reason) }.ok()
    }
    pub fn insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.insn_idx) }.ok()
    }
}
impl bpf_jit_poke_descriptor__bindgen_ty_1 {
    pub fn tail_call(&self) -> Option<bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.tail_call) }.ok()
    }
}
impl bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub fn map(&self) -> Option<*mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl bpf_ctx_arg_aux {
    pub fn offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn reg_type(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.reg_type) }.ok()
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
}
impl sk_buff {
    pub fn next(&self) -> Option<*mut sk_buff> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev(&self) -> Option<*mut sk_buff> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe {
            crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.__bindgen_anon_1.dev)
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_scratch(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .dev_scratch,
            )
        }
        .ok()
    }
    pub fn rbnode(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rbnode) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.list) }.ok()
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip_defrag_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ip_defrag_offset) }.ok()
    }
    pub fn tstamp(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.tstamp) }.ok()
    }
    pub fn skb_mstamp_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.skb_mstamp_ns) }.ok()
    }
    pub fn cb(&self) -> Option<[::aya_bpf_cty::c_char; 48usize]> {
        unsafe { crate::bpf_probe_read(&self.cb) }.ok()
    }
    pub fn _skb_refdst(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.__bindgen_anon_1._skb_refdst) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.__bindgen_anon_1.destructor) }.ok()
    }
    pub fn tcp_tsorted_anchor(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.tcp_tsorted_anchor) }.ok()
    }
    pub fn _nfct(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._nfct) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.data_len) }.ok()
    }
    pub fn mac_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.mac_len) }.ok()
    }
    pub fn hdr_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.hdr_len) }.ok()
    }
    pub fn queue_mapping(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.queue_mapping) }.ok()
    }
    pub fn __cloned_offset(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.__cloned_offset) }.ok()
    }
    pub fn active_extensions(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.active_extensions) }.ok()
    }
    pub fn headers_start(&self) -> Option<__IncompleteArrayField<__u32>> {
        unsafe { crate::bpf_probe_read(&self.headers_start) }.ok()
    }
    pub fn __pkt_type_offset(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.__pkt_type_offset) }.ok()
    }
    pub fn __pkt_vlan_present_offset(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.__pkt_vlan_present_offset) }.ok()
    }
    pub fn tc_index(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.tc_index) }.ok()
    }
    pub fn csum(&self) -> Option<__wsum> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.csum) }.ok()
    }
    pub fn csum_start(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.__bindgen_anon_1.csum_start) }.ok()
    }
    pub fn csum_offset(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_5.__bindgen_anon_1.csum_offset) }.ok()
    }
    pub fn priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn skb_iif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.skb_iif) }.ok()
    }
    pub fn hash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn vlan_proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.vlan_proto) }.ok()
    }
    pub fn vlan_tci(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.vlan_tci) }.ok()
    }
    pub fn napi_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.napi_id) }.ok()
    }
    pub fn sender_cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_6.sender_cpu) }.ok()
    }
    pub fn secmark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.secmark) }.ok()
    }
    pub fn mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.mark) }.ok()
    }
    pub fn reserved_tailroom(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_7.reserved_tailroom) }.ok()
    }
    pub fn inner_protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_8.inner_protocol) }.ok()
    }
    pub fn inner_ipproto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_8.inner_ipproto) }.ok()
    }
    pub fn inner_transport_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.inner_transport_header) }.ok()
    }
    pub fn inner_network_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.inner_network_header) }.ok()
    }
    pub fn inner_mac_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.inner_mac_header) }.ok()
    }
    pub fn protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn transport_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.transport_header) }.ok()
    }
    pub fn network_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.network_header) }.ok()
    }
    pub fn mac_header(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.mac_header) }.ok()
    }
    pub fn headers_end(&self) -> Option<__IncompleteArrayField<__u32>> {
        unsafe { crate::bpf_probe_read(&self.headers_end) }.ok()
    }
    pub fn tail(&self) -> Option<sk_buff_data_t> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
    pub fn end(&self) -> Option<sk_buff_data_t> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
    pub fn head(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn truesize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.truesize) }.ok()
    }
    pub fn users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn extensions(&self) -> Option<*mut skb_ext> {
        let v = unsafe { crate::bpf_probe_read(&self.extensions) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_buff__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_scratch(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.dev_scratch) }.ok()
    }
    pub fn rbnode(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rbnode) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_scratch(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dev_scratch) }.ok()
    }
}
impl sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_scratch(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dev_scratch) }.ok()
    }
}
impl sk_buff__bindgen_ty_2 {
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ip_defrag_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ip_defrag_offset) }.ok()
    }
}
impl sk_buff__bindgen_ty_3 {
    pub fn tstamp(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.tstamp) }.ok()
    }
    pub fn skb_mstamp_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.skb_mstamp_ns) }.ok()
    }
}
impl sk_buff__bindgen_ty_4 {
    pub fn _skb_refdst(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1._skb_refdst) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.destructor) }.ok()
    }
    pub fn tcp_tsorted_anchor(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tcp_tsorted_anchor) }.ok()
    }
}
impl sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub fn _skb_refdst(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._skb_refdst) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
}
impl sk_buff__bindgen_ty_5 {
    pub fn csum(&self) -> Option<__wsum> {
        unsafe { crate::bpf_probe_read(&self.csum) }.ok()
    }
    pub fn csum_start(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.csum_start) }.ok()
    }
    pub fn csum_offset(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.csum_offset) }.ok()
    }
}
impl sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub fn csum_start(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.csum_start) }.ok()
    }
    pub fn csum_offset(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.csum_offset) }.ok()
    }
}
impl sk_buff__bindgen_ty_6 {
    pub fn napi_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.napi_id) }.ok()
    }
    pub fn sender_cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sender_cpu) }.ok()
    }
}
impl sk_buff__bindgen_ty_7 {
    pub fn mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn reserved_tailroom(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reserved_tailroom) }.ok()
    }
}
impl sk_buff__bindgen_ty_8 {
    pub fn inner_protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.inner_protocol) }.ok()
    }
    pub fn inner_ipproto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.inner_ipproto) }.ok()
    }
}
impl scatterlist {
    pub fn page_link(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.page_link) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn length(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn dma_address(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.dma_address) }.ok()
    }
    pub fn dma_length(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dma_length) }.ok()
    }
}
impl flowi_tunnel {
    pub fn tun_id(&self) -> Option<__be64> {
        unsafe { crate::bpf_probe_read(&self.tun_id) }.ok()
    }
}
impl flowi_common {
    pub fn flowic_oif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flowic_oif) }.ok()
    }
    pub fn flowic_iif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flowic_iif) }.ok()
    }
    pub fn flowic_mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flowic_mark) }.ok()
    }
    pub fn flowic_tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flowic_tos) }.ok()
    }
    pub fn flowic_scope(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flowic_scope) }.ok()
    }
    pub fn flowic_proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flowic_proto) }.ok()
    }
    pub fn flowic_flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flowic_flags) }.ok()
    }
    pub fn flowic_secid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flowic_secid) }.ok()
    }
    pub fn flowic_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.flowic_uid) }.ok()
    }
    pub fn flowic_tun_key(&self) -> Option<flowi_tunnel> {
        unsafe { crate::bpf_probe_read(&self.flowic_tun_key) }.ok()
    }
    pub fn flowic_multipath_hash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flowic_multipath_hash) }.ok()
    }
}
impl flowi_uli {
    pub fn ports(&self) -> Option<flowi_uli__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ports) }.ok()
    }
    pub fn icmpt(&self) -> Option<flowi_uli__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.icmpt) }.ok()
    }
    pub fn dnports(&self) -> Option<flowi_uli__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.dnports) }.ok()
    }
    pub fn spi(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.spi) }.ok()
    }
    pub fn gre_key(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.gre_key) }.ok()
    }
    pub fn mht(&self) -> Option<flowi_uli__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.mht) }.ok()
    }
}
impl flowi_uli__bindgen_ty_1 {
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
}
impl flowi_uli__bindgen_ty_2 {
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn code(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
}
impl flowi_uli__bindgen_ty_3 {
    pub fn dport(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
    pub fn sport(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
}
impl flowi_uli__bindgen_ty_4 {
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl flowi4 {
    pub fn __fl_common(&self) -> Option<flowi_common> {
        unsafe { crate::bpf_probe_read(&self.__fl_common) }.ok()
    }
    pub fn saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn uli(&self) -> Option<flowi_uli> {
        unsafe { crate::bpf_probe_read(&self.uli) }.ok()
    }
}
impl flowi6 {
    pub fn __fl_common(&self) -> Option<flowi_common> {
        unsafe { crate::bpf_probe_read(&self.__fl_common) }.ok()
    }
    pub fn daddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn flowlabel(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.flowlabel) }.ok()
    }
    pub fn uli(&self) -> Option<flowi_uli> {
        unsafe { crate::bpf_probe_read(&self.uli) }.ok()
    }
    pub fn mp_hash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mp_hash) }.ok()
    }
}
impl flowidn {
    pub fn __fl_common(&self) -> Option<flowi_common> {
        unsafe { crate::bpf_probe_read(&self.__fl_common) }.ok()
    }
    pub fn daddr(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn saddr(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn uli(&self) -> Option<flowi_uli> {
        unsafe { crate::bpf_probe_read(&self.uli) }.ok()
    }
}
impl flowi {
    pub fn u(&self) -> Option<flowi__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
}
impl flowi__bindgen_ty_1 {
    pub fn __fl_common(&self) -> Option<flowi_common> {
        unsafe { crate::bpf_probe_read(&self.__fl_common) }.ok()
    }
    pub fn ip4(&self) -> Option<flowi4> {
        unsafe { crate::bpf_probe_read(&self.ip4) }.ok()
    }
    pub fn ip6(&self) -> Option<flowi6> {
        unsafe { crate::bpf_probe_read(&self.ip6) }.ok()
    }
    pub fn dn(&self) -> Option<flowidn> {
        unsafe { crate::bpf_probe_read(&self.dn) }.ok()
    }
}
impl ipstats_mib {
    pub fn mibs(&self) -> Option<[u64_; 37usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl icmp_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 28usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl icmpmsg_mib {
    pub fn mibs(&self) -> Option<[atomic_long_t; 512usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl icmpv6_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl icmpv6_mib_device {
    pub fn mibs(&self) -> Option<[atomic_long_t; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl icmpv6msg_mib {
    pub fn mibs(&self) -> Option<[atomic_long_t; 512usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl icmpv6msg_mib_device {
    pub fn mibs(&self) -> Option<[atomic_long_t; 512usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl tcp_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl udp_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl linux_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 124usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl linux_xfrm_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 29usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl linux_tls_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl fqdir {
    pub fn high_thresh(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.high_thresh) }.ok()
    }
    pub fn low_thresh(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.low_thresh) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn max_dist(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_dist) }.ok()
    }
    pub fn f(&self) -> Option<*mut inet_frags> {
        let v = unsafe { crate::bpf_probe_read(&self.f) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dead(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn rhashtable(&self) -> Option<rhashtable> {
        unsafe { crate::bpf_probe_read(&self.rhashtable) }.ok()
    }
    pub fn mem(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.mem) }.ok()
    }
    pub fn destroy_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.destroy_work) }.ok()
    }
    pub fn free_list(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.free_list) }.ok()
    }
}
impl inet_frags {
    pub fn qsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.qsize) }.ok()
    }
    pub fn constructor(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inet_frag_queue, arg2: *const ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.constructor) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
    pub fn frag_expire(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>> {
        unsafe { crate::bpf_probe_read(&self.frag_expire) }.ok()
    }
    pub fn frags_cachep(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.frags_cachep) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frags_cache_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.frags_cache_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rhash_params(&self) -> Option<rhashtable_params> {
        unsafe { crate::bpf_probe_read(&self.rhash_params) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn completion(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.completion) }.ok()
    }
}
impl frag_v4_compare_key {
    pub fn saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn user(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.user) }.ok()
    }
    pub fn vif(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.vif) }.ok()
    }
    pub fn id(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn protocol(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
}
impl frag_v6_compare_key {
    pub fn saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn user(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.user) }.ok()
    }
    pub fn id(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn iif(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.iif) }.ok()
    }
}
impl inet_frag_queue {
    pub fn node(&self) -> Option<rhash_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn key(&self) -> Option<inet_frag_queue__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn rb_fragments(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.rb_fragments) }.ok()
    }
    pub fn fragments_tail(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.fragments_tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn last_run_head(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.last_run_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stamp(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.stamp) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn meat(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.meat) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn max_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_size) }.ok()
    }
    pub fn fqdir(&self) -> Option<*mut fqdir> {
        let v = unsafe { crate::bpf_probe_read(&self.fqdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl inet_frag_queue__bindgen_ty_1 {
    pub fn v4(&self) -> Option<frag_v4_compare_key> {
        unsafe { crate::bpf_probe_read(&self.v4) }.ok()
    }
    pub fn v6(&self) -> Option<frag_v6_compare_key> {
        unsafe { crate::bpf_probe_read(&self.v6) }.ok()
    }
}
impl fib_rules_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn rule_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rule_size) }.ok()
    }
    pub fn addr_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.addr_size) }.ok()
    }
    pub fn unresolved_rules(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.unresolved_rules) }.ok()
    }
    pub fn nr_goto_rules(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_goto_rules) }.ok()
    }
    pub fn fib_rules_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib_rules_seq) }.ok()
    }
    pub fn action(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut flowi,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *mut fib_lookup_arg,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
    pub fn suppress(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut fib_rule, arg2: *mut fib_lookup_arg) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.suppress) }.ok()
    }
    pub fn match_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut flowi,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.match_) }.ok()
    }
    pub fn configure(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut sk_buff,
                arg3: *mut fib_rule_hdr,
                arg4: *mut *mut nlattr,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.configure) }.ok()
    }
    pub fn delete(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.delete) }.ok()
    }
    pub fn compare(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut fib_rule_hdr,
                arg3: *mut *mut nlattr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compare) }.ok()
    }
    pub fn fill(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut sk_buff,
                arg3: *mut fib_rule_hdr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill) }.ok()
    }
    pub fn nlmsg_payload(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> size_t>> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_payload) }.ok()
    }
    pub fn flush_cache(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rules_ops)>> {
        unsafe { crate::bpf_probe_read(&self.flush_cache) }.ok()
    }
    pub fn nlgroup(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nlgroup) }.ok()
    }
    pub fn policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rules_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rules_list) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fro_net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.fro_net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl tcp_congestion_ops {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn key(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn init(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn release(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn ssthresh(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.ssthresh) }.ok()
    }
    pub fn cong_avoid(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_, arg3: u32_)>>
    {
        unsafe { crate::bpf_probe_read(&self.cong_avoid) }.ok()
    }
    pub fn set_state(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u8_)>> {
        unsafe { crate::bpf_probe_read(&self.set_state) }.ok()
    }
    pub fn cwnd_event(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: tcp_ca_event::Type)>,
    > {
        unsafe { crate::bpf_probe_read(&self.cwnd_event) }.ok()
    }
    pub fn in_ack_event(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_)>> {
        unsafe { crate::bpf_probe_read(&self.in_ack_event) }.ok()
    }
    pub fn undo_cwnd(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.undo_cwnd) }.ok()
    }
    pub fn pkts_acked(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const ack_sample)>,
    > {
        unsafe { crate::bpf_probe_read(&self.pkts_acked) }.ok()
    }
    pub fn min_tso_segs(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.min_tso_segs) }.ok()
    }
    pub fn sndbuf_expand(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.sndbuf_expand) }.ok()
    }
    pub fn cong_control(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const rate_sample)>,
    > {
        unsafe { crate::bpf_probe_read(&self.cong_control) }.ok()
    }
    pub fn get_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: u32_,
                arg3: *mut ::aya_bpf_cty::c_int,
                arg4: *mut tcp_cc_info,
            ) -> size_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_info) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fib_notifier_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn fib_seq_read(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net) -> ::aya_bpf_cty::c_uint>>
    {
        unsafe { crate::bpf_probe_read(&self.fib_seq_read) }.ok()
    }
    pub fn fib_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut notifier_block,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fib_dump) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl dst_entry {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*mut dst_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _metrics(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self._metrics) }.ok()
    }
    pub fn expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
    pub fn xfrm(&self) -> Option<*mut xfrm_state> {
        let v = unsafe { crate::bpf_probe_read(&self.xfrm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn input(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.input) }.ok()
    }
    pub fn output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sock,
                arg3: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.output) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn obsolete(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.obsolete) }.ok()
    }
    pub fn header_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.header_len) }.ok()
    }
    pub fn trailer_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.trailer_len) }.ok()
    }
    pub fn __refcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__refcnt) }.ok()
    }
    pub fn __use(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__use) }.ok()
    }
    pub fn lastuse(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lastuse) }.ok()
    }
    pub fn lwtstate(&self) -> Option<*mut lwtunnel_state> {
        let v = unsafe { crate::bpf_probe_read(&self.lwtstate) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn error(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
    pub fn __pad(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.__pad) }.ok()
    }
    pub fn tclassid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tclassid) }.ok()
    }
}
impl hh_cache {
    pub fn hh_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hh_len) }.ok()
    }
    pub fn hh_lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.hh_lock) }.ok()
    }
    pub fn hh_data(&self) -> Option<[::aya_bpf_cty::c_ulong; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.hh_data) }.ok()
    }
}
impl neighbour {
    pub fn next(&self) -> Option<*mut neighbour> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tbl(&self) -> Option<*mut neigh_table> {
        let v = unsafe { crate::bpf_probe_read(&self.tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parms(&self) -> Option<*mut neigh_parms> {
        let v = unsafe { crate::bpf_probe_read(&self.parms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn confirmed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.confirmed) }.ok()
    }
    pub fn updated(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.updated) }.ok()
    }
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn arp_queue_len_bytes(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.arp_queue_len_bytes) }.ok()
    }
    pub fn arp_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.arp_queue) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn used(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.used) }.ok()
    }
    pub fn probes(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.probes) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn nud_state(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.nud_state) }.ok()
    }
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn dead(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn protocol(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn ha_lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.ha_lock) }.ok()
    }
    pub fn ha(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.ha) }.ok()
    }
    pub fn hh(&self) -> Option<hh_cache> {
        unsafe { crate::bpf_probe_read(&self.hh) }.ok()
    }
    pub fn output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.output) }.ok()
    }
    pub fn ops(&self) -> Option<*const neigh_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gc_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.gc_list) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn primary_key(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.primary_key) }.ok()
    }
}
impl ipv6_stable_secret {
    pub fn initialized(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.initialized) }.ok()
    }
    pub fn secret(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.secret) }.ok()
    }
}
impl ipv6_devconf {
    pub fn forwarding(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.forwarding) }.ok()
    }
    pub fn hop_limit(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.hop_limit) }.ok()
    }
    pub fn mtu6(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.mtu6) }.ok()
    }
    pub fn accept_ra(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra) }.ok()
    }
    pub fn accept_redirects(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_redirects) }.ok()
    }
    pub fn autoconf(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.autoconf) }.ok()
    }
    pub fn dad_transmits(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.dad_transmits) }.ok()
    }
    pub fn rtr_solicits(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rtr_solicits) }.ok()
    }
    pub fn rtr_solicit_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rtr_solicit_interval) }.ok()
    }
    pub fn rtr_solicit_max_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rtr_solicit_max_interval) }.ok()
    }
    pub fn rtr_solicit_delay(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rtr_solicit_delay) }.ok()
    }
    pub fn force_mld_version(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.force_mld_version) }.ok()
    }
    pub fn mldv1_unsolicited_report_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.mldv1_unsolicited_report_interval) }.ok()
    }
    pub fn mldv2_unsolicited_report_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.mldv2_unsolicited_report_interval) }.ok()
    }
    pub fn use_tempaddr(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.use_tempaddr) }.ok()
    }
    pub fn temp_valid_lft(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.temp_valid_lft) }.ok()
    }
    pub fn temp_prefered_lft(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.temp_prefered_lft) }.ok()
    }
    pub fn regen_max_retry(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.regen_max_retry) }.ok()
    }
    pub fn max_desync_factor(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.max_desync_factor) }.ok()
    }
    pub fn max_addresses(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.max_addresses) }.ok()
    }
    pub fn accept_ra_defrtr(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_defrtr) }.ok()
    }
    pub fn accept_ra_min_hop_limit(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_min_hop_limit) }.ok()
    }
    pub fn accept_ra_pinfo(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_pinfo) }.ok()
    }
    pub fn ignore_routes_with_linkdown(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.ignore_routes_with_linkdown) }.ok()
    }
    pub fn accept_ra_rtr_pref(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_rtr_pref) }.ok()
    }
    pub fn rtr_probe_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rtr_probe_interval) }.ok()
    }
    pub fn accept_ra_rt_info_min_plen(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_rt_info_min_plen) }.ok()
    }
    pub fn accept_ra_rt_info_max_plen(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_rt_info_max_plen) }.ok()
    }
    pub fn proxy_ndp(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.proxy_ndp) }.ok()
    }
    pub fn accept_source_route(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_source_route) }.ok()
    }
    pub fn accept_ra_from_local(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_from_local) }.ok()
    }
    pub fn mc_forwarding(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.mc_forwarding) }.ok()
    }
    pub fn disable_ipv6(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.disable_ipv6) }.ok()
    }
    pub fn drop_unicast_in_l2_multicast(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.drop_unicast_in_l2_multicast) }.ok()
    }
    pub fn accept_dad(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_dad) }.ok()
    }
    pub fn force_tllao(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.force_tllao) }.ok()
    }
    pub fn ndisc_notify(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.ndisc_notify) }.ok()
    }
    pub fn suppress_frag_ndisc(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.suppress_frag_ndisc) }.ok()
    }
    pub fn accept_ra_mtu(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.accept_ra_mtu) }.ok()
    }
    pub fn drop_unsolicited_na(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.drop_unsolicited_na) }.ok()
    }
    pub fn stable_secret(&self) -> Option<ipv6_stable_secret> {
        unsafe { crate::bpf_probe_read(&self.stable_secret) }.ok()
    }
    pub fn use_oif_addrs_only(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.use_oif_addrs_only) }.ok()
    }
    pub fn keep_addr_on_down(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.keep_addr_on_down) }.ok()
    }
    pub fn seg6_enabled(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.seg6_enabled) }.ok()
    }
    pub fn seg6_require_hmac(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.seg6_require_hmac) }.ok()
    }
    pub fn enhanced_dad(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.enhanced_dad) }.ok()
    }
    pub fn addr_gen_mode(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.addr_gen_mode) }.ok()
    }
    pub fn disable_policy(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.disable_policy) }.ok()
    }
    pub fn ndisc_tclass(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.ndisc_tclass) }.ok()
    }
    pub fn rpl_seg_enabled(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rpl_seg_enabled) }.ok()
    }
    pub fn sysctl_header(&self) -> Option<*mut ctl_table_header> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_header) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nf_queue_handler {
    pub fn outfn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut nf_queue_entry,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.outfn) }.ok()
    }
    pub fn nf_hook_drop(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net)>> {
        unsafe { crate::bpf_probe_read(&self.nf_hook_drop) }.ok()
    }
}
impl nf_logger {
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<nf_log_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn logfn(&self) -> Option<nf_logfn> {
        unsafe { crate::bpf_probe_read(&self.logfn) }.ok()
    }
    pub fn me(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.me) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl hlist_nulls_head {
    pub fn first(&self) -> Option<*mut hlist_nulls_node> {
        let v = unsafe { crate::bpf_probe_read(&self.first) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ip_conntrack_stat {
    pub fn found(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.found) }.ok()
    }
    pub fn invalid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.invalid) }.ok()
    }
    pub fn insert(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.insert) }.ok()
    }
    pub fn insert_failed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.insert_failed) }.ok()
    }
    pub fn clash_resolve(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clash_resolve) }.ok()
    }
    pub fn drop(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.drop) }.ok()
    }
    pub fn early_drop(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.early_drop) }.ok()
    }
    pub fn error(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
    pub fn expect_new(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.expect_new) }.ok()
    }
    pub fn expect_create(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.expect_create) }.ok()
    }
    pub fn expect_delete(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.expect_delete) }.ok()
    }
    pub fn search_restart(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.search_restart) }.ok()
    }
}
impl ct_pcpu {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn unconfirmed(&self) -> Option<hlist_nulls_head> {
        unsafe { crate::bpf_probe_read(&self.unconfirmed) }.ok()
    }
    pub fn dying(&self) -> Option<hlist_nulls_head> {
        unsafe { crate::bpf_probe_read(&self.dying) }.ok()
    }
}
impl sockptr_t {
    pub fn kernel(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.kernel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl sockptr_t__bindgen_ty_1 {
    pub fn kernel(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.kernel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl socket_wq {
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
    pub fn fasync_list(&self) -> Option<*mut fasync_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fasync_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl socket {
    pub fn state(&self) -> Option<socket_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const proto_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wq(&self) -> Option<socket_wq> {
        unsafe { crate::bpf_probe_read(&self.wq) }.ok()
    }
}
impl proto_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn release(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn bind(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bind) }.ok()
    }
    pub fn connect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.connect) }.ok()
    }
    pub fn socketpair(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut socket, arg2: *mut socket) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.socketpair) }.ok()
    }
    pub fn accept(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut socket,
                arg3: ::aya_bpf_cty::c_int,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.accept) }.ok()
    }
    pub fn getname(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getname) }.ok()
    }
    pub fn poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut socket,
                arg3: *mut poll_table_struct,
            ) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ioctl) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn gettstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: bool_,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.gettstamp) }.ok()
    }
    pub fn listen(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.listen) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn setsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: sockptr_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setsockopt) }.ok()
    }
    pub fn getsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *mut ::aya_bpf_cty::c_char,
                arg5: *mut ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getsockopt) }.ok()
    }
    pub fn show_fdinfo(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut socket)>>
    {
        unsafe { crate::bpf_probe_read(&self.show_fdinfo) }.ok()
    }
    pub fn sendmsg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut msghdr,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendmsg) }.ok()
    }
    pub fn recvmsg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut msghdr,
                arg3: size_t,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.recvmsg) }.ok()
    }
    pub fn mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut socket,
                arg3: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
    pub fn sendpage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut page,
                arg3: ::aya_bpf_cty::c_int,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_int,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendpage) }.ok()
    }
    pub fn splice_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut socket,
                arg2: *mut loff_t,
                arg3: *mut pipe_inode_info,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.splice_read) }.ok()
    }
    pub fn set_peek_off(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_peek_off) }.ok()
    }
    pub fn peek_len(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.peek_len) }.ok()
    }
    pub fn read_sock(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut read_descriptor_t,
                arg3: sk_read_actor_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_sock) }.ok()
    }
    pub fn sendpage_locked(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut page,
                arg3: ::aya_bpf_cty::c_int,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendpage_locked) }.ok()
    }
    pub fn sendmsg_locked(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut msghdr,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendmsg_locked) }.ok()
    }
    pub fn set_rcvlowat(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_rcvlowat) }.ok()
    }
}
impl pipe_buffer {
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn ops(&self) -> Option<*const pipe_buf_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn private(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.private) }.ok()
    }
}
impl pipe_buf_operations {
    pub fn confirm(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pipe_inode_info,
                arg2: *mut pipe_buffer,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.confirm) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn try_steal(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.try_steal) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
}
impl skb_ext {
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn offset(&self) -> Option<[u8_; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn chunks(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.chunks) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl dql {
    pub fn num_queued(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_queued) }.ok()
    }
    pub fn adj_limit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.adj_limit) }.ok()
    }
    pub fn last_obj_cnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.last_obj_cnt) }.ok()
    }
    pub fn limit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.limit) }.ok()
    }
    pub fn num_completed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_completed) }.ok()
    }
    pub fn prev_ovlimit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.prev_ovlimit) }.ok()
    }
    pub fn prev_num_queued(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.prev_num_queued) }.ok()
    }
    pub fn prev_last_obj_cnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.prev_last_obj_cnt) }.ok()
    }
    pub fn lowest_slack(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lowest_slack) }.ok()
    }
    pub fn slack_start_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.slack_start_time) }.ok()
    }
    pub fn max_limit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_limit) }.ok()
    }
    pub fn min_limit(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.min_limit) }.ok()
    }
    pub fn slack_hold_time(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.slack_hold_time) }.ok()
    }
}
impl ieee_ets {
    pub fn willing(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.willing) }.ok()
    }
    pub fn ets_cap(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ets_cap) }.ok()
    }
    pub fn cbs(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.cbs) }.ok()
    }
    pub fn tc_tx_bw(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_tx_bw) }.ok()
    }
    pub fn tc_rx_bw(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_rx_bw) }.ok()
    }
    pub fn tc_tsa(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_tsa) }.ok()
    }
    pub fn prio_tc(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.prio_tc) }.ok()
    }
    pub fn tc_reco_bw(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_reco_bw) }.ok()
    }
    pub fn tc_reco_tsa(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_reco_tsa) }.ok()
    }
    pub fn reco_prio_tc(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.reco_prio_tc) }.ok()
    }
}
impl ieee_maxrate {
    pub fn tc_maxrate(&self) -> Option<[__u64; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.tc_maxrate) }.ok()
    }
}
impl ieee_qcn {
    pub fn rpg_enable(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_enable) }.ok()
    }
    pub fn rppp_max_rps(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rppp_max_rps) }.ok()
    }
    pub fn rpg_time_reset(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_time_reset) }.ok()
    }
    pub fn rpg_byte_reset(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_byte_reset) }.ok()
    }
    pub fn rpg_threshold(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_threshold) }.ok()
    }
    pub fn rpg_max_rate(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_max_rate) }.ok()
    }
    pub fn rpg_ai_rate(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_ai_rate) }.ok()
    }
    pub fn rpg_hai_rate(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_hai_rate) }.ok()
    }
    pub fn rpg_gd(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_gd) }.ok()
    }
    pub fn rpg_min_dec_fac(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_min_dec_fac) }.ok()
    }
    pub fn rpg_min_rate(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rpg_min_rate) }.ok()
    }
    pub fn cndd_state_machine(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.cndd_state_machine) }.ok()
    }
}
impl ieee_qcn_stats {
    pub fn rppp_rp_centiseconds(&self) -> Option<[__u64; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rppp_rp_centiseconds) }.ok()
    }
    pub fn rppp_created_rps(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rppp_created_rps) }.ok()
    }
}
impl ieee_pfc {
    pub fn pfc_cap(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pfc_cap) }.ok()
    }
    pub fn pfc_en(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pfc_en) }.ok()
    }
    pub fn mbc(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.mbc) }.ok()
    }
    pub fn delay(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.delay) }.ok()
    }
    pub fn requests(&self) -> Option<[__u64; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.requests) }.ok()
    }
    pub fn indications(&self) -> Option<[__u64; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.indications) }.ok()
    }
}
impl dcbnl_buffer {
    pub fn prio2buffer(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.prio2buffer) }.ok()
    }
    pub fn buffer_size(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.buffer_size) }.ok()
    }
    pub fn total_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.total_size) }.ok()
    }
}
impl cee_pg {
    pub fn willing(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.willing) }.ok()
    }
    pub fn error(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
    pub fn pg_en(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pg_en) }.ok()
    }
    pub fn tcs_supported(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tcs_supported) }.ok()
    }
    pub fn pg_bw(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.pg_bw) }.ok()
    }
    pub fn prio_pg(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.prio_pg) }.ok()
    }
}
impl cee_pfc {
    pub fn willing(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.willing) }.ok()
    }
    pub fn error(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
    pub fn pfc_en(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pfc_en) }.ok()
    }
    pub fn tcs_supported(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tcs_supported) }.ok()
    }
}
impl dcb_app {
    pub fn selector(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.selector) }.ok()
    }
    pub fn priority(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn protocol(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
}
impl dcb_peer_app_info {
    pub fn willing(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.willing) }.ok()
    }
    pub fn error(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.error) }.ok()
    }
}
impl dcbnl_rtnl_ops {
    pub fn ieee_getets(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_ets,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getets) }.ok()
    }
    pub fn ieee_setets(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_ets,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_setets) }.ok()
    }
    pub fn ieee_getmaxrate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_maxrate,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getmaxrate) }.ok()
    }
    pub fn ieee_setmaxrate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_maxrate,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_setmaxrate) }.ok()
    }
    pub fn ieee_getqcn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_qcn,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getqcn) }.ok()
    }
    pub fn ieee_setqcn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_qcn,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_setqcn) }.ok()
    }
    pub fn ieee_getqcnstats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_qcn_stats,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getqcnstats) }.ok()
    }
    pub fn ieee_getpfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_pfc,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getpfc) }.ok()
    }
    pub fn ieee_setpfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_pfc,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_setpfc) }.ok()
    }
    pub fn ieee_getapp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_getapp) }.ok()
    }
    pub fn ieee_setapp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_setapp) }.ok()
    }
    pub fn ieee_delapp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_delapp) }.ok()
    }
    pub fn ieee_peer_getets(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_ets,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_peer_getets) }.ok()
    }
    pub fn ieee_peer_getpfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ieee_pfc,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ieee_peer_getpfc) }.ok()
    }
    pub fn getstate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>> {
        unsafe { crate::bpf_probe_read(&self.getstate) }.ok()
    }
    pub fn setstate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>>
    {
        unsafe { crate::bpf_probe_read(&self.setstate) }.ok()
    }
    pub fn getpermhwaddr(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u8_)>>
    {
        unsafe { crate::bpf_probe_read(&self.getpermhwaddr) }.ok()
    }
    pub fn setpgtccfgtx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u8_,
                arg4: u8_,
                arg5: u8_,
                arg6: u8_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setpgtccfgtx) }.ok()
    }
    pub fn setpgbwgcfgtx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setpgbwgcfgtx) }.ok()
    }
    pub fn setpgtccfgrx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u8_,
                arg4: u8_,
                arg5: u8_,
                arg6: u8_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setpgtccfgrx) }.ok()
    }
    pub fn setpgbwgcfgrx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setpgbwgcfgrx) }.ok()
    }
    pub fn getpgtccfgtx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
                arg4: *mut u8_,
                arg5: *mut u8_,
                arg6: *mut u8_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getpgtccfgtx) }.ok()
    }
    pub fn getpgbwgcfgtx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getpgbwgcfgtx) }.ok()
    }
    pub fn getpgtccfgrx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
                arg4: *mut u8_,
                arg5: *mut u8_,
                arg6: *mut u8_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getpgtccfgrx) }.ok()
    }
    pub fn getpgbwgcfgrx(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getpgbwgcfgrx) }.ok()
    }
    pub fn setpfccfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setpfccfg) }.ok()
    }
    pub fn getpfccfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getpfccfg) }.ok()
    }
    pub fn setall(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>> {
        unsafe { crate::bpf_probe_read(&self.setall) }.ok()
    }
    pub fn getcap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
            ) -> u8_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getcap) }.ok()
    }
    pub fn getnumtcs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getnumtcs) }.ok()
    }
    pub fn setnumtcs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setnumtcs) }.ok()
    }
    pub fn getpfcstate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>> {
        unsafe { crate::bpf_probe_read(&self.getpfcstate) }.ok()
    }
    pub fn setpfcstate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_)>>
    {
        unsafe { crate::bpf_probe_read(&self.setpfcstate) }.ok()
    }
    pub fn getbcncfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u32_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getbcncfg) }.ok()
    }
    pub fn setbcncfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u32_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setbcncfg) }.ok()
    }
    pub fn getbcnrp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: *mut u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getbcnrp) }.ok()
    }
    pub fn setbcnrp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setbcnrp) }.ok()
    }
    pub fn setapp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u8_,
                arg3: u16_,
                arg4: u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setapp) }.ok()
    }
    pub fn getapp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u8_,
                arg3: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getapp) }.ok()
    }
    pub fn getfeatcfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
            ) -> u8_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getfeatcfg) }.ok()
    }
    pub fn setfeatcfg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u8_,
            ) -> u8_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setfeatcfg) }.ok()
    }
    pub fn getdcbx(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>> {
        unsafe { crate::bpf_probe_read(&self.getdcbx) }.ok()
    }
    pub fn setdcbx(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>>
    {
        unsafe { crate::bpf_probe_read(&self.setdcbx) }.ok()
    }
    pub fn peer_getappinfo(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut dcb_peer_app_info,
                arg3: *mut u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.peer_getappinfo) }.ok()
    }
    pub fn peer_getapptable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.peer_getapptable) }.ok()
    }
    pub fn cee_peer_getpg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pg) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cee_peer_getpg) }.ok()
    }
    pub fn cee_peer_getpfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pfc) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cee_peer_getpfc) }.ok()
    }
    pub fn dcbnl_getbuffer(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut dcbnl_buffer,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dcbnl_getbuffer) }.ok()
    }
    pub fn dcbnl_setbuffer(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut dcbnl_buffer,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dcbnl_setbuffer) }.ok()
    }
}
impl netprio_map {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn priomap_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.priomap_len) }.ok()
    }
    pub fn priomap(&self) -> Option<__IncompleteArrayField<u32_>> {
        unsafe { crate::bpf_probe_read(&self.priomap) }.ok()
    }
}
impl xdp_mem_info {
    pub fn type_(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
}
impl xdp_rxq_info {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.queue_index) }.ok()
    }
    pub fn reg_state(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reg_state) }.ok()
    }
    pub fn mem(&self) -> Option<xdp_mem_info> {
        unsafe { crate::bpf_probe_read(&self.mem) }.ok()
    }
    pub fn napi_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.napi_id) }.ok()
    }
}
impl xdp_frame {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn headroom(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.headroom) }.ok()
    }
    pub fn mem(&self) -> Option<xdp_mem_info> {
        unsafe { crate::bpf_probe_read(&self.mem) }.ok()
    }
    pub fn dev_rx(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_rx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nlmsghdr {
    pub fn nlmsg_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_len) }.ok()
    }
    pub fn nlmsg_type(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_type) }.ok()
    }
    pub fn nlmsg_flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_flags) }.ok()
    }
    pub fn nlmsg_seq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_seq) }.ok()
    }
    pub fn nlmsg_pid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nlmsg_pid) }.ok()
    }
}
impl nlattr {
    pub fn nla_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.nla_len) }.ok()
    }
    pub fn nla_type(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.nla_type) }.ok()
    }
}
impl netlink_ext_ack {
    pub fn _msg(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self._msg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bad_attr(&self) -> Option<*const nlattr> {
        let v = unsafe { crate::bpf_probe_read(&self.bad_attr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cookie(&self) -> Option<[u8_; 20usize]> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn cookie_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.cookie_len) }.ok()
    }
}
impl nla_policy {
    pub fn type_(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn validation_type(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.validation_type) }.ok()
    }
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn bitfield32_valid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bitfield32_valid) }.ok()
    }
    pub fn mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mask) }.ok()
    }
    pub fn reject_message(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.reject_message) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nested_policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nested_policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn range(&self) -> Option<*mut netlink_range_validation> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.range) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn range_signed(&self) -> Option<*mut netlink_range_validation_signed> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.range_signed) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn min(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.min) }.ok()
    }
    pub fn max(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.max) }.ok()
    }
    pub fn validate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const nlattr,
                arg2: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.validate) }.ok()
    }
    pub fn strict_start_type(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.strict_start_type) }.ok()
    }
}
impl nla_policy__bindgen_ty_1 {
    pub fn bitfield32_valid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bitfield32_valid) }.ok()
    }
    pub fn mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn reject_message(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.reject_message) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nested_policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.nested_policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn range(&self) -> Option<*mut netlink_range_validation> {
        let v = unsafe { crate::bpf_probe_read(&self.range) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn range_signed(&self) -> Option<*mut netlink_range_validation_signed> {
        let v = unsafe { crate::bpf_probe_read(&self.range_signed) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn min(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.min) }.ok()
    }
    pub fn max(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.max) }.ok()
    }
    pub fn validate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const nlattr,
                arg2: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.validate) }.ok()
    }
    pub fn strict_start_type(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.strict_start_type) }.ok()
    }
}
impl nla_policy__bindgen_ty_1__bindgen_ty_1 {
    pub fn min(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn max(&self) -> Option<s16> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
}
impl netlink_callback {
    pub fn skb(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.skb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nlh(&self) -> Option<*const nlmsghdr> {
        let v = unsafe { crate::bpf_probe_read(&self.nlh) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut netlink_callback,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump) }.ok()
    }
    pub fn done(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut netlink_callback) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn module(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.module) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.extack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn family(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn answer_flags(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.answer_flags) }.ok()
    }
    pub fn min_dump_alloc(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.min_dump_alloc) }.ok()
    }
    pub fn prev_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.prev_seq) }.ok()
    }
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn strict_check(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.strict_check) }.ok()
    }
    pub fn ctx(&self) -> Option<[u8_; 48usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ctx) }.ok()
    }
    pub fn args(&self) -> Option<[::aya_bpf_cty::c_long; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.args) }.ok()
    }
}
impl netlink_callback__bindgen_ty_1 {
    pub fn ctx(&self) -> Option<[u8_; 48usize]> {
        unsafe { crate::bpf_probe_read(&self.ctx) }.ok()
    }
    pub fn args(&self) -> Option<[::aya_bpf_cty::c_long; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.args) }.ok()
    }
}
impl ndmsg {
    pub fn ndm_family(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ndm_family) }.ok()
    }
    pub fn ndm_pad1(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ndm_pad1) }.ok()
    }
    pub fn ndm_pad2(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.ndm_pad2) }.ok()
    }
    pub fn ndm_ifindex(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.ndm_ifindex) }.ok()
    }
    pub fn ndm_state(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.ndm_state) }.ok()
    }
    pub fn ndm_flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ndm_flags) }.ok()
    }
    pub fn ndm_type(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ndm_type) }.ok()
    }
}
impl rtnl_link_stats64 {
    pub fn rx_packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_packets) }.ok()
    }
    pub fn tx_packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_packets) }.ok()
    }
    pub fn rx_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_bytes) }.ok()
    }
    pub fn tx_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_bytes) }.ok()
    }
    pub fn rx_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_errors) }.ok()
    }
    pub fn tx_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_errors) }.ok()
    }
    pub fn rx_dropped(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_dropped) }.ok()
    }
    pub fn tx_dropped(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_dropped) }.ok()
    }
    pub fn multicast(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.multicast) }.ok()
    }
    pub fn collisions(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.collisions) }.ok()
    }
    pub fn rx_length_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_length_errors) }.ok()
    }
    pub fn rx_over_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_over_errors) }.ok()
    }
    pub fn rx_crc_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_crc_errors) }.ok()
    }
    pub fn rx_frame_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_frame_errors) }.ok()
    }
    pub fn rx_fifo_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_fifo_errors) }.ok()
    }
    pub fn rx_missed_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_missed_errors) }.ok()
    }
    pub fn tx_aborted_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_aborted_errors) }.ok()
    }
    pub fn tx_carrier_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_carrier_errors) }.ok()
    }
    pub fn tx_fifo_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_fifo_errors) }.ok()
    }
    pub fn tx_heartbeat_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_heartbeat_errors) }.ok()
    }
    pub fn tx_window_errors(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_window_errors) }.ok()
    }
    pub fn rx_compressed(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_compressed) }.ok()
    }
    pub fn tx_compressed(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_compressed) }.ok()
    }
    pub fn rx_nohandler(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_nohandler) }.ok()
    }
}
impl ifla_vf_guid {
    pub fn vf(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vf) }.ok()
    }
    pub fn guid(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.guid) }.ok()
    }
}
impl ifla_vf_stats {
    pub fn rx_packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_packets) }.ok()
    }
    pub fn tx_packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_packets) }.ok()
    }
    pub fn rx_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_bytes) }.ok()
    }
    pub fn tx_bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_bytes) }.ok()
    }
    pub fn broadcast(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.broadcast) }.ok()
    }
    pub fn multicast(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.multicast) }.ok()
    }
    pub fn rx_dropped(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.rx_dropped) }.ok()
    }
    pub fn tx_dropped(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tx_dropped) }.ok()
    }
}
impl ifla_vf_info {
    pub fn vf(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vf) }.ok()
    }
    pub fn mac(&self) -> Option<[__u8; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.mac) }.ok()
    }
    pub fn vlan(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vlan) }.ok()
    }
    pub fn qos(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.qos) }.ok()
    }
    pub fn spoofchk(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.spoofchk) }.ok()
    }
    pub fn linkstate(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.linkstate) }.ok()
    }
    pub fn min_tx_rate(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.min_tx_rate) }.ok()
    }
    pub fn max_tx_rate(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_tx_rate) }.ok()
    }
    pub fn rss_query_en(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rss_query_en) }.ok()
    }
    pub fn trusted(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.trusted) }.ok()
    }
    pub fn vlan_proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.vlan_proto) }.ok()
    }
}
impl tc_stats {
    pub fn bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn packets(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.packets) }.ok()
    }
    pub fn drops(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.drops) }.ok()
    }
    pub fn overlimits(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.overlimits) }.ok()
    }
    pub fn bps(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bps) }.ok()
    }
    pub fn pps(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pps) }.ok()
    }
    pub fn qlen(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn backlog(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.backlog) }.ok()
    }
}
impl tc_sizespec {
    pub fn cell_log(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.cell_log) }.ok()
    }
    pub fn size_log(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.size_log) }.ok()
    }
    pub fn cell_align(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.cell_align) }.ok()
    }
    pub fn overhead(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overhead) }.ok()
    }
    pub fn linklayer(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.linklayer) }.ok()
    }
    pub fn mpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mpu) }.ok()
    }
    pub fn mtu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mtu) }.ok()
    }
    pub fn tsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tsize) }.ok()
    }
}
impl header_ops {
    pub fn create(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: ::aya_bpf_cty::c_ushort,
                arg4: *const ::aya_bpf_cty::c_void,
                arg5: *const ::aya_bpf_cty::c_void,
                arg6: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.create) }.ok()
    }
    pub fn parse(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sk_buff,
                arg2: *mut ::aya_bpf_cty::c_uchar,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.parse) }.ok()
    }
    pub fn cache(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const neighbour,
                arg2: *mut hh_cache,
                arg3: __be16,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cache) }.ok()
    }
    pub fn cache_update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut hh_cache,
                arg2: *const net_device,
                arg3: *const ::aya_bpf_cty::c_uchar,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cache_update) }.ok()
    }
    pub fn validate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf_cty::c_char,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.validate) }.ok()
    }
    pub fn parse_protocol(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const sk_buff) -> __be16>> {
        unsafe { crate::bpf_probe_read(&self.parse_protocol) }.ok()
    }
}
impl netdev_queue {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qdisc(&self) -> Option<*mut Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.qdisc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qdisc_sleeping(&self) -> Option<*mut Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.qdisc_sleeping) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn numa_node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn tx_maxrate(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_maxrate) }.ok()
    }
    pub fn trans_timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trans_timeout) }.ok()
    }
    pub fn sb_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.sb_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pool(&self) -> Option<*mut xsk_buff_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _xmit_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self._xmit_lock) }.ok()
    }
    pub fn xmit_lock_owner(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.xmit_lock_owner) }.ok()
    }
    pub fn trans_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.trans_start) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn dql(&self) -> Option<dql> {
        unsafe { crate::bpf_probe_read(&self.dql) }.ok()
    }
}
impl qdisc_skb_head {
    pub fn head(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn qlen(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl gnet_stats_basic_packed {
    pub fn bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.packets) }.ok()
    }
}
impl gnet_stats_queue {
    pub fn qlen(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn backlog(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.backlog) }.ok()
    }
    pub fn drops(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.drops) }.ok()
    }
    pub fn requeues(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.requeues) }.ok()
    }
    pub fn overlimits(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.overlimits) }.ok()
    }
}
impl Qdisc {
    pub fn enqueue(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut Qdisc,
                arg3: *mut *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enqueue) }.ok()
    }
    pub fn dequeue(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>>
    {
        unsafe { crate::bpf_probe_read(&self.dequeue) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn limit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.limit) }.ok()
    }
    pub fn ops(&self) -> Option<*const Qdisc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stab(&self) -> Option<*mut qdisc_size_table> {
        let v = unsafe { crate::bpf_probe_read(&self.stab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn handle(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.handle) }.ok()
    }
    pub fn parent(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.parent) }.ok()
    }
    pub fn dev_queue(&self) -> Option<*mut netdev_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rate_est(&self) -> Option<*mut net_rate_estimator> {
        let v = unsafe { crate::bpf_probe_read(&self.rate_est) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_bstats(&self) -> Option<*mut gnet_stats_basic_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_bstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_qstats(&self) -> Option<*mut gnet_stats_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_qstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pad(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pad) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn gso_skb(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.gso_skb) }.ok()
    }
    pub fn q(&self) -> Option<qdisc_skb_head> {
        unsafe { crate::bpf_probe_read(&self.q) }.ok()
    }
    pub fn bstats(&self) -> Option<gnet_stats_basic_packed> {
        unsafe { crate::bpf_probe_read(&self.bstats) }.ok()
    }
    pub fn running(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.running) }.ok()
    }
    pub fn qstats(&self) -> Option<gnet_stats_queue> {
        unsafe { crate::bpf_probe_read(&self.qstats) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn next_sched(&self) -> Option<*mut Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.next_sched) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb_bad_txq(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.skb_bad_txq) }.ok()
    }
    pub fn busylock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.busylock) }.ok()
    }
    pub fn seqlock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.seqlock) }.ok()
    }
    pub fn empty(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.empty) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn privdata(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_long>> {
        unsafe { crate::bpf_probe_read(&self.privdata) }.ok()
    }
}
impl rps_map {
    pub fn len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn cpus(&self) -> Option<__IncompleteArrayField<u16_>> {
        unsafe { crate::bpf_probe_read(&self.cpus) }.ok()
    }
}
impl rps_dev_flow {
    pub fn cpu(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn filter(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.filter) }.ok()
    }
    pub fn last_qtail(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.last_qtail) }.ok()
    }
}
impl rps_dev_flow_table {
    pub fn mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn flows(&self) -> Option<__IncompleteArrayField<rps_dev_flow>> {
        unsafe { crate::bpf_probe_read(&self.flows) }.ok()
    }
}
impl netdev_rx_queue {
    pub fn rps_map(&self) -> Option<*mut rps_map> {
        let v = unsafe { crate::bpf_probe_read(&self.rps_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rps_flow_table(&self) -> Option<*mut rps_dev_flow_table> {
        let v = unsafe { crate::bpf_probe_read(&self.rps_flow_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xdp_rxq(&self) -> Option<xdp_rxq_info> {
        unsafe { crate::bpf_probe_read(&self.xdp_rxq) }.ok()
    }
    pub fn pool(&self) -> Option<*mut xsk_buff_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xps_map {
    pub fn len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn alloc_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alloc_len) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn queues(&self) -> Option<__IncompleteArrayField<u16_>> {
        unsafe { crate::bpf_probe_read(&self.queues) }.ok()
    }
}
impl xps_dev_maps {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn attr_map(&self) -> Option<__IncompleteArrayField<*mut xps_map>> {
        unsafe { crate::bpf_probe_read(&self.attr_map) }.ok()
    }
}
impl netdev_fcoe_hbainfo {
    pub fn manufacturer(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.manufacturer) }.ok()
    }
    pub fn serial_number(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.serial_number) }.ok()
    }
    pub fn hardware_version(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.hardware_version) }.ok()
    }
    pub fn driver_version(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.driver_version) }.ok()
    }
    pub fn optionrom_version(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.optionrom_version) }.ok()
    }
    pub fn firmware_version(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.firmware_version) }.ok()
    }
    pub fn model(&self) -> Option<[::aya_bpf_cty::c_char; 256usize]> {
        unsafe { crate::bpf_probe_read(&self.model) }.ok()
    }
    pub fn model_description(&self) -> Option<[::aya_bpf_cty::c_char; 256usize]> {
        unsafe { crate::bpf_probe_read(&self.model_description) }.ok()
    }
}
impl netdev_phys_item_id {
    pub fn id(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn id_len(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.id_len) }.ok()
    }
}
impl netdev_bpf {
    pub fn command(&self) -> Option<bpf_netdev_command::Type> {
        unsafe { crate::bpf_probe_read(&self.command) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.flags) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.extack) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offmap(&self) -> Option<*mut bpf_offloaded_map> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.offmap) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xsk(&self) -> Option<netdev_bpf__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.xsk) }.ok()
    }
}
impl netdev_bpf__bindgen_ty_1 {
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.flags) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.extack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offmap(&self) -> Option<*mut bpf_offloaded_map> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.offmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xsk(&self) -> Option<netdev_bpf__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.xsk) }.ok()
    }
}
impl netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.extack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    pub fn offmap(&self) -> Option<*mut bpf_offloaded_map> {
        let v = unsafe { crate::bpf_probe_read(&self.offmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    pub fn pool(&self) -> Option<*mut xsk_buff_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.queue_id) }.ok()
    }
}
impl xfrmdev_ops {
    pub fn xdo_dev_state_add(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.xdo_dev_state_add) }.ok()
    }
    pub fn xdo_dev_state_delete(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>> {
        unsafe { crate::bpf_probe_read(&self.xdo_dev_state_delete) }.ok()
    }
    pub fn xdo_dev_state_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>> {
        unsafe { crate::bpf_probe_read(&self.xdo_dev_state_free) }.ok()
    }
    pub fn xdo_dev_offload_ok(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut xfrm_state) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.xdo_dev_offload_ok) }.ok()
    }
    pub fn xdo_dev_state_advance_esn(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>> {
        unsafe { crate::bpf_probe_read(&self.xdo_dev_state_advance_esn) }.ok()
    }
}
impl dev_ifalias {
    pub fn rcuhead(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcuhead) }.ok()
    }
    pub fn ifalias(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.ifalias) }.ok()
    }
}
impl netdev_name_node {
    pub fn hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hlist) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl net_device_ops {
    pub fn ndo_init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_init) }.ok()
    }
    pub fn ndo_uninit(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.ndo_uninit) }.ok()
    }
    pub fn ndo_open(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_open) }.ok()
    }
    pub fn ndo_stop(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_stop) }.ok()
    }
    pub fn ndo_start_xmit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> netdev_tx_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_start_xmit) }.ok()
    }
    pub fn ndo_features_check(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: netdev_features_t,
            ) -> netdev_features_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_features_check) }.ok()
    }
    pub fn ndo_select_queue(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sk_buff,
                arg3: *mut net_device,
            ) -> u16_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_select_queue) }.ok()
    }
    pub fn ndo_change_rx_flags(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_change_rx_flags) }.ok()
    }
    pub fn ndo_set_rx_mode(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.ndo_set_rx_mode) }.ok()
    }
    pub fn ndo_set_mac_address(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_mac_address) }.ok()
    }
    pub fn ndo_validate_addr(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_validate_addr) }.ok()
    }
    pub fn ndo_do_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ifreq,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_do_ioctl) }.ok()
    }
    pub fn ndo_set_config(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ifmap) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_config) }.ok()
    }
    pub fn ndo_change_mtu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_change_mtu) }.ok()
    }
    pub fn ndo_neigh_setup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut neigh_parms,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_neigh_setup) }.ok()
    }
    pub fn ndo_tx_timeout(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_tx_timeout) }.ok()
    }
    pub fn ndo_get_stats64(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut rtnl_link_stats64),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_stats64) }.ok()
    }
    pub fn ndo_has_offload_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf_cty::c_int) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_has_offload_stats) }.ok()
    }
    pub fn ndo_get_offload_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_bpf_cty::c_int,
                arg2: *const net_device,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_offload_stats) }.ok()
    }
    pub fn ndo_get_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device_stats,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_stats) }.ok()
    }
    pub fn ndo_vlan_rx_add_vid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: __be16,
                arg3: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_vlan_rx_add_vid) }.ok()
    }
    pub fn ndo_vlan_rx_kill_vid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: __be16,
                arg3: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_vlan_rx_kill_vid) }.ok()
    }
    pub fn ndo_poll_controller(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.ndo_poll_controller) }.ok()
    }
    pub fn ndo_netpoll_setup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut netpoll_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_netpoll_setup) }.ok()
    }
    pub fn ndo_netpoll_cleanup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.ndo_netpoll_cleanup) }.ok()
    }
    pub fn ndo_set_vf_mac(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_mac) }.ok()
    }
    pub fn ndo_set_vf_vlan(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u16_,
                arg4: u8_,
                arg5: __be16,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_vlan) }.ok()
    }
    pub fn ndo_set_vf_rate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_rate) }.ok()
    }
    pub fn ndo_set_vf_spoofchk(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_spoofchk) }.ok()
    }
    pub fn ndo_set_vf_trust(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_trust) }.ok()
    }
    pub fn ndo_get_vf_config(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ifla_vf_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_vf_config) }.ok()
    }
    pub fn ndo_set_vf_link_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_link_state) }.ok()
    }
    pub fn ndo_get_vf_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ifla_vf_stats,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_vf_stats) }.ok()
    }
    pub fn ndo_set_vf_port(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut *mut nlattr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_port) }.ok()
    }
    pub fn ndo_get_vf_port(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_vf_port) }.ok()
    }
    pub fn ndo_get_vf_guid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ifla_vf_guid,
                arg4: *mut ifla_vf_guid,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_vf_guid) }.ok()
    }
    pub fn ndo_set_vf_guid(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u64_,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_guid) }.ok()
    }
    pub fn ndo_set_vf_rss_query_en(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_vf_rss_query_en) }.ok()
    }
    pub fn ndo_setup_tc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: tc_setup_type::Type,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_setup_tc) }.ok()
    }
    pub fn ndo_fcoe_enable(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_enable) }.ok()
    }
    pub fn ndo_fcoe_disable(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_disable) }.ok()
    }
    pub fn ndo_fcoe_ddp_setup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u16_,
                arg3: *mut scatterlist,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_ddp_setup) }.ok()
    }
    pub fn ndo_fcoe_ddp_done(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: u16_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_ddp_done) }.ok()
    }
    pub fn ndo_fcoe_ddp_target(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u16_,
                arg3: *mut scatterlist,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_ddp_target) }.ok()
    }
    pub fn ndo_fcoe_get_hbainfo(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut netdev_fcoe_hbainfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_get_hbainfo) }.ok()
    }
    pub fn ndo_fcoe_get_wwn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut u64_,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fcoe_get_wwn) }.ok()
    }
    pub fn ndo_rx_flow_steer(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const sk_buff,
                arg3: u16_,
                arg4: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_rx_flow_steer) }.ok()
    }
    pub fn ndo_add_slave(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut net_device,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_add_slave) }.ok()
    }
    pub fn ndo_del_slave(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_del_slave) }.ok()
    }
    pub fn ndo_get_xmit_slave(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sk_buff,
                arg3: bool_,
            ) -> *mut net_device,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_xmit_slave) }.ok()
    }
    pub fn ndo_sk_get_lower_dev(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sock) -> *mut net_device,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_sk_get_lower_dev) }.ok()
    }
    pub fn ndo_fix_features(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: netdev_features_t,
            ) -> netdev_features_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fix_features) }.ok()
    }
    pub fn ndo_set_features(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: netdev_features_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_features) }.ok()
    }
    pub fn ndo_neigh_construct(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut neighbour,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_neigh_construct) }.ok()
    }
    pub fn ndo_neigh_destroy(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neighbour)>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_neigh_destroy) }.ok()
    }
    pub fn ndo_fdb_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ndmsg,
                arg2: *mut *mut nlattr,
                arg3: *mut net_device,
                arg4: *const ::aya_bpf_cty::c_uchar,
                arg5: u16_,
                arg6: u16_,
                arg7: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fdb_add) }.ok()
    }
    pub fn ndo_fdb_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ndmsg,
                arg2: *mut *mut nlattr,
                arg3: *mut net_device,
                arg4: *const ::aya_bpf_cty::c_uchar,
                arg5: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fdb_del) }.ok()
    }
    pub fn ndo_fdb_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut netlink_callback,
                arg3: *mut net_device,
                arg4: *mut net_device,
                arg5: *mut ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fdb_dump) }.ok()
    }
    pub fn ndo_fdb_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut *mut nlattr,
                arg3: *mut net_device,
                arg4: *const ::aya_bpf_cty::c_uchar,
                arg5: u16_,
                arg6: u32_,
                arg7: u32_,
                arg8: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fdb_get) }.ok()
    }
    pub fn ndo_bridge_setlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut nlmsghdr,
                arg3: u16_,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_bridge_setlink) }.ok()
    }
    pub fn ndo_bridge_getlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: u32_,
                arg3: u32_,
                arg4: *mut net_device,
                arg5: u32_,
                arg6: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_bridge_getlink) }.ok()
    }
    pub fn ndo_bridge_dellink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut nlmsghdr,
                arg3: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_bridge_dellink) }.ok()
    }
    pub fn ndo_change_carrier(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_change_carrier) }.ok()
    }
    pub fn ndo_get_phys_port_id(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut netdev_phys_item_id,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_phys_port_id) }.ok()
    }
    pub fn ndo_get_port_parent_id(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut netdev_phys_item_id,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_port_parent_id) }.ok()
    }
    pub fn ndo_get_phys_port_name(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_phys_port_name) }.ok()
    }
    pub fn ndo_udp_tunnel_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut udp_tunnel_info),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_udp_tunnel_add) }.ok()
    }
    pub fn ndo_udp_tunnel_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut udp_tunnel_info),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_udp_tunnel_del) }.ok()
    }
    pub fn ndo_dfwd_add_station(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut net_device,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_dfwd_add_station) }.ok()
    }
    pub fn ndo_dfwd_del_station(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_dfwd_del_station) }.ok()
    }
    pub fn ndo_set_tx_maxrate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_tx_maxrate) }.ok()
    }
    pub fn ndo_get_iflink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_iflink) }.ok()
    }
    pub fn ndo_change_proto_down(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_change_proto_down) }.ok()
    }
    pub fn ndo_fill_metadata_dst(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_fill_metadata_dst) }.ok()
    }
    pub fn ndo_set_rx_headroom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_set_rx_headroom) }.ok()
    }
    pub fn ndo_bpf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut netdev_bpf,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_bpf) }.ok()
    }
    pub fn ndo_xdp_xmit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut *mut xdp_frame,
                arg4: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_xdp_xmit) }.ok()
    }
    pub fn ndo_xsk_wakeup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u32_,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_xsk_wakeup) }.ok()
    }
    pub fn ndo_get_devlink_port(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut devlink_port>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_devlink_port) }.ok()
    }
    pub fn ndo_tunnel_ctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ip_tunnel_parm,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_tunnel_ctl) }.ok()
    }
    pub fn ndo_get_peer_dev(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device>,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_get_peer_dev) }.ok()
    }
}
impl neigh_parms {
    pub fn net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.net) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn neigh_setup(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.neigh_setup) }.ok()
    }
    pub fn tbl(&self) -> Option<*mut neigh_table> {
        let v = unsafe { crate::bpf_probe_read(&self.tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_table(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dead(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn reachable_time(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.reachable_time) }.ok()
    }
    pub fn data(&self) -> Option<[::aya_bpf_cty::c_int; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn data_state(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.data_state) }.ok()
    }
}
impl pcpu_lstats {
    pub fn packets(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.packets) }.ok()
    }
    pub fn bytes(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl pcpu_sw_netstats {
    pub fn rx_packets(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rx_packets) }.ok()
    }
    pub fn rx_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rx_bytes) }.ok()
    }
    pub fn tx_packets(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tx_packets) }.ok()
    }
    pub fn tx_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tx_bytes) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl iw_handler_def {
    pub fn standard(&self) -> Option<*const iw_handler> {
        let v = unsafe { crate::bpf_probe_read(&self.standard) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_standard(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.num_standard) }.ok()
    }
    pub fn num_private(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.num_private) }.ok()
    }
    pub fn num_private_args(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.num_private_args) }.ok()
    }
    pub fn private(&self) -> Option<*const iw_handler> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private_args(&self) -> Option<*const iw_priv_args> {
        let v = unsafe { crate::bpf_probe_read(&self.private_args) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn get_wireless_stats(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut iw_statistics>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_wireless_stats) }.ok()
    }
}
impl ethtool_ops {
    pub fn supported_coalesce_params(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.supported_coalesce_params) }.ok()
    }
    pub fn get_drvinfo(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_drvinfo) }.ok()
    }
    pub fn get_regs_len(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_regs_len) }.ok()
    }
    pub fn get_regs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_regs,
                arg3: *mut ::aya_bpf_cty::c_void,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_regs) }.ok()
    }
    pub fn get_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_wol) }.ok()
    }
    pub fn set_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_wolinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_wol) }.ok()
    }
    pub fn get_msglevel(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.get_msglevel) }.ok()
    }
    pub fn set_msglevel(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>>
    {
        unsafe { crate::bpf_probe_read(&self.set_msglevel) }.ok()
    }
    pub fn nway_reset(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.nway_reset) }.ok()
    }
    pub fn get_link(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.get_link) }.ok()
    }
    pub fn get_link_ext_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_link_ext_state_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_link_ext_state) }.ok()
    }
    pub fn get_eeprom_len(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_eeprom_len) }.ok()
    }
    pub fn get_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_eeprom) }.ok()
    }
    pub fn set_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_eeprom) }.ok()
    }
    pub fn get_coalesce(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_coalesce,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_coalesce) }.ok()
    }
    pub fn set_coalesce(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_coalesce,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_coalesce) }.ok()
    }
    pub fn get_ringparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_ringparam),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ringparam) }.ok()
    }
    pub fn set_ringparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_ringparam,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_ringparam) }.ok()
    }
    pub fn get_pause_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pause_stats),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_pause_stats) }.ok()
    }
    pub fn get_pauseparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_pauseparam) }.ok()
    }
    pub fn set_pauseparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_pauseparam,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_pauseparam) }.ok()
    }
    pub fn self_test(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.self_test) }.ok()
    }
    pub fn get_strings(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_, arg3: *mut u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_strings) }.ok()
    }
    pub fn set_phys_id(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ethtool_phys_id_state::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_phys_id) }.ok()
    }
    pub fn get_ethtool_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ethtool_stats) }.ok()
    }
    pub fn begin(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.begin) }.ok()
    }
    pub fn complete(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.complete) }.ok()
    }
    pub fn get_priv_flags(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.get_priv_flags) }.ok()
    }
    pub fn set_priv_flags(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_priv_flags) }.ok()
    }
    pub fn get_sset_count(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sset_count) }.ok()
    }
    pub fn get_rxnfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_rxnfc,
                arg3: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_rxnfc) }.ok()
    }
    pub fn set_rxnfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_rxnfc,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_rxnfc) }.ok()
    }
    pub fn flash_device(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_flash,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flash_device) }.ok()
    }
    pub fn reset(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn get_rxfh_key_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.get_rxfh_key_size) }.ok()
    }
    pub fn get_rxfh_indir_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.get_rxfh_indir_size) }.ok()
    }
    pub fn get_rxfh(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut u32_,
                arg3: *mut u8_,
                arg4: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_rxfh) }.ok()
    }
    pub fn set_rxfh(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const u32_,
                arg3: *const u8_,
                arg4: u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_rxfh) }.ok()
    }
    pub fn get_rxfh_context(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut u32_,
                arg3: *mut u8_,
                arg4: *mut u8_,
                arg5: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_rxfh_context) }.ok()
    }
    pub fn set_rxfh_context(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const u32_,
                arg3: *const u8_,
                arg4: u8_,
                arg5: *mut u32_,
                arg6: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_rxfh_context) }.ok()
    }
    pub fn get_channels(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_channels) }.ok()
    }
    pub fn set_channels(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_channels,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_channels) }.ok()
    }
    pub fn get_dump_flag(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_dump,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_dump_flag) }.ok()
    }
    pub fn get_dump_data(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_dump,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_dump_data) }.ok()
    }
    pub fn set_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_dump,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_dump) }.ok()
    }
    pub fn get_ts_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_ts_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ts_info) }.ok()
    }
    pub fn get_module_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_modinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_module_info) }.ok()
    }
    pub fn get_module_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_module_eeprom) }.ok()
    }
    pub fn get_eee(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_eee,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_eee) }.ok()
    }
    pub fn set_eee(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_eee,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_eee) }.ok()
    }
    pub fn get_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const ethtool_tunable,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_tunable) }.ok()
    }
    pub fn set_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const ethtool_tunable,
                arg3: *const ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_tunable) }.ok()
    }
    pub fn get_per_queue_coalesce(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u32_,
                arg3: *mut ethtool_coalesce,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_per_queue_coalesce) }.ok()
    }
    pub fn set_per_queue_coalesce(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: u32_,
                arg3: *mut ethtool_coalesce,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_per_queue_coalesce) }.ok()
    }
    pub fn get_link_ksettings(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_link_ksettings,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_link_ksettings) }.ok()
    }
    pub fn set_link_ksettings(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const ethtool_link_ksettings,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_link_ksettings) }.ok()
    }
    pub fn get_fecparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_fecparam,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_fecparam) }.ok()
    }
    pub fn set_fecparam(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ethtool_fecparam,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_fecparam) }.ok()
    }
    pub fn get_ethtool_phy_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ethtool_phy_stats) }.ok()
    }
    pub fn get_phy_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const ethtool_tunable,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_phy_tunable) }.ok()
    }
    pub fn set_phy_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const ethtool_tunable,
                arg3: *const ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_phy_tunable) }.ok()
    }
}
impl l3mdev_ops {
    pub fn l3mdev_fib_table(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.l3mdev_fib_table) }.ok()
    }
    pub fn l3mdev_l3_rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sk_buff,
                arg3: u16_,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.l3mdev_l3_rcv) }.ok()
    }
    pub fn l3mdev_l3_out(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sock,
                arg3: *mut sk_buff,
                arg4: u16_,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.l3mdev_l3_out) }.ok()
    }
    pub fn l3mdev_link_scope_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device, arg2: *mut flowi6) -> *mut dst_entry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.l3mdev_link_scope_lookup) }.ok()
    }
}
impl ndisc_ops {
    pub fn is_useropt(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: u8_) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.is_useropt) }.ok()
    }
    pub fn parse_options(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const net_device,
                arg2: *mut nd_opt_hdr,
                arg3: *mut ndisc_options,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.parse_options) }.ok()
    }
    pub fn update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const net_device,
                arg2: *mut neighbour,
                arg3: u32_,
                arg4: u8_,
                arg5: *const ndisc_options,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update) }.ok()
    }
    pub fn opt_addr_space(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const net_device,
                arg2: u8_,
                arg3: *mut neighbour,
                arg4: *mut u8_,
                arg5: *mut *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.opt_addr_space) }.ok()
    }
    pub fn fill_addr_option(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const net_device,
                arg2: *mut sk_buff,
                arg3: u8_,
                arg4: *const u8_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_addr_option) }.ok()
    }
    pub fn prefix_rcv_add_addr(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut net_device,
                arg3: *const prefix_info,
                arg4: *mut inet6_dev,
                arg5: *mut in6_addr,
                arg6: ::aya_bpf_cty::c_int,
                arg7: u32_,
                arg8: bool_,
                arg9: bool_,
                arg10: __u32,
                arg11: u32_,
                arg12: bool_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.prefix_rcv_add_addr) }.ok()
    }
}
impl tlsdev_ops {
    pub fn tls_dev_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sock,
                arg3: tls_offload_ctx_dir::Type,
                arg4: *mut tls_crypto_info,
                arg5: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tls_dev_add) }.ok()
    }
    pub fn tls_dev_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut tls_context,
                arg3: tls_offload_ctx_dir::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tls_dev_del) }.ok()
    }
    pub fn tls_dev_resync(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut sock,
                arg3: u32_,
                arg4: *mut u8_,
                arg5: tls_offload_ctx_dir::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tls_dev_resync) }.ok()
    }
}
impl ipv6_devstat {
    pub fn proc_dir_entry(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_dir_entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6(&self) -> Option<*mut ipstats_mib> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmpv6dev(&self) -> Option<*mut icmpv6_mib_device> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpv6dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icmpv6msgdev(&self) -> Option<*mut icmpv6msg_mib_device> {
        let v = unsafe { crate::bpf_probe_read(&self.icmpv6msgdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl inet6_dev {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn addr_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.addr_list) }.ok()
    }
    pub fn mc_list(&self) -> Option<*mut ifmcaddr6> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_tomb(&self) -> Option<*mut ifmcaddr6> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_tomb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mc_lock) }.ok()
    }
    pub fn mc_qrv(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mc_qrv) }.ok()
    }
    pub fn mc_gq_running(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mc_gq_running) }.ok()
    }
    pub fn mc_ifc_count(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mc_ifc_count) }.ok()
    }
    pub fn mc_dad_count(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mc_dad_count) }.ok()
    }
    pub fn mc_v1_seen(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mc_v1_seen) }.ok()
    }
    pub fn mc_qi(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mc_qi) }.ok()
    }
    pub fn mc_qri(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mc_qri) }.ok()
    }
    pub fn mc_maxdelay(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mc_maxdelay) }.ok()
    }
    pub fn mc_gq_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mc_gq_timer) }.ok()
    }
    pub fn mc_ifc_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mc_ifc_timer) }.ok()
    }
    pub fn mc_dad_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mc_dad_timer) }.ok()
    }
    pub fn ac_list(&self) -> Option<*mut ifacaddr6> {
        let v = unsafe { crate::bpf_probe_read(&self.ac_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn if_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.if_flags) }.ok()
    }
    pub fn dead(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn desync_factor(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.desync_factor) }.ok()
    }
    pub fn tempaddr_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tempaddr_list) }.ok()
    }
    pub fn token(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.token) }.ok()
    }
    pub fn nd_parms(&self) -> Option<*mut neigh_parms> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_parms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cnf(&self) -> Option<ipv6_devconf> {
        unsafe { crate::bpf_probe_read(&self.cnf) }.ok()
    }
    pub fn stats(&self) -> Option<ipv6_devstat> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn rs_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.rs_timer) }.ok()
    }
    pub fn rs_interval(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rs_interval) }.ok()
    }
    pub fn rs_probes(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.rs_probes) }.ok()
    }
    pub fn tstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tstamp) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl mini_Qdisc {
    pub fn filter_list(&self) -> Option<*mut tcf_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.filter_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn block(&self) -> Option<*mut tcf_block> {
        let v = unsafe { crate::bpf_probe_read(&self.block) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_bstats(&self) -> Option<*mut gnet_stats_basic_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_bstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_qstats(&self) -> Option<*mut gnet_stats_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_qstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl rtnl_link_ops {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn kind(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.kind) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.priv_size) }.ok()
    }
    pub fn setup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
    pub fn netns_refund(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.netns_refund) }.ok()
    }
    pub fn maxtype(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.maxtype) }.ok()
    }
    pub fn policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn validate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *mut nlattr,
                arg2: *mut *mut nlattr,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.validate) }.ok()
    }
    pub fn newlink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut net_device,
                arg3: *mut *mut nlattr,
                arg4: *mut *mut nlattr,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.newlink) }.ok()
    }
    pub fn changelink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut *mut nlattr,
                arg3: *mut *mut nlattr,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.changelink) }.ok()
    }
    pub fn dellink(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut list_head)>,
    > {
        unsafe { crate::bpf_probe_read(&self.dellink) }.ok()
    }
    pub fn get_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> size_t>>
    {
        unsafe { crate::bpf_probe_read(&self.get_size) }.ok()
    }
    pub fn fill_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_info) }.ok()
    }
    pub fn get_xstats_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> size_t>>
    {
        unsafe { crate::bpf_probe_read(&self.get_xstats_size) }.ok()
    }
    pub fn fill_xstats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_xstats) }.ok()
    }
    pub fn get_num_tx_queues(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_uint>> {
        unsafe { crate::bpf_probe_read(&self.get_num_tx_queues) }.ok()
    }
    pub fn get_num_rx_queues(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf_cty::c_uint>> {
        unsafe { crate::bpf_probe_read(&self.get_num_rx_queues) }.ok()
    }
    pub fn slave_maxtype(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.slave_maxtype) }.ok()
    }
    pub fn slave_policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.slave_policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn slave_changelink(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut net_device,
                arg3: *mut *mut nlattr,
                arg4: *mut *mut nlattr,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.slave_changelink) }.ok()
    }
    pub fn get_slave_size(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device, arg2: *const net_device) -> size_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_slave_size) }.ok()
    }
    pub fn fill_slave_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const net_device,
                arg3: *const net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_slave_info) }.ok()
    }
    pub fn get_link_net(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> *mut net>>
    {
        unsafe { crate::bpf_probe_read(&self.get_link_net) }.ok()
    }
    pub fn get_linkxstats_size(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf_cty::c_int) -> size_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_linkxstats_size) }.ok()
    }
    pub fn fill_linkxstats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const net_device,
                arg3: *mut ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_linkxstats) }.ok()
    }
}
impl udp_tunnel_nic_table_info {
    pub fn n_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n_entries) }.ok()
    }
    pub fn tunnel_types(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tunnel_types) }.ok()
    }
}
impl udp_tunnel_nic_info {
    pub fn set_port(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut udp_tunnel_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_port) }.ok()
    }
    pub fn unset_port(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut udp_tunnel_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unset_port) }.ok()
    }
    pub fn sync_table(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sync_table) }.ok()
    }
    pub fn shared(&self) -> Option<*mut udp_tunnel_nic_shared> {
        let v = unsafe { crate::bpf_probe_read(&self.shared) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn tables(&self) -> Option<[udp_tunnel_nic_table_info; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.tables) }.ok()
    }
}
impl tcmsg {
    pub fn tcm_family(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tcm_family) }.ok()
    }
    pub fn tcm__pad1(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tcm__pad1) }.ok()
    }
    pub fn tcm__pad2(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.tcm__pad2) }.ok()
    }
    pub fn tcm_ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tcm_ifindex) }.ok()
    }
    pub fn tcm_handle(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcm_handle) }.ok()
    }
    pub fn tcm_parent(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcm_parent) }.ok()
    }
    pub fn tcm_info(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcm_info) }.ok()
    }
}
impl gnet_stats_basic_cpu {
    pub fn bstats(&self) -> Option<gnet_stats_basic_packed> {
        unsafe { crate::bpf_probe_read(&self.bstats) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl gnet_dump {
    pub fn lock(&self) -> Option<*mut spinlock_t> {
        let v = unsafe { crate::bpf_probe_read(&self.lock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.skb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail(&self) -> Option<*mut nlattr> {
        let v = unsafe { crate::bpf_probe_read(&self.tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn compat_tc_stats(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.compat_tc_stats) }.ok()
    }
    pub fn compat_xstats(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.compat_xstats) }.ok()
    }
    pub fn padattr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.padattr) }.ok()
    }
    pub fn xstats(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.xstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xstats_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.xstats_len) }.ok()
    }
    pub fn tc_stats(&self) -> Option<tc_stats> {
        unsafe { crate::bpf_probe_read(&self.tc_stats) }.ok()
    }
}
impl netlink_range_validation {
    pub fn min(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn max(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
}
impl netlink_range_validation_signed {
    pub fn min(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn max(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
}
impl flow_block {
    pub fn cb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cb_list) }.ok()
    }
}
impl qdisc_size_table {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn szopts(&self) -> Option<tc_sizespec> {
        unsafe { crate::bpf_probe_read(&self.szopts) }.ok()
    }
    pub fn refcnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<u16_>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl Qdisc_ops {
    pub fn next(&self) -> Option<*mut Qdisc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cl_ops(&self) -> Option<*const Qdisc_class_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.cl_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn priv_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.priv_size) }.ok()
    }
    pub fn static_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.static_flags) }.ok()
    }
    pub fn enqueue(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut Qdisc,
                arg3: *mut *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enqueue) }.ok()
    }
    pub fn dequeue(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>>
    {
        unsafe { crate::bpf_probe_read(&self.dequeue) }.ok()
    }
    pub fn peek(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>>
    {
        unsafe { crate::bpf_probe_read(&self.peek) }.ok()
    }
    pub fn init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: *mut nlattr,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn reset(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>> {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn change(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: *mut nlattr,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.change) }.ok()
    }
    pub fn attach(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>> {
        unsafe { crate::bpf_probe_read(&self.attach) }.ok()
    }
    pub fn change_tx_queue_len(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.change_tx_queue_len) }.ok()
    }
    pub fn dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump) }.ok()
    }
    pub fn dump_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut gnet_dump) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump_stats) }.ok()
    }
    pub fn ingress_block_set(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>> {
        unsafe { crate::bpf_probe_read(&self.ingress_block_set) }.ok()
    }
    pub fn egress_block_set(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>> {
        unsafe { crate::bpf_probe_read(&self.egress_block_set) }.ok()
    }
    pub fn ingress_block_get(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.ingress_block_get) }.ok()
    }
    pub fn egress_block_get(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.egress_block_get) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl Qdisc_class_ops {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn select_queue(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut tcmsg) -> *mut netdev_queue,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.select_queue) }.ok()
    }
    pub fn graft(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut Qdisc,
                arg4: *mut *mut Qdisc,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.graft) }.ok()
    }
    pub fn leaf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong) -> *mut Qdisc,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.leaf) }.ok()
    }
    pub fn qlen_notify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.qlen_notify) }.ok()
    }
    pub fn find(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.find) }.ok()
    }
    pub fn change(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: u32_,
                arg3: u32_,
                arg4: *mut *mut nlattr,
                arg5: *mut ::aya_bpf_cty::c_ulong,
                arg6: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.change) }.ok()
    }
    pub fn delete(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.delete) }.ok()
    }
    pub fn walk(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut qdisc_walker)>,
    > {
        unsafe { crate::bpf_probe_read(&self.walk) }.ok()
    }
    pub fn tcf_block(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut netlink_ext_ack,
            ) -> *mut tcf_block,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tcf_block) }.ok()
    }
    pub fn bind_tcf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bind_tcf) }.ok()
    }
    pub fn unbind_tcf(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf_cty::c_ulong),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.unbind_tcf) }.ok()
    }
    pub fn dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut sk_buff,
                arg4: *mut tcmsg,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump) }.ok()
    }
    pub fn dump_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut gnet_dump,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump_stats) }.ok()
    }
}
impl tcf_block {
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn chain_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.chain_list) }.ok()
    }
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.classid) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn q(&self) -> Option<*mut Qdisc> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cb_lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.cb_lock) }.ok()
    }
    pub fn flow_block(&self) -> Option<flow_block> {
        unsafe { crate::bpf_probe_read(&self.flow_block) }.ok()
    }
    pub fn owner_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.owner_list) }.ok()
    }
    pub fn keep_dst(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.keep_dst) }.ok()
    }
    pub fn offloadcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.offloadcnt) }.ok()
    }
    pub fn nooffloaddevcnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nooffloaddevcnt) }.ok()
    }
    pub fn lockeddevcnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lockeddevcnt) }.ok()
    }
    pub fn chain0(&self) -> Option<tcf_block__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.chain0) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn proto_destroy_ht(&self) -> Option<[hlist_head; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.proto_destroy_ht) }.ok()
    }
    pub fn proto_destroy_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.proto_destroy_lock) }.ok()
    }
}
impl tcf_block__bindgen_ty_1 {
    pub fn chain(&self) -> Option<*mut tcf_chain> {
        let v = unsafe { crate::bpf_probe_read(&self.chain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter_chain_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.filter_chain_list) }.ok()
    }
}
impl tcf_proto {
    pub fn next(&self) -> Option<*mut tcf_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn classify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const tcf_proto,
                arg3: *mut tcf_result,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.classify) }.ok()
    }
    pub fn protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn prio(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const tcf_proto_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chain(&self) -> Option<*mut tcf_chain> {
        let v = unsafe { crate::bpf_probe_read(&self.chain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn deleting(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.deleting) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn destroy_ht_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.destroy_ht_node) }.ok()
    }
}
impl tcf_result {
    pub fn class(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.class) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.classid) }.ok()
    }
    pub fn goto_tp(&self) -> Option<*const tcf_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.goto_tp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ingress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.ingress) }.ok()
    }
    pub fn qstats(&self) -> Option<*mut gnet_stats_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.qstats) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcf_result__bindgen_ty_1 {
    pub fn class(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.class) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.classid) }.ok()
    }
    pub fn goto_tp(&self) -> Option<*const tcf_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.goto_tp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ingress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ingress) }.ok()
    }
    pub fn qstats(&self) -> Option<*mut gnet_stats_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.qstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcf_result__bindgen_ty_1__bindgen_ty_1 {
    pub fn class(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.class) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.classid) }.ok()
    }
}
impl tcf_result__bindgen_ty_1__bindgen_ty_2 {
    pub fn ingress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ingress) }.ok()
    }
    pub fn qstats(&self) -> Option<*mut gnet_stats_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.qstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcf_proto_ops {
    pub fn head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn kind(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.kind) }.ok()
    }
    pub fn classify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *const tcf_proto,
                arg3: *mut tcf_result,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.classify) }.ok()
    }
    pub fn init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn destroy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: bool_, arg3: *mut netlink_ext_ack),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: u32_) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn put(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.put) }.ok()
    }
    pub fn change(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sk_buff,
                arg3: *mut tcf_proto,
                arg4: ::aya_bpf_cty::c_ulong,
                arg5: u32_,
                arg6: *mut *mut nlattr,
                arg7: *mut *mut ::aya_bpf_cty::c_void,
                arg8: bool_,
                arg9: bool_,
                arg10: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.change) }.ok()
    }
    pub fn delete(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tcf_proto,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut bool_,
                arg4: bool_,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.delete) }.ok()
    }
    pub fn delete_empty(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.delete_empty) }.ok()
    }
    pub fn walk(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut tcf_walker, arg3: bool_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.walk) }.ok()
    }
    pub fn reoffload(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tcf_proto,
                arg2: bool_,
                arg3: flow_setup_cb_t,
                arg4: *mut ::aya_bpf_cty::c_void,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reoffload) }.ok()
    }
    pub fn hw_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.hw_add) }.ok()
    }
    pub fn hw_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.hw_del) }.ok()
    }
    pub fn bind_class(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_void,
                arg2: u32_,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: *mut ::aya_bpf_cty::c_void,
                arg5: ::aya_bpf_cty::c_ulong,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bind_class) }.ok()
    }
    pub fn tmplt_create(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut tcf_chain,
                arg3: *mut *mut nlattr,
                arg4: *mut netlink_ext_ack,
            ) -> *mut ::aya_bpf_cty::c_void,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tmplt_create) }.ok()
    }
    pub fn tmplt_destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.tmplt_destroy) }.ok()
    }
    pub fn dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut tcf_proto,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: *mut sk_buff,
                arg5: *mut tcmsg,
                arg6: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dump) }.ok()
    }
    pub fn terse_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut tcf_proto,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: *mut sk_buff,
                arg5: *mut tcmsg,
                arg6: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.terse_dump) }.ok()
    }
    pub fn tmplt_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tmplt_dump) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl tcf_chain {
    pub fn filter_chain_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.filter_chain_lock) }.ok()
    }
    pub fn filter_chain(&self) -> Option<*mut tcf_proto> {
        let v = unsafe { crate::bpf_probe_read(&self.filter_chain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn block(&self) -> Option<*mut tcf_block> {
        let v = unsafe { crate::bpf_probe_read(&self.block) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn refcnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn action_refcnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.action_refcnt) }.ok()
    }
    pub fn explicitly_created(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.explicitly_created) }.ok()
    }
    pub fn flushing(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.flushing) }.ok()
    }
    pub fn tmplt_ops(&self) -> Option<*const tcf_proto_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.tmplt_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tmplt_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.tmplt_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl sock_fprog_kern {
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn filter(&self) -> Option<*mut sock_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_filter {
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl neigh_table {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn entry_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.entry_size) }.ok()
    }
    pub fn key_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.key_len) }.ok()
    }
    pub fn protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn hash(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf_cty::c_void,
                arg2: *const net_device,
                arg3: *mut __u32,
            ) -> __u32,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn key_eq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const neighbour,
                arg2: *const ::aya_bpf_cty::c_void,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.key_eq) }.ok()
    }
    pub fn constructor(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.constructor) }.ok()
    }
    pub fn pconstructor(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut pneigh_entry) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pconstructor) }.ok()
    }
    pub fn pdestructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>> {
        unsafe { crate::bpf_probe_read(&self.pdestructor) }.ok()
    }
    pub fn proxy_redo(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>> {
        unsafe { crate::bpf_probe_read(&self.proxy_redo) }.ok()
    }
    pub fn is_multicast(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_multicast) }.ok()
    }
    pub fn allow_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net_device, arg2: *mut netlink_ext_ack) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.allow_add) }.ok()
    }
    pub fn id(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parms(&self) -> Option<neigh_parms> {
        unsafe { crate::bpf_probe_read(&self.parms) }.ok()
    }
    pub fn parms_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.parms_list) }.ok()
    }
    pub fn gc_interval(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gc_interval) }.ok()
    }
    pub fn gc_thresh1(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gc_thresh1) }.ok()
    }
    pub fn gc_thresh2(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gc_thresh2) }.ok()
    }
    pub fn gc_thresh3(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.gc_thresh3) }.ok()
    }
    pub fn last_flush(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_flush) }.ok()
    }
    pub fn gc_work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.gc_work) }.ok()
    }
    pub fn proxy_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.proxy_timer) }.ok()
    }
    pub fn proxy_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.proxy_queue) }.ok()
    }
    pub fn entries(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
    pub fn gc_entries(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.gc_entries) }.ok()
    }
    pub fn gc_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.gc_list) }.ok()
    }
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn last_rand(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_rand) }.ok()
    }
    pub fn stats(&self) -> Option<*mut neigh_statistics> {
        let v = unsafe { crate::bpf_probe_read(&self.stats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nht(&self) -> Option<*mut neigh_hash_table> {
        let v = unsafe { crate::bpf_probe_read(&self.nht) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phash_buckets(&self) -> Option<*mut *mut pneigh_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.phash_buckets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl neigh_statistics {
    pub fn allocs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.allocs) }.ok()
    }
    pub fn destroys(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.destroys) }.ok()
    }
    pub fn hash_grows(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hash_grows) }.ok()
    }
    pub fn res_failed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.res_failed) }.ok()
    }
    pub fn lookups(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lookups) }.ok()
    }
    pub fn hits(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hits) }.ok()
    }
    pub fn rcv_probes_mcast(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rcv_probes_mcast) }.ok()
    }
    pub fn rcv_probes_ucast(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rcv_probes_ucast) }.ok()
    }
    pub fn periodic_gc_runs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.periodic_gc_runs) }.ok()
    }
    pub fn forced_gc_runs(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.forced_gc_runs) }.ok()
    }
    pub fn unres_discards(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.unres_discards) }.ok()
    }
    pub fn table_fulls(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.table_fulls) }.ok()
    }
}
impl neigh_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn solicit(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    > {
        unsafe { crate::bpf_probe_read(&self.solicit) }.ok()
    }
    pub fn error_report(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    > {
        unsafe { crate::bpf_probe_read(&self.error_report) }.ok()
    }
    pub fn output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.output) }.ok()
    }
    pub fn connected_output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.connected_output) }.ok()
    }
}
impl pneigh_entry {
    pub fn next(&self) -> Option<*mut pneigh_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.net) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn protocol(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn key(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl neigh_hash_table {
    pub fn hash_buckets(&self) -> Option<*mut *mut neighbour> {
        let v = unsafe { crate::bpf_probe_read(&self.hash_buckets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash_shift(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hash_shift) }.ok()
    }
    pub fn hash_rnd(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.hash_rnd) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl fib_rule_hdr {
    pub fn family(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn dst_len(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.dst_len) }.ok()
    }
    pub fn src_len(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.src_len) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn table(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.table) }.ok()
    }
    pub fn res1(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.res1) }.ok()
    }
    pub fn res2(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.res2) }.ok()
    }
    pub fn action(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl fib_rule_port_range {
    pub fn start(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn end(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
}
impl fib_kuid_range {
    pub fn start(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn end(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
}
impl fib_rule {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn iifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.iifindex) }.ok()
    }
    pub fn oifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.oifindex) }.ok()
    }
    pub fn mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn mark_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mark_mask) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn table(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.table) }.ok()
    }
    pub fn action(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
    pub fn l3mdev(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.l3mdev) }.ok()
    }
    pub fn proto(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn ip_proto(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ip_proto) }.ok()
    }
    pub fn target(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.target) }.ok()
    }
    pub fn tun_id(&self) -> Option<__be64> {
        unsafe { crate::bpf_probe_read(&self.tun_id) }.ok()
    }
    pub fn ctarget(&self) -> Option<*mut fib_rule> {
        let v = unsafe { crate::bpf_probe_read(&self.ctarget) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fr_net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.fr_net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn pref(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pref) }.ok()
    }
    pub fn suppress_ifgroup(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.suppress_ifgroup) }.ok()
    }
    pub fn suppress_prefixlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.suppress_prefixlen) }.ok()
    }
    pub fn iifname(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.iifname) }.ok()
    }
    pub fn oifname(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.oifname) }.ok()
    }
    pub fn uid_range(&self) -> Option<fib_kuid_range> {
        unsafe { crate::bpf_probe_read(&self.uid_range) }.ok()
    }
    pub fn sport_range(&self) -> Option<fib_rule_port_range> {
        unsafe { crate::bpf_probe_read(&self.sport_range) }.ok()
    }
    pub fn dport_range(&self) -> Option<fib_rule_port_range> {
        unsafe { crate::bpf_probe_read(&self.dport_range) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl fib_lookup_arg {
    pub fn lookup_ptr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.lookup_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lookup_data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.lookup_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn result(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.result) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rule(&self) -> Option<*mut fib_rule> {
        let v = unsafe { crate::bpf_probe_read(&self.rule) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn table(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.table) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl smc_hashinfo {}
impl proto {
    pub fn close(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_long)>,
    > {
        unsafe { crate::bpf_probe_read(&self.close) }.ok()
    }
    pub fn pre_connect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pre_connect) }.ok()
    }
    pub fn connect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.connect) }.ok()
    }
    pub fn disconnect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.disconnect) }.ok()
    }
    pub fn accept(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_int,
                arg4: bool_,
            ) -> *mut sock,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.accept) }.ok()
    }
    pub fn ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ioctl) }.ok()
    }
    pub fn init(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn destroy(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
    pub fn shutdown(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int)>,
    > {
        unsafe { crate::bpf_probe_read(&self.shutdown) }.ok()
    }
    pub fn setsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: sockptr_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setsockopt) }.ok()
    }
    pub fn getsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *mut ::aya_bpf_cty::c_char,
                arg5: *mut ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getsockopt) }.ok()
    }
    pub fn keepalive(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf_cty::c_int)>,
    > {
        unsafe { crate::bpf_probe_read(&self.keepalive) }.ok()
    }
    pub fn compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.compat_ioctl) }.ok()
    }
    pub fn sendmsg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut msghdr,
                arg3: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendmsg) }.ok()
    }
    pub fn recvmsg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut msghdr,
                arg3: size_t,
                arg4: ::aya_bpf_cty::c_int,
                arg5: ::aya_bpf_cty::c_int,
                arg6: *mut ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.recvmsg) }.ok()
    }
    pub fn sendpage(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut page,
                arg3: ::aya_bpf_cty::c_int,
                arg4: size_t,
                arg5: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sendpage) }.ok()
    }
    pub fn bind(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bind) }.ok()
    }
    pub fn bind_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sockaddr,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bind_add) }.ok()
    }
    pub fn backlog_rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.backlog_rcv) }.ok()
    }
    pub fn release_cb(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.release_cb) }.ok()
    }
    pub fn hash(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn unhash(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.unhash) }.ok()
    }
    pub fn rehash(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.rehash) }.ok()
    }
    pub fn get_port(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_ushort,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_port) }.ok()
    }
    pub fn inuse_idx(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.inuse_idx) }.ok()
    }
    pub fn stream_memory_free(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sock, arg2: ::aya_bpf_cty::c_int) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.stream_memory_free) }.ok()
    }
    pub fn stream_memory_read(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const sock) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.stream_memory_read) }.ok()
    }
    pub fn enter_memory_pressure(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.enter_memory_pressure) }.ok()
    }
    pub fn leave_memory_pressure(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.leave_memory_pressure) }.ok()
    }
    pub fn memory_allocated(&self) -> Option<*mut atomic_long_t> {
        let v = unsafe { crate::bpf_probe_read(&self.memory_allocated) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sockets_allocated(&self) -> Option<*mut percpu_counter> {
        let v = unsafe { crate::bpf_probe_read(&self.sockets_allocated) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn memory_pressure(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.memory_pressure) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_mem(&self) -> Option<*mut ::aya_bpf_cty::c_long> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_mem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_wmem(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_wmem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_rmem(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl_rmem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sysctl_wmem_offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_wmem_offset) }.ok()
    }
    pub fn sysctl_rmem_offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sysctl_rmem_offset) }.ok()
    }
    pub fn max_header(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_header) }.ok()
    }
    pub fn no_autobind(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.no_autobind) }.ok()
    }
    pub fn slab(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.slab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn obj_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.obj_size) }.ok()
    }
    pub fn slab_flags(&self) -> Option<slab_flags_t> {
        unsafe { crate::bpf_probe_read(&self.slab_flags) }.ok()
    }
    pub fn useroffset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.useroffset) }.ok()
    }
    pub fn usersize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.usersize) }.ok()
    }
    pub fn orphan_count(&self) -> Option<*mut percpu_counter> {
        let v = unsafe { crate::bpf_probe_read(&self.orphan_count) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rsk_prot(&self) -> Option<*mut request_sock_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.rsk_prot) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn twsk_prot(&self) -> Option<*mut timewait_sock_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.twsk_prot) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn h(&self) -> Option<proto__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.h) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn diag_destroy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.diag_destroy) }.ok()
    }
}
impl proto__bindgen_ty_1 {
    pub fn hashinfo(&self) -> Option<*mut inet_hashinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.hashinfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn udp_table(&self) -> Option<*mut udp_table> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn raw_hash(&self) -> Option<*mut raw_hashinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.raw_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn smc_hash(&self) -> Option<*mut smc_hashinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.smc_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl request_sock_ops {
    pub fn family(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn obj_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.obj_size) }.ok()
    }
    pub fn slab(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.slab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn slab_name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.slab_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rtx_syn_ack(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sock,
                arg2: *mut request_sock,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rtx_syn_ack) }.ok()
    }
    pub fn send_ack(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff, arg3: *mut request_sock),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.send_ack) }.ok()
    }
    pub fn send_reset(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff)>>
    {
        unsafe { crate::bpf_probe_read(&self.send_reset) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut request_sock)>> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
    pub fn syn_ack_timeout(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const request_sock)>> {
        unsafe { crate::bpf_probe_read(&self.syn_ack_timeout) }.ok()
    }
}
impl timewait_sock_ops {
    pub fn twsk_slab(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.twsk_slab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn twsk_slab_name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.twsk_slab_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn twsk_obj_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.twsk_obj_size) }.ok()
    }
    pub fn twsk_unique(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sock,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.twsk_unique) }.ok()
    }
    pub fn twsk_destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.twsk_destructor) }.ok()
    }
}
impl request_sock {
    pub fn __req_common(&self) -> Option<sock_common> {
        unsafe { crate::bpf_probe_read(&self.__req_common) }.ok()
    }
    pub fn dl_next(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.dl_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mss(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.mss) }.ok()
    }
    pub fn num_retrans(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.num_retrans) }.ok()
    }
    pub fn ts_recent(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ts_recent) }.ok()
    }
    pub fn rsk_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.rsk_timer) }.ok()
    }
    pub fn rsk_ops(&self) -> Option<*const request_sock_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.rsk_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saved_syn(&self) -> Option<*mut saved_syn> {
        let v = unsafe { crate::bpf_probe_read(&self.saved_syn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn secid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.secid) }.ok()
    }
    pub fn peer_secid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.peer_secid) }.ok()
    }
}
impl saved_syn {
    pub fn mac_hdrlen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mac_hdrlen) }.ok()
    }
    pub fn network_hdrlen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.network_hdrlen) }.ok()
    }
    pub fn tcp_hdrlen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tcp_hdrlen) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ip6_sf_list {
    pub fn sf_next(&self) -> Option<*mut ip6_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.sf_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sf_addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.sf_addr) }.ok()
    }
    pub fn sf_count(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.sf_count) }.ok()
    }
    pub fn sf_gsresp(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_gsresp) }.ok()
    }
    pub fn sf_oldin(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_oldin) }.ok()
    }
    pub fn sf_crcount(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_crcount) }.ok()
    }
}
impl ifmcaddr6 {
    pub fn mca_addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.mca_addr) }.ok()
    }
    pub fn idev(&self) -> Option<*mut inet6_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.idev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut ifmcaddr6> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mca_sources(&self) -> Option<*mut ip6_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.mca_sources) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mca_tomb(&self) -> Option<*mut ip6_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.mca_tomb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mca_sfmode(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mca_sfmode) }.ok()
    }
    pub fn mca_crcount(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mca_crcount) }.ok()
    }
    pub fn mca_sfcount(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.mca_sfcount) }.ok()
    }
    pub fn mca_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mca_timer) }.ok()
    }
    pub fn mca_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mca_flags) }.ok()
    }
    pub fn mca_users(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mca_users) }.ok()
    }
    pub fn mca_refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.mca_refcnt) }.ok()
    }
    pub fn mca_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mca_lock) }.ok()
    }
    pub fn mca_cstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mca_cstamp) }.ok()
    }
    pub fn mca_tstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mca_tstamp) }.ok()
    }
}
impl ifacaddr6 {
    pub fn aca_addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.aca_addr) }.ok()
    }
    pub fn aca_rt(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.aca_rt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aca_next(&self) -> Option<*mut ifacaddr6> {
        let v = unsafe { crate::bpf_probe_read(&self.aca_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aca_addr_lst(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.aca_addr_lst) }.ok()
    }
    pub fn aca_users(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.aca_users) }.ok()
    }
    pub fn aca_refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.aca_refcnt) }.ok()
    }
    pub fn aca_cstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.aca_cstamp) }.ok()
    }
    pub fn aca_tstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.aca_tstamp) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl nd_opt_hdr {
    pub fn nd_opt_type(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.nd_opt_type) }.ok()
    }
    pub fn nd_opt_len(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.nd_opt_len) }.ok()
    }
}
impl ndisc_options {
    pub fn nd_opt_array(&self) -> Option<[*mut nd_opt_hdr; 15usize]> {
        unsafe { crate::bpf_probe_read(&self.nd_opt_array) }.ok()
    }
    pub fn nd_opts_ri(&self) -> Option<*mut nd_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_opts_ri) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nd_opts_ri_end(&self) -> Option<*mut nd_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_opts_ri_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nd_useropts(&self) -> Option<*mut nd_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_useropts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nd_useropts_end(&self) -> Option<*mut nd_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_useropts_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nd_802154_opt_array(&self) -> Option<[*mut nd_opt_hdr; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.nd_802154_opt_array) }.ok()
    }
}
impl prefix_info {
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn length(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn prefix_len(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.prefix_len) }.ok()
    }
    pub fn valid(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.valid) }.ok()
    }
    pub fn prefered(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.prefered) }.ok()
    }
    pub fn reserved2(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.reserved2) }.ok()
    }
    pub fn prefix(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.prefix) }.ok()
    }
}
impl io_bitmap {
    pub fn sequence(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.sequence) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn bitmap(&self) -> Option<[::aya_bpf_cty::c_ulong; 1024usize]> {
        unsafe { crate::bpf_probe_read(&self.bitmap) }.ok()
    }
}
impl irqaction {
    pub fn handler(&self) -> Option<irq_handler_t> {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
    pub fn dev_id(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_dev_id(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_dev_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut irqaction> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn thread_fn(&self) -> Option<irq_handler_t> {
        unsafe { crate::bpf_probe_read(&self.thread_fn) }.ok()
    }
    pub fn thread(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.thread) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn secondary(&self) -> Option<*mut irqaction> {
        let v = unsafe { crate::bpf_probe_read(&self.secondary) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn thread_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.thread_flags) }.ok()
    }
    pub fn thread_mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.thread_mask) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dir(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_affinity_notify {
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn notify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut irq_affinity_notify, arg2: *const cpumask_t),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.notify) }.ok()
    }
    pub fn release(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut kref)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
}
impl irq_affinity_desc {
    pub fn mask(&self) -> Option<cpumask> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl irq_common_data {
    pub fn state_use_accessors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.state_use_accessors) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn handler_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.handler_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msi_desc(&self) -> Option<*mut msi_desc> {
        let v = unsafe { crate::bpf_probe_read(&self.msi_desc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn affinity(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.affinity) }.ok()
    }
    pub fn effective_affinity(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.effective_affinity) }.ok()
    }
}
impl irq_data {
    pub fn mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn hwirq(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.hwirq) }.ok()
    }
    pub fn common(&self) -> Option<*mut irq_common_data> {
        let v = unsafe { crate::bpf_probe_read(&self.common) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chip(&self) -> Option<*mut irq_chip> {
        let v = unsafe { crate::bpf_probe_read(&self.chip) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain(&self) -> Option<*mut irq_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn parent_data(&self) -> Option<*mut irq_data> {
        let v = unsafe { crate::bpf_probe_read(&self.parent_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chip_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.chip_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_desc {
    pub fn irq_common_data(&self) -> Option<irq_common_data> {
        unsafe { crate::bpf_probe_read(&self.irq_common_data) }.ok()
    }
    pub fn irq_data(&self) -> Option<irq_data> {
        unsafe { crate::bpf_probe_read(&self.irq_data) }.ok()
    }
    pub fn kstat_irqs(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.kstat_irqs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn handle_irq(&self) -> Option<irq_flow_handler_t> {
        unsafe { crate::bpf_probe_read(&self.handle_irq) }.ok()
    }
    pub fn action(&self) -> Option<*mut irqaction> {
        let v = unsafe { crate::bpf_probe_read(&self.action) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn status_use_accessors(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.status_use_accessors) }.ok()
    }
    pub fn core_internal_state__do_not_mess_with_it(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.core_internal_state__do_not_mess_with_it) }.ok()
    }
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
    pub fn wake_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.wake_depth) }.ok()
    }
    pub fn tot_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tot_count) }.ok()
    }
    pub fn irq_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq_count) }.ok()
    }
    pub fn last_unhandled(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_unhandled) }.ok()
    }
    pub fn irqs_unhandled(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irqs_unhandled) }.ok()
    }
    pub fn threads_handled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.threads_handled) }.ok()
    }
    pub fn threads_handled_last(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.threads_handled_last) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn percpu_enabled(&self) -> Option<*mut cpumask> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_enabled) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_affinity(&self) -> Option<*const cpumask> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_affinity) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn affinity_hint(&self) -> Option<*const cpumask> {
        let v = unsafe { crate::bpf_probe_read(&self.affinity_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn affinity_notify(&self) -> Option<*mut irq_affinity_notify> {
        let v = unsafe { crate::bpf_probe_read(&self.affinity_notify) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pending_mask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.pending_mask) }.ok()
    }
    pub fn threads_oneshot(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.threads_oneshot) }.ok()
    }
    pub fn threads_active(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.threads_active) }.ok()
    }
    pub fn wait_for_threads(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait_for_threads) }.ok()
    }
    pub fn nr_actions(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_actions) }.ok()
    }
    pub fn no_suspend_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.no_suspend_depth) }.ok()
    }
    pub fn cond_suspend_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cond_suspend_depth) }.ok()
    }
    pub fn force_resume_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.force_resume_depth) }.ok()
    }
    pub fn dir(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn request_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.request_mutex) }.ok()
    }
    pub fn parent_irq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.parent_irq) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl x86_msi_addr_lo {}
impl x86_msi_addr_lo__bindgen_ty_1 {}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1 {}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2 {}
impl x86_msi_addr_hi {}
impl x86_msi_data {
    pub fn dmar_subhandle(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dmar_subhandle) }.ok()
    }
}
impl msi_msg {
    pub fn address_lo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.address_lo) }.ok()
    }
    pub fn arch_addr_lo(&self) -> Option<arch_msi_msg_addr_lo_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arch_addr_lo) }.ok()
    }
    pub fn address_hi(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.address_hi) }.ok()
    }
    pub fn arch_addr_hi(&self) -> Option<arch_msi_msg_addr_hi_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.arch_addr_hi) }.ok()
    }
    pub fn data(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.data) }.ok()
    }
    pub fn arch_data(&self) -> Option<arch_msi_msg_data_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.arch_data) }.ok()
    }
}
impl msi_msg__bindgen_ty_1 {
    pub fn address_lo(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.address_lo) }.ok()
    }
    pub fn arch_addr_lo(&self) -> Option<arch_msi_msg_addr_lo_t> {
        unsafe { crate::bpf_probe_read(&self.arch_addr_lo) }.ok()
    }
}
impl msi_msg__bindgen_ty_2 {
    pub fn address_hi(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.address_hi) }.ok()
    }
    pub fn arch_addr_hi(&self) -> Option<arch_msi_msg_addr_hi_t> {
        unsafe { crate::bpf_probe_read(&self.arch_addr_hi) }.ok()
    }
}
impl msi_msg__bindgen_ty_3 {
    pub fn data(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn arch_data(&self) -> Option<arch_msi_msg_data_t> {
        unsafe { crate::bpf_probe_read(&self.arch_data) }.ok()
    }
}
impl platform_msi_desc {
    pub fn msi_priv_data(&self) -> Option<*mut platform_msi_priv_data> {
        let v = unsafe { crate::bpf_probe_read(&self.msi_priv_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msi_index(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.msi_index) }.ok()
    }
}
impl fsl_mc_msi_desc {
    pub fn msi_index(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.msi_index) }.ok()
    }
}
impl ti_sci_inta_msi_desc {
    pub fn dev_index(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.dev_index) }.ok()
    }
}
impl msi_desc {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn nvec_used(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nvec_used) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg(&self) -> Option<msi_msg> {
        unsafe { crate::bpf_probe_read(&self.msg) }.ok()
    }
    pub fn affinity(&self) -> Option<*mut irq_affinity_desc> {
        let v = unsafe { crate::bpf_probe_read(&self.affinity) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu_cookie(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_cookie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn write_msi_msg(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut msi_desc, arg2: *mut ::aya_bpf_cty::c_void),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_msi_msg) }.ok()
    }
    pub fn write_msi_msg_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.write_msi_msg_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn masked(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.masked) }.ok()
    }
    pub fn msi_attrib(&self) -> Option<msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.msi_attrib) }.ok()
    }
    pub fn mask_pos(&self) -> Option<u8_> {
        unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .mask_pos,
            )
        }
        .ok()
    }
    pub fn mask_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe {
            crate::bpf_probe_read(
                &self
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .__bindgen_anon_1
                    .mask_base,
            )
        }
        .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn platform(&self) -> Option<platform_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.platform) }.ok()
    }
    pub fn fsl_mc(&self) -> Option<fsl_mc_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fsl_mc) }.ok()
    }
    pub fn inta(&self) -> Option<ti_sci_inta_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.inta) }.ok()
    }
}
impl msi_desc__bindgen_ty_1 {
    pub fn masked(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.masked) }.ok()
    }
    pub fn msi_attrib(&self) -> Option<msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.msi_attrib) }.ok()
    }
    pub fn mask_pos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.mask_pos) }.ok()
    }
    pub fn mask_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.mask_base) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn platform(&self) -> Option<platform_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.platform) }.ok()
    }
    pub fn fsl_mc(&self) -> Option<fsl_mc_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.fsl_mc) }.ok()
    }
    pub fn inta(&self) -> Option<ti_sci_inta_msi_desc> {
        unsafe { crate::bpf_probe_read(&self.inta) }.ok()
    }
}
impl msi_desc__bindgen_ty_1__bindgen_ty_1 {
    pub fn masked(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.masked) }.ok()
    }
    pub fn msi_attrib(&self) -> Option<msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.msi_attrib) }.ok()
    }
    pub fn mask_pos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mask_pos) }.ok()
    }
    pub fn mask_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mask_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub fn entry_nr(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.entry_nr) }.ok()
    }
    pub fn default_irq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.default_irq) }.ok()
    }
}
impl msi_desc__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub fn mask_pos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mask_pos) }.ok()
    }
    pub fn mask_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.mask_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_chip {
    pub fn parent_device(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.parent_device) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn irq_startup(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_uint>,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_startup) }.ok()
    }
    pub fn irq_shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_shutdown) }.ok()
    }
    pub fn irq_enable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_enable) }.ok()
    }
    pub fn irq_disable(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_disable) }.ok()
    }
    pub fn irq_ack(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_ack) }.ok()
    }
    pub fn irq_mask(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_mask) }.ok()
    }
    pub fn irq_mask_ack(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_mask_ack) }.ok()
    }
    pub fn irq_unmask(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_unmask) }.ok()
    }
    pub fn irq_eoi(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_eoi) }.ok()
    }
    pub fn irq_set_affinity(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: *const cpumask,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_set_affinity) }.ok()
    }
    pub fn irq_retrigger(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_retrigger) }.ok()
    }
    pub fn irq_set_type(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_set_type) }.ok()
    }
    pub fn irq_set_wake(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_set_wake) }.ok()
    }
    pub fn irq_bus_lock(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_bus_lock) }.ok()
    }
    pub fn irq_bus_sync_unlock(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_bus_sync_unlock) }.ok()
    }
    pub fn irq_cpu_online(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_cpu_online) }.ok()
    }
    pub fn irq_cpu_offline(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_cpu_offline) }.ok()
    }
    pub fn irq_suspend(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_suspend) }.ok()
    }
    pub fn irq_resume(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_resume) }.ok()
    }
    pub fn irq_pm_shutdown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_pm_shutdown) }.ok()
    }
    pub fn irq_calc_mask(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_calc_mask) }.ok()
    }
    pub fn irq_print_chip(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut seq_file)>,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_print_chip) }.ok()
    }
    pub fn irq_request_resources(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_request_resources) }.ok()
    }
    pub fn irq_release_resources(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_release_resources) }.ok()
    }
    pub fn irq_compose_msi_msg(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>>
    {
        unsafe { crate::bpf_probe_read(&self.irq_compose_msi_msg) }.ok()
    }
    pub fn irq_write_msi_msg(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>>
    {
        unsafe { crate::bpf_probe_read(&self.irq_write_msi_msg) }.ok()
    }
    pub fn irq_get_irqchip_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: irqchip_irq_state::Type,
                arg3: *mut bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_get_irqchip_state) }.ok()
    }
    pub fn irq_set_irqchip_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: irqchip_irq_state::Type,
                arg3: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_set_irqchip_state) }.ok()
    }
    pub fn irq_set_vcpu_affinity(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut irq_data,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_set_vcpu_affinity) }.ok()
    }
    pub fn ipi_send_single(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut irq_data, arg2: ::aya_bpf_cty::c_uint),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ipi_send_single) }.ok()
    }
    pub fn ipi_send_mask(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *const cpumask)>,
    > {
        unsafe { crate::bpf_probe_read(&self.ipi_send_mask) }.ok()
    }
    pub fn irq_nmi_setup(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.irq_nmi_setup) }.ok()
    }
    pub fn irq_nmi_teardown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>> {
        unsafe { crate::bpf_probe_read(&self.irq_nmi_teardown) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl irq_chip_regs {
    pub fn enable(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.enable) }.ok()
    }
    pub fn disable(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.disable) }.ok()
    }
    pub fn mask(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn ack(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ack) }.ok()
    }
    pub fn eoi(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.eoi) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn polarity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.polarity) }.ok()
    }
}
impl irq_chip_type {
    pub fn chip(&self) -> Option<irq_chip> {
        unsafe { crate::bpf_probe_read(&self.chip) }.ok()
    }
    pub fn regs(&self) -> Option<irq_chip_regs> {
        unsafe { crate::bpf_probe_read(&self.regs) }.ok()
    }
    pub fn handler(&self) -> Option<irq_flow_handler_t> {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
    pub fn type_(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn mask_cache_priv(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask_cache_priv) }.ok()
    }
    pub fn mask_cache(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.mask_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_chip_generic {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn reg_base(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.reg_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reg_readl(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> u32_>,
    > {
        unsafe { crate::bpf_probe_read(&self.reg_readl) }.ok()
    }
    pub fn reg_writel(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: u32_, arg2: *mut ::aya_bpf_cty::c_void)>,
    > {
        unsafe { crate::bpf_probe_read(&self.reg_writel) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>> {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>> {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn irq_base(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq_base) }.ok()
    }
    pub fn irq_cnt(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq_cnt) }.ok()
    }
    pub fn mask_cache(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask_cache) }.ok()
    }
    pub fn type_cache(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.type_cache) }.ok()
    }
    pub fn polarity_cache(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.polarity_cache) }.ok()
    }
    pub fn wake_enabled(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.wake_enabled) }.ok()
    }
    pub fn wake_active(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.wake_active) }.ok()
    }
    pub fn num_ct(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_ct) }.ok()
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn installed(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.installed) }.ok()
    }
    pub fn unused(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.unused) }.ok()
    }
    pub fn domain(&self) -> Option<*mut irq_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn chip_types(&self) -> Option<__IncompleteArrayField<irq_chip_type>> {
        unsafe { crate::bpf_probe_read(&self.chip_types) }.ok()
    }
}
impl irq_domain_chip_generic {
    pub fn irqs_per_chip(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irqs_per_chip) }.ok()
    }
    pub fn num_chips(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_chips) }.ok()
    }
    pub fn irq_flags_to_clear(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq_flags_to_clear) }.ok()
    }
    pub fn irq_flags_to_set(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.irq_flags_to_set) }.ok()
    }
    pub fn gc_flags(&self) -> Option<irq_gc_flags::Type> {
        unsafe { crate::bpf_probe_read(&self.gc_flags) }.ok()
    }
    pub fn gc(&self) -> Option<__IncompleteArrayField<*mut irq_chip_generic>> {
        unsafe { crate::bpf_probe_read(&self.gc) }.ok()
    }
}
impl vm_special_mapping {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pages(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fault(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const vm_special_mapping,
                arg2: *mut vm_area_struct,
                arg3: *mut vm_fault,
            ) -> vm_fault_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fault) }.ok()
    }
    pub fn mremap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const vm_special_mapping,
                arg2: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.mremap) }.ok()
    }
}
impl timens_offsets {
    pub fn monotonic(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.monotonic) }.ok()
    }
    pub fn boottime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.boottime) }.ok()
    }
}
impl time_namespace {
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
    pub fn offsets(&self) -> Option<timens_offsets> {
        unsafe { crate::bpf_probe_read(&self.offsets) }.ok()
    }
    pub fn vvar_page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.vvar_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frozen_offsets(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.frozen_offsets) }.ok()
    }
}
impl perf_event_mmap_page {
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn compat_version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.compat_version) }.ok()
    }
    pub fn lock(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn index(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn offset(&self) -> Option<__s64> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn time_enabled(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_enabled) }.ok()
    }
    pub fn time_running(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_running) }.ok()
    }
    pub fn capabilities(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.capabilities) }.ok()
    }
    pub fn pmc_width(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.pmc_width) }.ok()
    }
    pub fn time_shift(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.time_shift) }.ok()
    }
    pub fn time_mult(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.time_mult) }.ok()
    }
    pub fn time_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_offset) }.ok()
    }
    pub fn time_zero(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_zero) }.ok()
    }
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn __reserved_1(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__reserved_1) }.ok()
    }
    pub fn time_cycles(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_cycles) }.ok()
    }
    pub fn time_mask(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.time_mask) }.ok()
    }
    pub fn __reserved(&self) -> Option<[__u8; 928usize]> {
        unsafe { crate::bpf_probe_read(&self.__reserved) }.ok()
    }
    pub fn data_head(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_head) }.ok()
    }
    pub fn data_tail(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_tail) }.ok()
    }
    pub fn data_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_offset) }.ok()
    }
    pub fn data_size(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data_size) }.ok()
    }
    pub fn aux_head(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.aux_head) }.ok()
    }
    pub fn aux_tail(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.aux_tail) }.ok()
    }
    pub fn aux_offset(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.aux_offset) }.ok()
    }
    pub fn aux_size(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.aux_size) }.ok()
    }
}
impl perf_event_mmap_page__bindgen_ty_1 {
    pub fn capabilities(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.capabilities) }.ok()
    }
}
impl perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {}
impl ldt_struct {
    pub fn entries(&self) -> Option<*mut desc_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_entries) }.ok()
    }
    pub fn slot(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.slot) }.ok()
    }
}
impl plist_head {
    pub fn node_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node_list) }.ok()
    }
}
impl pm_qos_constraints {
    pub fn list(&self) -> Option<plist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn target_value(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.target_value) }.ok()
    }
    pub fn default_value(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.default_value) }.ok()
    }
    pub fn no_constraint_value(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.no_constraint_value) }.ok()
    }
    pub fn type_(&self) -> Option<pm_qos_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn notifiers(&self) -> Option<*mut blocking_notifier_head> {
        let v = unsafe { crate::bpf_probe_read(&self.notifiers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl freq_constraints {
    pub fn min_freq(&self) -> Option<pm_qos_constraints> {
        unsafe { crate::bpf_probe_read(&self.min_freq) }.ok()
    }
    pub fn min_freq_notifiers(&self) -> Option<blocking_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.min_freq_notifiers) }.ok()
    }
    pub fn max_freq(&self) -> Option<pm_qos_constraints> {
        unsafe { crate::bpf_probe_read(&self.max_freq) }.ok()
    }
    pub fn max_freq_notifiers(&self) -> Option<blocking_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.max_freq_notifiers) }.ok()
    }
}
impl pm_qos_flags {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn effective_flags(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.effective_flags) }.ok()
    }
}
impl dev_pm_qos {
    pub fn resume_latency(&self) -> Option<pm_qos_constraints> {
        unsafe { crate::bpf_probe_read(&self.resume_latency) }.ok()
    }
    pub fn latency_tolerance(&self) -> Option<pm_qos_constraints> {
        unsafe { crate::bpf_probe_read(&self.latency_tolerance) }.ok()
    }
    pub fn freq(&self) -> Option<freq_constraints> {
        unsafe { crate::bpf_probe_read(&self.freq) }.ok()
    }
    pub fn flags(&self) -> Option<pm_qos_flags> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn resume_latency_req(&self) -> Option<*mut dev_pm_qos_request> {
        let v = unsafe { crate::bpf_probe_read(&self.resume_latency_req) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn latency_tolerance_req(&self) -> Option<*mut dev_pm_qos_request> {
        let v = unsafe { crate::bpf_probe_read(&self.latency_tolerance_req) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags_req(&self) -> Option<*mut dev_pm_qos_request> {
        let v = unsafe { crate::bpf_probe_read(&self.flags_req) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl pm_qos_flags_request {
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn flags(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl freq_qos_request {
    pub fn type_(&self) -> Option<freq_qos_req_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn pnode(&self) -> Option<plist_node> {
        unsafe { crate::bpf_probe_read(&self.pnode) }.ok()
    }
    pub fn qos(&self) -> Option<*mut freq_constraints> {
        let v = unsafe { crate::bpf_probe_read(&self.qos) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl dev_pm_qos_request {
    pub fn type_(&self) -> Option<dev_pm_qos_req_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn data(&self) -> Option<dev_pm_qos_request__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl dev_pm_qos_request__bindgen_ty_1 {
    pub fn pnode(&self) -> Option<plist_node> {
        unsafe { crate::bpf_probe_read(&self.pnode) }.ok()
    }
    pub fn flr(&self) -> Option<pm_qos_flags_request> {
        unsafe { crate::bpf_probe_read(&self.flr) }.ok()
    }
    pub fn freq(&self) -> Option<freq_qos_request> {
        unsafe { crate::bpf_probe_read(&self.freq) }.ok()
    }
}
impl sg_table {
    pub fn sgl(&self) -> Option<*mut scatterlist> {
        let v = unsafe { crate::bpf_probe_read(&self.sgl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nents(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nents) }.ok()
    }
    pub fn orig_nents(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.orig_nents) }.ok()
    }
}
impl __kernel_fsid_t {
    pub fn val(&self) -> Option<[::aya_bpf_cty::c_int; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl kstatfs {
    pub fn f_type(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.f_type) }.ok()
    }
    pub fn f_bsize(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.f_bsize) }.ok()
    }
    pub fn f_blocks(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_blocks) }.ok()
    }
    pub fn f_bfree(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_bfree) }.ok()
    }
    pub fn f_bavail(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_bavail) }.ok()
    }
    pub fn f_files(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_files) }.ok()
    }
    pub fn f_ffree(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.f_ffree) }.ok()
    }
    pub fn f_fsid(&self) -> Option<__kernel_fsid_t> {
        unsafe { crate::bpf_probe_read(&self.f_fsid) }.ok()
    }
    pub fn f_namelen(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.f_namelen) }.ok()
    }
    pub fn f_frsize(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.f_frsize) }.ok()
    }
    pub fn f_flags(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.f_flags) }.ok()
    }
    pub fn f_spare(&self) -> Option<[::aya_bpf_cty::c_long; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.f_spare) }.ok()
    }
}
impl dev_iommu {
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn fault_param(&self) -> Option<*mut iommu_fault_param> {
        let v = unsafe { crate::bpf_probe_read(&self.fault_param) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fwspec(&self) -> Option<*mut iommu_fwspec> {
        let v = unsafe { crate::bpf_probe_read(&self.fwspec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu_dev(&self) -> Option<*mut iommu_device> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl of_phandle_args {
    pub fn np(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.np) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn args_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.args_count) }.ok()
    }
    pub fn args(&self) -> Option<[u32; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.args) }.ok()
    }
}
impl iommu_fault_unrecoverable {
    pub fn reason(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reason) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pasid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
    pub fn perm(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.perm) }.ok()
    }
    pub fn addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn fetch_addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.fetch_addr) }.ok()
    }
}
impl iommu_fault_page_request {
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pasid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
    pub fn grpid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.grpid) }.ok()
    }
    pub fn perm(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.perm) }.ok()
    }
    pub fn addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn private_data(&self) -> Option<[__u64; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.private_data) }.ok()
    }
}
impl iommu_fault {
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn padding(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn event(&self) -> Option<iommu_fault_unrecoverable> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.event) }.ok()
    }
    pub fn prm(&self) -> Option<iommu_fault_page_request> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.prm) }.ok()
    }
    pub fn padding2(&self) -> Option<[__u8; 56usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.padding2) }.ok()
    }
}
impl iommu_fault__bindgen_ty_1 {
    pub fn event(&self) -> Option<iommu_fault_unrecoverable> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn prm(&self) -> Option<iommu_fault_page_request> {
        unsafe { crate::bpf_probe_read(&self.prm) }.ok()
    }
    pub fn padding2(&self) -> Option<[__u8; 56usize]> {
        unsafe { crate::bpf_probe_read(&self.padding2) }.ok()
    }
}
impl iommu_page_response {
    pub fn argsz(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.argsz) }.ok()
    }
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pasid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
    pub fn grpid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.grpid) }.ok()
    }
    pub fn code(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
}
impl iommu_inv_addr_info {
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn archid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.archid) }.ok()
    }
    pub fn pasid(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
    pub fn addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn granule_size(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.granule_size) }.ok()
    }
    pub fn nb_granules(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.nb_granules) }.ok()
    }
}
impl iommu_inv_pasid_info {
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn archid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.archid) }.ok()
    }
    pub fn pasid(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.pasid) }.ok()
    }
}
impl iommu_cache_invalidate_info {
    pub fn argsz(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.argsz) }.ok()
    }
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn cache(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.cache) }.ok()
    }
    pub fn granularity(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.granularity) }.ok()
    }
    pub fn padding(&self) -> Option<[__u8; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn granu(&self) -> Option<iommu_cache_invalidate_info__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.granu) }.ok()
    }
}
impl iommu_cache_invalidate_info__bindgen_ty_1 {
    pub fn pasid_info(&self) -> Option<iommu_inv_pasid_info> {
        unsafe { crate::bpf_probe_read(&self.pasid_info) }.ok()
    }
    pub fn addr_info(&self) -> Option<iommu_inv_addr_info> {
        unsafe { crate::bpf_probe_read(&self.addr_info) }.ok()
    }
}
impl iommu_gpasid_bind_data_vtd {
    pub fn flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pat(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pat) }.ok()
    }
    pub fn emt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.emt) }.ok()
    }
}
impl iommu_gpasid_bind_data {
    pub fn argsz(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.argsz) }.ok()
    }
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn format(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.format) }.ok()
    }
    pub fn addr_width(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.addr_width) }.ok()
    }
    pub fn flags(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn gpgd(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.gpgd) }.ok()
    }
    pub fn hpasid(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hpasid) }.ok()
    }
    pub fn gpasid(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.gpasid) }.ok()
    }
    pub fn padding(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn vendor(&self) -> Option<iommu_gpasid_bind_data__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.vendor) }.ok()
    }
}
impl iommu_gpasid_bind_data__bindgen_ty_1 {
    pub fn vtd(&self) -> Option<iommu_gpasid_bind_data_vtd> {
        unsafe { crate::bpf_probe_read(&self.vtd) }.ok()
    }
}
impl iommu_domain_geometry {
    pub fn aperture_start(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.aperture_start) }.ok()
    }
    pub fn aperture_end(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.aperture_end) }.ok()
    }
    pub fn force_aperture(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.force_aperture) }.ok()
    }
}
impl iommu_domain {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn ops(&self) -> Option<*const iommu_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pgsize_bitmap(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pgsize_bitmap) }.ok()
    }
    pub fn handler(&self) -> Option<iommu_fault_handler_t> {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
    pub fn handler_token(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.handler_token) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn geometry(&self) -> Option<iommu_domain_geometry> {
        unsafe { crate::bpf_probe_read(&self.geometry) }.ok()
    }
    pub fn iova_cookie(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iova_cookie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iommu_resv_region {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn start(&self) -> Option<phys_addr_t> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn length(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn prot(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prot) }.ok()
    }
    pub fn type_(&self) -> Option<iommu_resv_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl iommu_iotlb_gather {
    pub fn start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.end) }.ok()
    }
    pub fn pgsize(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.pgsize) }.ok()
    }
    pub fn freelist(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.freelist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iommu_device {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn ops(&self) -> Option<*const iommu_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iommu_sva {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iommu_fault_event {
    pub fn fault(&self) -> Option<iommu_fault> {
        unsafe { crate::bpf_probe_read(&self.fault) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl iommu_fault_param {
    pub fn handler(&self) -> Option<iommu_dev_fault_handler_t> {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn faults(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.faults) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl iommu_fwspec {
    pub fn ops(&self) -> Option<*const iommu_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu_fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn num_pasid_bits(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_pasid_bits) }.ok()
    }
    pub fn num_ids(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_ids) }.ok()
    }
    pub fn ids(&self) -> Option<__IncompleteArrayField<u32_>> {
        unsafe { crate::bpf_probe_read(&self.ids) }.ok()
    }
}
impl proc_ops {
    pub fn proc_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.proc_flags) }.ok()
    }
    pub fn proc_open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_open) }.ok()
    }
    pub fn proc_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_read) }.ok()
    }
    pub fn proc_read_iter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_read_iter) }.ok()
    }
    pub fn proc_write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *const ::aya_bpf_cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_write) }.ok()
    }
    pub fn proc_lseek(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: ::aya_bpf_cty::c_int,
            ) -> loff_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_lseek) }.ok()
    }
    pub fn proc_release(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_release) }.ok()
    }
    pub fn proc_poll(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_poll) }.ok()
    }
    pub fn proc_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_ioctl) }.ok()
    }
    pub fn proc_compat_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_long,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_compat_ioctl) }.ok()
    }
    pub fn proc_mmap(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut vm_area_struct,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_mmap) }.ok()
    }
    pub fn proc_get_unmapped_area(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: ::aya_bpf_cty::c_ulong,
                arg4: ::aya_bpf_cty::c_ulong,
                arg5: ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_ulong,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.proc_get_unmapped_area) }.ok()
    }
}
impl firmware {
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn data(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl crypto_tfm {
    pub fn crt_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.crt_flags) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn exit(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>> {
        unsafe { crate::bpf_probe_read(&self.exit) }.ok()
    }
    pub fn __crt_alg(&self) -> Option<*mut crypto_alg> {
        let v = unsafe { crate::bpf_probe_read(&self.__crt_alg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __crt_ctx(&self) -> Option<__IncompleteArrayField<*mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.__crt_ctx) }.ok()
    }
}
impl cipher_alg {
    pub fn cia_min_keysize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cia_min_keysize) }.ok()
    }
    pub fn cia_max_keysize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cia_max_keysize) }.ok()
    }
    pub fn cia_setkey(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_tfm,
                arg2: *const u8_,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cia_setkey) }.ok()
    }
    pub fn cia_encrypt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cia_encrypt) }.ok()
    }
    pub fn cia_decrypt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cia_decrypt) }.ok()
    }
}
impl compress_alg {
    pub fn coa_compress(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_tfm,
                arg2: *const u8_,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut u8_,
                arg5: *mut ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.coa_compress) }.ok()
    }
    pub fn coa_decompress(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_tfm,
                arg2: *const u8_,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut u8_,
                arg5: *mut ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.coa_decompress) }.ok()
    }
}
impl crypto_istat_aead {
    pub fn encrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_cnt) }.ok()
    }
    pub fn encrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_tlen) }.ok()
    }
    pub fn decrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_cnt) }.ok()
    }
    pub fn decrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_tlen) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_akcipher {
    pub fn encrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_cnt) }.ok()
    }
    pub fn encrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_tlen) }.ok()
    }
    pub fn decrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_cnt) }.ok()
    }
    pub fn decrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_tlen) }.ok()
    }
    pub fn verify_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.verify_cnt) }.ok()
    }
    pub fn sign_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.sign_cnt) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_cipher {
    pub fn encrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_cnt) }.ok()
    }
    pub fn encrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.encrypt_tlen) }.ok()
    }
    pub fn decrypt_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_cnt) }.ok()
    }
    pub fn decrypt_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decrypt_tlen) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_compress {
    pub fn compress_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.compress_cnt) }.ok()
    }
    pub fn compress_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.compress_tlen) }.ok()
    }
    pub fn decompress_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decompress_cnt) }.ok()
    }
    pub fn decompress_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.decompress_tlen) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_hash {
    pub fn hash_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.hash_cnt) }.ok()
    }
    pub fn hash_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.hash_tlen) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_kpp {
    pub fn setsecret_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.setsecret_cnt) }.ok()
    }
    pub fn generate_public_key_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.generate_public_key_cnt) }.ok()
    }
    pub fn compute_shared_secret_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.compute_shared_secret_cnt) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_istat_rng {
    pub fn generate_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.generate_cnt) }.ok()
    }
    pub fn generate_tlen(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.generate_tlen) }.ok()
    }
    pub fn seed_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.seed_cnt) }.ok()
    }
    pub fn err_cnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.err_cnt) }.ok()
    }
}
impl crypto_alg {
    pub fn cra_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cra_list) }.ok()
    }
    pub fn cra_users(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cra_users) }.ok()
    }
    pub fn cra_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cra_flags) }.ok()
    }
    pub fn cra_blocksize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cra_blocksize) }.ok()
    }
    pub fn cra_ctxsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cra_ctxsize) }.ok()
    }
    pub fn cra_alignmask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cra_alignmask) }.ok()
    }
    pub fn cra_priority(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cra_priority) }.ok()
    }
    pub fn cra_refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.cra_refcnt) }.ok()
    }
    pub fn cra_name(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.cra_name) }.ok()
    }
    pub fn cra_driver_name(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.cra_driver_name) }.ok()
    }
    pub fn cra_type(&self) -> Option<*const crypto_type> {
        let v = unsafe { crate::bpf_probe_read(&self.cra_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cra_u(&self) -> Option<crypto_alg__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.cra_u) }.ok()
    }
    pub fn cra_init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.cra_init) }.ok()
    }
    pub fn cra_exit(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>> {
        unsafe { crate::bpf_probe_read(&self.cra_exit) }.ok()
    }
    pub fn cra_destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_alg)>> {
        unsafe { crate::bpf_probe_read(&self.cra_destroy) }.ok()
    }
    pub fn cra_module(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.cra_module) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stats(&self) -> Option<crypto_alg__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
}
impl crypto_alg__bindgen_ty_1 {
    pub fn cipher(&self) -> Option<cipher_alg> {
        unsafe { crate::bpf_probe_read(&self.cipher) }.ok()
    }
    pub fn compress(&self) -> Option<compress_alg> {
        unsafe { crate::bpf_probe_read(&self.compress) }.ok()
    }
}
impl crypto_alg__bindgen_ty_2 {
    pub fn aead(&self) -> Option<crypto_istat_aead> {
        unsafe { crate::bpf_probe_read(&self.aead) }.ok()
    }
    pub fn akcipher(&self) -> Option<crypto_istat_akcipher> {
        unsafe { crate::bpf_probe_read(&self.akcipher) }.ok()
    }
    pub fn cipher(&self) -> Option<crypto_istat_cipher> {
        unsafe { crate::bpf_probe_read(&self.cipher) }.ok()
    }
    pub fn compress(&self) -> Option<crypto_istat_compress> {
        unsafe { crate::bpf_probe_read(&self.compress) }.ok()
    }
    pub fn hash(&self) -> Option<crypto_istat_hash> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn rng(&self) -> Option<crypto_istat_rng> {
        unsafe { crate::bpf_probe_read(&self.rng) }.ok()
    }
    pub fn kpp(&self) -> Option<crypto_istat_kpp> {
        unsafe { crate::bpf_probe_read(&self.kpp) }.ok()
    }
}
impl crypto_type {
    pub fn ctxsize(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_alg,
                arg2: u32_,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ctxsize) }.ok()
    }
    pub fn extsize(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut crypto_alg) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.extsize) }.ok()
    }
    pub fn init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_tfm,
                arg2: u32_,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn init_tfm(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.init_tfm) }.ok()
    }
    pub fn show(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut crypto_alg)>,
    > {
        unsafe { crate::bpf_probe_read(&self.show) }.ok()
    }
    pub fn report(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut crypto_alg) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.report) }.ok()
    }
    pub fn free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_instance)>> {
        unsafe { crate::bpf_probe_read(&self.free) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn maskclear(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.maskclear) }.ok()
    }
    pub fn maskset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.maskset) }.ok()
    }
    pub fn tfmsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tfmsize) }.ok()
    }
}
impl ioapic_alloc_info {
    pub fn pin(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pin) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl uv_alloc_info {
    pub fn limit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.limit) }.ok()
    }
    pub fn blade(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.blade) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl irq_alloc_info {
    pub fn type_(&self) -> Option<irq_alloc_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn devid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.devid) }.ok()
    }
    pub fn hwirq(&self) -> Option<irq_hw_number_t> {
        unsafe { crate::bpf_probe_read(&self.hwirq) }.ok()
    }
    pub fn mask(&self) -> Option<*const cpumask> {
        let v = unsafe { crate::bpf_probe_read(&self.mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn desc(&self) -> Option<*mut msi_desc> {
        let v = unsafe { crate::bpf_probe_read(&self.desc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ioapic(&self) -> Option<ioapic_alloc_info> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ioapic) }.ok()
    }
    pub fn uv(&self) -> Option<uv_alloc_info> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.uv) }.ok()
    }
}
impl irq_alloc_info__bindgen_ty_1 {
    pub fn ioapic(&self) -> Option<ioapic_alloc_info> {
        unsafe { crate::bpf_probe_read(&self.ioapic) }.ok()
    }
    pub fn uv(&self) -> Option<uv_alloc_info> {
        unsafe { crate::bpf_probe_read(&self.uv) }.ok()
    }
}
impl serial_icounter_struct {
    pub fn cts(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cts) }.ok()
    }
    pub fn dsr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dsr) }.ok()
    }
    pub fn rng(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rng) }.ok()
    }
    pub fn dcd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dcd) }.ok()
    }
    pub fn rx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rx) }.ok()
    }
    pub fn tx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tx) }.ok()
    }
    pub fn frame(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.frame) }.ok()
    }
    pub fn overrun(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overrun) }.ok()
    }
    pub fn parity(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.parity) }.ok()
    }
    pub fn brk(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.brk) }.ok()
    }
    pub fn buf_overrun(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.buf_overrun) }.ok()
    }
    pub fn reserved(&self) -> Option<[::aya_bpf_cty::c_int; 9usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl serial_struct {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn line(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.line) }.ok()
    }
    pub fn port(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn xmit_fifo_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.xmit_fifo_size) }.ok()
    }
    pub fn custom_divisor(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.custom_divisor) }.ok()
    }
    pub fn baud_base(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.baud_base) }.ok()
    }
    pub fn close_delay(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.close_delay) }.ok()
    }
    pub fn io_type(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.io_type) }.ok()
    }
    pub fn reserved_char(&self) -> Option<[::aya_bpf_cty::c_char; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved_char) }.ok()
    }
    pub fn hub6(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.hub6) }.ok()
    }
    pub fn closing_wait(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.closing_wait) }.ok()
    }
    pub fn closing_wait2(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.closing_wait2) }.ok()
    }
    pub fn iomem_base(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.iomem_base) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iomem_reg_shift(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.iomem_reg_shift) }.ok()
    }
    pub fn port_high(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.port_high) }.ok()
    }
    pub fn iomap_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.iomap_base) }.ok()
    }
}
impl sched_domain_shared {
    pub fn ref_(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn nr_busy_cpus(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_busy_cpus) }.ok()
    }
    pub fn has_idle_cores(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.has_idle_cores) }.ok()
    }
}
impl sched_domain {
    pub fn parent(&self) -> Option<*mut sched_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn child(&self) -> Option<*mut sched_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.child) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn groups(&self) -> Option<*mut sched_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn min_interval(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_interval) }.ok()
    }
    pub fn max_interval(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_interval) }.ok()
    }
    pub fn busy_factor(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.busy_factor) }.ok()
    }
    pub fn imbalance_pct(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.imbalance_pct) }.ok()
    }
    pub fn cache_nice_tries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cache_nice_tries) }.ok()
    }
    pub fn nohz_idle(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nohz_idle) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn level(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn last_balance(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_balance) }.ok()
    }
    pub fn balance_interval(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.balance_interval) }.ok()
    }
    pub fn nr_balance_failed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_balance_failed) }.ok()
    }
    pub fn max_newidle_lb_cost(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max_newidle_lb_cost) }.ok()
    }
    pub fn next_decay_max_lb_cost(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.next_decay_max_lb_cost) }.ok()
    }
    pub fn avg_scan_cost(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avg_scan_cost) }.ok()
    }
    pub fn lb_count(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_count) }.ok()
    }
    pub fn lb_failed(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_failed) }.ok()
    }
    pub fn lb_balanced(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_balanced) }.ok()
    }
    pub fn lb_imbalance(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_imbalance) }.ok()
    }
    pub fn lb_gained(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_gained) }.ok()
    }
    pub fn lb_hot_gained(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_hot_gained) }.ok()
    }
    pub fn lb_nobusyg(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_nobusyg) }.ok()
    }
    pub fn lb_nobusyq(&self) -> Option<[::aya_bpf_cty::c_uint; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.lb_nobusyq) }.ok()
    }
    pub fn alb_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alb_count) }.ok()
    }
    pub fn alb_failed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alb_failed) }.ok()
    }
    pub fn alb_pushed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alb_pushed) }.ok()
    }
    pub fn sbe_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbe_count) }.ok()
    }
    pub fn sbe_balanced(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbe_balanced) }.ok()
    }
    pub fn sbe_pushed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbe_pushed) }.ok()
    }
    pub fn sbf_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbf_count) }.ok()
    }
    pub fn sbf_balanced(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbf_balanced) }.ok()
    }
    pub fn sbf_pushed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sbf_pushed) }.ok()
    }
    pub fn ttwu_wake_remote(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_wake_remote) }.ok()
    }
    pub fn ttwu_move_affine(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_move_affine) }.ok()
    }
    pub fn ttwu_move_balance(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_move_balance) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn shared(&self) -> Option<*mut sched_domain_shared> {
        let v = unsafe { crate::bpf_probe_read(&self.shared) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn span_weight(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.span_weight) }.ok()
    }
    pub fn span(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.span) }.ok()
    }
}
impl sched_domain__bindgen_ty_1 {
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl gpio_desc {}
impl arch_uprobe {
    pub fn insn(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.insn) }.ok()
    }
    pub fn ixol(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ixol) }.ok()
    }
    pub fn ops(&self) -> Option<*const uprobe_xol_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn branch(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.branch) }.ok()
    }
    pub fn defparam(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.defparam) }.ok()
    }
    pub fn push(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.push) }.ok()
    }
}
impl arch_uprobe__bindgen_ty_1 {
    pub fn insn(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.insn) }.ok()
    }
    pub fn ixol(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ixol) }.ok()
    }
}
impl arch_uprobe__bindgen_ty_2 {
    pub fn branch(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.branch) }.ok()
    }
    pub fn defparam(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.defparam) }.ok()
    }
    pub fn push(&self) -> Option<arch_uprobe__bindgen_ty_2__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.push) }.ok()
    }
}
impl arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub fn offs(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.offs) }.ok()
    }
    pub fn ilen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ilen) }.ok()
    }
    pub fn opc1(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.opc1) }.ok()
    }
}
impl arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fn fixups(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.fixups) }.ok()
    }
    pub fn ilen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ilen) }.ok()
    }
}
impl arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub fn reg_offset(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.reg_offset) }.ok()
    }
    pub fn ilen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ilen) }.ok()
    }
}
impl uprobe_xol_ops {
    pub fn emulate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.emulate) }.ok()
    }
    pub fn pre_xol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut arch_uprobe,
                arg2: *mut pt_regs,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pre_xol) }.ok()
    }
    pub fn post_xol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut arch_uprobe,
                arg2: *mut pt_regs,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.post_xol) }.ok()
    }
    pub fn abort(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs)>,
    > {
        unsafe { crate::bpf_probe_read(&self.abort) }.ok()
    }
}
impl crypto_instance {
    pub fn alg(&self) -> Option<crypto_alg> {
        unsafe { crate::bpf_probe_read(&self.alg) }.ok()
    }
    pub fn tmpl(&self) -> Option<*mut crypto_template> {
        let v = unsafe { crate::bpf_probe_read(&self.tmpl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.list) }.ok()
    }
    pub fn spawns(&self) -> Option<*mut crypto_spawn> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.spawns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __ctx(&self) -> Option<__IncompleteArrayField<*mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.__ctx) }.ok()
    }
}
impl crypto_instance__bindgen_ty_1 {
    pub fn list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn spawns(&self) -> Option<*mut crypto_spawn> {
        let v = unsafe { crate::bpf_probe_read(&self.spawns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl crypto_spawn {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn alg(&self) -> Option<*mut crypto_alg> {
        let v = unsafe { crate::bpf_probe_read(&self.alg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inst(&self) -> Option<*mut crypto_instance> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.inst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut crypto_spawn> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frontend(&self) -> Option<*const crypto_type> {
        let v = unsafe { crate::bpf_probe_read(&self.frontend) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn dead(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn registered(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.registered) }.ok()
    }
}
impl crypto_spawn__bindgen_ty_1 {
    pub fn inst(&self) -> Option<*mut crypto_instance> {
        let v = unsafe { crate::bpf_probe_read(&self.inst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut crypto_spawn> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl crypto_template {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn instances(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.instances) }.ok()
    }
    pub fn module(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.module) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn create(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_template,
                arg2: *mut *mut rtattr,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.create) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
}
impl semaphore {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn wait_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.wait_list) }.ok()
    }
}
impl fdtable {
    pub fn max_fds(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_fds) }.ok()
    }
    pub fn fd(&self) -> Option<*mut *mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.fd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn close_on_exec(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.close_on_exec) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn open_fds(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.open_fds) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn full_fds_bits(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.full_fds_bits) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl files_struct {
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn resize_in_progress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.resize_in_progress) }.ok()
    }
    pub fn resize_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.resize_wait) }.ok()
    }
    pub fn fdt(&self) -> Option<*mut fdtable> {
        let v = unsafe { crate::bpf_probe_read(&self.fdt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fdtab(&self) -> Option<fdtable> {
        unsafe { crate::bpf_probe_read(&self.fdtab) }.ok()
    }
    pub fn file_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.file_lock) }.ok()
    }
    pub fn next_fd(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.next_fd) }.ok()
    }
    pub fn close_on_exec_init(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.close_on_exec_init) }.ok()
    }
    pub fn open_fds_init(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.open_fds_init) }.ok()
    }
    pub fn full_fds_bits_init(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.full_fds_bits_init) }.ok()
    }
    pub fn fd_array(&self) -> Option<[*mut file; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.fd_array) }.ok()
    }
}
impl io_identity {
    pub fn files(&self) -> Option<*mut files_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.files) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blkcg_css(&self) -> Option<*mut cgroup_subsys_state> {
        let v = unsafe { crate::bpf_probe_read(&self.blkcg_css) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn creds(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.creds) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nsproxy(&self) -> Option<*mut nsproxy> {
        let v = unsafe { crate::bpf_probe_read(&self.nsproxy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fs(&self) -> Option<*mut fs_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.fs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fsize(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fsize) }.ok()
    }
    pub fn loginuid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.loginuid) }.ok()
    }
    pub fn sessionid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sessionid) }.ok()
    }
    pub fn count(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl io_uring_task {
    pub fn xa(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.xa) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
    pub fn last(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.last) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inflight(&self) -> Option<percpu_counter> {
        unsafe { crate::bpf_probe_read(&self.inflight) }.ok()
    }
    pub fn __identity(&self) -> Option<io_identity> {
        unsafe { crate::bpf_probe_read(&self.__identity) }.ok()
    }
    pub fn identity(&self) -> Option<*mut io_identity> {
        let v = unsafe { crate::bpf_probe_read(&self.identity) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn in_idle(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.in_idle) }.ok()
    }
    pub fn sqpoll(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.sqpoll) }.ok()
    }
}
impl robust_list {
    pub fn next(&self) -> Option<*mut robust_list> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl robust_list_head {
    pub fn list(&self) -> Option<robust_list> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn futex_offset(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.futex_offset) }.ok()
    }
    pub fn list_op_pending(&self) -> Option<*mut robust_list> {
        let v = unsafe { crate::bpf_probe_read(&self.list_op_pending) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl workqueue_struct {
    pub fn pwqs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pwqs) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn work_color(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.work_color) }.ok()
    }
    pub fn flush_color(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flush_color) }.ok()
    }
    pub fn nr_pwqs_to_flush(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_pwqs_to_flush) }.ok()
    }
    pub fn first_flusher(&self) -> Option<*mut wq_flusher> {
        let v = unsafe { crate::bpf_probe_read(&self.first_flusher) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flusher_queue(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flusher_queue) }.ok()
    }
    pub fn flusher_overflow(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flusher_overflow) }.ok()
    }
    pub fn maydays(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.maydays) }.ok()
    }
    pub fn rescuer(&self) -> Option<*mut worker> {
        let v = unsafe { crate::bpf_probe_read(&self.rescuer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_drainers(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_drainers) }.ok()
    }
    pub fn saved_max_active(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.saved_max_active) }.ok()
    }
    pub fn unbound_attrs(&self) -> Option<*mut workqueue_attrs> {
        let v = unsafe { crate::bpf_probe_read(&self.unbound_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dfl_pwq(&self) -> Option<*mut pool_workqueue> {
        let v = unsafe { crate::bpf_probe_read(&self.dfl_pwq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wq_dev(&self) -> Option<*mut wq_device> {
        let v = unsafe { crate::bpf_probe_read(&self.wq_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 24usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn cpu_pwqs(&self) -> Option<*mut pool_workqueue> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_pwqs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn numa_pwq_tbl(&self) -> Option<__IncompleteArrayField<*mut pool_workqueue>> {
        unsafe { crate::bpf_probe_read(&self.numa_pwq_tbl) }.ok()
    }
}
impl workqueue_attrs {
    pub fn nice(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nice) }.ok()
    }
    pub fn cpumask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
    pub fn no_numa(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.no_numa) }.ok()
    }
}
impl ida {
    pub fn xa(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.xa) }.ok()
    }
}
impl worker {
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.entry) }.ok()
    }
    pub fn hentry(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.hentry) }.ok()
    }
    pub fn current_work(&self) -> Option<*mut work_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.current_work) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn current_func(&self) -> Option<work_func_t> {
        unsafe { crate::bpf_probe_read(&self.current_func) }.ok()
    }
    pub fn current_pwq(&self) -> Option<*mut pool_workqueue> {
        let v = unsafe { crate::bpf_probe_read(&self.current_pwq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn scheduled(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.scheduled) }.ok()
    }
    pub fn task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pool(&self) -> Option<*mut worker_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn last_active(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_active) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn sleeping(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sleeping) }.ok()
    }
    pub fn desc(&self) -> Option<[::aya_bpf_cty::c_char; 24usize]> {
        unsafe { crate::bpf_probe_read(&self.desc) }.ok()
    }
    pub fn rescue_wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.rescue_wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn last_func(&self) -> Option<work_func_t> {
        unsafe { crate::bpf_probe_read(&self.last_func) }.ok()
    }
}
impl worker__bindgen_ty_1 {
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
    pub fn hentry(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hentry) }.ok()
    }
}
impl pool_workqueue {
    pub fn pool(&self) -> Option<*mut worker_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work_color(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.work_color) }.ok()
    }
    pub fn flush_color(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flush_color) }.ok()
    }
    pub fn refcnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn nr_in_flight(&self) -> Option<[::aya_bpf_cty::c_int; 15usize]> {
        unsafe { crate::bpf_probe_read(&self.nr_in_flight) }.ok()
    }
    pub fn nr_active(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_active) }.ok()
    }
    pub fn max_active(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_active) }.ok()
    }
    pub fn delayed_works(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.delayed_works) }.ok()
    }
    pub fn pwqs_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pwqs_node) }.ok()
    }
    pub fn mayday_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mayday_node) }.ok()
    }
    pub fn unbound_release_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.unbound_release_work) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl worker_pool {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn watchdog_ts(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.watchdog_ts) }.ok()
    }
    pub fn worklist(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.worklist) }.ok()
    }
    pub fn nr_workers(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_workers) }.ok()
    }
    pub fn nr_idle(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_idle) }.ok()
    }
    pub fn idle_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.idle_list) }.ok()
    }
    pub fn idle_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.idle_timer) }.ok()
    }
    pub fn mayday_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mayday_timer) }.ok()
    }
    pub fn busy_hash(&self) -> Option<[hlist_head; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.busy_hash) }.ok()
    }
    pub fn manager(&self) -> Option<*mut worker> {
        let v = unsafe { crate::bpf_probe_read(&self.manager) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn workers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.workers) }.ok()
    }
    pub fn detach_completion(&self) -> Option<*mut completion> {
        let v = unsafe { crate::bpf_probe_read(&self.detach_completion) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn worker_ida(&self) -> Option<ida> {
        unsafe { crate::bpf_probe_read(&self.worker_ida) }.ok()
    }
    pub fn attrs(&self) -> Option<*mut workqueue_attrs> {
        let v = unsafe { crate::bpf_probe_read(&self.attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hash_node) }.ok()
    }
    pub fn refcnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn nr_running(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_running) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl wq_flusher {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn flush_color(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flush_color) }.ok()
    }
    pub fn done(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
}
impl wq_device {
    pub fn wq(&self) -> Option<*mut workqueue_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.wq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
}
impl param_attribute {
    pub fn mattr(&self) -> Option<module_attribute> {
        unsafe { crate::bpf_probe_read(&self.mattr) }.ok()
    }
    pub fn param(&self) -> Option<*const kernel_param> {
        let v = unsafe { crate::bpf_probe_read(&self.param) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl module_param_attrs {
    pub fn num(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num) }.ok()
    }
    pub fn grp(&self) -> Option<attribute_group> {
        unsafe { crate::bpf_probe_read(&self.grp) }.ok()
    }
    pub fn attrs(&self) -> Option<__IncompleteArrayField<param_attribute>> {
        unsafe { crate::bpf_probe_read(&self.attrs) }.ok()
    }
}
impl ipc_ids {
    pub fn in_use(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.in_use) }.ok()
    }
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.rwsem) }.ok()
    }
    pub fn ipcs_idr(&self) -> Option<idr> {
        unsafe { crate::bpf_probe_read(&self.ipcs_idr) }.ok()
    }
    pub fn max_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_idx) }.ok()
    }
    pub fn last_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.last_idx) }.ok()
    }
    pub fn next_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.next_id) }.ok()
    }
    pub fn key_ht(&self) -> Option<rhashtable> {
        unsafe { crate::bpf_probe_read(&self.key_ht) }.ok()
    }
}
impl ipc_namespace {
    pub fn ids(&self) -> Option<[ipc_ids; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.ids) }.ok()
    }
    pub fn sem_ctls(&self) -> Option<[::aya_bpf_cty::c_int; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.sem_ctls) }.ok()
    }
    pub fn used_sems(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.used_sems) }.ok()
    }
    pub fn msg_ctlmax(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.msg_ctlmax) }.ok()
    }
    pub fn msg_ctlmnb(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.msg_ctlmnb) }.ok()
    }
    pub fn msg_ctlmni(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.msg_ctlmni) }.ok()
    }
    pub fn msg_bytes(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.msg_bytes) }.ok()
    }
    pub fn msg_hdrs(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.msg_hdrs) }.ok()
    }
    pub fn shm_ctlmax(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.shm_ctlmax) }.ok()
    }
    pub fn shm_ctlall(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.shm_ctlall) }.ok()
    }
    pub fn shm_tot(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.shm_tot) }.ok()
    }
    pub fn shm_ctlmni(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.shm_ctlmni) }.ok()
    }
    pub fn shm_rmid_forced(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.shm_rmid_forced) }.ok()
    }
    pub fn ipcns_nb(&self) -> Option<notifier_block> {
        unsafe { crate::bpf_probe_read(&self.ipcns_nb) }.ok()
    }
    pub fn mq_mnt(&self) -> Option<*mut vfsmount> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_mnt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_queues_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_queues_count) }.ok()
    }
    pub fn mq_queues_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_queues_max) }.ok()
    }
    pub fn mq_msg_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_msg_max) }.ok()
    }
    pub fn mq_msgsize_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_msgsize_max) }.ok()
    }
    pub fn mq_msg_default(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_msg_default) }.ok()
    }
    pub fn mq_msgsize_default(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mq_msgsize_default) }.ok()
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_llist(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.mnt_llist) }.ok()
    }
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
}
impl lsmblob {
    pub fn secid(&self) -> Option<[u32_; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.secid) }.ok()
    }
}
impl pin_cookie {}
impl dl_bw {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bw) }.ok()
    }
    pub fn total_bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.total_bw) }.ok()
    }
}
impl cpudl {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn free_cpus(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.free_cpus) }.ok()
    }
    pub fn elements(&self) -> Option<*mut cpudl_item> {
        let v = unsafe { crate::bpf_probe_read(&self.elements) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cpupri_vec {
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn mask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
}
impl cpupri {
    pub fn pri_to_cpu(&self) -> Option<[cpupri_vec; 101usize]> {
        unsafe { crate::bpf_probe_read(&self.pri_to_cpu) }.ok()
    }
    pub fn cpu_to_pri(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_to_pri) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl root_domain {
    pub fn refcount(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn rto_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.rto_count) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn span(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.span) }.ok()
    }
    pub fn online(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.online) }.ok()
    }
    pub fn overload(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overload) }.ok()
    }
    pub fn overutilized(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overutilized) }.ok()
    }
    pub fn dlo_mask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.dlo_mask) }.ok()
    }
    pub fn dlo_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dlo_count) }.ok()
    }
    pub fn dl_bw(&self) -> Option<dl_bw> {
        unsafe { crate::bpf_probe_read(&self.dl_bw) }.ok()
    }
    pub fn cpudl(&self) -> Option<cpudl> {
        unsafe { crate::bpf_probe_read(&self.cpudl) }.ok()
    }
    pub fn visit_gen(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.visit_gen) }.ok()
    }
    pub fn rto_push_work(&self) -> Option<irq_work> {
        unsafe { crate::bpf_probe_read(&self.rto_push_work) }.ok()
    }
    pub fn rto_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rto_lock) }.ok()
    }
    pub fn rto_loop(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rto_loop) }.ok()
    }
    pub fn rto_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rto_cpu) }.ok()
    }
    pub fn rto_loop_next(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.rto_loop_next) }.ok()
    }
    pub fn rto_loop_start(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.rto_loop_start) }.ok()
    }
    pub fn rto_mask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.rto_mask) }.ok()
    }
    pub fn cpupri(&self) -> Option<cpupri> {
        unsafe { crate::bpf_probe_read(&self.cpupri) }.ok()
    }
    pub fn max_cpu_capacity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_cpu_capacity) }.ok()
    }
    pub fn pd(&self) -> Option<*mut perf_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.pd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cfs_rq {
    pub fn load(&self) -> Option<load_weight> {
        unsafe { crate::bpf_probe_read(&self.load) }.ok()
    }
    pub fn nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_running) }.ok()
    }
    pub fn h_nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.h_nr_running) }.ok()
    }
    pub fn idle_h_nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.idle_h_nr_running) }.ok()
    }
    pub fn exec_clock(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.exec_clock) }.ok()
    }
    pub fn min_vruntime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.min_vruntime) }.ok()
    }
    pub fn tasks_timeline(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.tasks_timeline) }.ok()
    }
    pub fn curr(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.curr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn last(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.last) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skip(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.skip) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_spread_over(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_spread_over) }.ok()
    }
    pub fn avg(&self) -> Option<sched_avg> {
        unsafe { crate::bpf_probe_read(&self.avg) }.ok()
    }
    pub fn removed(&self) -> Option<cfs_rq__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.removed) }.ok()
    }
    pub fn tg_load_avg_contrib(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tg_load_avg_contrib) }.ok()
    }
    pub fn propagate(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.propagate) }.ok()
    }
    pub fn prop_runnable_sum(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.prop_runnable_sum) }.ok()
    }
    pub fn h_load(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.h_load) }.ok()
    }
    pub fn last_h_load_update(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_h_load_update) }.ok()
    }
    pub fn h_load_next(&self) -> Option<*mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.h_load_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rq(&self) -> Option<*mut rq> {
        let v = unsafe { crate::bpf_probe_read(&self.rq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn on_list(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.on_list) }.ok()
    }
    pub fn leaf_cfs_rq_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.leaf_cfs_rq_list) }.ok()
    }
    pub fn tg(&self) -> Option<*mut task_group> {
        let v = unsafe { crate::bpf_probe_read(&self.tg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn runtime_enabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.runtime_enabled) }.ok()
    }
    pub fn runtime_remaining(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.runtime_remaining) }.ok()
    }
    pub fn throttled_clock(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.throttled_clock) }.ok()
    }
    pub fn throttled_clock_task(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.throttled_clock_task) }.ok()
    }
    pub fn throttled_clock_task_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.throttled_clock_task_time) }.ok()
    }
    pub fn throttled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.throttled) }.ok()
    }
    pub fn throttle_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.throttle_count) }.ok()
    }
    pub fn throttled_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.throttled_list) }.ok()
    }
}
impl cfs_rq__bindgen_ty_1 {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr) }.ok()
    }
    pub fn load_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.load_avg) }.ok()
    }
    pub fn util_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.util_avg) }.ok()
    }
    pub fn runnable_avg(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.runnable_avg) }.ok()
    }
}
impl cfs_bandwidth {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn period(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.period) }.ok()
    }
    pub fn quota(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.quota) }.ok()
    }
    pub fn runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.runtime) }.ok()
    }
    pub fn hierarchical_quota(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.hierarchical_quota) }.ok()
    }
    pub fn idle(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.idle) }.ok()
    }
    pub fn period_active(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.period_active) }.ok()
    }
    pub fn slack_started(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.slack_started) }.ok()
    }
    pub fn period_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.period_timer) }.ok()
    }
    pub fn slack_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.slack_timer) }.ok()
    }
    pub fn throttled_cfs_rq(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.throttled_cfs_rq) }.ok()
    }
    pub fn nr_periods(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_periods) }.ok()
    }
    pub fn nr_throttled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_throttled) }.ok()
    }
    pub fn throttled_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.throttled_time) }.ok()
    }
}
impl task_group {
    pub fn css(&self) -> Option<cgroup_subsys_state> {
        unsafe { crate::bpf_probe_read(&self.css) }.ok()
    }
    pub fn se(&self) -> Option<*mut *mut sched_entity> {
        let v = unsafe { crate::bpf_probe_read(&self.se) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cfs_rq(&self) -> Option<*mut *mut cfs_rq> {
        let v = unsafe { crate::bpf_probe_read(&self.cfs_rq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn shares(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.shares) }.ok()
    }
    pub fn load_avg(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.load_avg) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn parent(&self) -> Option<*mut task_group> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn siblings(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.siblings) }.ok()
    }
    pub fn children(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.children) }.ok()
    }
    pub fn autogroup(&self) -> Option<*mut autogroup> {
        let v = unsafe { crate::bpf_probe_read(&self.autogroup) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cfs_bandwidth(&self) -> Option<cfs_bandwidth> {
        unsafe { crate::bpf_probe_read(&self.cfs_bandwidth) }.ok()
    }
    pub fn uclamp_pct(&self) -> Option<[::aya_bpf_cty::c_uint; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp_pct) }.ok()
    }
    pub fn uclamp_req(&self) -> Option<[uclamp_se; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp_req) }.ok()
    }
    pub fn uclamp(&self) -> Option<[uclamp_se; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp) }.ok()
    }
}
impl sched_group {
    pub fn next(&self) -> Option<*mut sched_group> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ref_(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn group_weight(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.group_weight) }.ok()
    }
    pub fn sgc(&self) -> Option<*mut sched_group_capacity> {
        let v = unsafe { crate::bpf_probe_read(&self.sgc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn asym_prefer_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.asym_prefer_cpu) }.ok()
    }
    pub fn cpumask(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
}
impl sched_group_capacity {
    pub fn ref_(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn capacity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.capacity) }.ok()
    }
    pub fn min_capacity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_capacity) }.ok()
    }
    pub fn max_capacity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_capacity) }.ok()
    }
    pub fn next_update(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.next_update) }.ok()
    }
    pub fn imbalance(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.imbalance) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn cpumask(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
}
impl autogroup {
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn tg(&self) -> Option<*mut task_group> {
        let v = unsafe { crate::bpf_probe_read(&self.tg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn nice(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nice) }.ok()
    }
}
impl cpuidle_state_usage {
    pub fn disable(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.disable) }.ok()
    }
    pub fn usage(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn time_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time_ns) }.ok()
    }
    pub fn above(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.above) }.ok()
    }
    pub fn below(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.below) }.ok()
    }
    pub fn rejected(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.rejected) }.ok()
    }
    pub fn s2idle_usage(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.s2idle_usage) }.ok()
    }
    pub fn s2idle_time(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.s2idle_time) }.ok()
    }
}
impl cpuidle_state {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn desc(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.desc) }.ok()
    }
    pub fn exit_latency_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.exit_latency_ns) }.ok()
    }
    pub fn target_residency_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.target_residency_ns) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn exit_latency(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.exit_latency) }.ok()
    }
    pub fn power_usage(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.power_usage) }.ok()
    }
    pub fn target_residency(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.target_residency) }.ok()
    }
    pub fn enter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cpuidle_device,
                arg2: *mut cpuidle_driver,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enter) }.ok()
    }
    pub fn enter_dead(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cpuidle_device,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enter_dead) }.ok()
    }
    pub fn enter_s2idle(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cpuidle_device,
                arg2: *mut cpuidle_driver,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.enter_s2idle) }.ok()
    }
}
impl cpuidle_driver_kobj {}
impl cpuidle_device {
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn next_hrtimer(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.next_hrtimer) }.ok()
    }
    pub fn last_state_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.last_state_idx) }.ok()
    }
    pub fn last_residency_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_residency_ns) }.ok()
    }
    pub fn poll_limit_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.poll_limit_ns) }.ok()
    }
    pub fn forced_idle_latency_limit_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.forced_idle_latency_limit_ns) }.ok()
    }
    pub fn states_usage(&self) -> Option<[cpuidle_state_usage; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.states_usage) }.ok()
    }
    pub fn kobjs(&self) -> Option<[*mut cpuidle_state_kobj; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.kobjs) }.ok()
    }
    pub fn kobj_driver(&self) -> Option<*mut cpuidle_driver_kobj> {
        let v = unsafe { crate::bpf_probe_read(&self.kobj_driver) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj_dev(&self) -> Option<*mut cpuidle_device_kobj> {
        let v = unsafe { crate::bpf_probe_read(&self.kobj_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn device_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.device_list) }.ok()
    }
}
impl cpuidle_driver {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn states(&self) -> Option<[cpuidle_state; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.states) }.ok()
    }
    pub fn state_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.state_count) }.ok()
    }
    pub fn safe_state_index(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.safe_state_index) }.ok()
    }
    pub fn cpumask(&self) -> Option<*mut cpumask> {
        let v = unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn governor(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.governor) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cpu_stop_work {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn fn_(&self) -> Option<cpu_stop_fn_t> {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
    pub fn caller(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.caller) }.ok()
    }
    pub fn arg(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.arg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn done(&self) -> Option<*mut cpu_stop_done> {
        let v = unsafe { crate::bpf_probe_read(&self.done) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cpudl_item {
    pub fn dl(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.dl) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.idx) }.ok()
    }
}
impl rt_prio_array {
    pub fn bitmap(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.bitmap) }.ok()
    }
    pub fn queue(&self) -> Option<[list_head; 100usize]> {
        unsafe { crate::bpf_probe_read(&self.queue) }.ok()
    }
}
impl uclamp_bucket {}
impl uclamp_rq {
    pub fn value(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.value) }.ok()
    }
    pub fn bucket(&self) -> Option<[uclamp_bucket; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.bucket) }.ok()
    }
}
impl rt_rq {
    pub fn active(&self) -> Option<rt_prio_array> {
        unsafe { crate::bpf_probe_read(&self.active) }.ok()
    }
    pub fn rt_nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rt_nr_running) }.ok()
    }
    pub fn rr_nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rr_nr_running) }.ok()
    }
    pub fn highest_prio(&self) -> Option<rt_rq__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.highest_prio) }.ok()
    }
    pub fn rt_nr_migratory(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rt_nr_migratory) }.ok()
    }
    pub fn rt_nr_total(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rt_nr_total) }.ok()
    }
    pub fn overloaded(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overloaded) }.ok()
    }
    pub fn pushable_tasks(&self) -> Option<plist_head> {
        unsafe { crate::bpf_probe_read(&self.pushable_tasks) }.ok()
    }
    pub fn rt_queued(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rt_queued) }.ok()
    }
    pub fn rt_throttled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rt_throttled) }.ok()
    }
    pub fn rt_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rt_time) }.ok()
    }
    pub fn rt_runtime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rt_runtime) }.ok()
    }
    pub fn rt_runtime_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rt_runtime_lock) }.ok()
    }
}
impl rt_rq__bindgen_ty_1 {
    pub fn curr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.curr) }.ok()
    }
    pub fn next(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.next) }.ok()
    }
}
impl dl_rq {
    pub fn root(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.root) }.ok()
    }
    pub fn dl_nr_running(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dl_nr_running) }.ok()
    }
    pub fn earliest_dl(&self) -> Option<dl_rq__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.earliest_dl) }.ok()
    }
    pub fn dl_nr_migratory(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dl_nr_migratory) }.ok()
    }
    pub fn overloaded(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overloaded) }.ok()
    }
    pub fn pushable_dl_tasks_root(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.pushable_dl_tasks_root) }.ok()
    }
    pub fn running_bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.running_bw) }.ok()
    }
    pub fn this_bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.this_bw) }.ok()
    }
    pub fn extra_bw(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.extra_bw) }.ok()
    }
    pub fn bw_ratio(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bw_ratio) }.ok()
    }
}
impl dl_rq__bindgen_ty_1 {
    pub fn curr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.curr) }.ok()
    }
    pub fn next(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.next) }.ok()
    }
}
impl rq {
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nr_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_running) }.ok()
    }
    pub fn nr_numa_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_numa_running) }.ok()
    }
    pub fn nr_preferred_running(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_preferred_running) }.ok()
    }
    pub fn numa_migrate_on(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.numa_migrate_on) }.ok()
    }
    pub fn last_blocked_load_update_tick(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_blocked_load_update_tick) }.ok()
    }
    pub fn has_blocked_load(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.has_blocked_load) }.ok()
    }
    pub fn nohz_csd(&self) -> Option<call_single_data_t> {
        unsafe { crate::bpf_probe_read(&self.nohz_csd) }.ok()
    }
    pub fn nohz_tick_stopped(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nohz_tick_stopped) }.ok()
    }
    pub fn nohz_flags(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nohz_flags) }.ok()
    }
    pub fn ttwu_pending(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_pending) }.ok()
    }
    pub fn nr_switches(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.nr_switches) }.ok()
    }
    pub fn uclamp(&self) -> Option<[uclamp_rq; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.uclamp) }.ok()
    }
    pub fn uclamp_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.uclamp_flags) }.ok()
    }
    pub fn cfs(&self) -> Option<cfs_rq> {
        unsafe { crate::bpf_probe_read(&self.cfs) }.ok()
    }
    pub fn rt(&self) -> Option<rt_rq> {
        unsafe { crate::bpf_probe_read(&self.rt) }.ok()
    }
    pub fn dl(&self) -> Option<dl_rq> {
        unsafe { crate::bpf_probe_read(&self.dl) }.ok()
    }
    pub fn leaf_cfs_rq_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.leaf_cfs_rq_list) }.ok()
    }
    pub fn tmp_alone_branch(&self) -> Option<*mut list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.tmp_alone_branch) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_uninterruptible(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_uninterruptible) }.ok()
    }
    pub fn curr(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.curr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn idle(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.idle) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stop(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.stop) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next_balance(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.next_balance) }.ok()
    }
    pub fn prev_mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.prev_mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn clock_update_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_update_flags) }.ok()
    }
    pub fn clock(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.clock) }.ok()
    }
    pub fn clock_task(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.clock_task) }.ok()
    }
    pub fn clock_pelt(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.clock_pelt) }.ok()
    }
    pub fn lost_idle_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lost_idle_time) }.ok()
    }
    pub fn nr_iowait(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_iowait) }.ok()
    }
    pub fn membarrier_state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.membarrier_state) }.ok()
    }
    pub fn rd(&self) -> Option<*mut root_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.rd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sd(&self) -> Option<*mut sched_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.sd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_capacity(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cpu_capacity) }.ok()
    }
    pub fn cpu_capacity_orig(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cpu_capacity_orig) }.ok()
    }
    pub fn balance_callback(&self) -> Option<*mut callback_head> {
        let v = unsafe { crate::bpf_probe_read(&self.balance_callback) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn balance_push(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.balance_push) }.ok()
    }
    pub fn nohz_idle_balance(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.nohz_idle_balance) }.ok()
    }
    pub fn idle_balance(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.idle_balance) }.ok()
    }
    pub fn misfit_task_load(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.misfit_task_load) }.ok()
    }
    pub fn active_balance(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.active_balance) }.ok()
    }
    pub fn push_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.push_cpu) }.ok()
    }
    pub fn active_balance_work(&self) -> Option<cpu_stop_work> {
        unsafe { crate::bpf_probe_read(&self.active_balance_work) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn online(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.online) }.ok()
    }
    pub fn cfs_tasks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.cfs_tasks) }.ok()
    }
    pub fn avg_rt(&self) -> Option<sched_avg> {
        unsafe { crate::bpf_probe_read(&self.avg_rt) }.ok()
    }
    pub fn avg_dl(&self) -> Option<sched_avg> {
        unsafe { crate::bpf_probe_read(&self.avg_dl) }.ok()
    }
    pub fn idle_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.idle_stamp) }.ok()
    }
    pub fn avg_idle(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avg_idle) }.ok()
    }
    pub fn max_idle_balance_cost(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max_idle_balance_cost) }.ok()
    }
    pub fn hotplug_wait(&self) -> Option<rcuwait> {
        unsafe { crate::bpf_probe_read(&self.hotplug_wait) }.ok()
    }
    pub fn prev_steal_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.prev_steal_time) }.ok()
    }
    pub fn calc_load_update(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.calc_load_update) }.ok()
    }
    pub fn calc_load_active(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.calc_load_active) }.ok()
    }
    pub fn hrtick_csd(&self) -> Option<call_single_data_t> {
        unsafe { crate::bpf_probe_read(&self.hrtick_csd) }.ok()
    }
    pub fn hrtick_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.hrtick_timer) }.ok()
    }
    pub fn hrtick_time(&self) -> Option<ktime_t> {
        unsafe { crate::bpf_probe_read(&self.hrtick_time) }.ok()
    }
    pub fn rq_sched_info(&self) -> Option<sched_info> {
        unsafe { crate::bpf_probe_read(&self.rq_sched_info) }.ok()
    }
    pub fn rq_cpu_time(&self) -> Option<::aya_bpf_cty::c_ulonglong> {
        unsafe { crate::bpf_probe_read(&self.rq_cpu_time) }.ok()
    }
    pub fn yld_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.yld_count) }.ok()
    }
    pub fn sched_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sched_count) }.ok()
    }
    pub fn sched_goidle(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sched_goidle) }.ok()
    }
    pub fn ttwu_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_count) }.ok()
    }
    pub fn ttwu_local(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ttwu_local) }.ok()
    }
    pub fn idle_state(&self) -> Option<*mut cpuidle_state> {
        let v = unsafe { crate::bpf_probe_read(&self.idle_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_pinned(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_pinned) }.ok()
    }
    pub fn push_busy(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.push_busy) }.ok()
    }
    pub fn push_work(&self) -> Option<cpu_stop_work> {
        unsafe { crate::bpf_probe_read(&self.push_work) }.ok()
    }
}
impl perf_domain {
    pub fn em_pd(&self) -> Option<*mut em_perf_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.em_pd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next(&self) -> Option<*mut perf_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl rq_flags {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn cookie(&self) -> Option<pin_cookie> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn clock_update_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clock_update_flags) }.ok()
    }
}
impl numa_group {
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nr_tasks(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_tasks) }.ok()
    }
    pub fn gid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn active_nodes(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.active_nodes) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn total_faults(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_faults) }.ok()
    }
    pub fn max_faults_cpu(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_faults_cpu) }.ok()
    }
    pub fn faults_cpu(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.faults_cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn faults(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.faults) }.ok()
    }
}
impl rt_mutex_waiter {
    pub fn tree_entry(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.tree_entry) }.ok()
    }
    pub fn pi_tree_entry(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.pi_tree_entry) }.ok()
    }
    pub fn task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<*mut rt_mutex> {
        let v = unsafe { crate::bpf_probe_read(&self.lock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prio(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn deadline(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.deadline) }.ok()
    }
}
impl rt_mutex {
    pub fn wait_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.wait_lock) }.ok()
    }
    pub fn waiters(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.waiters) }.ok()
    }
    pub fn owner(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl futex_key {
    pub fn shared(&self) -> Option<futex_key__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.shared) }.ok()
    }
    pub fn private(&self) -> Option<futex_key__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.private) }.ok()
    }
    pub fn both(&self) -> Option<futex_key__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.both) }.ok()
    }
}
impl futex_key__bindgen_ty_1 {
    pub fn i_seq(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.i_seq) }.ok()
    }
    pub fn pgoff(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.pgoff) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl futex_key__bindgen_ty_2 {
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __tmp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__tmp) }.ok()
    }
    pub fn address(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.address) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl futex_key__bindgen_ty_2__bindgen_ty_1 {
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __tmp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.__tmp) }.ok()
    }
}
impl futex_key__bindgen_ty_3 {
    pub fn ptr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.ptr) }.ok()
    }
    pub fn word(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.word) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl futex_pi_state {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn pi_mutex(&self) -> Option<rt_mutex> {
        unsafe { crate::bpf_probe_read(&self.pi_mutex) }.ok()
    }
    pub fn owner(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn key(&self) -> Option<futex_key> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl module_sect_attr {
    pub fn battr(&self) -> Option<bin_attribute> {
        unsafe { crate::bpf_probe_read(&self.battr) }.ok()
    }
    pub fn address(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.address) }.ok()
    }
}
impl module_sect_attrs {
    pub fn grp(&self) -> Option<attribute_group> {
        unsafe { crate::bpf_probe_read(&self.grp) }.ok()
    }
    pub fn nsections(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nsections) }.ok()
    }
    pub fn attrs(&self) -> Option<__IncompleteArrayField<module_sect_attr>> {
        unsafe { crate::bpf_probe_read(&self.attrs) }.ok()
    }
}
impl module_notes_attrs {
    pub fn dir(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notes(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.notes) }.ok()
    }
    pub fn attrs(&self) -> Option<__IncompleteArrayField<bin_attribute>> {
        unsafe { crate::bpf_probe_read(&self.attrs) }.ok()
    }
}
impl fs_pin {
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
    pub fn done(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn s_list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.s_list) }.ok()
    }
    pub fn m_list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.m_list) }.ok()
    }
    pub fn kill(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_pin)>> {
        unsafe { crate::bpf_probe_read(&self.kill) }.ok()
    }
}
impl bpf_link_info {
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn prog_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.prog_id) }.ok()
    }
    pub fn raw_tracepoint(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.raw_tracepoint) }.ok()
    }
    pub fn tracing(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tracing) }.ok()
    }
    pub fn cgroup(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.cgroup) }.ok()
    }
    pub fn iter(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.iter) }.ok()
    }
    pub fn netns(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.netns) }.ok()
    }
    pub fn xdp(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.xdp) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1 {
    pub fn raw_tracepoint(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.raw_tracepoint) }.ok()
    }
    pub fn tracing(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.tracing) }.ok()
    }
    pub fn cgroup(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.cgroup) }.ok()
    }
    pub fn iter(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.iter) }.ok()
    }
    pub fn netns(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.netns) }.ok()
    }
    pub fn xdp(&self) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.xdp) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub fn tp_name(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tp_name) }.ok()
    }
    pub fn tp_name_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tp_name_len) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub fn cgroup_id(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.cgroup_id) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub fn target_name(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.target_name) }.ok()
    }
    pub fn target_name_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.target_name_len) }.ok()
    }
    pub fn map(
        &self,
    ) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub fn map(
        &self,
    ) -> Option<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub fn map_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_id) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub fn netns_ino(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.netns_ino) }.ok()
    }
    pub fn attach_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.attach_type) }.ok()
    }
}
impl bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub fn ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
}
impl bpf_link {
    pub fn refcnt(&self) -> Option<atomic64_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn type_(&self) -> Option<bpf_link_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn ops(&self) -> Option<*const bpf_link_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
}
impl bpf_link_ops {
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn dealloc(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>> {
        unsafe { crate::bpf_probe_read(&self.dealloc) }.ok()
    }
    pub fn detach(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.detach) }.ok()
    }
    pub fn update_prog(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_link,
                arg2: *mut bpf_prog,
                arg3: *mut bpf_prog,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update_prog) }.ok()
    }
    pub fn show_fdinfo(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_link, arg2: *mut seq_file)>,
    > {
        unsafe { crate::bpf_probe_read(&self.show_fdinfo) }.ok()
    }
    pub fn fill_link_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const bpf_link,
                arg2: *mut bpf_link_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fill_link_info) }.ok()
    }
}
impl cgroup_taskset {
    pub fn src_csets(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.src_csets) }.ok()
    }
    pub fn dst_csets(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dst_csets) }.ok()
    }
    pub fn nr_tasks(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_tasks) }.ok()
    }
    pub fn ssid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ssid) }.ok()
    }
    pub fn csets(&self) -> Option<*mut list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.csets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cur_cset(&self) -> Option<*mut css_set> {
        let v = unsafe { crate::bpf_probe_read(&self.cur_cset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cur_task(&self) -> Option<*mut task_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.cur_task) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kernel_pkey_query {
    pub fn supported_ops(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.supported_ops) }.ok()
    }
    pub fn key_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.key_size) }.ok()
    }
    pub fn max_data_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.max_data_size) }.ok()
    }
    pub fn max_sig_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.max_sig_size) }.ok()
    }
    pub fn max_enc_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.max_enc_size) }.ok()
    }
    pub fn max_dec_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.max_dec_size) }.ok()
    }
}
impl kernel_pkey_params {
    pub fn key(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn encoding(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.encoding) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash_algo(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.hash_algo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn info(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn in_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.in_len) }.ok()
    }
    pub fn out_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.out_len) }.ok()
    }
    pub fn in2_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.in2_len) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl kernel_pkey_params__bindgen_ty_1 {
    pub fn out_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.out_len) }.ok()
    }
    pub fn in2_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.in2_len) }.ok()
    }
}
impl key_preparsed_payload {
    pub fn orig_description(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.orig_description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn payload(&self) -> Option<key_payload> {
        unsafe { crate::bpf_probe_read(&self.payload) }.ok()
    }
    pub fn data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn datalen(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.datalen) }.ok()
    }
    pub fn quotalen(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.quotalen) }.ok()
    }
    pub fn expiry(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.expiry) }.ok()
    }
}
impl key_match_data {
    pub fn cmp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const key, arg2: *const key_match_data) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cmp) }.ok()
    }
    pub fn raw_data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.raw_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn preparsed(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.preparsed) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lookup_type(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lookup_type) }.ok()
    }
}
impl cpu_stop_done {
    pub fn nr_todo(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_todo) }.ok()
    }
    pub fn ret(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ret) }.ok()
    }
    pub fn completion(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.completion) }.ok()
    }
}
impl audit_cap_data {
    pub fn permitted(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.permitted) }.ok()
    }
    pub fn inheritable(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.inheritable) }.ok()
    }
    pub fn fE(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fE) }.ok()
    }
    pub fn effective(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.effective) }.ok()
    }
    pub fn ambient(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.ambient) }.ok()
    }
    pub fn rootid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.rootid) }.ok()
    }
}
impl audit_cap_data__bindgen_ty_1 {
    pub fn fE(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fE) }.ok()
    }
    pub fn effective(&self) -> Option<kernel_cap_t> {
        unsafe { crate::bpf_probe_read(&self.effective) }.ok()
    }
}
impl audit_names {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn name(&self) -> Option<*mut filename> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.name_len) }.ok()
    }
    pub fn hidden(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.hidden) }.ok()
    }
    pub fn ino(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ino) }.ok()
    }
    pub fn dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn rdev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.rdev) }.ok()
    }
    pub fn oblob(&self) -> Option<lsmblob> {
        unsafe { crate::bpf_probe_read(&self.oblob) }.ok()
    }
    pub fn fcap(&self) -> Option<audit_cap_data> {
        unsafe { crate::bpf_probe_read(&self.fcap) }.ok()
    }
    pub fn fcap_ver(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fcap_ver) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn should_free(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.should_free) }.ok()
    }
}
impl mq_attr {
    pub fn mq_flags(&self) -> Option<__kernel_long_t> {
        unsafe { crate::bpf_probe_read(&self.mq_flags) }.ok()
    }
    pub fn mq_maxmsg(&self) -> Option<__kernel_long_t> {
        unsafe { crate::bpf_probe_read(&self.mq_maxmsg) }.ok()
    }
    pub fn mq_msgsize(&self) -> Option<__kernel_long_t> {
        unsafe { crate::bpf_probe_read(&self.mq_msgsize) }.ok()
    }
    pub fn mq_curmsgs(&self) -> Option<__kernel_long_t> {
        unsafe { crate::bpf_probe_read(&self.mq_curmsgs) }.ok()
    }
    pub fn __reserved(&self) -> Option<[__kernel_long_t; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__reserved) }.ok()
    }
}
impl audit_proctitle {
    pub fn len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn value(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.value) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl audit_context {
    pub fn dummy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dummy) }.ok()
    }
    pub fn in_syscall(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.in_syscall) }.ok()
    }
    pub fn state(&self) -> Option<audit_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn current_state(&self) -> Option<audit_state::Type> {
        unsafe { crate::bpf_probe_read(&self.current_state) }.ok()
    }
    pub fn serial(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.serial) }.ok()
    }
    pub fn major(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.major) }.ok()
    }
    pub fn ctime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ctime) }.ok()
    }
    pub fn argv(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.argv) }.ok()
    }
    pub fn return_code(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.return_code) }.ok()
    }
    pub fn prio(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn return_valid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.return_valid) }.ok()
    }
    pub fn preallocated_names(&self) -> Option<[audit_names; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.preallocated_names) }.ok()
    }
    pub fn name_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.name_count) }.ok()
    }
    pub fn names_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.names_list) }.ok()
    }
    pub fn filterkey(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.filterkey) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pwd(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.pwd) }.ok()
    }
    pub fn aux(&self) -> Option<*mut audit_aux_data> {
        let v = unsafe { crate::bpf_probe_read(&self.aux) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aux_pids(&self) -> Option<*mut audit_aux_data> {
        let v = unsafe { crate::bpf_probe_read(&self.aux_pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sockaddr(&self) -> Option<*mut __kernel_sockaddr_storage> {
        let v = unsafe { crate::bpf_probe_read(&self.sockaddr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sockaddr_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.sockaddr_len) }.ok()
    }
    pub fn pid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn ppid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.ppid) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn euid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.euid) }.ok()
    }
    pub fn suid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.suid) }.ok()
    }
    pub fn fsuid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.fsuid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn egid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.egid) }.ok()
    }
    pub fn sgid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.sgid) }.ok()
    }
    pub fn fsgid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.fsgid) }.ok()
    }
    pub fn personality(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.personality) }.ok()
    }
    pub fn arch(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.arch) }.ok()
    }
    pub fn target_pid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.target_pid) }.ok()
    }
    pub fn target_auid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.target_auid) }.ok()
    }
    pub fn target_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.target_uid) }.ok()
    }
    pub fn target_sessionid(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.target_sessionid) }.ok()
    }
    pub fn target_lsm(&self) -> Option<lsmblob> {
        unsafe { crate::bpf_probe_read(&self.target_lsm) }.ok()
    }
    pub fn target_comm(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.target_comm) }.ok()
    }
    pub fn trees(&self) -> Option<*mut audit_tree_refs> {
        let v = unsafe { crate::bpf_probe_read(&self.trees) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn first_trees(&self) -> Option<*mut audit_tree_refs> {
        let v = unsafe { crate::bpf_probe_read(&self.first_trees) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn killed_trees(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.killed_trees) }.ok()
    }
    pub fn tree_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tree_count) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn socketcall(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.socketcall) }.ok()
    }
    pub fn ipc(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipc) }.ok()
    }
    pub fn mq_getsetattr(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mq_getsetattr) }.ok()
    }
    pub fn mq_notify(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mq_notify) }.ok()
    }
    pub fn mq_sendrecv(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mq_sendrecv) }.ok()
    }
    pub fn mq_open(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mq_open) }.ok()
    }
    pub fn capset(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.capset) }.ok()
    }
    pub fn mmap(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mmap) }.ok()
    }
    pub fn execve(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_9> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.execve) }.ok()
    }
    pub fn module(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_10> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.module) }.ok()
    }
    pub fn fds(&self) -> Option<[::aya_bpf_cty::c_int; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.fds) }.ok()
    }
    pub fn proctitle(&self) -> Option<audit_proctitle> {
        unsafe { crate::bpf_probe_read(&self.proctitle) }.ok()
    }
}
impl audit_context__bindgen_ty_1 {
    pub fn socketcall(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.socketcall) }.ok()
    }
    pub fn ipc(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.ipc) }.ok()
    }
    pub fn mq_getsetattr(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.mq_getsetattr) }.ok()
    }
    pub fn mq_notify(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.mq_notify) }.ok()
    }
    pub fn mq_sendrecv(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.mq_sendrecv) }.ok()
    }
    pub fn mq_open(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.mq_open) }.ok()
    }
    pub fn capset(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self.capset) }.ok()
    }
    pub fn mmap(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_8> {
        unsafe { crate::bpf_probe_read(&self.mmap) }.ok()
    }
    pub fn execve(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_9> {
        unsafe { crate::bpf_probe_read(&self.execve) }.ok()
    }
    pub fn module(&self) -> Option<audit_context__bindgen_ty_1__bindgen_ty_10> {
        unsafe { crate::bpf_probe_read(&self.module) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_1 {
    pub fn nargs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nargs) }.ok()
    }
    pub fn args(&self) -> Option<[::aya_bpf_cty::c_long; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.args) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_2 {
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn oblob(&self) -> Option<lsmblob> {
        unsafe { crate::bpf_probe_read(&self.oblob) }.ok()
    }
    pub fn has_perm(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.has_perm) }.ok()
    }
    pub fn perm_uid(&self) -> Option<uid_t> {
        unsafe { crate::bpf_probe_read(&self.perm_uid) }.ok()
    }
    pub fn perm_gid(&self) -> Option<gid_t> {
        unsafe { crate::bpf_probe_read(&self.perm_gid) }.ok()
    }
    pub fn perm_mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.perm_mode) }.ok()
    }
    pub fn qbytes(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.qbytes) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_3 {
    pub fn mqdes(&self) -> Option<mqd_t> {
        unsafe { crate::bpf_probe_read(&self.mqdes) }.ok()
    }
    pub fn mqstat(&self) -> Option<mq_attr> {
        unsafe { crate::bpf_probe_read(&self.mqstat) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_4 {
    pub fn mqdes(&self) -> Option<mqd_t> {
        unsafe { crate::bpf_probe_read(&self.mqdes) }.ok()
    }
    pub fn sigev_signo(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sigev_signo) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_5 {
    pub fn mqdes(&self) -> Option<mqd_t> {
        unsafe { crate::bpf_probe_read(&self.mqdes) }.ok()
    }
    pub fn msg_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.msg_len) }.ok()
    }
    pub fn msg_prio(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.msg_prio) }.ok()
    }
    pub fn abs_timeout(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.abs_timeout) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_6 {
    pub fn oflag(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.oflag) }.ok()
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn attr(&self) -> Option<mq_attr> {
        unsafe { crate::bpf_probe_read(&self.attr) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_7 {
    pub fn pid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn cap(&self) -> Option<audit_cap_data> {
        unsafe { crate::bpf_probe_read(&self.cap) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_8 {
    pub fn fd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fd) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_9 {
    pub fn argc(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.argc) }.ok()
    }
}
impl audit_context__bindgen_ty_1__bindgen_ty_10 {
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __kernel_sockaddr_storage {
    pub fn ss_family(&self) -> Option<__kernel_sa_family_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ss_family) }.ok()
    }
    pub fn __data(&self) -> Option<[::aya_bpf_cty::c_char; 126usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.__data) }.ok()
    }
    pub fn __align(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__align) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __kernel_sockaddr_storage__bindgen_ty_1 {
    pub fn ss_family(&self) -> Option<__kernel_sa_family_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ss_family) }.ok()
    }
    pub fn __data(&self) -> Option<[::aya_bpf_cty::c_char; 126usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__data) }.ok()
    }
    pub fn __align(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__align) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub fn ss_family(&self) -> Option<__kernel_sa_family_t> {
        unsafe { crate::bpf_probe_read(&self.ss_family) }.ok()
    }
    pub fn __data(&self) -> Option<[::aya_bpf_cty::c_char; 126usize]> {
        unsafe { crate::bpf_probe_read(&self.__data) }.ok()
    }
}
impl net_generic {
    pub fn s(&self) -> Option<__BindgenUnionField<net_generic__bindgen_ty_1__bindgen_ty_1>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.s) }.ok()
    }
    pub fn ptr(&self) -> Option<__BindgenUnionField<[*mut ::aya_bpf_cty::c_void; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ptr) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u64; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bindgen_union_field) }.ok()
    }
}
impl net_generic__bindgen_ty_1 {
    pub fn s(&self) -> Option<__BindgenUnionField<net_generic__bindgen_ty_1__bindgen_ty_1>> {
        unsafe { crate::bpf_probe_read(&self.s) }.ok()
    }
    pub fn ptr(&self) -> Option<__BindgenUnionField<[*mut ::aya_bpf_cty::c_void; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.ptr) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u64; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl net_generic__bindgen_ty_1__bindgen_ty_1 {
    pub fn len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl fsnotify_mark_connector {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn fsid(&self) -> Option<__kernel_fsid_t> {
        unsafe { crate::bpf_probe_read(&self.fsid) }.ok()
    }
    pub fn obj(&self) -> Option<*mut fsnotify_connp_t> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.obj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn destroy_next(&self) -> Option<*mut fsnotify_mark_connector> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.destroy_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl fsnotify_mark_connector__bindgen_ty_1 {
    pub fn obj(&self) -> Option<*mut fsnotify_connp_t> {
        let v = unsafe { crate::bpf_probe_read(&self.obj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn destroy_next(&self) -> Option<*mut fsnotify_mark_connector> {
        let v = unsafe { crate::bpf_probe_read(&self.destroy_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl audit_aux_data {
    pub fn next(&self) -> Option<*mut audit_aux_data> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
}
impl audit_chunk {}
impl audit_tree_refs {
    pub fn next(&self) -> Option<*mut audit_tree_refs> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn c(&self) -> Option<[*mut audit_chunk; 31usize]> {
        unsafe { crate::bpf_probe_read(&self.c) }.ok()
    }
}
impl action_cache {
    pub fn allow_native(&self) -> Option<[::aya_bpf_cty::c_ulong; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.allow_native) }.ok()
    }
    pub fn allow_compat(&self) -> Option<[::aya_bpf_cty::c_ulong; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.allow_compat) }.ok()
    }
}
impl seccomp_filter {
    pub fn refs(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refs) }.ok()
    }
    pub fn users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn log(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.log) }.ok()
    }
    pub fn cache(&self) -> Option<action_cache> {
        unsafe { crate::bpf_probe_read(&self.cache) }.ok()
    }
    pub fn prev(&self) -> Option<*mut seccomp_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.prev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notif(&self) -> Option<*mut notification> {
        let v = unsafe { crate::bpf_probe_read(&self.notif) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notify_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.notify_lock) }.ok()
    }
    pub fn wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wqh) }.ok()
    }
}
impl notification {
    pub fn request(&self) -> Option<semaphore> {
        unsafe { crate::bpf_probe_read(&self.request) }.ok()
    }
    pub fn next_id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.next_id) }.ok()
    }
    pub fn notifications(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.notifications) }.ok()
    }
}
impl rchan_buf {
    pub fn start(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn subbufs_produced(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.subbufs_produced) }.ok()
    }
    pub fn subbufs_consumed(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.subbufs_consumed) }.ok()
    }
    pub fn chan(&self) -> Option<*mut rchan> {
        let v = unsafe { crate::bpf_probe_read(&self.chan) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn read_wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.read_wait) }.ok()
    }
    pub fn wakeup_work(&self) -> Option<irq_work> {
        unsafe { crate::bpf_probe_read(&self.wakeup_work) }.ok()
    }
    pub fn dentry(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dentry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn page_array(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page_array) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn page_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.page_count) }.ok()
    }
    pub fn finalized(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.finalized) }.ok()
    }
    pub fn padding(&self) -> Option<*mut size_t> {
        let v = unsafe { crate::bpf_probe_read(&self.padding) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev_padding(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.prev_padding) }.ok()
    }
    pub fn bytes_consumed(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.bytes_consumed) }.ok()
    }
    pub fn early_bytes(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.early_bytes) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
}
impl rchan {
    pub fn version(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn subbuf_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.subbuf_size) }.ok()
    }
    pub fn n_subbufs(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.n_subbufs) }.ok()
    }
    pub fn alloc_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.alloc_size) }.ok()
    }
    pub fn cb(&self) -> Option<*const rchan_callbacks> {
        let v = unsafe { crate::bpf_probe_read(&self.cb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn private_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn last_toobig(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.last_toobig) }.ok()
    }
    pub fn buf(&self) -> Option<*mut *mut rchan_buf> {
        let v = unsafe { crate::bpf_probe_read(&self.buf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn is_global(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.is_global) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn parent(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn has_base_filename(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.has_base_filename) }.ok()
    }
    pub fn base_filename(&self) -> Option<[::aya_bpf_cty::c_char; 255usize]> {
        unsafe { crate::bpf_probe_read(&self.base_filename) }.ok()
    }
}
impl rchan_callbacks {
    pub fn subbuf_start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut rchan_buf,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut ::aya_bpf_cty::c_void,
                arg4: size_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.subbuf_start) }.ok()
    }
    pub fn create_buf_file(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf_cty::c_char,
                arg2: *mut dentry,
                arg3: umode_t,
                arg4: *mut rchan_buf,
                arg5: *mut ::aya_bpf_cty::c_int,
            ) -> *mut dentry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.create_buf_file) }.ok()
    }
    pub fn remove_buf_file(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.remove_buf_file) }.ok()
    }
}
impl ftrace_hash {
    pub fn size_bits(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.size_bits) }.ok()
    }
    pub fn buckets(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.buckets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl event_filter {
    pub fn prog(&self) -> Option<*mut prog_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter_string(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.filter_string) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl array_buffer {
    pub fn tr(&self) -> Option<*mut trace_array> {
        let v = unsafe { crate::bpf_probe_read(&self.tr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn buffer(&self) -> Option<*mut trace_buffer> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut trace_array_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn time_start(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time_start) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
}
impl trace_array {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn array_buffer(&self) -> Option<array_buffer> {
        unsafe { crate::bpf_probe_read(&self.array_buffer) }.ok()
    }
    pub fn max_buffer(&self) -> Option<array_buffer> {
        unsafe { crate::bpf_probe_read(&self.max_buffer) }.ok()
    }
    pub fn allocated_snapshot(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.allocated_snapshot) }.ok()
    }
    pub fn max_latency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.max_latency) }.ok()
    }
    pub fn d_max_latency(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.d_max_latency) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fsnotify_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.fsnotify_work) }.ok()
    }
    pub fn fsnotify_irqwork(&self) -> Option<irq_work> {
        unsafe { crate::bpf_probe_read(&self.fsnotify_irqwork) }.ok()
    }
    pub fn filtered_pids(&self) -> Option<*mut trace_pid_list> {
        let v = unsafe { crate::bpf_probe_read(&self.filtered_pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filtered_no_pids(&self) -> Option<*mut trace_pid_list> {
        let v = unsafe { crate::bpf_probe_read(&self.filtered_no_pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn max_lock(&self) -> Option<arch_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.max_lock) }.ok()
    }
    pub fn buffer_disabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.buffer_disabled) }.ok()
    }
    pub fn sys_refcount_enter(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sys_refcount_enter) }.ok()
    }
    pub fn sys_refcount_exit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sys_refcount_exit) }.ok()
    }
    pub fn enter_syscall_files(&self) -> Option<[*mut trace_event_file; 442usize]> {
        unsafe { crate::bpf_probe_read(&self.enter_syscall_files) }.ok()
    }
    pub fn exit_syscall_files(&self) -> Option<[*mut trace_event_file; 442usize]> {
        unsafe { crate::bpf_probe_read(&self.exit_syscall_files) }.ok()
    }
    pub fn stop_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.stop_count) }.ok()
    }
    pub fn clock_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.clock_id) }.ok()
    }
    pub fn nr_topts(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_topts) }.ok()
    }
    pub fn clear_trace(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.clear_trace) }.ok()
    }
    pub fn buffer_percent(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.buffer_percent) }.ok()
    }
    pub fn n_err_log_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.n_err_log_entries) }.ok()
    }
    pub fn current_trace(&self) -> Option<*mut tracer> {
        let v = unsafe { crate::bpf_probe_read(&self.current_trace) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trace_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.trace_flags) }.ok()
    }
    pub fn trace_flags_index(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.trace_flags_index) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn start_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.start_lock) }.ok()
    }
    pub fn err_log(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.err_log) }.ok()
    }
    pub fn dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn options(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.options) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn percpu_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.percpu_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn event_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.event_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn topts(&self) -> Option<*mut trace_options> {
        let v = unsafe { crate::bpf_probe_read(&self.topts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn systems(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.systems) }.ok()
    }
    pub fn events(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn trace_marker_file(&self) -> Option<*mut trace_event_file> {
        let v = unsafe { crate::bpf_probe_read(&self.trace_marker_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tracing_cpumask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.tracing_cpumask) }.ok()
    }
    pub fn ref_(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn trace_ref(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.trace_ref) }.ok()
    }
    pub fn ops(&self) -> Option<*mut ftrace_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn function_pids(&self) -> Option<*mut trace_pid_list> {
        let v = unsafe { crate::bpf_probe_read(&self.function_pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn function_no_pids(&self) -> Option<*mut trace_pid_list> {
        let v = unsafe { crate::bpf_probe_read(&self.function_no_pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func_probes(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.func_probes) }.ok()
    }
    pub fn mod_trace(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mod_trace) }.ok()
    }
    pub fn mod_notrace(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mod_notrace) }.ok()
    }
    pub fn function_enabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.function_enabled) }.ok()
    }
    pub fn time_stamp_abs_ref(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.time_stamp_abs_ref) }.ok()
    }
    pub fn hist_vars(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.hist_vars) }.ok()
    }
    pub fn cond_snapshot(&self) -> Option<*mut cond_snapshot> {
        let v = unsafe { crate::bpf_probe_read(&self.cond_snapshot) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tracer {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn reset(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>> {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn start(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn stop(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>> {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn update_thresh(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update_thresh) }.ok()
    }
    pub fn open(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>> {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn pipe_open(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>> {
        unsafe { crate::bpf_probe_read(&self.pipe_open) }.ok()
    }
    pub fn close(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>> {
        unsafe { crate::bpf_probe_read(&self.close) }.ok()
    }
    pub fn pipe_close(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>> {
        unsafe { crate::bpf_probe_read(&self.pipe_close) }.ok()
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_iterator,
                arg2: *mut file,
                arg3: *mut ::aya_bpf_cty::c_char,
                arg4: size_t,
                arg5: *mut loff_t,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn splice_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_iterator,
                arg2: *mut file,
                arg3: *mut loff_t,
                arg4: *mut pipe_inode_info,
                arg5: size_t,
                arg6: ::aya_bpf_cty::c_uint,
            ) -> ssize_t,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.splice_read) }.ok()
    }
    pub fn print_header(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file)>> {
        unsafe { crate::bpf_probe_read(&self.print_header) }.ok()
    }
    pub fn print_line(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut trace_iterator) -> print_line_t::Type,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.print_line) }.ok()
    }
    pub fn set_flag(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_array,
                arg2: u32_,
                arg3: u32_,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_flag) }.ok()
    }
    pub fn flag_changed(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut trace_array,
                arg2: u32_,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flag_changed) }.ok()
    }
    pub fn next(&self) -> Option<*mut tracer> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<*mut tracer_flags> {
        let v = unsafe { crate::bpf_probe_read(&self.flags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn enabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.enabled) }.ok()
    }
    pub fn print_max(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.print_max) }.ok()
    }
    pub fn allow_instances(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.allow_instances) }.ok()
    }
    pub fn use_max_tr(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.use_max_tr) }.ok()
    }
    pub fn noboot(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.noboot) }.ok()
    }
}
impl trace_subsystem_dir {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn subsystem(&self) -> Option<*mut event_subsystem> {
        let v = unsafe { crate::bpf_probe_read(&self.subsystem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tr(&self) -> Option<*mut trace_array> {
        let v = unsafe { crate::bpf_probe_read(&self.tr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entry(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ref_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ref_count) }.ok()
    }
    pub fn nr_events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_events) }.ok()
    }
}
impl trace_array_cpu {
    pub fn disabled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.disabled) }.ok()
    }
    pub fn buffer_page(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entries(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
    pub fn saved_latency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.saved_latency) }.ok()
    }
    pub fn critical_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.critical_start) }.ok()
    }
    pub fn critical_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.critical_end) }.ok()
    }
    pub fn critical_sequence(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.critical_sequence) }.ok()
    }
    pub fn nice(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nice) }.ok()
    }
    pub fn policy(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.policy) }.ok()
    }
    pub fn rt_priority(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rt_priority) }.ok()
    }
    pub fn skipped_entries(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.skipped_entries) }.ok()
    }
    pub fn preempt_timestamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.preempt_timestamp) }.ok()
    }
    pub fn pid(&self) -> Option<pid_t> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn comm(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.comm) }.ok()
    }
    pub fn ftrace_ignore_pid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ftrace_ignore_pid) }.ok()
    }
    pub fn ignore_pid(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ignore_pid) }.ok()
    }
}
impl trace_options {
    pub fn tracer(&self) -> Option<*mut tracer> {
        let v = unsafe { crate::bpf_probe_read(&self.tracer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn topts(&self) -> Option<*mut trace_option_dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.topts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl trace_option_dentry {
    pub fn opt(&self) -> Option<*mut tracer_opt> {
        let v = unsafe { crate::bpf_probe_read(&self.opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<*mut tracer_flags> {
        let v = unsafe { crate::bpf_probe_read(&self.flags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tr(&self) -> Option<*mut trace_array> {
        let v = unsafe { crate::bpf_probe_read(&self.tr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entry(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.entry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl trace_pid_list {
    pub fn pid_max(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pid_max) }.ok()
    }
    pub fn pids(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.pids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cond_snapshot {
    pub fn cond_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.cond_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn update(&self) -> Option<cond_update_fn_t> {
        unsafe { crate::bpf_probe_read(&self.update) }.ok()
    }
}
impl tracer_opt {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bit) }.ok()
    }
}
impl tracer_flags {
    pub fn val(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn opts(&self) -> Option<*mut tracer_opt> {
        let v = unsafe { crate::bpf_probe_read(&self.opts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trace(&self) -> Option<*mut tracer> {
        let v = unsafe { crate::bpf_probe_read(&self.trace) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl event_subsystem {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter(&self) -> Option<*mut event_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ref_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ref_count) }.ok()
    }
}
impl ring_buffer_iter {
    pub fn cpu_buffer(&self) -> Option<*mut ring_buffer_per_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn head(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn next_event(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.next_event) }.ok()
    }
    pub fn head_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.head_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cache_reader_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.cache_reader_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cache_read(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cache_read) }.ok()
    }
    pub fn read_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.read_stamp) }.ok()
    }
    pub fn page_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.page_stamp) }.ok()
    }
    pub fn event(&self) -> Option<*mut ring_buffer_event> {
        let v = unsafe { crate::bpf_probe_read(&self.event) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn missed_events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.missed_events) }.ok()
    }
}
impl rb_irq_work {
    pub fn work(&self) -> Option<irq_work> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn waiters(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.waiters) }.ok()
    }
    pub fn full_waiters(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.full_waiters) }.ok()
    }
    pub fn waiters_pending(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.waiters_pending) }.ok()
    }
    pub fn full_waiters_pending(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.full_waiters_pending) }.ok()
    }
    pub fn wakeup_full(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.wakeup_full) }.ok()
    }
}
impl trace_buffer___2 {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn cpus(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpus) }.ok()
    }
    pub fn record_disabled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.record_disabled) }.ok()
    }
    pub fn cpumask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
    pub fn reader_lock_key(&self) -> Option<*mut lock_class_key> {
        let v = unsafe { crate::bpf_probe_read(&self.reader_lock_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn buffers(&self) -> Option<*mut *mut ring_buffer_per_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.buffers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn clock(&self) -> Option<::core::option::Option<unsafe extern "C" fn() -> u64_>> {
        unsafe { crate::bpf_probe_read(&self.clock) }.ok()
    }
    pub fn irq_work(&self) -> Option<rb_irq_work> {
        unsafe { crate::bpf_probe_read(&self.irq_work) }.ok()
    }
    pub fn time_stamp_abs(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.time_stamp_abs) }.ok()
    }
}
impl buffer_data_page {
    pub fn time_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time_stamp) }.ok()
    }
    pub fn commit(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.commit) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_uchar>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl buffer_page {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn write(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn read(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn entries(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
    pub fn real_end(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.real_end) }.ok()
    }
    pub fn page(&self) -> Option<*mut buffer_data_page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rb_time_struct {
    pub fn time(&self) -> Option<local64_t> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
}
impl ring_buffer_per_cpu {
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn record_disabled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.record_disabled) }.ok()
    }
    pub fn resize_disabled(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.resize_disabled) }.ok()
    }
    pub fn buffer(&self) -> Option<*mut trace_buffer___2> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reader_lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.reader_lock) }.ok()
    }
    pub fn lock(&self) -> Option<arch_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn lock_key(&self) -> Option<lock_class_key> {
        unsafe { crate::bpf_probe_read(&self.lock_key) }.ok()
    }
    pub fn free_page(&self) -> Option<*mut buffer_data_page> {
        let v = unsafe { crate::bpf_probe_read(&self.free_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_pages(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_pages) }.ok()
    }
    pub fn current_context(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.current_context) }.ok()
    }
    pub fn pages(&self) -> Option<*mut list_head> {
        let v = unsafe { crate::bpf_probe_read(&self.pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn head_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.head_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tail_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.tail_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn commit_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.commit_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reader_page(&self) -> Option<*mut buffer_page> {
        let v = unsafe { crate::bpf_probe_read(&self.reader_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lost_events(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lost_events) }.ok()
    }
    pub fn last_overrun(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_overrun) }.ok()
    }
    pub fn nest(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nest) }.ok()
    }
    pub fn entries_bytes(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.entries_bytes) }.ok()
    }
    pub fn entries(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
    pub fn overrun(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.overrun) }.ok()
    }
    pub fn commit_overrun(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.commit_overrun) }.ok()
    }
    pub fn dropped_events(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.dropped_events) }.ok()
    }
    pub fn committing(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.committing) }.ok()
    }
    pub fn commits(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.commits) }.ok()
    }
    pub fn pages_touched(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.pages_touched) }.ok()
    }
    pub fn pages_read(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.pages_read) }.ok()
    }
    pub fn last_pages_touch(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.last_pages_touch) }.ok()
    }
    pub fn shortest_full(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.shortest_full) }.ok()
    }
    pub fn read(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn read_bytes(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.read_bytes) }.ok()
    }
    pub fn write_stamp(&self) -> Option<rb_time_t> {
        unsafe { crate::bpf_probe_read(&self.write_stamp) }.ok()
    }
    pub fn before_stamp(&self) -> Option<rb_time_t> {
        unsafe { crate::bpf_probe_read(&self.before_stamp) }.ok()
    }
    pub fn read_stamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.read_stamp) }.ok()
    }
    pub fn nr_pages_to_update(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.nr_pages_to_update) }.ok()
    }
    pub fn new_pages(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.new_pages) }.ok()
    }
    pub fn update_pages_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.update_pages_work) }.ok()
    }
    pub fn update_done(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.update_done) }.ok()
    }
    pub fn irq_work(&self) -> Option<rb_irq_work> {
        unsafe { crate::bpf_probe_read(&self.irq_work) }.ok()
    }
}
impl disk_stats {
    pub fn nsecs(&self) -> Option<[u64_; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.nsecs) }.ok()
    }
    pub fn sectors(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.sectors) }.ok()
    }
    pub fn ios(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ios) }.ok()
    }
    pub fn merges(&self) -> Option<[::aya_bpf_cty::c_ulong; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.merges) }.ok()
    }
    pub fn io_ticks(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.io_ticks) }.ok()
    }
    pub fn in_flight(&self) -> Option<[local_t; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.in_flight) }.ok()
    }
}
impl bio_crypt_ctx {
    pub fn bc_key(&self) -> Option<*const blk_crypto_key> {
        let v = unsafe { crate::bpf_probe_read(&self.bc_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bc_dun(&self) -> Option<[u64_; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.bc_dun) }.ok()
    }
}
impl blk_mq_ctx {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lock) }.ok()
    }
    pub fn rq_lists(&self) -> Option<[list_head; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rq_lists) }.ok()
    }
    pub fn cpu(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn index_hw(&self) -> Option<[::aya_bpf_cty::c_ushort; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.index_hw) }.ok()
    }
    pub fn hctxs(&self) -> Option<[*mut blk_mq_hw_ctx; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.hctxs) }.ok()
    }
    pub fn rq_dispatched(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.rq_dispatched) }.ok()
    }
    pub fn rq_merged(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.rq_merged) }.ok()
    }
    pub fn rq_completed(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.rq_completed) }.ok()
    }
    pub fn queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctxs(&self) -> Option<*mut blk_mq_ctxs> {
        let v = unsafe { crate::bpf_probe_read(&self.ctxs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
}
impl blk_mq_ctx__bindgen_ty_1 {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn rq_lists(&self) -> Option<[list_head; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.rq_lists) }.ok()
    }
}
impl sbitmap {
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
    pub fn shift(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.shift) }.ok()
    }
    pub fn map_nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.map_nr) }.ok()
    }
    pub fn map(&self) -> Option<*mut sbitmap_word> {
        let v = unsafe { crate::bpf_probe_read(&self.map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_mq_hw_ctx {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.lock) }.ok()
    }
    pub fn dispatch(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dispatch) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.state) }.ok()
    }
    pub fn run_work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.run_work) }.ok()
    }
    pub fn cpumask(&self) -> Option<cpumask_var_t> {
        unsafe { crate::bpf_probe_read(&self.cpumask) }.ok()
    }
    pub fn next_cpu(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.next_cpu) }.ok()
    }
    pub fn next_cpu_batch(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.next_cpu_batch) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn sched_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fq(&self) -> Option<*mut blk_flush_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.fq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ctx_map(&self) -> Option<sbitmap> {
        unsafe { crate::bpf_probe_read(&self.ctx_map) }.ok()
    }
    pub fn dispatch_from(&self) -> Option<*mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.dispatch_from) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dispatch_busy(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dispatch_busy) }.ok()
    }
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn nr_ctx(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.nr_ctx) }.ok()
    }
    pub fn ctxs(&self) -> Option<*mut *mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.ctxs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dispatch_wait_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.dispatch_wait_lock) }.ok()
    }
    pub fn dispatch_wait(&self) -> Option<wait_queue_entry_t> {
        unsafe { crate::bpf_probe_read(&self.dispatch_wait) }.ok()
    }
    pub fn wait_index(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.wait_index) }.ok()
    }
    pub fn tags(&self) -> Option<*mut blk_mq_tags> {
        let v = unsafe { crate::bpf_probe_read(&self.tags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sched_tags(&self) -> Option<*mut blk_mq_tags> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_tags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queued(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.queued) }.ok()
    }
    pub fn run(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.run) }.ok()
    }
    pub fn dispatched(&self) -> Option<[::aya_bpf_cty::c_ulong; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.dispatched) }.ok()
    }
    pub fn numa_node(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn queue_num(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.queue_num) }.ok()
    }
    pub fn nr_active(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_active) }.ok()
    }
    pub fn elevator_queued(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.elevator_queued) }.ok()
    }
    pub fn cpuhp_online(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.cpuhp_online) }.ok()
    }
    pub fn cpuhp_dead(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.cpuhp_dead) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn poll_considered(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.poll_considered) }.ok()
    }
    pub fn poll_invoked(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.poll_invoked) }.ok()
    }
    pub fn poll_success(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.poll_success) }.ok()
    }
    pub fn debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sched_debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.sched_debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hctx_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.hctx_list) }.ok()
    }
    pub fn srcu(&self) -> Option<__IncompleteArrayField<srcu_struct>> {
        unsafe { crate::bpf_probe_read(&self.srcu) }.ok()
    }
}
impl blk_mq_hw_ctx__bindgen_ty_1 {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn dispatch(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dispatch) }.ok()
    }
    pub fn state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
}
impl blk_mq_alloc_data {
    pub fn q(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<blk_mq_req_flags_t> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn shallow_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.shallow_depth) }.ok()
    }
    pub fn cmd_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cmd_flags) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hctx(&self) -> Option<*mut blk_mq_hw_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.hctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_stat_callback {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn cpu_stat(&self) -> Option<*mut blk_rq_stat> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_stat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bucket_fn(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *const request) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.bucket_fn) }.ok()
    }
    pub fn buckets(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.buckets) }.ok()
    }
    pub fn stat(&self) -> Option<*mut blk_rq_stat> {
        let v = unsafe { crate::bpf_probe_read(&self.stat) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn timer_fn(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_stat_callback)>> {
        unsafe { crate::bpf_probe_read(&self.timer_fn) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl blk_trace {
    pub fn trace_state(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.trace_state) }.ok()
    }
    pub fn rchan(&self) -> Option<*mut rchan> {
        let v = unsafe { crate::bpf_probe_read(&self.rchan) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sequence(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.sequence) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_data(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn act_mask(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.act_mask) }.ok()
    }
    pub fn start_lba(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.start_lba) }.ok()
    }
    pub fn end_lba(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.end_lba) }.ok()
    }
    pub fn pid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn dev(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dropped_file(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.dropped_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn msg_file(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.msg_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn running_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.running_list) }.ok()
    }
    pub fn dropped(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dropped) }.ok()
    }
}
impl blk_flush_queue {
    pub fn rq_status(&self) -> Option<blk_status_t> {
        unsafe { crate::bpf_probe_read(&self.rq_status) }.ok()
    }
    pub fn flush_pending_since(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flush_pending_since) }.ok()
    }
    pub fn flush_queue(&self) -> Option<[list_head; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.flush_queue) }.ok()
    }
    pub fn flush_data_in_flight(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flush_data_in_flight) }.ok()
    }
    pub fn flush_rq(&self) -> Option<*mut request> {
        let v = unsafe { crate::bpf_probe_read(&self.flush_rq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mq_flush_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mq_flush_lock) }.ok()
    }
}
impl blk_mq_queue_map {
    pub fn mq_map(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.mq_map) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_queues) }.ok()
    }
    pub fn queue_offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.queue_offset) }.ok()
    }
}
impl sbitmap_queue {
    pub fn sb(&self) -> Option<sbitmap> {
        unsafe { crate::bpf_probe_read(&self.sb) }.ok()
    }
    pub fn alloc_hint(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.alloc_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wake_batch(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.wake_batch) }.ok()
    }
    pub fn wake_index(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.wake_index) }.ok()
    }
    pub fn ws(&self) -> Option<*mut sbq_wait_state> {
        let v = unsafe { crate::bpf_probe_read(&self.ws) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ws_active(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.ws_active) }.ok()
    }
    pub fn round_robin(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.round_robin) }.ok()
    }
    pub fn min_shallow_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.min_shallow_depth) }.ok()
    }
}
impl blk_mq_tag_set {
    pub fn map(&self) -> Option<[blk_mq_queue_map; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn nr_maps(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_maps) }.ok()
    }
    pub fn ops(&self) -> Option<*const blk_mq_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_hw_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_hw_queues) }.ok()
    }
    pub fn queue_depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.queue_depth) }.ok()
    }
    pub fn reserved_tags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reserved_tags) }.ok()
    }
    pub fn cmd_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cmd_size) }.ok()
    }
    pub fn numa_node(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.numa_node) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn driver_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn active_queues_shared_sbitmap(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.active_queues_shared_sbitmap) }.ok()
    }
    pub fn __bitmap_tags(&self) -> Option<sbitmap_queue> {
        unsafe { crate::bpf_probe_read(&self.__bitmap_tags) }.ok()
    }
    pub fn __breserved_tags(&self) -> Option<sbitmap_queue> {
        unsafe { crate::bpf_probe_read(&self.__breserved_tags) }.ok()
    }
    pub fn tags(&self) -> Option<*mut *mut blk_mq_tags> {
        let v = unsafe { crate::bpf_probe_read(&self.tags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tag_list_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.tag_list_lock) }.ok()
    }
    pub fn tag_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tag_list) }.ok()
    }
}
impl sbitmap_word {
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
    pub fn word(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.word) }.ok()
    }
    pub fn cleared(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cleared) }.ok()
    }
}
impl sbq_wait_state {
    pub fn wait_cnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.wait_cnt) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl blk_mq_tags {
    pub fn nr_tags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_tags) }.ok()
    }
    pub fn nr_reserved_tags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_reserved_tags) }.ok()
    }
    pub fn active_queues(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.active_queues) }.ok()
    }
    pub fn bitmap_tags(&self) -> Option<*mut sbitmap_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.bitmap_tags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn breserved_tags(&self) -> Option<*mut sbitmap_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.breserved_tags) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __bitmap_tags(&self) -> Option<sbitmap_queue> {
        unsafe { crate::bpf_probe_read(&self.__bitmap_tags) }.ok()
    }
    pub fn __breserved_tags(&self) -> Option<sbitmap_queue> {
        unsafe { crate::bpf_probe_read(&self.__breserved_tags) }.ok()
    }
    pub fn rqs(&self) -> Option<*mut *mut request> {
        let v = unsafe { crate::bpf_probe_read(&self.rqs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn static_rqs(&self) -> Option<*mut *mut request> {
        let v = unsafe { crate::bpf_probe_read(&self.static_rqs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn page_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.page_list) }.ok()
    }
}
impl blk_mq_queue_data {
    pub fn rq(&self) -> Option<*mut request> {
        let v = unsafe { crate::bpf_probe_read(&self.rq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn last(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.last) }.ok()
    }
}
impl blk_crypto_config {
    pub fn crypto_mode(&self) -> Option<blk_crypto_mode_num::Type> {
        unsafe { crate::bpf_probe_read(&self.crypto_mode) }.ok()
    }
    pub fn data_unit_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.data_unit_size) }.ok()
    }
    pub fn dun_bytes(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dun_bytes) }.ok()
    }
}
impl blk_crypto_key {
    pub fn crypto_cfg(&self) -> Option<blk_crypto_config> {
        unsafe { crate::bpf_probe_read(&self.crypto_cfg) }.ok()
    }
    pub fn data_unit_size_bits(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.data_unit_size_bits) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn raw(&self) -> Option<[u8_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.raw) }.ok()
    }
}
impl blk_mq_ctxs {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn queue_ctx(&self) -> Option<*mut blk_mq_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.queue_ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ftrace_event_field {
    pub fn link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn filter_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.filter_type) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn is_signed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.is_signed) }.ok()
    }
}
impl prog_entry {
    pub fn target(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.target) }.ok()
    }
    pub fn when_to_branch(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.when_to_branch) }.ok()
    }
    pub fn pred(&self) -> Option<*mut filter_pred> {
        let v = unsafe { crate::bpf_probe_read(&self.pred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl regex {
    pub fn pattern(&self) -> Option<[::aya_bpf_cty::c_char; 256usize]> {
        unsafe { crate::bpf_probe_read(&self.pattern) }.ok()
    }
    pub fn len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn field_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.field_len) }.ok()
    }
    pub fn match_(&self) -> Option<regex_match_func> {
        unsafe { crate::bpf_probe_read(&self.match_) }.ok()
    }
}
impl filter_pred {
    pub fn fn_(&self) -> Option<filter_pred_fn_t> {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
    pub fn val(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn regex(&self) -> Option<regex> {
        unsafe { crate::bpf_probe_read(&self.regex) }.ok()
    }
    pub fn ops(&self) -> Option<*mut ::aya_bpf_cty::c_ushort> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn field(&self) -> Option<*mut ftrace_event_field> {
        let v = unsafe { crate::bpf_probe_read(&self.field) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn not(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.not) }.ok()
    }
    pub fn op(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.op) }.ok()
    }
}
impl bpf_perf_event_value {
    pub fn counter(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.counter) }.ok()
    }
    pub fn enabled(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.enabled) }.ok()
    }
    pub fn running(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.running) }.ok()
    }
}
impl btf_ptr {
    pub fn ptr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_id) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl bpf_local_storage_map {
    pub fn map(&self) -> Option<bpf_map> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn buckets(&self) -> Option<*mut bpf_local_storage_map_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.buckets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bucket_log(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bucket_log) }.ok()
    }
    pub fn elem_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.elem_size) }.ok()
    }
    pub fn cache_idx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cache_idx) }.ok()
    }
}
impl bpf_local_storage {
    pub fn cache(&self) -> Option<[*mut bpf_local_storage_data; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.cache) }.ok()
    }
    pub fn list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn owner(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl bpf_func_proto {
    pub fn func(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: u64_,
                arg2: u64_,
                arg3: u64_,
                arg4: u64_,
                arg5: u64_,
            ) -> u64_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn gpl_only(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.gpl_only) }.ok()
    }
    pub fn pkt_access(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.pkt_access) }.ok()
    }
    pub fn ret_type(&self) -> Option<bpf_return_type::Type> {
        unsafe { crate::bpf_probe_read(&self.ret_type) }.ok()
    }
    pub fn arg1_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.arg1_type) }.ok()
    }
    pub fn arg2_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.arg2_type) }.ok()
    }
    pub fn arg3_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.arg3_type) }.ok()
    }
    pub fn arg4_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.arg4_type) }.ok()
    }
    pub fn arg5_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.arg5_type) }.ok()
    }
    pub fn arg_type(&self) -> Option<[bpf_arg_type::Type; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg_type) }.ok()
    }
    pub fn arg1_btf_id(&self) -> Option<*mut u32_> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.arg1_btf_id) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg2_btf_id(&self) -> Option<*mut u32_> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.arg2_btf_id) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg3_btf_id(&self) -> Option<*mut u32_> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.arg3_btf_id) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg4_btf_id(&self) -> Option<*mut u32_> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.arg4_btf_id) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg5_btf_id(&self) -> Option<*mut u32_> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.__bindgen_anon_1.arg5_btf_id) }
                .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg_btf_id(&self) -> Option<[*mut u32_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.arg_btf_id) }.ok()
    }
    pub fn ret_btf_id(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.ret_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn allowed(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_prog) -> bool_>> {
        unsafe { crate::bpf_probe_read(&self.allowed) }.ok()
    }
}
impl bpf_func_proto__bindgen_ty_1 {
    pub fn arg1_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg1_type) }.ok()
    }
    pub fn arg2_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg2_type) }.ok()
    }
    pub fn arg3_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg3_type) }.ok()
    }
    pub fn arg4_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg4_type) }.ok()
    }
    pub fn arg5_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg5_type) }.ok()
    }
    pub fn arg_type(&self) -> Option<[bpf_arg_type::Type; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.arg_type) }.ok()
    }
}
impl bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    pub fn arg1_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.arg1_type) }.ok()
    }
    pub fn arg2_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.arg2_type) }.ok()
    }
    pub fn arg3_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.arg3_type) }.ok()
    }
    pub fn arg4_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.arg4_type) }.ok()
    }
    pub fn arg5_type(&self) -> Option<bpf_arg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.arg5_type) }.ok()
    }
}
impl bpf_func_proto__bindgen_ty_2 {
    pub fn arg1_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg1_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg2_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg2_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg3_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg3_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg4_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg4_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg5_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.arg5_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg_btf_id(&self) -> Option<[*mut u32_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.arg_btf_id) }.ok()
    }
}
impl bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    pub fn arg1_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.arg1_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg2_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.arg2_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg3_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.arg3_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg4_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.arg4_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg5_btf_id(&self) -> Option<*mut u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.arg5_btf_id) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_insn_access_aux {
    pub fn reg_type(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.reg_type) }.ok()
    }
    pub fn ctx_field_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ctx_field_size) }.ok()
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn log(&self) -> Option<*mut bpf_verifier_log> {
        let v = unsafe { crate::bpf_probe_read(&self.log) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_insn_access_aux__bindgen_ty_1 {
    pub fn ctx_field_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ctx_field_size) }.ok()
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_id) }.ok()
    }
}
impl bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
}
impl bpf_verifier_ops {
    pub fn get_func_proto(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: bpf_func_id::Type,
                arg2: *const bpf_prog,
            ) -> *const bpf_func_proto,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_func_proto) }.ok()
    }
    pub fn is_valid_access(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_bpf_cty::c_int,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bpf_access_type::Type,
                arg4: *const bpf_prog,
                arg5: *mut bpf_insn_access_aux,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.is_valid_access) }.ok()
    }
    pub fn gen_prologue(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_insn,
                arg2: bool_,
                arg3: *const bpf_prog,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.gen_prologue) }.ok()
    }
    pub fn gen_ld_abs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const bpf_insn,
                arg2: *mut bpf_insn,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.gen_ld_abs) }.ok()
    }
    pub fn convert_ctx_access(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: bpf_access_type::Type,
                arg2: *const bpf_insn,
                arg3: *mut bpf_insn,
                arg4: *mut bpf_prog,
                arg5: *mut u32_,
            ) -> u32_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.convert_ctx_access) }.ok()
    }
    pub fn btf_struct_access(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_verifier_log,
                arg2: *const btf,
                arg3: *const btf_type,
                arg4: ::aya_bpf_cty::c_int,
                arg5: ::aya_bpf_cty::c_int,
                arg6: bpf_access_type::Type,
                arg7: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.btf_struct_access) }.ok()
    }
}
impl bpf_perf_event_data {
    pub fn regs(&self) -> Option<bpf_user_pt_regs_t> {
        unsafe { crate::bpf_probe_read(&self.regs) }.ok()
    }
    pub fn sample_period(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.sample_period) }.ok()
    }
    pub fn addr(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
}
impl bpf_local_storage_map_bucket {
    pub fn list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn lock(&self) -> Option<raw_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl bpf_local_storage_data {
    pub fn smap(&self) -> Option<*mut bpf_local_storage_map> {
        let v = unsafe { crate::bpf_probe_read(&self.smap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl uprobe_consumer {
    pub fn handler(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut uprobe_consumer,
                arg2: *mut pt_regs,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.handler) }.ok()
    }
    pub fn ret_handler(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut uprobe_consumer,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut pt_regs,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ret_handler) }.ok()
    }
    pub fn filter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut uprobe_consumer,
                arg2: uprobe_filter_ctx::Type,
                arg3: *mut mm_struct,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.filter) }.ok()
    }
    pub fn next(&self) -> Option<*mut uprobe_consumer> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bucket_table {
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn nest(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nest) }.ok()
    }
    pub fn hash_rnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.hash_rnd) }.ok()
    }
    pub fn walkers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.walkers) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn future_tbl(&self) -> Option<*mut bucket_table> {
        let v = unsafe { crate::bpf_probe_read(&self.future_tbl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dep_map(&self) -> Option<lockdep_map> {
        unsafe { crate::bpf_probe_read(&self.dep_map) }.ok()
    }
    pub fn buckets(&self) -> Option<__IncompleteArrayField<*mut rhash_lock_head>> {
        unsafe { crate::bpf_probe_read(&self.buckets) }.ok()
    }
}
impl rhash_lock_head {}
impl bpf_map_info {
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn key_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.key_size) }.ok()
    }
    pub fn value_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.value_size) }.ok()
    }
    pub fn max_entries(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_entries) }.ok()
    }
    pub fn map_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.map_flags) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn btf_vmlinux_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_vmlinux_value_type_id) }.ok()
    }
    pub fn netns_dev(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.netns_dev) }.ok()
    }
    pub fn netns_ino(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.netns_ino) }.ok()
    }
    pub fn btf_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
    pub fn btf_key_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_key_type_id) }.ok()
    }
    pub fn btf_value_type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.btf_value_type_id) }.ok()
    }
}
impl bpf_spin_lock {
    pub fn val(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl bpf_verifier_log {
    pub fn level(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn kbuf(&self) -> Option<[::aya_bpf_cty::c_char; 1024usize]> {
        unsafe { crate::bpf_probe_read(&self.kbuf) }.ok()
    }
    pub fn ubuf(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.ubuf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn len_used(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.len_used) }.ok()
    }
    pub fn len_total(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.len_total) }.ok()
    }
}
impl bpf_subprog_info {
    pub fn start(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn linfo_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.linfo_idx) }.ok()
    }
    pub fn stack_depth(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.stack_depth) }.ok()
    }
    pub fn has_tail_call(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_tail_call) }.ok()
    }
    pub fn tail_call_reachable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tail_call_reachable) }.ok()
    }
    pub fn has_ld_abs(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_ld_abs) }.ok()
    }
}
impl bpf_verifier_env {
    pub fn insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.insn_idx) }.ok()
    }
    pub fn prev_insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prev_insn_idx) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const bpf_verifier_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn head(&self) -> Option<*mut bpf_verifier_stack_elem> {
        let v = unsafe { crate::bpf_probe_read(&self.head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stack_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.stack_size) }.ok()
    }
    pub fn strict_alignment(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.strict_alignment) }.ok()
    }
    pub fn test_state_freq(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.test_state_freq) }.ok()
    }
    pub fn cur_state(&self) -> Option<*mut bpf_verifier_state> {
        let v = unsafe { crate::bpf_probe_read(&self.cur_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn explored_states(&self) -> Option<*mut *mut bpf_verifier_state_list> {
        let v = unsafe { crate::bpf_probe_read(&self.explored_states) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn free_list(&self) -> Option<*mut bpf_verifier_state_list> {
        let v = unsafe { crate::bpf_probe_read(&self.free_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn used_maps(&self) -> Option<[*mut bpf_map; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.used_maps) }.ok()
    }
    pub fn used_map_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.used_map_cnt) }.ok()
    }
    pub fn id_gen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id_gen) }.ok()
    }
    pub fn allow_ptr_leaks(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.allow_ptr_leaks) }.ok()
    }
    pub fn allow_uninit_stack(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.allow_uninit_stack) }.ok()
    }
    pub fn allow_ptr_to_map_access(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.allow_ptr_to_map_access) }.ok()
    }
    pub fn bpf_capable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bpf_capable) }.ok()
    }
    pub fn bypass_spec_v1(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bypass_spec_v1) }.ok()
    }
    pub fn bypass_spec_v4(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bypass_spec_v4) }.ok()
    }
    pub fn seen_direct_write(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.seen_direct_write) }.ok()
    }
    pub fn insn_aux_data(&self) -> Option<*mut bpf_insn_aux_data> {
        let v = unsafe { crate::bpf_probe_read(&self.insn_aux_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn prev_linfo(&self) -> Option<*const bpf_line_info> {
        let v = unsafe { crate::bpf_probe_read(&self.prev_linfo) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn log(&self) -> Option<bpf_verifier_log> {
        unsafe { crate::bpf_probe_read(&self.log) }.ok()
    }
    pub fn subprog_info(&self) -> Option<[bpf_subprog_info; 257usize]> {
        unsafe { crate::bpf_probe_read(&self.subprog_info) }.ok()
    }
    pub fn cfg(&self) -> Option<bpf_verifier_env__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.cfg) }.ok()
    }
    pub fn pass_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pass_cnt) }.ok()
    }
    pub fn subprog_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.subprog_cnt) }.ok()
    }
    pub fn prev_insn_processed(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prev_insn_processed) }.ok()
    }
    pub fn insn_processed(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.insn_processed) }.ok()
    }
    pub fn prev_jmps_processed(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prev_jmps_processed) }.ok()
    }
    pub fn jmps_processed(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.jmps_processed) }.ok()
    }
    pub fn verification_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.verification_time) }.ok()
    }
    pub fn max_states_per_insn(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_states_per_insn) }.ok()
    }
    pub fn total_states(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.total_states) }.ok()
    }
    pub fn peak_states(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.peak_states) }.ok()
    }
    pub fn longest_mark_read_walk(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.longest_mark_read_walk) }.ok()
    }
}
impl bpf_verifier_env__bindgen_ty_1 {
    pub fn insn_state(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.insn_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn insn_stack(&self) -> Option<*mut ::aya_bpf_cty::c_int> {
        let v = unsafe { crate::bpf_probe_read(&self.insn_stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cur_stack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cur_stack) }.ok()
    }
}
impl tnum {
    pub fn value(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.value) }.ok()
    }
    pub fn mask(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
}
impl bpf_reg_state {
    pub fn type_(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn off(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.off) }.ok()
    }
    pub fn range(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.range) }.ok()
    }
    pub fn map_ptr(&self) -> Option<*mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn mem_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mem_size) }.ok()
    }
    pub fn raw(&self) -> Option<bpf_reg_state__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.raw) }.ok()
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn ref_obj_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ref_obj_id) }.ok()
    }
    pub fn var_off(&self) -> Option<tnum> {
        unsafe { crate::bpf_probe_read(&self.var_off) }.ok()
    }
    pub fn smin_value(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.smin_value) }.ok()
    }
    pub fn smax_value(&self) -> Option<s64> {
        unsafe { crate::bpf_probe_read(&self.smax_value) }.ok()
    }
    pub fn umin_value(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.umin_value) }.ok()
    }
    pub fn umax_value(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.umax_value) }.ok()
    }
    pub fn s32_min_value(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.s32_min_value) }.ok()
    }
    pub fn s32_max_value(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.s32_max_value) }.ok()
    }
    pub fn u32_min_value(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.u32_min_value) }.ok()
    }
    pub fn u32_max_value(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.u32_max_value) }.ok()
    }
    pub fn parent(&self) -> Option<*mut bpf_reg_state> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frameno(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.frameno) }.ok()
    }
    pub fn subreg_def(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.subreg_def) }.ok()
    }
    pub fn live(&self) -> Option<bpf_reg_liveness::Type> {
        unsafe { crate::bpf_probe_read(&self.live) }.ok()
    }
    pub fn precise(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.precise) }.ok()
    }
}
impl bpf_reg_state__bindgen_ty_1 {
    pub fn range(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.range) }.ok()
    }
    pub fn map_ptr(&self) -> Option<*mut bpf_map> {
        let v = unsafe { crate::bpf_probe_read(&self.map_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn mem_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mem_size) }.ok()
    }
    pub fn raw(&self) -> Option<bpf_reg_state__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.raw) }.ok()
    }
}
impl bpf_reg_state__bindgen_ty_1__bindgen_ty_1 {
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
}
impl bpf_reg_state__bindgen_ty_1__bindgen_ty_2 {
    pub fn raw1(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.raw1) }.ok()
    }
    pub fn raw2(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.raw2) }.ok()
    }
}
impl bpf_stack_state {
    pub fn spilled_ptr(&self) -> Option<bpf_reg_state> {
        unsafe { crate::bpf_probe_read(&self.spilled_ptr) }.ok()
    }
    pub fn slot_type(&self) -> Option<[u8_; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.slot_type) }.ok()
    }
}
impl bpf_reference_state {
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn insn_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.insn_idx) }.ok()
    }
}
impl bpf_func_state {
    pub fn regs(&self) -> Option<[bpf_reg_state; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.regs) }.ok()
    }
    pub fn callsite(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.callsite) }.ok()
    }
    pub fn frameno(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.frameno) }.ok()
    }
    pub fn subprogno(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.subprogno) }.ok()
    }
    pub fn acquired_refs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.acquired_refs) }.ok()
    }
    pub fn refs(&self) -> Option<*mut bpf_reference_state> {
        let v = unsafe { crate::bpf_probe_read(&self.refs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn allocated_stack(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.allocated_stack) }.ok()
    }
    pub fn stack(&self) -> Option<*mut bpf_stack_state> {
        let v = unsafe { crate::bpf_probe_read(&self.stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_idx_pair {
    pub fn prev_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prev_idx) }.ok()
    }
    pub fn idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.idx) }.ok()
    }
}
impl bpf_verifier_state {
    pub fn frame(&self) -> Option<[*mut bpf_func_state; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.frame) }.ok()
    }
    pub fn parent(&self) -> Option<*mut bpf_verifier_state> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn branches(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.branches) }.ok()
    }
    pub fn insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.insn_idx) }.ok()
    }
    pub fn curframe(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.curframe) }.ok()
    }
    pub fn active_spin_lock(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.active_spin_lock) }.ok()
    }
    pub fn speculative(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.speculative) }.ok()
    }
    pub fn first_insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.first_insn_idx) }.ok()
    }
    pub fn last_insn_idx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_insn_idx) }.ok()
    }
    pub fn jmp_history(&self) -> Option<*mut bpf_idx_pair> {
        let v = unsafe { crate::bpf_probe_read(&self.jmp_history) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn jmp_history_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.jmp_history_cnt) }.ok()
    }
}
impl bpf_verifier_state_list {
    pub fn state(&self) -> Option<bpf_verifier_state> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn next(&self) -> Option<*mut bpf_verifier_state_list> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn miss_cnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.miss_cnt) }.ok()
    }
    pub fn hit_cnt(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.hit_cnt) }.ok()
    }
}
impl bpf_insn_aux_data {
    pub fn ptr_type(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ptr_type) }.ok()
    }
    pub fn map_ptr_state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_ptr_state) }.ok()
    }
    pub fn call_imm(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.call_imm) }.ok()
    }
    pub fn alu_limit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.alu_limit) }.ok()
    }
    pub fn map_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.map_index) }.ok()
    }
    pub fn map_off(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.map_off) }.ok()
    }
    pub fn btf_var(&self) -> Option<bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_var) }.ok()
    }
    pub fn map_key_state(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.map_key_state) }.ok()
    }
    pub fn ctx_field_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ctx_field_size) }.ok()
    }
    pub fn sanitize_stack_off(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sanitize_stack_off) }.ok()
    }
    pub fn seen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seen) }.ok()
    }
    pub fn zext_dst(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.zext_dst) }.ok()
    }
    pub fn alu_state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.alu_state) }.ok()
    }
    pub fn orig_idx(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.orig_idx) }.ok()
    }
    pub fn prune_point(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.prune_point) }.ok()
    }
}
impl bpf_insn_aux_data__bindgen_ty_1 {
    pub fn ptr_type(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.ptr_type) }.ok()
    }
    pub fn map_ptr_state(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.map_ptr_state) }.ok()
    }
    pub fn call_imm(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.call_imm) }.ok()
    }
    pub fn alu_limit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.alu_limit) }.ok()
    }
    pub fn map_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_index) }.ok()
    }
    pub fn map_off(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.map_off) }.ok()
    }
    pub fn btf_var(&self) -> Option<bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.btf_var) }.ok()
    }
}
impl bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_1 {
    pub fn map_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.map_index) }.ok()
    }
    pub fn map_off(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.map_off) }.ok()
    }
}
impl bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2 {
    pub fn reg_type(&self) -> Option<bpf_reg_type::Type> {
        unsafe { crate::bpf_probe_read(&self.reg_type) }.ok()
    }
    pub fn btf(&self) -> Option<*mut btf> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn mem_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mem_size) }.ok()
    }
}
impl bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.btf_id) }.ok()
    }
    pub fn mem_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mem_size) }.ok()
    }
}
impl bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub fn btf(&self) -> Option<*mut btf> {
        let v = unsafe { crate::bpf_probe_read(&self.btf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn btf_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.btf_id) }.ok()
    }
}
impl bpf_verifier_stack_elem {
    pub fn st(&self) -> Option<bpf_verifier_state> {
        unsafe { crate::bpf_probe_read(&self.st) }.ok()
    }
    pub fn insn_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.insn_idx) }.ok()
    }
    pub fn prev_insn_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.prev_insn_idx) }.ok()
    }
    pub fn next(&self) -> Option<*mut bpf_verifier_stack_elem> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn log_pos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.log_pos) }.ok()
    }
}
impl bpf_pidns_info {
    pub fn pid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pid) }.ok()
    }
    pub fn tgid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tgid) }.ok()
    }
}
impl bpf_cgroup_storage_map {
    pub fn map(&self) -> Option<bpf_map> {
        unsafe { crate::bpf_probe_read(&self.map) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.root) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl bpf_flow_keys {
    pub fn nhoff(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.nhoff) }.ok()
    }
    pub fn thoff(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.thoff) }.ok()
    }
    pub fn addr_proto(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.addr_proto) }.ok()
    }
    pub fn is_frag(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.is_frag) }.ok()
    }
    pub fn is_first_frag(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.is_first_frag) }.ok()
    }
    pub fn is_encap(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.is_encap) }.ok()
    }
    pub fn ip_proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ip_proto) }.ok()
    }
    pub fn n_proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.n_proto) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
    pub fn ipv4_src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ipv4_src) }.ok()
    }
    pub fn ipv4_dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ipv4_dst) }.ok()
    }
    pub fn ipv6_src(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.ipv6_src) }.ok()
    }
    pub fn ipv6_dst(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.ipv6_dst) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn flow_label(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.flow_label) }.ok()
    }
}
impl bpf_flow_keys__bindgen_ty_1 {
    pub fn ipv4_src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv4_src) }.ok()
    }
    pub fn ipv4_dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv4_dst) }.ok()
    }
    pub fn ipv6_src(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ipv6_src) }.ok()
    }
    pub fn ipv6_dst(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ipv6_dst) }.ok()
    }
}
impl bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
    pub fn ipv4_src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4_src) }.ok()
    }
    pub fn ipv4_dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4_dst) }.ok()
    }
}
impl bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
    pub fn ipv6_src(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ipv6_src) }.ok()
    }
    pub fn ipv6_dst(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ipv6_dst) }.ok()
    }
}
impl bpf_sock {
    pub fn bound_dev_if(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bound_dev_if) }.ok()
    }
    pub fn family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn src_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.src_ip4) }.ok()
    }
    pub fn src_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.src_ip6) }.ok()
    }
    pub fn src_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.src_port) }.ok()
    }
    pub fn dst_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dst_port) }.ok()
    }
    pub fn dst_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dst_ip4) }.ok()
    }
    pub fn dst_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.dst_ip6) }.ok()
    }
    pub fn state(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn rx_queue_mapping(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.rx_queue_mapping) }.ok()
    }
}
impl __sk_buff {
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn pkt_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pkt_type) }.ok()
    }
    pub fn mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn queue_mapping(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.queue_mapping) }.ok()
    }
    pub fn protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn vlan_present(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vlan_present) }.ok()
    }
    pub fn vlan_tci(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vlan_tci) }.ok()
    }
    pub fn vlan_proto(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vlan_proto) }.ok()
    }
    pub fn priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn ingress_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ingress_ifindex) }.ok()
    }
    pub fn ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn tc_index(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tc_index) }.ok()
    }
    pub fn cb(&self) -> Option<[__u32; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.cb) }.ok()
    }
    pub fn hash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn tc_classid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tc_classid) }.ok()
    }
    pub fn data(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn data_end(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_end) }.ok()
    }
    pub fn napi_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.napi_id) }.ok()
    }
    pub fn family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn remote_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_ip4) }.ok()
    }
    pub fn local_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_ip4) }.ok()
    }
    pub fn remote_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_ip6) }.ok()
    }
    pub fn local_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.local_ip6) }.ok()
    }
    pub fn remote_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_port) }.ok()
    }
    pub fn local_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_port) }.ok()
    }
    pub fn data_meta(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_meta) }.ok()
    }
    pub fn flow_keys(&self) -> Option<*mut bpf_flow_keys> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.flow_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tstamp(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.tstamp) }.ok()
    }
    pub fn wire_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.wire_len) }.ok()
    }
    pub fn gso_segs(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.gso_segs) }.ok()
    }
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn gso_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.gso_size) }.ok()
    }
}
impl __sk_buff__bindgen_ty_1 {
    pub fn flow_keys(&self) -> Option<*mut bpf_flow_keys> {
        let v = unsafe { crate::bpf_probe_read(&self.flow_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl __sk_buff__bindgen_ty_2 {
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xdp_md {
    pub fn data(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn data_end(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_end) }.ok()
    }
    pub fn data_meta(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_meta) }.ok()
    }
    pub fn ingress_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ingress_ifindex) }.ok()
    }
    pub fn rx_queue_index(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_queue_index) }.ok()
    }
    pub fn egress_ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.egress_ifindex) }.ok()
    }
}
impl sk_msg_md {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn remote_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_ip4) }.ok()
    }
    pub fn local_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_ip4) }.ok()
    }
    pub fn remote_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_ip6) }.ok()
    }
    pub fn local_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.local_ip6) }.ok()
    }
    pub fn remote_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_port) }.ok()
    }
    pub fn local_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_port) }.ok()
    }
    pub fn size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_msg_md__bindgen_ty_1 {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_msg_md__bindgen_ty_2 {
    pub fn data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_msg_md__bindgen_ty_3 {
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_reuseport_md {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn eth_protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.eth_protocol) }.ok()
    }
    pub fn ip_protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ip_protocol) }.ok()
    }
    pub fn bind_inany(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bind_inany) }.ok()
    }
    pub fn hash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
}
impl sk_reuseport_md__bindgen_ty_1 {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl sk_reuseport_md__bindgen_ty_2 {
    pub fn data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sock_addr {
    pub fn user_family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.user_family) }.ok()
    }
    pub fn user_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.user_ip4) }.ok()
    }
    pub fn user_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.user_ip6) }.ok()
    }
    pub fn user_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.user_port) }.ok()
    }
    pub fn family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn protocol(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn msg_src_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.msg_src_ip4) }.ok()
    }
    pub fn msg_src_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.msg_src_ip6) }.ok()
    }
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sock_addr__bindgen_ty_1 {
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sock_ops {
    pub fn op(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.op) }.ok()
    }
    pub fn args(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.args) }.ok()
    }
    pub fn reply(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.reply) }.ok()
    }
    pub fn replylong(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.replylong) }.ok()
    }
    pub fn family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn remote_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_ip4) }.ok()
    }
    pub fn local_ip4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_ip4) }.ok()
    }
    pub fn remote_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_ip6) }.ok()
    }
    pub fn local_ip6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.local_ip6) }.ok()
    }
    pub fn remote_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_port) }.ok()
    }
    pub fn local_port(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.local_port) }.ok()
    }
    pub fn is_fullsock(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.is_fullsock) }.ok()
    }
    pub fn snd_cwnd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd) }.ok()
    }
    pub fn srtt_us(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.srtt_us) }.ok()
    }
    pub fn bpf_sock_ops_cb_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bpf_sock_ops_cb_flags) }.ok()
    }
    pub fn state(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn rtt_min(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rtt_min) }.ok()
    }
    pub fn snd_ssthresh(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_ssthresh) }.ok()
    }
    pub fn rcv_nxt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rcv_nxt) }.ok()
    }
    pub fn snd_nxt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_nxt) }.ok()
    }
    pub fn snd_una(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_una) }.ok()
    }
    pub fn mss_cache(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mss_cache) }.ok()
    }
    pub fn ecn_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ecn_flags) }.ok()
    }
    pub fn rate_delivered(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rate_delivered) }.ok()
    }
    pub fn rate_interval_us(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rate_interval_us) }.ok()
    }
    pub fn packets_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.packets_out) }.ok()
    }
    pub fn retrans_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.retrans_out) }.ok()
    }
    pub fn total_retrans(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.total_retrans) }.ok()
    }
    pub fn segs_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.segs_in) }.ok()
    }
    pub fn data_segs_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_segs_in) }.ok()
    }
    pub fn segs_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.segs_out) }.ok()
    }
    pub fn data_segs_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_segs_out) }.ok()
    }
    pub fn lost_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.lost_out) }.ok()
    }
    pub fn sacked_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sacked_out) }.ok()
    }
    pub fn sk_txhash(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sk_txhash) }.ok()
    }
    pub fn bytes_received(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes_received) }.ok()
    }
    pub fn bytes_acked(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes_acked) }.ok()
    }
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.skb_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb_data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.skb_data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.skb_len) }.ok()
    }
    pub fn skb_tcp_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.skb_tcp_flags) }.ok()
    }
}
impl bpf_sock_ops__bindgen_ty_1 {
    pub fn args(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.args) }.ok()
    }
    pub fn reply(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reply) }.ok()
    }
    pub fn replylong(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.replylong) }.ok()
    }
}
impl bpf_sock_ops__bindgen_ty_2 {
    pub fn sk(&self) -> Option<*mut bpf_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sock_ops__bindgen_ty_3 {
    pub fn skb_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.skb_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sock_ops__bindgen_ty_4 {
    pub fn skb_data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.skb_data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_sysctl {
    pub fn write(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn file_pos(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.file_pos) }.ok()
    }
}
impl inet_listen_hashbucket {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn head(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.head) }.ok()
    }
    pub fn nulls_head(&self) -> Option<hlist_nulls_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nulls_head) }.ok()
    }
}
impl inet_listen_hashbucket__bindgen_ty_1 {
    pub fn head(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn nulls_head(&self) -> Option<hlist_nulls_head> {
        unsafe { crate::bpf_probe_read(&self.nulls_head) }.ok()
    }
}
impl inet_hashinfo {
    pub fn ehash(&self) -> Option<*mut inet_ehash_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.ehash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ehash_locks(&self) -> Option<*mut spinlock_t> {
        let v = unsafe { crate::bpf_probe_read(&self.ehash_locks) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ehash_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ehash_mask) }.ok()
    }
    pub fn ehash_locks_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ehash_locks_mask) }.ok()
    }
    pub fn bind_bucket_cachep(&self) -> Option<*mut kmem_cache> {
        let v = unsafe { crate::bpf_probe_read(&self.bind_bucket_cachep) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bhash(&self) -> Option<*mut inet_bind_hashbucket> {
        let v = unsafe { crate::bpf_probe_read(&self.bhash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bhash_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bhash_size) }.ok()
    }
    pub fn lhash2_mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.lhash2_mask) }.ok()
    }
    pub fn lhash2(&self) -> Option<*mut inet_listen_hashbucket> {
        let v = unsafe { crate::bpf_probe_read(&self.lhash2) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn listening_hash(&self) -> Option<[inet_listen_hashbucket; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.listening_hash) }.ok()
    }
}
impl ip_ra_chain {
    pub fn next(&self) -> Option<*mut ip_ra_chain> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.destructor) }.ok()
    }
    pub fn saved_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.saved_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ip_ra_chain__bindgen_ty_1 {
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
    pub fn saved_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.saved_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fib_table {
    pub fn tb_hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.tb_hlist) }.ok()
    }
    pub fn tb_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tb_id) }.ok()
    }
    pub fn tb_num_default(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tb_num_default) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn tb_data(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.tb_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_ulong>> {
        unsafe { crate::bpf_probe_read(&self.__data) }.ok()
    }
}
impl inet_peer_base {
    pub fn rb_root(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.rb_root) }.ok()
    }
    pub fn lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn total(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.total) }.ok()
    }
}
impl tcp_fastopen_context {
    pub fn key(&self) -> Option<[siphash_key_t; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn num(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.num) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl xdp_txq_info {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xdp_buff {
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_end(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_end) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_meta(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_meta) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_hard_start(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data_hard_start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rxq(&self) -> Option<*mut xdp_rxq_info> {
        let v = unsafe { crate::bpf_probe_read(&self.rxq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn txq(&self) -> Option<*mut xdp_txq_info> {
        let v = unsafe { crate::bpf_probe_read(&self.txq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn frame_sz(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.frame_sz) }.ok()
    }
}
impl sock_reuseport {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn max_socks(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_socks) }.ok()
    }
    pub fn num_socks(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.num_socks) }.ok()
    }
    pub fn synq_overflow_ts(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.synq_overflow_ts) }.ok()
    }
    pub fn reuseport_id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reuseport_id) }.ok()
    }
    pub fn prog(&self) -> Option<*mut bpf_prog> {
        let v = unsafe { crate::bpf_probe_read(&self.prog) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn socks(&self) -> Option<__IncompleteArrayField<*mut sock>> {
        unsafe { crate::bpf_probe_read(&self.socks) }.ok()
    }
}
impl inet_ehash_bucket {
    pub fn chain(&self) -> Option<hlist_nulls_head> {
        unsafe { crate::bpf_probe_read(&self.chain) }.ok()
    }
}
impl inet_bind_hashbucket {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn chain(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.chain) }.ok()
    }
}
impl ack_sample {
    pub fn pkts_acked(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pkts_acked) }.ok()
    }
    pub fn rtt_us(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.rtt_us) }.ok()
    }
    pub fn in_flight(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.in_flight) }.ok()
    }
}
impl rate_sample {
    pub fn prior_mstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.prior_mstamp) }.ok()
    }
    pub fn prior_delivered(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prior_delivered) }.ok()
    }
    pub fn delivered(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.delivered) }.ok()
    }
    pub fn interval_us(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.interval_us) }.ok()
    }
    pub fn snd_interval_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_interval_us) }.ok()
    }
    pub fn rcv_interval_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_interval_us) }.ok()
    }
    pub fn rtt_us(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.rtt_us) }.ok()
    }
    pub fn losses(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.losses) }.ok()
    }
    pub fn acked_sacked(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.acked_sacked) }.ok()
    }
    pub fn prior_in_flight(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prior_in_flight) }.ok()
    }
    pub fn is_app_limited(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_app_limited) }.ok()
    }
    pub fn is_retrans(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_retrans) }.ok()
    }
    pub fn is_ack_delayed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_ack_delayed) }.ok()
    }
}
impl xdp_dev_bulk_queue {
    pub fn q(&self) -> Option<[*mut xdp_frame; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.q) }.ok()
    }
    pub fn flush_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.flush_node) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_rx(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev_rx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl netdev_notifier_info {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.extack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl bpf_prog_offload_ops {
    pub fn insn_hook(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_verifier_env,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.insn_hook) }.ok()
    }
    pub fn finalize(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut bpf_verifier_env) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.finalize) }.ok()
    }
    pub fn replace_insn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_verifier_env,
                arg2: u32_,
                arg3: *mut bpf_insn,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.replace_insn) }.ok()
    }
    pub fn remove_insns(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut bpf_verifier_env,
                arg2: u32_,
                arg3: u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.remove_insns) }.ok()
    }
    pub fn prepare(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.prepare) }.ok()
    }
    pub fn translate(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.translate) }.ok()
    }
    pub fn destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog)>> {
        unsafe { crate::bpf_probe_read(&self.destroy) }.ok()
    }
}
impl bpf_offload_dev {
    pub fn ops(&self) -> Option<*const bpf_prog_offload_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdevs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.netdevs) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xfrm_sec_ctx {
    pub fn ctx_doi(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ctx_doi) }.ok()
    }
    pub fn ctx_alg(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ctx_alg) }.ok()
    }
    pub fn ctx_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.ctx_len) }.ok()
    }
    pub fn ctx_sid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ctx_sid) }.ok()
    }
    pub fn ctx_str(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.ctx_str) }.ok()
    }
}
impl perf_buffer {
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn nr_pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_pages) }.ok()
    }
    pub fn overwrite(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.overwrite) }.ok()
    }
    pub fn paused(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.paused) }.ok()
    }
    pub fn poll(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn head(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn nest(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nest) }.ok()
    }
    pub fn events(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.events) }.ok()
    }
    pub fn wakeup(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.wakeup) }.ok()
    }
    pub fn lost(&self) -> Option<local_t> {
        unsafe { crate::bpf_probe_read(&self.lost) }.ok()
    }
    pub fn watermark(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.watermark) }.ok()
    }
    pub fn aux_watermark(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.aux_watermark) }.ok()
    }
    pub fn event_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.event_lock) }.ok()
    }
    pub fn event_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.event_list) }.ok()
    }
    pub fn mmap_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.mmap_count) }.ok()
    }
    pub fn mmap_locked(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_locked) }.ok()
    }
    pub fn mmap_user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mmap_user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aux_head(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.aux_head) }.ok()
    }
    pub fn aux_nest(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.aux_nest) }.ok()
    }
    pub fn aux_wakeup(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.aux_wakeup) }.ok()
    }
    pub fn aux_pgoff(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.aux_pgoff) }.ok()
    }
    pub fn aux_nr_pages(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.aux_nr_pages) }.ok()
    }
    pub fn aux_overwrite(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.aux_overwrite) }.ok()
    }
    pub fn aux_mmap_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.aux_mmap_count) }.ok()
    }
    pub fn aux_mmap_locked(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.aux_mmap_locked) }.ok()
    }
    pub fn free_aux(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.free_aux) }.ok()
    }
    pub fn aux_refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.aux_refcount) }.ok()
    }
    pub fn aux_in_sampling(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.aux_in_sampling) }.ok()
    }
    pub fn aux_pages(&self) -> Option<*mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.aux_pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aux_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.aux_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn user_page(&self) -> Option<*mut perf_event_mmap_page> {
        let v = unsafe { crate::bpf_probe_read(&self.user_page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_pages(&self) -> Option<__IncompleteArrayField<*mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.data_pages) }.ok()
    }
}
impl uprobe {
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()
    }
    pub fn ref_(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.ref_) }.ok()
    }
    pub fn register_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.register_rwsem) }.ok()
    }
    pub fn consumer_rwsem(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.consumer_rwsem) }.ok()
    }
    pub fn pending_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pending_list) }.ok()
    }
    pub fn consumers(&self) -> Option<*mut uprobe_consumer> {
        let v = unsafe { crate::bpf_probe_read(&self.consumers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offset(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn ref_ctr_offset(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.ref_ctr_offset) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn arch(&self) -> Option<arch_uprobe> {
        unsafe { crate::bpf_probe_read(&self.arch) }.ok()
    }
}
impl xol_area {
    pub fn wq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wq) }.ok()
    }
    pub fn slot_count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.slot_count) }.ok()
    }
    pub fn bitmap(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.bitmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xol_mapping(&self) -> Option<vm_special_mapping> {
        unsafe { crate::bpf_probe_read(&self.xol_mapping) }.ok()
    }
    pub fn pages(&self) -> Option<[*mut page; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.pages) }.ok()
    }
    pub fn vaddr(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.vaddr) }.ok()
    }
}
impl capture_control {
    pub fn cc(&self) -> Option<*mut compact_control> {
        let v = unsafe { crate::bpf_probe_read(&self.cc) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl compact_control {
    pub fn freepages(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.freepages) }.ok()
    }
    pub fn migratepages(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.migratepages) }.ok()
    }
    pub fn nr_freepages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_freepages) }.ok()
    }
    pub fn nr_migratepages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_migratepages) }.ok()
    }
    pub fn free_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.free_pfn) }.ok()
    }
    pub fn migrate_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.migrate_pfn) }.ok()
    }
    pub fn fast_start_pfn(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fast_start_pfn) }.ok()
    }
    pub fn zone(&self) -> Option<*mut zone> {
        let v = unsafe { crate::bpf_probe_read(&self.zone) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn total_migrate_scanned(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_migrate_scanned) }.ok()
    }
    pub fn total_free_scanned(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_free_scanned) }.ok()
    }
    pub fn fast_search_fail(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.fast_search_fail) }.ok()
    }
    pub fn search_order(&self) -> Option<::aya_bpf_cty::c_short> {
        unsafe { crate::bpf_probe_read(&self.search_order) }.ok()
    }
    pub fn gfp_mask(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.gfp_mask) }.ok()
    }
    pub fn order(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.order) }.ok()
    }
    pub fn migratetype(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.migratetype) }.ok()
    }
    pub fn alloc_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alloc_flags) }.ok()
    }
    pub fn highest_zoneidx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.highest_zoneidx) }.ok()
    }
    pub fn mode(&self) -> Option<migrate_mode::Type> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn ignore_skip_hint(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ignore_skip_hint) }.ok()
    }
    pub fn no_set_skip_hint(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.no_set_skip_hint) }.ok()
    }
    pub fn ignore_block_suitable(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ignore_block_suitable) }.ok()
    }
    pub fn direct_compaction(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.direct_compaction) }.ok()
    }
    pub fn proactive_compaction(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.proactive_compaction) }.ok()
    }
    pub fn whole_zone(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.whole_zone) }.ok()
    }
    pub fn contended(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.contended) }.ok()
    }
    pub fn rescan(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.rescan) }.ok()
    }
    pub fn alloc_contig(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.alloc_contig) }.ok()
    }
}
impl static_key_mod {
    pub fn next(&self) -> Option<*mut static_key_mod> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entries(&self) -> Option<*mut jump_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mod_(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.mod_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl watch_list {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn watchers(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.watchers) }.ok()
    }
    pub fn release_watch(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut watch)>> {
        unsafe { crate::bpf_probe_read(&self.release_watch) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl watch_type_filter {
    pub fn type_(&self) -> Option<watch_notification_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn subtype_filter(&self) -> Option<[__u32; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.subtype_filter) }.ok()
    }
    pub fn info_filter(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.info_filter) }.ok()
    }
    pub fn info_mask(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.info_mask) }.ok()
    }
}
impl watch_filter {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn type_filter(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.type_filter) }.ok()
    }
    pub fn nr_filters(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nr_filters) }.ok()
    }
    pub fn filters(&self) -> Option<__IncompleteArrayField<watch_type_filter>> {
        unsafe { crate::bpf_probe_read(&self.filters) }.ok()
    }
}
impl watch_filter__bindgen_ty_1 {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn type_filter(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.type_filter) }.ok()
    }
}
impl watch_queue {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn filter(&self) -> Option<*mut watch_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pipe(&self) -> Option<*mut pipe_inode_info> {
        let v = unsafe { crate::bpf_probe_read(&self.pipe) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn watches(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.watches) }.ok()
    }
    pub fn notes(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.notes) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn notes_bitmap(&self) -> Option<*mut ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.notes_bitmap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn usage(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn nr_notes(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_notes) }.ok()
    }
    pub fn nr_pages(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_pages) }.ok()
    }
    pub fn defunct(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.defunct) }.ok()
    }
}
impl watch {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rcu) }.ok()
    }
    pub fn info_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.info_id) }.ok()
    }
    pub fn queue(&self) -> Option<*mut watch_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queue_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.queue_node) }.ok()
    }
    pub fn watch_list(&self) -> Option<*mut watch_list> {
        let v = unsafe { crate::bpf_probe_read(&self.watch_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.list_node) }.ok()
    }
    pub fn cred(&self) -> Option<*const cred> {
        let v = unsafe { crate::bpf_probe_read(&self.cred) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn private(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn usage(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
}
impl watch__bindgen_ty_1 {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn info_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.info_id) }.ok()
    }
}
impl fid {
    pub fn i32_(&self) -> Option<__BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_1>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.i32_) }.ok()
    }
    pub fn udf(&self) -> Option<__BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_2>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.udf) }.ok()
    }
    pub fn raw(&self) -> Option<__BindgenUnionField<[__u32; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.raw) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u32; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bindgen_union_field) }.ok()
    }
}
impl fid__bindgen_ty_1 {
    pub fn i32_(&self) -> Option<__BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_1>> {
        unsafe { crate::bpf_probe_read(&self.i32_) }.ok()
    }
    pub fn udf(&self) -> Option<__BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_2>> {
        unsafe { crate::bpf_probe_read(&self.udf) }.ok()
    }
    pub fn raw(&self) -> Option<__BindgenUnionField<[__u32; 0usize]>> {
        unsafe { crate::bpf_probe_read(&self.raw) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u32; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl fid__bindgen_ty_1__bindgen_ty_1 {
    pub fn ino(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ino) }.ok()
    }
    pub fn gen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.gen) }.ok()
    }
    pub fn parent_ino(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.parent_ino) }.ok()
    }
    pub fn parent_gen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.parent_gen) }.ok()
    }
}
impl fid__bindgen_ty_1__bindgen_ty_2 {
    pub fn block(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.block) }.ok()
    }
    pub fn partref(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.partref) }.ok()
    }
    pub fn parent_partref(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.parent_partref) }.ok()
    }
    pub fn generation(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.generation) }.ok()
    }
    pub fn parent_block(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.parent_block) }.ok()
    }
    pub fn parent_generation(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.parent_generation) }.ok()
    }
}
impl reciprocal_value {
    pub fn m(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.m) }.ok()
    }
    pub fn sh1(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sh1) }.ok()
    }
    pub fn sh2(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sh2) }.ok()
    }
}
impl kmem_cache_order_objects {
    pub fn x(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.x) }.ok()
    }
}
impl kmem_cache {
    pub fn cpu_slab(&self) -> Option<*mut kmem_cache_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_slab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<slab_flags_t> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn min_partial(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.min_partial) }.ok()
    }
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn object_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.object_size) }.ok()
    }
    pub fn reciprocal_size(&self) -> Option<reciprocal_value> {
        unsafe { crate::bpf_probe_read(&self.reciprocal_size) }.ok()
    }
    pub fn offset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn cpu_partial(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cpu_partial) }.ok()
    }
    pub fn oo(&self) -> Option<kmem_cache_order_objects> {
        unsafe { crate::bpf_probe_read(&self.oo) }.ok()
    }
    pub fn max(&self) -> Option<kmem_cache_order_objects> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn min(&self) -> Option<kmem_cache_order_objects> {
        unsafe { crate::bpf_probe_read(&self.min) }.ok()
    }
    pub fn allocflags(&self) -> Option<gfp_t> {
        unsafe { crate::bpf_probe_read(&self.allocflags) }.ok()
    }
    pub fn refcount(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn ctor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.ctor) }.ok()
    }
    pub fn inuse(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.inuse) }.ok()
    }
    pub fn align(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.align) }.ok()
    }
    pub fn red_left_pad(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.red_left_pad) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn random(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.random) }.ok()
    }
    pub fn remote_node_defrag_ratio(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.remote_node_defrag_ratio) }.ok()
    }
    pub fn random_seq(&self) -> Option<*mut ::aya_bpf_cty::c_uint> {
        let v = unsafe { crate::bpf_probe_read(&self.random_seq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn useroffset(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.useroffset) }.ok()
    }
    pub fn usersize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.usersize) }.ok()
    }
    pub fn node(&self) -> Option<[*mut kmem_cache_node; 1024usize]> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
}
impl kmem_cache_cpu {
    pub fn freelist(&self) -> Option<*mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.freelist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tid(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tid) }.ok()
    }
    pub fn page(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn partial(&self) -> Option<*mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.partial) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kmem_cache_node {
    pub fn list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.list_lock) }.ok()
    }
    pub fn nr_partial(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.nr_partial) }.ok()
    }
    pub fn partial(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.partial) }.ok()
    }
    pub fn nr_slabs(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.nr_slabs) }.ok()
    }
    pub fn total_objects(&self) -> Option<atomic_long_t> {
        unsafe { crate::bpf_probe_read(&self.total_objects) }.ok()
    }
    pub fn full(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.full) }.ok()
    }
}
impl simple_xattrs {
    pub fn head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl crypto_async_request {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn complete(&self) -> Option<crypto_completion_t> {
        unsafe { crate::bpf_probe_read(&self.complete) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tfm(&self) -> Option<*mut crypto_tfm> {
        let v = unsafe { crate::bpf_probe_read(&self.tfm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl mmu_notifier_subscriptions {
    pub fn list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn has_itree(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_itree) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn invalidate_seq(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.invalidate_seq) }.ok()
    }
    pub fn active_invalidate_ranges(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.active_invalidate_ranges) }.ok()
    }
    pub fn itree(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.itree) }.ok()
    }
    pub fn wq(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wq) }.ok()
    }
    pub fn deferred_list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.deferred_list) }.ok()
    }
}
impl fscrypt_policy_v1 {
    pub fn version(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn contents_encryption_mode(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.contents_encryption_mode) }.ok()
    }
    pub fn filenames_encryption_mode(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.filenames_encryption_mode) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn master_key_descriptor(&self) -> Option<[__u8; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.master_key_descriptor) }.ok()
    }
}
impl fscrypt_policy_v2 {
    pub fn version(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn contents_encryption_mode(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.contents_encryption_mode) }.ok()
    }
    pub fn filenames_encryption_mode(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.filenames_encryption_mode) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn __reserved(&self) -> Option<[__u8; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__reserved) }.ok()
    }
    pub fn master_key_identifier(&self) -> Option<[__u8; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.master_key_identifier) }.ok()
    }
}
impl fscrypt_policy {
    pub fn version(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn v1(&self) -> Option<fscrypt_policy_v1> {
        unsafe { crate::bpf_probe_read(&self.v1) }.ok()
    }
    pub fn v2(&self) -> Option<fscrypt_policy_v2> {
        unsafe { crate::bpf_probe_read(&self.v2) }.ok()
    }
}
impl mnt_namespace {
    pub fn ns(&self) -> Option<ns_common> {
        unsafe { crate::bpf_probe_read(&self.ns) }.ok()
    }
    pub fn root(&self) -> Option<*mut mount> {
        let v = unsafe { crate::bpf_probe_read(&self.root) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn ns_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.ns_lock) }.ok()
    }
    pub fn user_ns(&self) -> Option<*mut user_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.user_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ucounts(&self) -> Option<*mut ucounts> {
        let v = unsafe { crate::bpf_probe_read(&self.ucounts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn poll(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn event(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn mounts(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mounts) }.ok()
    }
    pub fn pending_mounts(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.pending_mounts) }.ok()
    }
}
impl mount {
    pub fn mnt_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.mnt_hash) }.ok()
    }
    pub fn mnt_parent(&self) -> Option<*mut mount> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_mountpoint(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_mountpoint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt(&self) -> Option<vfsmount> {
        unsafe { crate::bpf_probe_read(&self.mnt) }.ok()
    }
    pub fn mnt_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mnt_rcu) }.ok()
    }
    pub fn mnt_llist(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mnt_llist) }.ok()
    }
    pub fn mnt_pcp(&self) -> Option<*mut mnt_pcp> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_pcp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_mounts(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_mounts) }.ok()
    }
    pub fn mnt_child(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_child) }.ok()
    }
    pub fn mnt_instance(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_instance) }.ok()
    }
    pub fn mnt_devname(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_devname) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_list) }.ok()
    }
    pub fn mnt_expire(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_expire) }.ok()
    }
    pub fn mnt_share(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_share) }.ok()
    }
    pub fn mnt_slave_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_slave_list) }.ok()
    }
    pub fn mnt_slave(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_slave) }.ok()
    }
    pub fn mnt_master(&self) -> Option<*mut mount> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_master) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_ns(&self) -> Option<*mut mnt_namespace> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_ns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_mp(&self) -> Option<*mut mountpoint> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_mp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_mp_list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.mnt_mp_list) }.ok()
    }
    pub fn mnt_umount(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.mnt_umount) }.ok()
    }
    pub fn mnt_umounting(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_umounting) }.ok()
    }
    pub fn mnt_fsnotify_marks(&self) -> Option<*mut fsnotify_mark_connector> {
        let v = unsafe { crate::bpf_probe_read(&self.mnt_fsnotify_marks) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mnt_fsnotify_mask(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mnt_fsnotify_mask) }.ok()
    }
    pub fn mnt_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_id) }.ok()
    }
    pub fn mnt_group_id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_group_id) }.ok()
    }
    pub fn mnt_expiry_mark(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_expiry_mark) }.ok()
    }
    pub fn mnt_pins(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_pins) }.ok()
    }
    pub fn mnt_stuck_children(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_stuck_children) }.ok()
    }
}
impl mount__bindgen_ty_1 {
    pub fn mnt_rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.mnt_rcu) }.ok()
    }
    pub fn mnt_llist(&self) -> Option<llist_node> {
        unsafe { crate::bpf_probe_read(&self.mnt_llist) }.ok()
    }
}
impl mount__bindgen_ty_2 {
    pub fn mnt_mp_list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.mnt_mp_list) }.ok()
    }
    pub fn mnt_umount(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.mnt_umount) }.ok()
    }
}
impl mnt_pcp {
    pub fn mnt_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_count) }.ok()
    }
    pub fn mnt_writers(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mnt_writers) }.ok()
    }
}
impl mountpoint {
    pub fn m_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.m_hash) }.ok()
    }
    pub fn m_dentry(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.m_dentry) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn m_list(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.m_list) }.ok()
    }
    pub fn m_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.m_count) }.ok()
    }
}
impl saved {
    pub fn link(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn done(&self) -> Option<delayed_call> {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
}
impl nameidata {
    pub fn path(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.path) }.ok()
    }
    pub fn last(&self) -> Option<qstr> {
        unsafe { crate::bpf_probe_read(&self.last) }.ok()
    }
    pub fn root(&self) -> Option<path> {
        unsafe { crate::bpf_probe_read(&self.root) }.ok()
    }
    pub fn inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn m_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.m_seq) }.ok()
    }
    pub fn r_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.r_seq) }.ok()
    }
    pub fn last_type(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.last_type) }.ok()
    }
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
    pub fn total_link_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.total_link_count) }.ok()
    }
    pub fn stack(&self) -> Option<*mut saved> {
        let v = unsafe { crate::bpf_probe_read(&self.stack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn internal(&self) -> Option<[saved; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.internal) }.ok()
    }
    pub fn name(&self) -> Option<*mut filename> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saved(&self) -> Option<*mut nameidata> {
        let v = unsafe { crate::bpf_probe_read(&self.saved) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn root_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.root_seq) }.ok()
    }
    pub fn dfd(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dfd) }.ok()
    }
    pub fn dir_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.dir_uid) }.ok()
    }
    pub fn dir_mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.dir_mode) }.ok()
    }
}
impl fiemap_extent_info {
    pub fn fi_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fi_flags) }.ok()
    }
    pub fn fi_extents_mapped(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fi_extents_mapped) }.ok()
    }
    pub fn fi_extents_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fi_extents_max) }.ok()
    }
    pub fn fi_extents_start(&self) -> Option<*mut fiemap_extent> {
        let v = unsafe { crate::bpf_probe_read(&self.fi_extents_start) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fiemap_extent {
    pub fn fe_logical(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.fe_logical) }.ok()
    }
    pub fn fe_physical(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.fe_physical) }.ok()
    }
    pub fn fe_length(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.fe_length) }.ok()
    }
    pub fn fe_reserved64(&self) -> Option<[__u64; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.fe_reserved64) }.ok()
    }
    pub fn fe_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fe_flags) }.ok()
    }
    pub fn fe_reserved(&self) -> Option<[__u32; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.fe_reserved) }.ok()
    }
}
impl unicode_map {
    pub fn charset(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.charset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn version(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
}
impl proc_dir_entry {
    pub fn in_use(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.in_use) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn pde_openers(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pde_openers) }.ok()
    }
    pub fn pde_unload_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.pde_unload_lock) }.ok()
    }
    pub fn pde_unload_completion(&self) -> Option<*mut completion> {
        let v = unsafe { crate::bpf_probe_read(&self.pde_unload_completion) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_iops(&self) -> Option<*const inode_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_iops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_ops(&self) -> Option<*const proc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.proc_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_dir_ops(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.proc_dir_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_dops(&self) -> Option<*const dentry_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_dops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq_ops(&self) -> Option<*const seq_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.seq_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn single_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.single_show) }.ok()
    }
    pub fn write(&self) -> Option<proc_write_t> {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.state_size) }.ok()
    }
    pub fn low_ino(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.low_ino) }.ok()
    }
    pub fn nlink(&self) -> Option<nlink_t> {
        unsafe { crate::bpf_probe_read(&self.nlink) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.gid) }.ok()
    }
    pub fn size(&self) -> Option<loff_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn parent(&self) -> Option<*mut proc_dir_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn subdir(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.subdir) }.ok()
    }
    pub fn subdir_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.subdir_node) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mode(&self) -> Option<umode_t> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn namelen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.namelen) }.ok()
    }
    pub fn inline_name(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.inline_name) }.ok()
    }
}
impl proc_dir_entry__bindgen_ty_1 {
    pub fn proc_ops(&self) -> Option<*const proc_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proc_dir_ops(&self) -> Option<*const file_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.proc_dir_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl proc_dir_entry__bindgen_ty_2 {
    pub fn seq_ops(&self) -> Option<*const seq_operations> {
        let v = unsafe { crate::bpf_probe_read(&self.seq_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn single_show(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.single_show) }.ok()
    }
}
impl userfaultfd_ctx {
    pub fn fault_pending_wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.fault_pending_wqh) }.ok()
    }
    pub fn fault_wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.fault_wqh) }.ok()
    }
    pub fn fd_wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.fd_wqh) }.ok()
    }
    pub fn event_wqh(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.event_wqh) }.ok()
    }
    pub fn refile_seq(&self) -> Option<seqcount_spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.refile_seq) }.ok()
    }
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn features(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.features) }.ok()
    }
    pub fn state(&self) -> Option<userfaultfd_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn released(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.released) }.ok()
    }
    pub fn mmap_changing(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.mmap_changing) }.ok()
    }
    pub fn mm(&self) -> Option<*mut mm_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.mm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl kioctx_table {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn nr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr) }.ok()
    }
    pub fn table(&self) -> Option<__IncompleteArrayField<*mut kioctx>> {
        unsafe { crate::bpf_probe_read(&self.table) }.ok()
    }
}
impl kioctx {
    pub fn users(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn dead(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn reqs(&self) -> Option<percpu_ref> {
        unsafe { crate::bpf_probe_read(&self.reqs) }.ok()
    }
    pub fn user_id(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.user_id) }.ok()
    }
    pub fn cpu(&self) -> Option<*mut kioctx_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn req_batch(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.req_batch) }.ok()
    }
    pub fn max_reqs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_reqs) }.ok()
    }
    pub fn nr_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_events) }.ok()
    }
    pub fn mmap_base(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_base) }.ok()
    }
    pub fn mmap_size(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mmap_size) }.ok()
    }
    pub fn ring_pages(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.ring_pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_pages(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.nr_pages) }.ok()
    }
    pub fn free_rwork(&self) -> Option<rcu_work> {
        unsafe { crate::bpf_probe_read(&self.free_rwork) }.ok()
    }
    pub fn rq_wait(&self) -> Option<*mut ctx_rq_wait> {
        let v = unsafe { crate::bpf_probe_read(&self.rq_wait) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reqs_available(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.reqs_available) }.ok()
    }
    pub fn ctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ctx_lock) }.ok()
    }
    pub fn active_reqs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.active_reqs) }.ok()
    }
    pub fn ring_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.ring_lock) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.wait) }.ok()
    }
    pub fn tail(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.tail) }.ok()
    }
    pub fn completed_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.completed_events) }.ok()
    }
    pub fn completion_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_4.completion_lock) }.ok()
    }
    pub fn internal_pages(&self) -> Option<[*mut page; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.internal_pages) }.ok()
    }
    pub fn aio_ring_file(&self) -> Option<*mut file> {
        let v = unsafe { crate::bpf_probe_read(&self.aio_ring_file) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
}
impl kioctx__bindgen_ty_1 {
    pub fn reqs_available(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.reqs_available) }.ok()
    }
}
impl kioctx__bindgen_ty_2 {
    pub fn ctx_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.ctx_lock) }.ok()
    }
    pub fn active_reqs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.active_reqs) }.ok()
    }
}
impl kioctx__bindgen_ty_3 {
    pub fn ring_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.ring_lock) }.ok()
    }
    pub fn wait(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.wait) }.ok()
    }
}
impl kioctx__bindgen_ty_4 {
    pub fn tail(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tail) }.ok()
    }
    pub fn completed_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.completed_events) }.ok()
    }
    pub fn completion_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.completion_lock) }.ok()
    }
}
impl kioctx_cpu {
    pub fn reqs_available(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reqs_available) }.ok()
    }
}
impl ctx_rq_wait {
    pub fn comp(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.comp) }.ok()
    }
    pub fn count(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
}
impl fscrypt_prepared_key {
    pub fn tfm(&self) -> Option<*mut crypto_skcipher> {
        let v = unsafe { crate::bpf_probe_read(&self.tfm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blk_key(&self) -> Option<*mut fscrypt_blk_crypto_key> {
        let v = unsafe { crate::bpf_probe_read(&self.blk_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fscrypt_info {
    pub fn ci_enc_key(&self) -> Option<fscrypt_prepared_key> {
        unsafe { crate::bpf_probe_read(&self.ci_enc_key) }.ok()
    }
    pub fn ci_owns_key(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ci_owns_key) }.ok()
    }
    pub fn ci_inlinecrypt(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ci_inlinecrypt) }.ok()
    }
    pub fn ci_mode(&self) -> Option<*mut fscrypt_mode> {
        let v = unsafe { crate::bpf_probe_read(&self.ci_mode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ci_inode(&self) -> Option<*mut inode> {
        let v = unsafe { crate::bpf_probe_read(&self.ci_inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ci_master_key(&self) -> Option<*mut key> {
        let v = unsafe { crate::bpf_probe_read(&self.ci_master_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ci_master_key_link(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ci_master_key_link) }.ok()
    }
    pub fn ci_direct_key(&self) -> Option<*mut fscrypt_direct_key> {
        let v = unsafe { crate::bpf_probe_read(&self.ci_direct_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ci_dirhash_key(&self) -> Option<siphash_key_t> {
        unsafe { crate::bpf_probe_read(&self.ci_dirhash_key) }.ok()
    }
    pub fn ci_dirhash_key_initialized(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ci_dirhash_key_initialized) }.ok()
    }
    pub fn ci_policy(&self) -> Option<fscrypt_policy> {
        unsafe { crate::bpf_probe_read(&self.ci_policy) }.ok()
    }
    pub fn ci_nonce(&self) -> Option<[u8_; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ci_nonce) }.ok()
    }
    pub fn ci_hashed_ino(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ci_hashed_ino) }.ok()
    }
}
impl crypto_skcipher {
    pub fn reqsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reqsize) }.ok()
    }
    pub fn base(&self) -> Option<crypto_tfm> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
}
impl fscrypt_mode {
    pub fn friendly_name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.friendly_name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cipher_str(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.cipher_str) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn keysize(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.keysize) }.ok()
    }
    pub fn ivsize(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ivsize) }.ok()
    }
    pub fn logged_impl_name(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.logged_impl_name) }.ok()
    }
    pub fn blk_crypto_mode(&self) -> Option<blk_crypto_mode_num::Type> {
        unsafe { crate::bpf_probe_read(&self.blk_crypto_mode) }.ok()
    }
}
impl fscrypt_direct_key {
    pub fn dk_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.dk_node) }.ok()
    }
    pub fn dk_refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.dk_refcount) }.ok()
    }
    pub fn dk_mode(&self) -> Option<*const fscrypt_mode> {
        let v = unsafe { crate::bpf_probe_read(&self.dk_mode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dk_key(&self) -> Option<fscrypt_prepared_key> {
        unsafe { crate::bpf_probe_read(&self.dk_key) }.ok()
    }
    pub fn dk_descriptor(&self) -> Option<[u8_; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.dk_descriptor) }.ok()
    }
    pub fn dk_raw(&self) -> Option<[u8_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.dk_raw) }.ok()
    }
}
impl fscrypt_blk_crypto_key {
    pub fn base(&self) -> Option<blk_crypto_key> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
    pub fn num_devs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.num_devs) }.ok()
    }
    pub fn devs(&self) -> Option<__IncompleteArrayField<*mut request_queue>> {
        unsafe { crate::bpf_probe_read(&self.devs) }.ok()
    }
}
impl merkle_tree_params {
    pub fn hash_alg(&self) -> Option<*mut fsverity_hash_alg> {
        let v = unsafe { crate::bpf_probe_read(&self.hash_alg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hashstate(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.hashstate) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn digest_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.digest_size) }.ok()
    }
    pub fn block_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.block_size) }.ok()
    }
    pub fn hashes_per_block(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hashes_per_block) }.ok()
    }
    pub fn log_blocksize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.log_blocksize) }.ok()
    }
    pub fn log_arity(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.log_arity) }.ok()
    }
    pub fn num_levels(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_levels) }.ok()
    }
    pub fn tree_size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tree_size) }.ok()
    }
    pub fn level0_blocks(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.level0_blocks) }.ok()
    }
    pub fn level_start(&self) -> Option<[u64_; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.level_start) }.ok()
    }
}
impl fsverity_info {
    pub fn tree_params(&self) -> Option<merkle_tree_params> {
        unsafe { crate::bpf_probe_read(&self.tree_params) }.ok()
    }
    pub fn root_hash(&self) -> Option<[u8_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.root_hash) }.ok()
    }
    pub fn file_digest(&self) -> Option<[u8_; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.file_digest) }.ok()
    }
    pub fn inode(&self) -> Option<*const inode> {
        let v = unsafe { crate::bpf_probe_read(&self.inode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fsverity_hash_alg {
    pub fn tfm(&self) -> Option<*mut crypto_ahash> {
        let v = unsafe { crate::bpf_probe_read(&self.tfm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn digest_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.digest_size) }.ok()
    }
    pub fn block_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.block_size) }.ok()
    }
    pub fn req_pool(&self) -> Option<mempool_t> {
        unsafe { crate::bpf_probe_read(&self.req_pool) }.ok()
    }
}
impl crypto_ahash {
    pub fn init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update) }.ok()
    }
    pub fn final_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.final_) }.ok()
    }
    pub fn finup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.finup) }.ok()
    }
    pub fn digest(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.digest) }.ok()
    }
    pub fn export(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ahash_request,
                arg2: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.export) }.ok()
    }
    pub fn import(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ahash_request,
                arg2: *const ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.import) }.ok()
    }
    pub fn setkey(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crypto_ahash,
                arg2: *const u8_,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setkey) }.ok()
    }
    pub fn reqsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reqsize) }.ok()
    }
    pub fn base(&self) -> Option<crypto_tfm> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
}
impl ahash_request {
    pub fn base(&self) -> Option<crypto_async_request> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
    pub fn nbytes(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nbytes) }.ok()
    }
    pub fn src(&self) -> Option<*mut scatterlist> {
        let v = unsafe { crate::bpf_probe_read(&self.src) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn result(&self) -> Option<*mut u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.result) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __ctx(&self) -> Option<__IncompleteArrayField<*mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.__ctx) }.ok()
    }
}
impl kernfs_iattrs {
    pub fn ia_uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.ia_uid) }.ok()
    }
    pub fn ia_gid(&self) -> Option<kgid_t> {
        unsafe { crate::bpf_probe_read(&self.ia_gid) }.ok()
    }
    pub fn ia_atime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_atime) }.ok()
    }
    pub fn ia_mtime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_mtime) }.ok()
    }
    pub fn ia_ctime(&self) -> Option<timespec64> {
        unsafe { crate::bpf_probe_read(&self.ia_ctime) }.ok()
    }
    pub fn xattrs(&self) -> Option<simple_xattrs> {
        unsafe { crate::bpf_probe_read(&self.xattrs) }.ok()
    }
    pub fn nr_user_xattrs(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nr_user_xattrs) }.ok()
    }
    pub fn user_xattr_size(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.user_xattr_size) }.ok()
    }
}
impl kernfs_open_node {
    pub fn refcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn event(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.event) }.ok()
    }
    pub fn poll(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.poll) }.ok()
    }
    pub fn files(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.files) }.ok()
    }
}
impl sem_undo_list {
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn list_proc(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list_proc) }.ok()
    }
}
impl key_user {
    pub fn node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn cons_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.cons_lock) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn usage(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.usage) }.ok()
    }
    pub fn nkeys(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nkeys) }.ok()
    }
    pub fn nikeys(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nikeys) }.ok()
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
    pub fn qnkeys(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.qnkeys) }.ok()
    }
    pub fn qnbytes(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.qnbytes) }.ok()
    }
}
impl ethhdr {
    pub fn h_dest(&self) -> Option<[::aya_bpf_cty::c_uchar; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.h_dest) }.ok()
    }
    pub fn h_source(&self) -> Option<[::aya_bpf_cty::c_uchar; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.h_source) }.ok()
    }
    pub fn h_proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.h_proto) }.ok()
    }
}
impl ethtool_drvinfo {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn driver(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.driver) }.ok()
    }
    pub fn version(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn fw_version(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.fw_version) }.ok()
    }
    pub fn bus_info(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.bus_info) }.ok()
    }
    pub fn erom_version(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.erom_version) }.ok()
    }
    pub fn reserved2(&self) -> Option<[::aya_bpf_cty::c_char; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved2) }.ok()
    }
    pub fn n_priv_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.n_priv_flags) }.ok()
    }
    pub fn n_stats(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.n_stats) }.ok()
    }
    pub fn testinfo_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.testinfo_len) }.ok()
    }
    pub fn eedump_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.eedump_len) }.ok()
    }
    pub fn regdump_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.regdump_len) }.ok()
    }
}
impl ethtool_wolinfo {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn supported(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.supported) }.ok()
    }
    pub fn wolopts(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.wolopts) }.ok()
    }
    pub fn sopass(&self) -> Option<[__u8; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.sopass) }.ok()
    }
}
impl ethtool_tunable {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn type_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_id) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<*mut ::aya_bpf_cty::c_void>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_regs {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_eeprom {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn magic(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.magic) }.ok()
    }
    pub fn offset(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_eee {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn supported(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.supported) }.ok()
    }
    pub fn advertised(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.advertised) }.ok()
    }
    pub fn lp_advertised(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.lp_advertised) }.ok()
    }
    pub fn eee_active(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.eee_active) }.ok()
    }
    pub fn eee_enabled(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.eee_enabled) }.ok()
    }
    pub fn tx_lpi_enabled(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_lpi_enabled) }.ok()
    }
    pub fn tx_lpi_timer(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_lpi_timer) }.ok()
    }
    pub fn reserved(&self) -> Option<[__u32; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl ethtool_modinfo {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn type_(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn eeprom_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.eeprom_len) }.ok()
    }
    pub fn reserved(&self) -> Option<[__u32; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl ethtool_coalesce {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn rx_coalesce_usecs(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_coalesce_usecs) }.ok()
    }
    pub fn rx_max_coalesced_frames(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_max_coalesced_frames) }.ok()
    }
    pub fn rx_coalesce_usecs_irq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_coalesce_usecs_irq) }.ok()
    }
    pub fn rx_max_coalesced_frames_irq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_max_coalesced_frames_irq) }.ok()
    }
    pub fn tx_coalesce_usecs(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_coalesce_usecs) }.ok()
    }
    pub fn tx_max_coalesced_frames(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_max_coalesced_frames) }.ok()
    }
    pub fn tx_coalesce_usecs_irq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_coalesce_usecs_irq) }.ok()
    }
    pub fn tx_max_coalesced_frames_irq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_max_coalesced_frames_irq) }.ok()
    }
    pub fn stats_block_coalesce_usecs(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.stats_block_coalesce_usecs) }.ok()
    }
    pub fn use_adaptive_rx_coalesce(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.use_adaptive_rx_coalesce) }.ok()
    }
    pub fn use_adaptive_tx_coalesce(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.use_adaptive_tx_coalesce) }.ok()
    }
    pub fn pkt_rate_low(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pkt_rate_low) }.ok()
    }
    pub fn rx_coalesce_usecs_low(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_coalesce_usecs_low) }.ok()
    }
    pub fn rx_max_coalesced_frames_low(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_max_coalesced_frames_low) }.ok()
    }
    pub fn tx_coalesce_usecs_low(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_coalesce_usecs_low) }.ok()
    }
    pub fn tx_max_coalesced_frames_low(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_max_coalesced_frames_low) }.ok()
    }
    pub fn pkt_rate_high(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.pkt_rate_high) }.ok()
    }
    pub fn rx_coalesce_usecs_high(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_coalesce_usecs_high) }.ok()
    }
    pub fn rx_max_coalesced_frames_high(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_max_coalesced_frames_high) }.ok()
    }
    pub fn tx_coalesce_usecs_high(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_coalesce_usecs_high) }.ok()
    }
    pub fn tx_max_coalesced_frames_high(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_max_coalesced_frames_high) }.ok()
    }
    pub fn rate_sample_interval(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rate_sample_interval) }.ok()
    }
}
impl ethtool_ringparam {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn rx_max_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_max_pending) }.ok()
    }
    pub fn rx_mini_max_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_mini_max_pending) }.ok()
    }
    pub fn rx_jumbo_max_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_jumbo_max_pending) }.ok()
    }
    pub fn tx_max_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_max_pending) }.ok()
    }
    pub fn rx_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_pending) }.ok()
    }
    pub fn rx_mini_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_mini_pending) }.ok()
    }
    pub fn rx_jumbo_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_jumbo_pending) }.ok()
    }
    pub fn tx_pending(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_pending) }.ok()
    }
}
impl ethtool_channels {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn max_rx(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_rx) }.ok()
    }
    pub fn max_tx(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_tx) }.ok()
    }
    pub fn max_other(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_other) }.ok()
    }
    pub fn max_combined(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_combined) }.ok()
    }
    pub fn rx_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_count) }.ok()
    }
    pub fn tx_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_count) }.ok()
    }
    pub fn other_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.other_count) }.ok()
    }
    pub fn combined_count(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.combined_count) }.ok()
    }
}
impl ethtool_pauseparam {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn autoneg(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.autoneg) }.ok()
    }
    pub fn rx_pause(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_pause) }.ok()
    }
    pub fn tx_pause(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_pause) }.ok()
    }
}
impl ethtool_test {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn reserved(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u64>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_stats {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn n_stats(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.n_stats) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u64>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_tcpip4_spec {
    pub fn ip4src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4src) }.ok()
    }
    pub fn ip4dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4dst) }.ok()
    }
    pub fn psrc(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.psrc) }.ok()
    }
    pub fn pdst(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.pdst) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
}
impl ethtool_ah_espip4_spec {
    pub fn ip4src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4src) }.ok()
    }
    pub fn ip4dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4dst) }.ok()
    }
    pub fn spi(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.spi) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
}
impl ethtool_usrip4_spec {
    pub fn ip4src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4src) }.ok()
    }
    pub fn ip4dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip4dst) }.ok()
    }
    pub fn l4_4_bytes(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.l4_4_bytes) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn ip_ver(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ip_ver) }.ok()
    }
    pub fn proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
}
impl ethtool_tcpip6_spec {
    pub fn ip6src(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6src) }.ok()
    }
    pub fn ip6dst(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6dst) }.ok()
    }
    pub fn psrc(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.psrc) }.ok()
    }
    pub fn pdst(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.pdst) }.ok()
    }
    pub fn tclass(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tclass) }.ok()
    }
}
impl ethtool_ah_espip6_spec {
    pub fn ip6src(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6src) }.ok()
    }
    pub fn ip6dst(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6dst) }.ok()
    }
    pub fn spi(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.spi) }.ok()
    }
    pub fn tclass(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tclass) }.ok()
    }
}
impl ethtool_usrip6_spec {
    pub fn ip6src(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6src) }.ok()
    }
    pub fn ip6dst(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6dst) }.ok()
    }
    pub fn l4_4_bytes(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.l4_4_bytes) }.ok()
    }
    pub fn tclass(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tclass) }.ok()
    }
    pub fn l4_proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.l4_proto) }.ok()
    }
}
impl ethtool_flow_union {
    pub fn tcp_ip4_spec(&self) -> Option<ethtool_tcpip4_spec> {
        unsafe { crate::bpf_probe_read(&self.tcp_ip4_spec) }.ok()
    }
    pub fn udp_ip4_spec(&self) -> Option<ethtool_tcpip4_spec> {
        unsafe { crate::bpf_probe_read(&self.udp_ip4_spec) }.ok()
    }
    pub fn sctp_ip4_spec(&self) -> Option<ethtool_tcpip4_spec> {
        unsafe { crate::bpf_probe_read(&self.sctp_ip4_spec) }.ok()
    }
    pub fn ah_ip4_spec(&self) -> Option<ethtool_ah_espip4_spec> {
        unsafe { crate::bpf_probe_read(&self.ah_ip4_spec) }.ok()
    }
    pub fn esp_ip4_spec(&self) -> Option<ethtool_ah_espip4_spec> {
        unsafe { crate::bpf_probe_read(&self.esp_ip4_spec) }.ok()
    }
    pub fn usr_ip4_spec(&self) -> Option<ethtool_usrip4_spec> {
        unsafe { crate::bpf_probe_read(&self.usr_ip4_spec) }.ok()
    }
    pub fn tcp_ip6_spec(&self) -> Option<ethtool_tcpip6_spec> {
        unsafe { crate::bpf_probe_read(&self.tcp_ip6_spec) }.ok()
    }
    pub fn udp_ip6_spec(&self) -> Option<ethtool_tcpip6_spec> {
        unsafe { crate::bpf_probe_read(&self.udp_ip6_spec) }.ok()
    }
    pub fn sctp_ip6_spec(&self) -> Option<ethtool_tcpip6_spec> {
        unsafe { crate::bpf_probe_read(&self.sctp_ip6_spec) }.ok()
    }
    pub fn ah_ip6_spec(&self) -> Option<ethtool_ah_espip6_spec> {
        unsafe { crate::bpf_probe_read(&self.ah_ip6_spec) }.ok()
    }
    pub fn esp_ip6_spec(&self) -> Option<ethtool_ah_espip6_spec> {
        unsafe { crate::bpf_probe_read(&self.esp_ip6_spec) }.ok()
    }
    pub fn usr_ip6_spec(&self) -> Option<ethtool_usrip6_spec> {
        unsafe { crate::bpf_probe_read(&self.usr_ip6_spec) }.ok()
    }
    pub fn ether_spec(&self) -> Option<ethhdr> {
        unsafe { crate::bpf_probe_read(&self.ether_spec) }.ok()
    }
    pub fn hdata(&self) -> Option<[__u8; 52usize]> {
        unsafe { crate::bpf_probe_read(&self.hdata) }.ok()
    }
}
impl ethtool_flow_ext {
    pub fn padding(&self) -> Option<[__u8; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.padding) }.ok()
    }
    pub fn h_dest(&self) -> Option<[::aya_bpf_cty::c_uchar; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.h_dest) }.ok()
    }
    pub fn vlan_etype(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.vlan_etype) }.ok()
    }
    pub fn vlan_tci(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.vlan_tci) }.ok()
    }
    pub fn data(&self) -> Option<[__be32; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_rx_flow_spec {
    pub fn flow_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flow_type) }.ok()
    }
    pub fn h_u(&self) -> Option<ethtool_flow_union> {
        unsafe { crate::bpf_probe_read(&self.h_u) }.ok()
    }
    pub fn h_ext(&self) -> Option<ethtool_flow_ext> {
        unsafe { crate::bpf_probe_read(&self.h_ext) }.ok()
    }
    pub fn m_u(&self) -> Option<ethtool_flow_union> {
        unsafe { crate::bpf_probe_read(&self.m_u) }.ok()
    }
    pub fn m_ext(&self) -> Option<ethtool_flow_ext> {
        unsafe { crate::bpf_probe_read(&self.m_ext) }.ok()
    }
    pub fn ring_cookie(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.ring_cookie) }.ok()
    }
    pub fn location(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.location) }.ok()
    }
}
impl ethtool_rxnfc {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn flow_type(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flow_type) }.ok()
    }
    pub fn data(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn fs(&self) -> Option<ethtool_rx_flow_spec> {
        unsafe { crate::bpf_probe_read(&self.fs) }.ok()
    }
    pub fn rule_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rule_cnt) }.ok()
    }
    pub fn rss_context(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rss_context) }.ok()
    }
    pub fn rule_locs(&self) -> Option<__IncompleteArrayField<__u32>> {
        unsafe { crate::bpf_probe_read(&self.rule_locs) }.ok()
    }
}
impl ethtool_rxnfc__bindgen_ty_1 {
    pub fn rule_cnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rule_cnt) }.ok()
    }
    pub fn rss_context(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rss_context) }.ok()
    }
}
impl ethtool_flash {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn region(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.region) }.ok()
    }
    pub fn data(&self) -> Option<[::aya_bpf_cty::c_char; 128usize]> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_dump {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn version(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn flag(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.flag) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl ethtool_ts_info {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn so_timestamping(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.so_timestamping) }.ok()
    }
    pub fn phc_index(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.phc_index) }.ok()
    }
    pub fn tx_types(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tx_types) }.ok()
    }
    pub fn tx_reserved(&self) -> Option<[__u32; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.tx_reserved) }.ok()
    }
    pub fn rx_filters(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_filters) }.ok()
    }
    pub fn rx_reserved(&self) -> Option<[__u32; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.rx_reserved) }.ok()
    }
}
impl ethtool_fecparam {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn active_fec(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.active_fec) }.ok()
    }
    pub fn fec(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fec) }.ok()
    }
    pub fn reserved(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl ethtool_link_settings {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn speed(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.speed) }.ok()
    }
    pub fn duplex(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.duplex) }.ok()
    }
    pub fn port(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn phy_address(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.phy_address) }.ok()
    }
    pub fn autoneg(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.autoneg) }.ok()
    }
    pub fn mdio_support(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.mdio_support) }.ok()
    }
    pub fn eth_tp_mdix(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.eth_tp_mdix) }.ok()
    }
    pub fn eth_tp_mdix_ctrl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.eth_tp_mdix_ctrl) }.ok()
    }
    pub fn link_mode_masks_nwords(&self) -> Option<__s8> {
        unsafe { crate::bpf_probe_read(&self.link_mode_masks_nwords) }.ok()
    }
    pub fn transceiver(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.transceiver) }.ok()
    }
    pub fn master_slave_cfg(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.master_slave_cfg) }.ok()
    }
    pub fn master_slave_state(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.master_slave_state) }.ok()
    }
    pub fn reserved1(&self) -> Option<[__u8; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved1) }.ok()
    }
    pub fn reserved(&self) -> Option<[__u32; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
    pub fn link_mode_masks(&self) -> Option<__IncompleteArrayField<__u32>> {
        unsafe { crate::bpf_probe_read(&self.link_mode_masks) }.ok()
    }
}
impl ethtool_link_ext_state_info {
    pub fn link_ext_state(&self) -> Option<ethtool_link_ext_state::Type> {
        unsafe { crate::bpf_probe_read(&self.link_ext_state) }.ok()
    }
    pub fn autoneg(&self) -> Option<ethtool_link_ext_substate_autoneg::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.autoneg) }.ok()
    }
    pub fn link_training(&self) -> Option<ethtool_link_ext_substate_link_training::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.link_training) }.ok()
    }
    pub fn link_logical_mismatch(
        &self,
    ) -> Option<ethtool_link_ext_substate_link_logical_mismatch::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.link_logical_mismatch) }.ok()
    }
    pub fn bad_signal_integrity(
        &self,
    ) -> Option<ethtool_link_ext_substate_bad_signal_integrity::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bad_signal_integrity) }.ok()
    }
    pub fn cable_issue(&self) -> Option<ethtool_link_ext_substate_cable_issue::Type> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.cable_issue) }.ok()
    }
    pub fn __link_ext_substate(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__link_ext_substate) }.ok()
    }
}
impl ethtool_link_ext_state_info__bindgen_ty_1 {
    pub fn autoneg(&self) -> Option<ethtool_link_ext_substate_autoneg::Type> {
        unsafe { crate::bpf_probe_read(&self.autoneg) }.ok()
    }
    pub fn link_training(&self) -> Option<ethtool_link_ext_substate_link_training::Type> {
        unsafe { crate::bpf_probe_read(&self.link_training) }.ok()
    }
    pub fn link_logical_mismatch(
        &self,
    ) -> Option<ethtool_link_ext_substate_link_logical_mismatch::Type> {
        unsafe { crate::bpf_probe_read(&self.link_logical_mismatch) }.ok()
    }
    pub fn bad_signal_integrity(
        &self,
    ) -> Option<ethtool_link_ext_substate_bad_signal_integrity::Type> {
        unsafe { crate::bpf_probe_read(&self.bad_signal_integrity) }.ok()
    }
    pub fn cable_issue(&self) -> Option<ethtool_link_ext_substate_cable_issue::Type> {
        unsafe { crate::bpf_probe_read(&self.cable_issue) }.ok()
    }
    pub fn __link_ext_substate(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.__link_ext_substate) }.ok()
    }
}
impl ethtool_link_ksettings {
    pub fn base(&self) -> Option<ethtool_link_settings> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
    pub fn link_modes(&self) -> Option<ethtool_link_ksettings__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.link_modes) }.ok()
    }
}
impl ethtool_link_ksettings__bindgen_ty_1 {
    pub fn supported(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.supported) }.ok()
    }
    pub fn advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.advertising) }.ok()
    }
    pub fn lp_advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.lp_advertising) }.ok()
    }
}
impl ethtool_pause_stats {
    pub fn tx_pause_frames(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tx_pause_frames) }.ok()
    }
    pub fn rx_pause_frames(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rx_pause_frames) }.ok()
    }
}
impl in_addr {
    pub fn s_addr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.s_addr) }.ok()
    }
}
impl nf_hook_entry {
    pub fn hook(&self) -> Option<nf_hookfn> {
        unsafe { crate::bpf_probe_read(&self.hook) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nf_hook_entries {
    pub fn num_hook_entries(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.num_hook_entries) }.ok()
    }
    pub fn hooks(&self) -> Option<__IncompleteArrayField<nf_hook_entry>> {
        unsafe { crate::bpf_probe_read(&self.hooks) }.ok()
    }
}
impl nf_hook_state {
    pub fn hook(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hook) }.ok()
    }
    pub fn pf(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.pf) }.ok()
    }
    pub fn in_(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.in_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn out(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.out) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn okfn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sock,
                arg3: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.okfn) }.ok()
    }
}
impl ip_options {
    pub fn faddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.faddr) }.ok()
    }
    pub fn nexthop(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.nexthop) }.ok()
    }
    pub fn optlen(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.optlen) }.ok()
    }
    pub fn srr(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.srr) }.ok()
    }
    pub fn rr(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.rr) }.ok()
    }
    pub fn ts(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.ts) }.ok()
    }
    pub fn router_alert(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.router_alert) }.ok()
    }
    pub fn cipso(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.cipso) }.ok()
    }
    pub fn __pad2(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.__pad2) }.ok()
    }
    pub fn __data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_uchar>> {
        unsafe { crate::bpf_probe_read(&self.__data) }.ok()
    }
}
impl ip_options_rcu {
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn opt(&self) -> Option<ip_options> {
        unsafe { crate::bpf_probe_read(&self.opt) }.ok()
    }
}
impl ipv6_txoptions {
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn tot_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tot_len) }.ok()
    }
    pub fn opt_flen(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.opt_flen) }.ok()
    }
    pub fn opt_nflen(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.opt_nflen) }.ok()
    }
    pub fn hopopt(&self) -> Option<*mut ipv6_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.hopopt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst0opt(&self) -> Option<*mut ipv6_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.dst0opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn srcrt(&self) -> Option<*mut ipv6_rt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.srcrt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst1opt(&self) -> Option<*mut ipv6_opt_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.dst1opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl inet_cork {
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn addr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn opt(&self) -> Option<*mut ip_options> {
        let v = unsafe { crate::bpf_probe_read(&self.opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fragsize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fragsize) }.ok()
    }
    pub fn length(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn dst(&self) -> Option<*mut dst_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.dst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tx_flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tx_flags) }.ok()
    }
    pub fn ttl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ttl) }.ok()
    }
    pub fn tos(&self) -> Option<__s16> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn priority(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn gso_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.gso_size) }.ok()
    }
    pub fn transmit_time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.transmit_time) }.ok()
    }
    pub fn mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
}
impl inet_cork_full {
    pub fn base(&self) -> Option<inet_cork> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
    pub fn fl(&self) -> Option<flowi> {
        unsafe { crate::bpf_probe_read(&self.fl) }.ok()
    }
}
impl inet_sock {
    pub fn sk(&self) -> Option<sock> {
        unsafe { crate::bpf_probe_read(&self.sk) }.ok()
    }
    pub fn pinet6(&self) -> Option<*mut ipv6_pinfo> {
        let v = unsafe { crate::bpf_probe_read(&self.pinet6) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inet_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.inet_saddr) }.ok()
    }
    pub fn uc_ttl(&self) -> Option<__s16> {
        unsafe { crate::bpf_probe_read(&self.uc_ttl) }.ok()
    }
    pub fn cmsg_flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.cmsg_flags) }.ok()
    }
    pub fn inet_sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.inet_sport) }.ok()
    }
    pub fn inet_id(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.inet_id) }.ok()
    }
    pub fn inet_opt(&self) -> Option<*mut ip_options_rcu> {
        let v = unsafe { crate::bpf_probe_read(&self.inet_opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rx_dst_ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rx_dst_ifindex) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn min_ttl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.min_ttl) }.ok()
    }
    pub fn mc_ttl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.mc_ttl) }.ok()
    }
    pub fn pmtudisc(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pmtudisc) }.ok()
    }
    pub fn rcv_tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.rcv_tos) }.ok()
    }
    pub fn convert_csum(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.convert_csum) }.ok()
    }
    pub fn uc_index(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.uc_index) }.ok()
    }
    pub fn mc_index(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mc_index) }.ok()
    }
    pub fn mc_addr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.mc_addr) }.ok()
    }
    pub fn mc_list(&self) -> Option<*mut ip_mc_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cork(&self) -> Option<inet_cork_full> {
        unsafe { crate::bpf_probe_read(&self.cork) }.ok()
    }
}
impl in6_pktinfo {
    pub fn ipi6_addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.ipi6_addr) }.ok()
    }
    pub fn ipi6_ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ipi6_ifindex) }.ok()
    }
}
impl inet6_cork {
    pub fn opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hop_limit(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.hop_limit) }.ok()
    }
    pub fn tclass(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tclass) }.ok()
    }
}
impl ipv6_pinfo {
    pub fn saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn sticky_pktinfo(&self) -> Option<in6_pktinfo> {
        unsafe { crate::bpf_probe_read(&self.sticky_pktinfo) }.ok()
    }
    pub fn daddr_cache(&self) -> Option<*const in6_addr> {
        let v = unsafe { crate::bpf_probe_read(&self.daddr_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saddr_cache(&self) -> Option<*const in6_addr> {
        let v = unsafe { crate::bpf_probe_read(&self.saddr_cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flow_label(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.flow_label) }.ok()
    }
    pub fn frag_size(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.frag_size) }.ok()
    }
    pub fn ucast_oif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ucast_oif) }.ok()
    }
    pub fn mcast_oif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mcast_oif) }.ok()
    }
    pub fn rxopt(&self) -> Option<ipv6_pinfo__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.rxopt) }.ok()
    }
    pub fn min_hopcount(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.min_hopcount) }.ok()
    }
    pub fn tclass(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tclass) }.ok()
    }
    pub fn rcv_flowinfo(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.rcv_flowinfo) }.ok()
    }
    pub fn dst_cookie(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dst_cookie) }.ok()
    }
    pub fn rx_dst_cookie(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rx_dst_cookie) }.ok()
    }
    pub fn ipv6_mc_list(&self) -> Option<*mut ipv6_mc_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6_mc_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6_ac_list(&self) -> Option<*mut ipv6_ac_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6_ac_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6_fl_list(&self) -> Option<*mut ipv6_fl_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6_fl_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pktoptions(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.pktoptions) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rxpmtu(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.rxpmtu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cork(&self) -> Option<inet6_cork> {
        unsafe { crate::bpf_probe_read(&self.cork) }.ok()
    }
}
impl ipv6_pinfo__bindgen_ty_1 {
    pub fn bits(&self) -> Option<ipv6_pinfo__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.bits) }.ok()
    }
    pub fn all(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
}
impl ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {}
impl tcphdr {
    pub fn source(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.source) }.ok()
    }
    pub fn dest(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dest) }.ok()
    }
    pub fn seq(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn ack_seq(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ack_seq) }.ok()
    }
    pub fn window(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.window) }.ok()
    }
    pub fn check(&self) -> Option<__sum16> {
        unsafe { crate::bpf_probe_read(&self.check) }.ok()
    }
    pub fn urg_ptr(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.urg_ptr) }.ok()
    }
}
impl iphdr {
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn tot_len(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.tot_len) }.ok()
    }
    pub fn id(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn frag_off(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.frag_off) }.ok()
    }
    pub fn ttl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.ttl) }.ok()
    }
    pub fn protocol(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn check(&self) -> Option<__sum16> {
        unsafe { crate::bpf_probe_read(&self.check) }.ok()
    }
    pub fn saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
}
impl ipv6_rt_hdr {
    pub fn nexthdr(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.nexthdr) }.ok()
    }
    pub fn hdrlen(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.hdrlen) }.ok()
    }
    pub fn type_(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn segments_left(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.segments_left) }.ok()
    }
}
impl ipv6_opt_hdr {
    pub fn nexthdr(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.nexthdr) }.ok()
    }
    pub fn hdrlen(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.hdrlen) }.ok()
    }
}
impl ipv6_mc_socklist {
    pub fn addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn sfmode(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sfmode) }.ok()
    }
    pub fn next(&self) -> Option<*mut ipv6_mc_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sflock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.sflock) }.ok()
    }
    pub fn sflist(&self) -> Option<*mut ip6_sf_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.sflist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ipv6_ac_socklist {
    pub fn acl_addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.acl_addr) }.ok()
    }
    pub fn acl_ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.acl_ifindex) }.ok()
    }
    pub fn acl_next(&self) -> Option<*mut ipv6_ac_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.acl_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ipv6_fl_socklist {
    pub fn next(&self) -> Option<*mut ipv6_fl_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fl(&self) -> Option<*mut ip6_flowlabel> {
        let v = unsafe { crate::bpf_probe_read(&self.fl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ip6_sf_socklist {
    pub fn sl_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sl_max) }.ok()
    }
    pub fn sl_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sl_count) }.ok()
    }
    pub fn sl_addr(&self) -> Option<__IncompleteArrayField<in6_addr>> {
        unsafe { crate::bpf_probe_read(&self.sl_addr) }.ok()
    }
}
impl ip6_flowlabel {
    pub fn next(&self) -> Option<*mut ip6_flowlabel> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn label(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.label) }.ok()
    }
    pub fn users(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn dst(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
    pub fn opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn linger(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.linger) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn share(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.share) }.ok()
    }
    pub fn owner(&self) -> Option<ip6_flowlabel__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.owner) }.ok()
    }
    pub fn lastuse(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.lastuse) }.ok()
    }
    pub fn expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
    pub fn fl_net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.fl_net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ip6_flowlabel__bindgen_ty_1 {
    pub fn pid(&self) -> Option<*mut pid> {
        let v = unsafe { crate::bpf_probe_read(&self.pid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn uid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.uid) }.ok()
    }
}
impl rt6key {
    pub fn addr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn plen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.plen) }.ok()
    }
}
impl fib_nh_common {
    pub fn nhc_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.nhc_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nhc_oif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nhc_oif) }.ok()
    }
    pub fn nhc_scope(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.nhc_scope) }.ok()
    }
    pub fn nhc_family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.nhc_family) }.ok()
    }
    pub fn nhc_gw_family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.nhc_gw_family) }.ok()
    }
    pub fn nhc_flags(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.nhc_flags) }.ok()
    }
    pub fn nhc_lwtstate(&self) -> Option<*mut lwtunnel_state> {
        let v = unsafe { crate::bpf_probe_read(&self.nhc_lwtstate) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nhc_gw(&self) -> Option<fib_nh_common__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.nhc_gw) }.ok()
    }
    pub fn nhc_weight(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nhc_weight) }.ok()
    }
    pub fn nhc_upper_bound(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.nhc_upper_bound) }.ok()
    }
    pub fn nhc_pcpu_rth_output(&self) -> Option<*mut *mut rtable> {
        let v = unsafe { crate::bpf_probe_read(&self.nhc_pcpu_rth_output) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nhc_rth_input(&self) -> Option<*mut rtable> {
        let v = unsafe { crate::bpf_probe_read(&self.nhc_rth_input) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nhc_exceptions(&self) -> Option<*mut fnhe_hash_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.nhc_exceptions) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fib_nh_common__bindgen_ty_1 {
    pub fn ipv4(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4) }.ok()
    }
    pub fn ipv6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()
    }
}
impl fib6_nh {
    pub fn nh_common(&self) -> Option<fib_nh_common> {
        unsafe { crate::bpf_probe_read(&self.nh_common) }.ok()
    }
    pub fn last_probe(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_probe) }.ok()
    }
    pub fn rt6i_pcpu(&self) -> Option<*mut *mut rt6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.rt6i_pcpu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rt6i_exception_bucket(&self) -> Option<*mut rt6_exception_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.rt6i_exception_bucket) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl fib6_info {
    pub fn fib6_table(&self) -> Option<*mut fib6_table> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_next(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_node(&self) -> Option<*mut fib6_node> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_siblings(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fib6_siblings) }.ok()
    }
    pub fn nh_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nh_list) }.ok()
    }
    pub fn fib6_nsiblings(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib6_nsiblings) }.ok()
    }
    pub fn fib6_ref(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.fib6_ref) }.ok()
    }
    pub fn expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.expires) }.ok()
    }
    pub fn fib6_metrics(&self) -> Option<*mut dst_metrics> {
        let v = unsafe { crate::bpf_probe_read(&self.fib6_metrics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_dst(&self) -> Option<rt6key> {
        unsafe { crate::bpf_probe_read(&self.fib6_dst) }.ok()
    }
    pub fn fib6_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fib6_flags) }.ok()
    }
    pub fn fib6_src(&self) -> Option<rt6key> {
        unsafe { crate::bpf_probe_read(&self.fib6_src) }.ok()
    }
    pub fn fib6_prefsrc(&self) -> Option<rt6key> {
        unsafe { crate::bpf_probe_read(&self.fib6_prefsrc) }.ok()
    }
    pub fn fib6_metric(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fib6_metric) }.ok()
    }
    pub fn fib6_protocol(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.fib6_protocol) }.ok()
    }
    pub fn fib6_type(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.fib6_type) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn nh(&self) -> Option<*mut nexthop> {
        let v = unsafe { crate::bpf_probe_read(&self.nh) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib6_nh(&self) -> Option<__IncompleteArrayField<fib6_nh>> {
        unsafe { crate::bpf_probe_read(&self.fib6_nh) }.ok()
    }
}
impl fib6_info__bindgen_ty_1 {
    pub fn fib6_siblings(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fib6_siblings) }.ok()
    }
    pub fn nh_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.nh_list) }.ok()
    }
}
impl rt6_info {
    pub fn dst(&self) -> Option<dst_entry> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
    pub fn from(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.from) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sernum(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sernum) }.ok()
    }
    pub fn rt6i_dst(&self) -> Option<rt6key> {
        unsafe { crate::bpf_probe_read(&self.rt6i_dst) }.ok()
    }
    pub fn rt6i_src(&self) -> Option<rt6key> {
        unsafe { crate::bpf_probe_read(&self.rt6i_src) }.ok()
    }
    pub fn rt6i_gateway(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.rt6i_gateway) }.ok()
    }
    pub fn rt6i_idev(&self) -> Option<*mut inet6_dev> {
        let v = unsafe { crate::bpf_probe_read(&self.rt6i_idev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rt6i_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rt6i_flags) }.ok()
    }
    pub fn rt6i_uncached(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rt6i_uncached) }.ok()
    }
    pub fn rt6i_uncached_list(&self) -> Option<*mut uncached_list> {
        let v = unsafe { crate::bpf_probe_read(&self.rt6i_uncached_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rt6i_nfheader_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.rt6i_nfheader_len) }.ok()
    }
}
impl rt6_statistics {
    pub fn fib_nodes(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fib_nodes) }.ok()
    }
    pub fn fib_route_nodes(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fib_route_nodes) }.ok()
    }
    pub fn fib_rt_entries(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fib_rt_entries) }.ok()
    }
    pub fn fib_rt_cache(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fib_rt_cache) }.ok()
    }
    pub fn fib_discarded_routes(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fib_discarded_routes) }.ok()
    }
    pub fn fib_rt_alloc(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.fib_rt_alloc) }.ok()
    }
    pub fn fib_rt_uncache(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.fib_rt_uncache) }.ok()
    }
}
impl fib6_node {
    pub fn parent(&self) -> Option<*mut fib6_node> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn left(&self) -> Option<*mut fib6_node> {
        let v = unsafe { crate::bpf_probe_read(&self.left) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn right(&self) -> Option<*mut fib6_node> {
        let v = unsafe { crate::bpf_probe_read(&self.right) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn subtree(&self) -> Option<*mut fib6_node> {
        let v = unsafe { crate::bpf_probe_read(&self.subtree) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn leaf(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.leaf) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fn_bit(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.fn_bit) }.ok()
    }
    pub fn fn_flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.fn_flags) }.ok()
    }
    pub fn fn_sernum(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fn_sernum) }.ok()
    }
    pub fn rr_ptr(&self) -> Option<*mut fib6_info> {
        let v = unsafe { crate::bpf_probe_read(&self.rr_ptr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl fib6_table {
    pub fn tb6_hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.tb6_hlist) }.ok()
    }
    pub fn tb6_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tb6_id) }.ok()
    }
    pub fn tb6_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.tb6_lock) }.ok()
    }
    pub fn tb6_root(&self) -> Option<fib6_node> {
        unsafe { crate::bpf_probe_read(&self.tb6_root) }.ok()
    }
    pub fn tb6_peers(&self) -> Option<inet_peer_base> {
        unsafe { crate::bpf_probe_read(&self.tb6_peers) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn fib_seq(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib_seq) }.ok()
    }
}
impl xfrm_address_t {
    pub fn a4(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.a4) }.ok()
    }
    pub fn a6(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.a6) }.ok()
    }
    pub fn in6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.in6) }.ok()
    }
}
impl xfrm_id {
    pub fn daddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn spi(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.spi) }.ok()
    }
    pub fn proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
}
impl xfrm_selector {
    pub fn daddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn saddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
    pub fn dport_mask(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport_mask) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
    pub fn sport_mask(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport_mask) }.ok()
    }
    pub fn family(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn prefixlen_d(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.prefixlen_d) }.ok()
    }
    pub fn prefixlen_s(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.prefixlen_s) }.ok()
    }
    pub fn proto(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn user(&self) -> Option<__kernel_uid32_t> {
        unsafe { crate::bpf_probe_read(&self.user) }.ok()
    }
}
impl xfrm_lifetime_cfg {
    pub fn soft_byte_limit(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.soft_byte_limit) }.ok()
    }
    pub fn hard_byte_limit(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hard_byte_limit) }.ok()
    }
    pub fn soft_packet_limit(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.soft_packet_limit) }.ok()
    }
    pub fn hard_packet_limit(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hard_packet_limit) }.ok()
    }
    pub fn soft_add_expires_seconds(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.soft_add_expires_seconds) }.ok()
    }
    pub fn hard_add_expires_seconds(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hard_add_expires_seconds) }.ok()
    }
    pub fn soft_use_expires_seconds(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.soft_use_expires_seconds) }.ok()
    }
    pub fn hard_use_expires_seconds(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.hard_use_expires_seconds) }.ok()
    }
}
impl xfrm_lifetime_cur {
    pub fn bytes(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn packets(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.packets) }.ok()
    }
    pub fn add_time(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.add_time) }.ok()
    }
    pub fn use_time(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.use_time) }.ok()
    }
}
impl xfrm_replay_state {
    pub fn oseq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.oseq) }.ok()
    }
    pub fn seq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn bitmap(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bitmap) }.ok()
    }
}
impl xfrm_replay_state_esn {
    pub fn bmp_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bmp_len) }.ok()
    }
    pub fn oseq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.oseq) }.ok()
    }
    pub fn seq(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn oseq_hi(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.oseq_hi) }.ok()
    }
    pub fn seq_hi(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.seq_hi) }.ok()
    }
    pub fn replay_window(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.replay_window) }.ok()
    }
    pub fn bmp(&self) -> Option<__IncompleteArrayField<__u32>> {
        unsafe { crate::bpf_probe_read(&self.bmp) }.ok()
    }
}
impl xfrm_algo {
    pub fn alg_name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.alg_name) }.ok()
    }
    pub fn alg_key_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alg_key_len) }.ok()
    }
    pub fn alg_key(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.alg_key) }.ok()
    }
}
impl xfrm_algo_auth {
    pub fn alg_name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.alg_name) }.ok()
    }
    pub fn alg_key_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alg_key_len) }.ok()
    }
    pub fn alg_trunc_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alg_trunc_len) }.ok()
    }
    pub fn alg_key(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.alg_key) }.ok()
    }
}
impl xfrm_algo_aead {
    pub fn alg_name(&self) -> Option<[::aya_bpf_cty::c_char; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.alg_name) }.ok()
    }
    pub fn alg_key_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alg_key_len) }.ok()
    }
    pub fn alg_icv_len(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.alg_icv_len) }.ok()
    }
    pub fn alg_key(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.alg_key) }.ok()
    }
}
impl xfrm_stats {
    pub fn replay_window(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.replay_window) }.ok()
    }
    pub fn replay(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.replay) }.ok()
    }
    pub fn integrity_failed(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.integrity_failed) }.ok()
    }
}
impl xfrm_encap_tmpl {
    pub fn encap_type(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.encap_type) }.ok()
    }
    pub fn encap_sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.encap_sport) }.ok()
    }
    pub fn encap_dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.encap_dport) }.ok()
    }
    pub fn encap_oa(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.encap_oa) }.ok()
    }
}
impl xfrm_mark {
    pub fn v(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.v) }.ok()
    }
    pub fn m(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.m) }.ok()
    }
}
impl xfrm_address_filter {
    pub fn saddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn family(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn splen(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.splen) }.ok()
    }
    pub fn dplen(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.dplen) }.ok()
    }
}
impl xfrm_state_walk {
    pub fn all(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn dying(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.dying) }.ok()
    }
    pub fn proto(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn filter(&self) -> Option<*mut xfrm_address_filter> {
        let v = unsafe { crate::bpf_probe_read(&self.filter) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xfrm_state_offload {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn real_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.real_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn offload_handle(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.offload_handle) }.ok()
    }
    pub fn num_exthdrs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_exthdrs) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl xfrm_mode {
    pub fn encap(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.encap) }.ok()
    }
    pub fn family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl xfrm_state {
    pub fn xs_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.xs_net) }.ok()
    }
    pub fn gclist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.gclist) }.ok()
    }
    pub fn bydst(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.bydst) }.ok()
    }
    pub fn bysrc(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.bysrc) }.ok()
    }
    pub fn byspi(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.byspi) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn id(&self) -> Option<xfrm_id> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn sel(&self) -> Option<xfrm_selector> {
        unsafe { crate::bpf_probe_read(&self.sel) }.ok()
    }
    pub fn mark(&self) -> Option<xfrm_mark> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn if_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.if_id) }.ok()
    }
    pub fn tfcpad(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tfcpad) }.ok()
    }
    pub fn genid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.genid) }.ok()
    }
    pub fn km(&self) -> Option<xfrm_state_walk> {
        unsafe { crate::bpf_probe_read(&self.km) }.ok()
    }
    pub fn props(&self) -> Option<xfrm_state__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.props) }.ok()
    }
    pub fn lft(&self) -> Option<xfrm_lifetime_cfg> {
        unsafe { crate::bpf_probe_read(&self.lft) }.ok()
    }
    pub fn aalg(&self) -> Option<*mut xfrm_algo_auth> {
        let v = unsafe { crate::bpf_probe_read(&self.aalg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ealg(&self) -> Option<*mut xfrm_algo> {
        let v = unsafe { crate::bpf_probe_read(&self.ealg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn calg(&self) -> Option<*mut xfrm_algo> {
        let v = unsafe { crate::bpf_probe_read(&self.calg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn aead(&self) -> Option<*mut xfrm_algo_aead> {
        let v = unsafe { crate::bpf_probe_read(&self.aead) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn geniv(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.geniv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn encap(&self) -> Option<*mut xfrm_encap_tmpl> {
        let v = unsafe { crate::bpf_probe_read(&self.encap) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn encap_sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.encap_sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn coaddr(&self) -> Option<*mut xfrm_address_t> {
        let v = unsafe { crate::bpf_probe_read(&self.coaddr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tunnel(&self) -> Option<*mut xfrm_state> {
        let v = unsafe { crate::bpf_probe_read(&self.tunnel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tunnel_users(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.tunnel_users) }.ok()
    }
    pub fn replay(&self) -> Option<xfrm_replay_state> {
        unsafe { crate::bpf_probe_read(&self.replay) }.ok()
    }
    pub fn replay_esn(&self) -> Option<*mut xfrm_replay_state_esn> {
        let v = unsafe { crate::bpf_probe_read(&self.replay_esn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn preplay(&self) -> Option<xfrm_replay_state> {
        unsafe { crate::bpf_probe_read(&self.preplay) }.ok()
    }
    pub fn preplay_esn(&self) -> Option<*mut xfrm_replay_state_esn> {
        let v = unsafe { crate::bpf_probe_read(&self.preplay_esn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn repl(&self) -> Option<*const xfrm_replay> {
        let v = unsafe { crate::bpf_probe_read(&self.repl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xflags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.xflags) }.ok()
    }
    pub fn replay_maxage(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.replay_maxage) }.ok()
    }
    pub fn replay_maxdiff(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.replay_maxdiff) }.ok()
    }
    pub fn rtimer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.rtimer) }.ok()
    }
    pub fn stats(&self) -> Option<xfrm_stats> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn curlft(&self) -> Option<xfrm_lifetime_cur> {
        unsafe { crate::bpf_probe_read(&self.curlft) }.ok()
    }
    pub fn mtimer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.mtimer) }.ok()
    }
    pub fn xso(&self) -> Option<xfrm_state_offload> {
        unsafe { crate::bpf_probe_read(&self.xso) }.ok()
    }
    pub fn saved_tmo(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.saved_tmo) }.ok()
    }
    pub fn lastused(&self) -> Option<time64_t> {
        unsafe { crate::bpf_probe_read(&self.lastused) }.ok()
    }
    pub fn xfrag(&self) -> Option<page_frag> {
        unsafe { crate::bpf_probe_read(&self.xfrag) }.ok()
    }
    pub fn type_(&self) -> Option<*const xfrm_type> {
        let v = unsafe { crate::bpf_probe_read(&self.type_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn inner_mode(&self) -> Option<xfrm_mode> {
        unsafe { crate::bpf_probe_read(&self.inner_mode) }.ok()
    }
    pub fn inner_mode_iaf(&self) -> Option<xfrm_mode> {
        unsafe { crate::bpf_probe_read(&self.inner_mode_iaf) }.ok()
    }
    pub fn outer_mode(&self) -> Option<xfrm_mode> {
        unsafe { crate::bpf_probe_read(&self.outer_mode) }.ok()
    }
    pub fn type_offload(&self) -> Option<*const xfrm_type_offload> {
        let v = unsafe { crate::bpf_probe_read(&self.type_offload) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn security(&self) -> Option<*mut xfrm_sec_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl xfrm_state__bindgen_ty_1 {
    pub fn gclist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.gclist) }.ok()
    }
    pub fn bydst(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.bydst) }.ok()
    }
}
impl xfrm_state__bindgen_ty_2 {
    pub fn reqid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reqid) }.ok()
    }
    pub fn mode(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn replay_window(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.replay_window) }.ok()
    }
    pub fn aalgo(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.aalgo) }.ok()
    }
    pub fn ealgo(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ealgo) }.ok()
    }
    pub fn calgo(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.calgo) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn family(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn saddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn header_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.header_len) }.ok()
    }
    pub fn trailer_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.trailer_len) }.ok()
    }
    pub fn extra_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.extra_flags) }.ok()
    }
    pub fn smark(&self) -> Option<xfrm_mark> {
        unsafe { crate::bpf_probe_read(&self.smark) }.ok()
    }
}
impl dst_metrics {
    pub fn metrics(&self) -> Option<[u32_; 17usize]> {
        unsafe { crate::bpf_probe_read(&self.metrics) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
}
impl xfrm_policy_walk_entry {
    pub fn all(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn dead(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
}
impl xfrm_policy_queue {
    pub fn hold_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.hold_queue) }.ok()
    }
    pub fn hold_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.hold_timer) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
}
impl xfrm_tmpl {
    pub fn id(&self) -> Option<xfrm_id> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn saddr(&self) -> Option<xfrm_address_t> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn encap_family(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.encap_family) }.ok()
    }
    pub fn reqid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reqid) }.ok()
    }
    pub fn mode(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn share(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.share) }.ok()
    }
    pub fn optional(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.optional) }.ok()
    }
    pub fn allalgs(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.allalgs) }.ok()
    }
    pub fn aalgos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.aalgos) }.ok()
    }
    pub fn ealgos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ealgos) }.ok()
    }
    pub fn calgos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.calgos) }.ok()
    }
}
impl xfrm_policy {
    pub fn xp_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.xp_net) }.ok()
    }
    pub fn bydst(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.bydst) }.ok()
    }
    pub fn byidx(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.byidx) }.ok()
    }
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn pos(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pos) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn genid(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.genid) }.ok()
    }
    pub fn priority(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn if_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.if_id) }.ok()
    }
    pub fn mark(&self) -> Option<xfrm_mark> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn selector(&self) -> Option<xfrm_selector> {
        unsafe { crate::bpf_probe_read(&self.selector) }.ok()
    }
    pub fn lft(&self) -> Option<xfrm_lifetime_cfg> {
        unsafe { crate::bpf_probe_read(&self.lft) }.ok()
    }
    pub fn curlft(&self) -> Option<xfrm_lifetime_cur> {
        unsafe { crate::bpf_probe_read(&self.curlft) }.ok()
    }
    pub fn walk(&self) -> Option<xfrm_policy_walk_entry> {
        unsafe { crate::bpf_probe_read(&self.walk) }.ok()
    }
    pub fn polq(&self) -> Option<xfrm_policy_queue> {
        unsafe { crate::bpf_probe_read(&self.polq) }.ok()
    }
    pub fn bydst_reinsert(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.bydst_reinsert) }.ok()
    }
    pub fn type_(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn action(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn xfrm_nr(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.xfrm_nr) }.ok()
    }
    pub fn family(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn security(&self) -> Option<*mut xfrm_sec_ctx> {
        let v = unsafe { crate::bpf_probe_read(&self.security) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xfrm_vec(&self) -> Option<[xfrm_tmpl; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.xfrm_vec) }.ok()
    }
    pub fn bydst_inexact_list(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.bydst_inexact_list) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl udp_table {
    pub fn hash(&self) -> Option<*mut udp_hslot> {
        let v = unsafe { crate::bpf_probe_read(&self.hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hash2(&self) -> Option<*mut udp_hslot> {
        let v = unsafe { crate::bpf_probe_read(&self.hash2) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mask(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn log(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.log) }.ok()
    }
}
impl fib_nh_exception {
    pub fn fnhe_next(&self) -> Option<*mut fib_nh_exception> {
        let v = unsafe { crate::bpf_probe_read(&self.fnhe_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fnhe_genid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fnhe_genid) }.ok()
    }
    pub fn fnhe_daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.fnhe_daddr) }.ok()
    }
    pub fn fnhe_pmtu(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fnhe_pmtu) }.ok()
    }
    pub fn fnhe_mtu_locked(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fnhe_mtu_locked) }.ok()
    }
    pub fn fnhe_gw(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.fnhe_gw) }.ok()
    }
    pub fn fnhe_expires(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fnhe_expires) }.ok()
    }
    pub fn fnhe_rth_input(&self) -> Option<*mut rtable> {
        let v = unsafe { crate::bpf_probe_read(&self.fnhe_rth_input) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fnhe_rth_output(&self) -> Option<*mut rtable> {
        let v = unsafe { crate::bpf_probe_read(&self.fnhe_rth_output) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fnhe_stamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.fnhe_stamp) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl rtable {
    pub fn dst(&self) -> Option<dst_entry> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
    pub fn rt_genid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rt_genid) }.ok()
    }
    pub fn rt_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.rt_flags) }.ok()
    }
    pub fn rt_type(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.rt_type) }.ok()
    }
    pub fn rt_is_input(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.rt_is_input) }.ok()
    }
    pub fn rt_uses_gateway(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.rt_uses_gateway) }.ok()
    }
    pub fn rt_iif(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.rt_iif) }.ok()
    }
    pub fn rt_gw_family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rt_gw_family) }.ok()
    }
    pub fn rt_gw4(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rt_gw4) }.ok()
    }
    pub fn rt_gw6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rt_gw6) }.ok()
    }
    pub fn rt_uncached(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rt_uncached) }.ok()
    }
    pub fn rt_uncached_list(&self) -> Option<*mut uncached_list> {
        let v = unsafe { crate::bpf_probe_read(&self.rt_uncached_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rtable__bindgen_ty_1 {
    pub fn rt_gw4(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.rt_gw4) }.ok()
    }
    pub fn rt_gw6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.rt_gw6) }.ok()
    }
}
impl fnhe_hash_bucket {
    pub fn chain(&self) -> Option<*mut fib_nh_exception> {
        let v = unsafe { crate::bpf_probe_read(&self.chain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rt6_exception_bucket {
    pub fn chain(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.chain) }.ok()
    }
    pub fn depth(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.depth) }.ok()
    }
}
impl xfrm_replay {
    pub fn advance(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: __be32)>>
    {
        unsafe { crate::bpf_probe_read(&self.advance) }.ok()
    }
    pub fn check(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut xfrm_state,
                arg2: *mut sk_buff,
                arg3: __be32,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check) }.ok()
    }
    pub fn recheck(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut xfrm_state,
                arg2: *mut sk_buff,
                arg3: __be32,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.recheck) }.ok()
    }
    pub fn notify(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.notify) }.ok()
    }
    pub fn overflow(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.overflow) }.ok()
    }
}
impl xfrm_type {
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proto(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn init_state(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.init_state) }.ok()
    }
    pub fn destructor(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
    pub fn input(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.input) }.ok()
    }
    pub fn output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.output) }.ok()
    }
    pub fn reject(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut xfrm_state,
                arg2: *mut sk_buff,
                arg3: *const flowi,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reject) }.ok()
    }
    pub fn hdr_offset(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut xfrm_state,
                arg2: *mut sk_buff,
                arg3: *mut *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.hdr_offset) }.ok()
    }
}
impl xfrm_type_offload {
    pub fn description(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.description) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proto(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn encap(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff)>,
    > {
        unsafe { crate::bpf_probe_read(&self.encap) }.ok()
    }
    pub fn input_tail(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.input_tail) }.ok()
    }
    pub fn xmit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut xfrm_state,
                arg2: *mut sk_buff,
                arg3: netdev_features_t,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.xmit) }.ok()
    }
}
impl udp_hslot {
    pub fn head(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
}
impl rtattr {
    pub fn rta_len(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.rta_len) }.ok()
    }
    pub fn rta_type(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.rta_type) }.ok()
    }
}
impl rq_qos {
    pub fn ops(&self) -> Option<*mut rq_qos_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn q(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.q) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<rq_qos_id::Type> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn next(&self) -> Option<*mut rq_qos> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn debugfs_dir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.debugfs_dir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl rq_qos_ops {
    pub fn throttle(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>>
    {
        unsafe { crate::bpf_probe_read(&self.throttle) }.ok()
    }
    pub fn track(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.track) }.ok()
    }
    pub fn merge(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.merge) }.ok()
    }
    pub fn issue(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>>
    {
        unsafe { crate::bpf_probe_read(&self.issue) }.ok()
    }
    pub fn requeue(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>>
    {
        unsafe { crate::bpf_probe_read(&self.requeue) }.ok()
    }
    pub fn done(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>>
    {
        unsafe { crate::bpf_probe_read(&self.done) }.ok()
    }
    pub fn done_bio(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>>
    {
        unsafe { crate::bpf_probe_read(&self.done_bio) }.ok()
    }
    pub fn cleanup(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>>
    {
        unsafe { crate::bpf_probe_read(&self.cleanup) }.ok()
    }
    pub fn queue_depth_changed(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>> {
        unsafe { crate::bpf_probe_read(&self.queue_depth_changed) }.ok()
    }
    pub fn exit(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>> {
        unsafe { crate::bpf_probe_read(&self.exit) }.ok()
    }
    pub fn debugfs_attrs(&self) -> Option<*const blk_mq_debugfs_attr> {
        let v = unsafe { crate::bpf_probe_read(&self.debugfs_attrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_queue_stats {
    pub fn callbacks(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.callbacks) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn enable_accounting(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.enable_accounting) }.ok()
    }
}
impl hd_geometry {
    pub fn heads(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.heads) }.ok()
    }
    pub fn sectors(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sectors) }.ok()
    }
    pub fn cylinders(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.cylinders) }.ok()
    }
    pub fn start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
}
impl klist {
    pub fn k_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.k_lock) }.ok()
    }
    pub fn k_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.k_list) }.ok()
    }
    pub fn get(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>> {
        unsafe { crate::bpf_probe_read(&self.get) }.ok()
    }
    pub fn put(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>> {
        unsafe { crate::bpf_probe_read(&self.put) }.ok()
    }
}
impl klist_node {
    pub fn n_klist(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.n_klist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.n_node) }.ok()
    }
    pub fn n_ref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.n_ref) }.ok()
    }
}
impl disk_events {
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn disk(&self) -> Option<*mut gendisk> {
        let v = unsafe { crate::bpf_probe_read(&self.disk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn block_mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.block_mutex) }.ok()
    }
    pub fn block(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.block) }.ok()
    }
    pub fn pending(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
    pub fn clearing(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.clearing) }.ok()
    }
    pub fn poll_msecs(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.poll_msecs) }.ok()
    }
    pub fn dwork(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.dwork) }.ok()
    }
}
impl badblocks {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn unacked_exist(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.unacked_exist) }.ok()
    }
    pub fn shift(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.shift) }.ok()
    }
    pub fn page(&self) -> Option<*mut u64_> {
        let v = unsafe { crate::bpf_probe_read(&self.page) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn changed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.changed) }.ok()
    }
    pub fn lock(&self) -> Option<seqlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn sector(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.sector) }.ok()
    }
    pub fn size(&self) -> Option<sector_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl cdrom_device_info {
    pub fn ops(&self) -> Option<*const cdrom_device_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn disk(&self) -> Option<*mut gendisk> {
        let v = unsafe { crate::bpf_probe_read(&self.disk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn handle(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.handle) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mask(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn speed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.speed) }.ok()
    }
    pub fn capacity(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.capacity) }.ok()
    }
    pub fn vfs_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.vfs_events) }.ok()
    }
    pub fn ioctl_events(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ioctl_events) }.ok()
    }
    pub fn use_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.use_count) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 20usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn cdda_method(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.cdda_method) }.ok()
    }
    pub fn last_sense(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.last_sense) }.ok()
    }
    pub fn media_written(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.media_written) }.ok()
    }
    pub fn mmc3_profile(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.mmc3_profile) }.ok()
    }
    pub fn for_data(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.for_data) }.ok()
    }
    pub fn exit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.exit) }.ok()
    }
    pub fn mrw_mode_page(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mrw_mode_page) }.ok()
    }
}
impl scsi_sense_hdr {
    pub fn response_code(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.response_code) }.ok()
    }
    pub fn sense_key(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sense_key) }.ok()
    }
    pub fn asc(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.asc) }.ok()
    }
    pub fn ascq(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ascq) }.ok()
    }
    pub fn byte4(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.byte4) }.ok()
    }
    pub fn byte5(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.byte5) }.ok()
    }
    pub fn byte6(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.byte6) }.ok()
    }
    pub fn additional_length(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.additional_length) }.ok()
    }
}
impl cdrom_msf0 {
    pub fn minute(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.minute) }.ok()
    }
    pub fn second(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.second) }.ok()
    }
    pub fn frame(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.frame) }.ok()
    }
}
impl cdrom_addr {
    pub fn msf(&self) -> Option<cdrom_msf0> {
        unsafe { crate::bpf_probe_read(&self.msf) }.ok()
    }
    pub fn lba(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.lba) }.ok()
    }
}
impl cdrom_multisession {
    pub fn addr(&self) -> Option<cdrom_addr> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn xa_flag(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.xa_flag) }.ok()
    }
    pub fn addr_format(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.addr_format) }.ok()
    }
}
impl cdrom_mcn {
    pub fn medium_catalog_number(&self) -> Option<[__u8; 14usize]> {
        unsafe { crate::bpf_probe_read(&self.medium_catalog_number) }.ok()
    }
}
impl packet_command {
    pub fn cmd(&self) -> Option<[::aya_bpf_cty::c_uchar; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn buffer(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.buffer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn buflen(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.buflen) }.ok()
    }
    pub fn stat(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.stat) }.ok()
    }
    pub fn sshdr(&self) -> Option<*mut scsi_sense_hdr> {
        let v = unsafe { crate::bpf_probe_read(&self.sshdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_direction(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.data_direction) }.ok()
    }
    pub fn quiet(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.quiet) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn reserved(&self) -> Option<[*mut ::aya_bpf_cty::c_void; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl cdrom_device_ops {
    pub fn open(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.open) }.ok()
    }
    pub fn release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut cdrom_device_info)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn drive_status(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.drive_status) }.ok()
    }
    pub fn check_events(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.check_events) }.ok()
    }
    pub fn tray_move(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.tray_move) }.ok()
    }
    pub fn lock_door(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.lock_door) }.ok()
    }
    pub fn select_speed(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.select_speed) }.ok()
    }
    pub fn select_disc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.select_disc) }.ok()
    }
    pub fn get_last_session(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: *mut cdrom_multisession,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_last_session) }.ok()
    }
    pub fn get_mcn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: *mut cdrom_mcn,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_mcn) }.ok()
    }
    pub fn reset(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn audio_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.audio_ioctl) }.ok()
    }
    pub fn capability(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.capability) }.ok()
    }
    pub fn generic_packet(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cdrom_device_info,
                arg2: *mut packet_command,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.generic_packet) }.ok()
    }
}
impl throtl_service_queue {
    pub fn parent_sq(&self) -> Option<*mut throtl_service_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.parent_sq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn queued(&self) -> Option<[list_head; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.queued) }.ok()
    }
    pub fn nr_queued(&self) -> Option<[::aya_bpf_cty::c_uint; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.nr_queued) }.ok()
    }
    pub fn pending_tree(&self) -> Option<rb_root_cached> {
        unsafe { crate::bpf_probe_read(&self.pending_tree) }.ok()
    }
    pub fn nr_pending(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_pending) }.ok()
    }
    pub fn first_pending_disptime(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.first_pending_disptime) }.ok()
    }
    pub fn pending_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.pending_timer) }.ok()
    }
}
impl latency_bucket {
    pub fn total_latency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.total_latency) }.ok()
    }
    pub fn samples(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.samples) }.ok()
    }
}
impl avg_latency_bucket {
    pub fn latency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.latency) }.ok()
    }
    pub fn valid(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.valid) }.ok()
    }
}
impl throtl_data {
    pub fn service_queue(&self) -> Option<throtl_service_queue> {
        unsafe { crate::bpf_probe_read(&self.service_queue) }.ok()
    }
    pub fn queue(&self) -> Option<*mut request_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.queue) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_queued(&self) -> Option<[::aya_bpf_cty::c_uint; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.nr_queued) }.ok()
    }
    pub fn throtl_slice(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.throtl_slice) }.ok()
    }
    pub fn dispatch_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.dispatch_work) }.ok()
    }
    pub fn limit_index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.limit_index) }.ok()
    }
    pub fn limit_valid(&self) -> Option<[bool_; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.limit_valid) }.ok()
    }
    pub fn low_upgrade_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.low_upgrade_time) }.ok()
    }
    pub fn low_downgrade_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.low_downgrade_time) }.ok()
    }
    pub fn scale(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.scale) }.ok()
    }
    pub fn tmp_buckets(&self) -> Option<[latency_bucket; 18usize]> {
        unsafe { crate::bpf_probe_read(&self.tmp_buckets) }.ok()
    }
    pub fn avg_buckets(&self) -> Option<[avg_latency_bucket; 18usize]> {
        unsafe { crate::bpf_probe_read(&self.avg_buckets) }.ok()
    }
    pub fn latency_buckets(&self) -> Option<[*mut latency_bucket; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.latency_buckets) }.ok()
    }
    pub fn last_calculate_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.last_calculate_time) }.ok()
    }
    pub fn filtered_latency(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.filtered_latency) }.ok()
    }
    pub fn track_bio_latency(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.track_bio_latency) }.ok()
    }
}
impl blk_ksm_keyslot {
    pub fn slot_refs(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.slot_refs) }.ok()
    }
    pub fn idle_slot_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.idle_slot_node) }.ok()
    }
    pub fn hash_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hash_node) }.ok()
    }
    pub fn key(&self) -> Option<*const blk_crypto_key> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ksm(&self) -> Option<*mut blk_keyslot_manager> {
        let v = unsafe { crate::bpf_probe_read(&self.ksm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl blk_ksm_ll_ops {
    pub fn keyslot_program(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_keyslot_manager,
                arg2: *const blk_crypto_key,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.keyslot_program) }.ok()
    }
    pub fn keyslot_evict(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut blk_keyslot_manager,
                arg2: *const blk_crypto_key,
                arg3: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.keyslot_evict) }.ok()
    }
}
impl blk_keyslot_manager {
    pub fn ksm_ll_ops(&self) -> Option<blk_ksm_ll_ops> {
        unsafe { crate::bpf_probe_read(&self.ksm_ll_ops) }.ok()
    }
    pub fn max_dun_bytes_supported(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_dun_bytes_supported) }.ok()
    }
    pub fn crypto_modes_supported(&self) -> Option<[::aya_bpf_cty::c_uint; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.crypto_modes_supported) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_slots(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_slots) }.ok()
    }
    pub fn lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn idle_slots_wait_queue(&self) -> Option<wait_queue_head_t> {
        unsafe { crate::bpf_probe_read(&self.idle_slots_wait_queue) }.ok()
    }
    pub fn idle_slots(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.idle_slots) }.ok()
    }
    pub fn idle_slots_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.idle_slots_lock) }.ok()
    }
    pub fn slot_hashtable(&self) -> Option<*mut hlist_head> {
        let v = unsafe { crate::bpf_probe_read(&self.slot_hashtable) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn log_slot_ht_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.log_slot_ht_size) }.ok()
    }
    pub fn slots(&self) -> Option<*mut blk_ksm_keyslot> {
        let v = unsafe { crate::bpf_probe_read(&self.slots) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cpu_rmap {
    pub fn refcount(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn used(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.used) }.ok()
    }
    pub fn obj(&self) -> Option<*mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.obj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn near(&self) -> Option<__IncompleteArrayField<cpu_rmap__bindgen_ty_1>> {
        unsafe { crate::bpf_probe_read(&self.near) }.ok()
    }
}
impl cpu_rmap__bindgen_ty_1 {
    pub fn index(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn dist(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.dist) }.ok()
    }
}
impl uevent_sock {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn sk(&self) -> Option<*mut sock> {
        let v = unsafe { crate::bpf_probe_read(&self.sk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl minmax_sample {
    pub fn t(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.t) }.ok()
    }
    pub fn v(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.v) }.ok()
    }
}
impl minmax {
    pub fn s(&self) -> Option<[minmax_sample; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.s) }.ok()
    }
}
impl dev_pin_info {
    pub fn p(&self) -> Option<*mut pinctrl> {
        let v = unsafe { crate::bpf_probe_read(&self.p) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn default_state(&self) -> Option<*mut pinctrl_state> {
        let v = unsafe { crate::bpf_probe_read(&self.default_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init_state(&self) -> Option<*mut pinctrl_state> {
        let v = unsafe { crate::bpf_probe_read(&self.init_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sleep_state(&self) -> Option<*mut pinctrl_state> {
        let v = unsafe { crate::bpf_probe_read(&self.sleep_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn idle_state(&self) -> Option<*mut pinctrl_state> {
        let v = unsafe { crate::bpf_probe_read(&self.idle_state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl pinctrl {
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn states(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.states) }.ok()
    }
    pub fn state(&self) -> Option<*mut pinctrl_state> {
        let v = unsafe { crate::bpf_probe_read(&self.state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dt_maps(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dt_maps) }.ok()
    }
    pub fn users(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
}
impl pinctrl_state {
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn settings(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.settings) }.ok()
    }
}
impl pm_domain_data {
    pub fn list_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list_node) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl led_hw_trigger_type {
    pub fn dummy(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dummy) }.ok()
    }
}
impl led_classdev {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn brightness(&self) -> Option<led_brightness::Type> {
        unsafe { crate::bpf_probe_read(&self.brightness) }.ok()
    }
    pub fn max_brightness(&self) -> Option<led_brightness::Type> {
        unsafe { crate::bpf_probe_read(&self.max_brightness) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn work_flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.work_flags) }.ok()
    }
    pub fn brightness_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut led_classdev, arg2: led_brightness::Type),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.brightness_set) }.ok()
    }
    pub fn brightness_set_blocking(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut led_classdev,
                arg2: led_brightness::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.brightness_set_blocking) }.ok()
    }
    pub fn brightness_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut led_classdev) -> led_brightness::Type,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.brightness_get) }.ok()
    }
    pub fn blink_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut led_classdev,
                arg2: *mut ::aya_bpf_cty::c_ulong,
                arg3: *mut ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.blink_set) }.ok()
    }
    pub fn pattern_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut led_classdev,
                arg2: *mut led_pattern,
                arg3: u32_,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pattern_set) }.ok()
    }
    pub fn pattern_clear(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut led_classdev) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.pattern_clear) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn default_trigger(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.default_trigger) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn blink_delay_on(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.blink_delay_on) }.ok()
    }
    pub fn blink_delay_off(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.blink_delay_off) }.ok()
    }
    pub fn blink_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.blink_timer) }.ok()
    }
    pub fn blink_brightness(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.blink_brightness) }.ok()
    }
    pub fn new_blink_brightness(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.new_blink_brightness) }.ok()
    }
    pub fn flash_resume(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut led_classdev)>> {
        unsafe { crate::bpf_probe_read(&self.flash_resume) }.ok()
    }
    pub fn set_brightness_work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.set_brightness_work) }.ok()
    }
    pub fn delayed_set_value(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.delayed_set_value) }.ok()
    }
    pub fn trigger_lock(&self) -> Option<rw_semaphore> {
        unsafe { crate::bpf_probe_read(&self.trigger_lock) }.ok()
    }
    pub fn trigger(&self) -> Option<*mut led_trigger> {
        let v = unsafe { crate::bpf_probe_read(&self.trigger) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trig_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.trig_list) }.ok()
    }
    pub fn trigger_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.trigger_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn activated(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.activated) }.ok()
    }
    pub fn trigger_type(&self) -> Option<*mut led_hw_trigger_type> {
        let v = unsafe { crate::bpf_probe_read(&self.trigger_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn brightness_hw_changed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.brightness_hw_changed) }.ok()
    }
    pub fn brightness_hw_changed_kn(&self) -> Option<*mut kernfs_node> {
        let v = unsafe { crate::bpf_probe_read(&self.brightness_hw_changed_kn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn led_access(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.led_access) }.ok()
    }
}
impl led_pattern {
    pub fn delta_t(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.delta_t) }.ok()
    }
    pub fn brightness(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.brightness) }.ok()
    }
}
impl led_trigger {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn activate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut led_classdev) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.activate) }.ok()
    }
    pub fn deactivate(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut led_classdev)>> {
        unsafe { crate::bpf_probe_read(&self.deactivate) }.ok()
    }
    pub fn trigger_type(&self) -> Option<*mut led_hw_trigger_type> {
        let v = unsafe { crate::bpf_probe_read(&self.trigger_type) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn leddev_list_lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.leddev_list_lock) }.ok()
    }
    pub fn led_cdevs(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.led_cdevs) }.ok()
    }
    pub fn next_trig(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.next_trig) }.ok()
    }
    pub fn groups(&self) -> Option<*mut *const attribute_group> {
        let v = unsafe { crate::bpf_probe_read(&self.groups) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tty_audit_buf {
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn dev(&self) -> Option<dev_t> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn valid(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.valid) }.ok()
    }
    pub fn data(&self) -> Option<*mut ::aya_bpf_cty::c_uchar> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl timer_rand_state {
    pub fn last_time(&self) -> Option<cycles_t> {
        unsafe { crate::bpf_probe_read(&self.last_time) }.ok()
    }
    pub fn last_delta(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.last_delta) }.ok()
    }
    pub fn last_delta2(&self) -> Option<::aya_bpf_cty::c_long> {
        unsafe { crate::bpf_probe_read(&self.last_delta2) }.ok()
    }
}
impl iommu_group {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn devices_kobj(&self) -> Option<*mut kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.devices_kobj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devices(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.devices) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn notifier(&self) -> Option<blocking_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.notifier) }.ok()
    }
    pub fn iommu_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.iommu_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iommu_data_release(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.iommu_data_release) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn default_domain(&self) -> Option<*mut iommu_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.default_domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn domain(&self) -> Option<*mut iommu_domain> {
        let v = unsafe { crate::bpf_probe_read(&self.domain) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entry(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.entry) }.ok()
    }
}
impl wake_irq {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn status(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl subsys_private {
    pub fn subsys(&self) -> Option<kset> {
        unsafe { crate::bpf_probe_read(&self.subsys) }.ok()
    }
    pub fn devices_kset(&self) -> Option<*mut kset> {
        let v = unsafe { crate::bpf_probe_read(&self.devices_kset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn interfaces(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.interfaces) }.ok()
    }
    pub fn mutex(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mutex) }.ok()
    }
    pub fn drivers_kset(&self) -> Option<*mut kset> {
        let v = unsafe { crate::bpf_probe_read(&self.drivers_kset) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn klist_devices(&self) -> Option<klist> {
        unsafe { crate::bpf_probe_read(&self.klist_devices) }.ok()
    }
    pub fn klist_drivers(&self) -> Option<klist> {
        unsafe { crate::bpf_probe_read(&self.klist_drivers) }.ok()
    }
    pub fn bus_notifier(&self) -> Option<blocking_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.bus_notifier) }.ok()
    }
    pub fn bus(&self) -> Option<*mut bus_type> {
        let v = unsafe { crate::bpf_probe_read(&self.bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn glue_dirs(&self) -> Option<kset> {
        unsafe { crate::bpf_probe_read(&self.glue_dirs) }.ok()
    }
    pub fn class(&self) -> Option<*mut class> {
        let v = unsafe { crate::bpf_probe_read(&self.class) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl driver_private {
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn klist_devices(&self) -> Option<klist> {
        unsafe { crate::bpf_probe_read(&self.klist_devices) }.ok()
    }
    pub fn knode_bus(&self) -> Option<klist_node> {
        unsafe { crate::bpf_probe_read(&self.knode_bus) }.ok()
    }
    pub fn mkobj(&self) -> Option<*mut module_kobject> {
        let v = unsafe { crate::bpf_probe_read(&self.mkobj) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn driver(&self) -> Option<*mut device_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.driver) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl device_private {
    pub fn klist_children(&self) -> Option<klist> {
        unsafe { crate::bpf_probe_read(&self.klist_children) }.ok()
    }
    pub fn knode_parent(&self) -> Option<klist_node> {
        unsafe { crate::bpf_probe_read(&self.knode_parent) }.ok()
    }
    pub fn knode_driver(&self) -> Option<klist_node> {
        unsafe { crate::bpf_probe_read(&self.knode_driver) }.ok()
    }
    pub fn knode_bus(&self) -> Option<klist_node> {
        unsafe { crate::bpf_probe_read(&self.knode_bus) }.ok()
    }
    pub fn knode_class(&self) -> Option<klist_node> {
        unsafe { crate::bpf_probe_read(&self.knode_class) }.ok()
    }
    pub fn deferred_probe(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.deferred_probe) }.ok()
    }
    pub fn async_driver(&self) -> Option<*mut device_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.async_driver) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn deferred_probe_reason(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.deferred_probe_reason) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn device(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.device) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl reset_control___2 {}
impl mdio_device {
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn bus(&self) -> Option<*mut mii_bus> {
        let v = unsafe { crate::bpf_probe_read(&self.bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn modalias(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.modalias) }.ok()
    }
    pub fn bus_match(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut device_driver,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.bus_match) }.ok()
    }
    pub fn device_free(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>> {
        unsafe { crate::bpf_probe_read(&self.device_free) }.ok()
    }
    pub fn device_remove(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>> {
        unsafe { crate::bpf_probe_read(&self.device_remove) }.ok()
    }
    pub fn addr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn reset_gpio(&self) -> Option<*mut gpio_desc> {
        let v = unsafe { crate::bpf_probe_read(&self.reset_gpio) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reset_ctrl(&self) -> Option<*mut reset_control___2> {
        let v = unsafe { crate::bpf_probe_read(&self.reset_ctrl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reset_assert_delay(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reset_assert_delay) }.ok()
    }
    pub fn reset_deassert_delay(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.reset_deassert_delay) }.ok()
    }
}
impl phy_c45_device_ids {
    pub fn devices_in_package(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.devices_in_package) }.ok()
    }
    pub fn mmds_present(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mmds_present) }.ok()
    }
    pub fn device_ids(&self) -> Option<[u32_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.device_ids) }.ok()
    }
}
impl phylink {}
impl phy_device {
    pub fn mdio(&self) -> Option<mdio_device> {
        unsafe { crate::bpf_probe_read(&self.mdio) }.ok()
    }
    pub fn drv(&self) -> Option<*mut phy_driver> {
        let v = unsafe { crate::bpf_probe_read(&self.drv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phy_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phy_id) }.ok()
    }
    pub fn c45_ids(&self) -> Option<phy_c45_device_ids> {
        unsafe { crate::bpf_probe_read(&self.c45_ids) }.ok()
    }
    pub fn state(&self) -> Option<phy_state::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn dev_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dev_flags) }.ok()
    }
    pub fn interface(&self) -> Option<phy_interface_t::Type> {
        unsafe { crate::bpf_probe_read(&self.interface) }.ok()
    }
    pub fn speed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.speed) }.ok()
    }
    pub fn duplex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.duplex) }.ok()
    }
    pub fn port(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn pause(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pause) }.ok()
    }
    pub fn asym_pause(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.asym_pause) }.ok()
    }
    pub fn master_slave_get(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.master_slave_get) }.ok()
    }
    pub fn master_slave_set(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.master_slave_set) }.ok()
    }
    pub fn master_slave_state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.master_slave_state) }.ok()
    }
    pub fn supported(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.supported) }.ok()
    }
    pub fn advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.advertising) }.ok()
    }
    pub fn lp_advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.lp_advertising) }.ok()
    }
    pub fn adv_old(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.adv_old) }.ok()
    }
    pub fn eee_broken_modes(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.eee_broken_modes) }.ok()
    }
    pub fn phy_led_triggers(&self) -> Option<*mut phy_led_trigger> {
        let v = unsafe { crate::bpf_probe_read(&self.phy_led_triggers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phy_num_led_triggers(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.phy_num_led_triggers) }.ok()
    }
    pub fn last_triggered(&self) -> Option<*mut phy_led_trigger> {
        let v = unsafe { crate::bpf_probe_read(&self.last_triggered) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn led_link_trigger(&self) -> Option<*mut phy_led_trigger> {
        let v = unsafe { crate::bpf_probe_read(&self.led_link_trigger) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn irq(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn shared(&self) -> Option<*mut phy_package_shared> {
        let v = unsafe { crate::bpf_probe_read(&self.shared) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn skb(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.skb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ehdr(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ehdr) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nest(&self) -> Option<*mut nlattr> {
        let v = unsafe { crate::bpf_probe_read(&self.nest) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_queue(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.state_queue) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn sfp_bus_attached(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.sfp_bus_attached) }.ok()
    }
    pub fn sfp_bus(&self) -> Option<*mut sfp_bus> {
        let v = unsafe { crate::bpf_probe_read(&self.sfp_bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phylink(&self) -> Option<*mut phylink> {
        let v = unsafe { crate::bpf_probe_read(&self.phylink) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn attached_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.attached_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mii_ts(&self) -> Option<*mut mii_timestamper> {
        let v = unsafe { crate::bpf_probe_read(&self.mii_ts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mdix(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mdix) }.ok()
    }
    pub fn mdix_ctrl(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mdix_ctrl) }.ok()
    }
    pub fn phy_link_change(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_)>>
    {
        unsafe { crate::bpf_probe_read(&self.phy_link_change) }.ok()
    }
    pub fn adjust_link(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>> {
        unsafe { crate::bpf_probe_read(&self.adjust_link) }.ok()
    }
    pub fn macsec_ops(&self) -> Option<*const macsec_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.macsec_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl phy_tdr_config {
    pub fn first(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.first) }.ok()
    }
    pub fn last(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last) }.ok()
    }
    pub fn step(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.step) }.ok()
    }
    pub fn pair(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.pair) }.ok()
    }
}
impl mdio_bus_stats {
    pub fn transfers(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.transfers) }.ok()
    }
    pub fn errors(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.errors) }.ok()
    }
    pub fn writes(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.writes) }.ok()
    }
    pub fn reads(&self) -> Option<u64_stats_t> {
        unsafe { crate::bpf_probe_read(&self.reads) }.ok()
    }
    pub fn syncp(&self) -> Option<u64_stats_sync> {
        unsafe { crate::bpf_probe_read(&self.syncp) }.ok()
    }
}
impl mii_bus {
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<[::aya_bpf_cty::c_char; 61usize]> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_bus,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read) }.ok()
    }
    pub fn write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_bus,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write) }.ok()
    }
    pub fn reset(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mii_bus) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.reset) }.ok()
    }
    pub fn stats(&self) -> Option<[mdio_bus_stats; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn mdio_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mdio_lock) }.ok()
    }
    pub fn parent(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state(&self) -> Option<mii_bus__bindgen_ty_1::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn mdio_map(&self) -> Option<[*mut mdio_device; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.mdio_map) }.ok()
    }
    pub fn phy_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phy_mask) }.ok()
    }
    pub fn phy_ignore_ta_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phy_ignore_ta_mask) }.ok()
    }
    pub fn irq(&self) -> Option<[::aya_bpf_cty::c_int; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.irq) }.ok()
    }
    pub fn reset_delay_us(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.reset_delay_us) }.ok()
    }
    pub fn reset_post_delay_us(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.reset_post_delay_us) }.ok()
    }
    pub fn reset_gpiod(&self) -> Option<*mut gpio_desc> {
        let v = unsafe { crate::bpf_probe_read(&self.reset_gpiod) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn probe_capabilities(&self) -> Option<mii_bus__bindgen_ty_2::Type> {
        unsafe { crate::bpf_probe_read(&self.probe_capabilities) }.ok()
    }
    pub fn shared_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.shared_lock) }.ok()
    }
    pub fn shared(&self) -> Option<[*mut phy_package_shared; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.shared) }.ok()
    }
}
impl mdio_driver_common {
    pub fn driver(&self) -> Option<device_driver> {
        unsafe { crate::bpf_probe_read(&self.driver) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl mii_timestamper {
    pub fn rxtstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_timestamper,
                arg2: *mut sk_buff,
                arg3: ::aya_bpf_cty::c_int,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rxtstamp) }.ok()
    }
    pub fn txtstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_timestamper,
                arg2: *mut sk_buff,
                arg3: ::aya_bpf_cty::c_int,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.txtstamp) }.ok()
    }
    pub fn hwtstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_timestamper,
                arg2: *mut ifreq,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.hwtstamp) }.ok()
    }
    pub fn link_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut mii_timestamper, arg2: *mut phy_device),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.link_state) }.ok()
    }
    pub fn ts_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mii_timestamper,
                arg2: *mut ethtool_ts_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ts_info) }.ok()
    }
    pub fn device(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.device) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl phy_package_shared {
    pub fn addr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn priv_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.priv_size) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl phy_driver {
    pub fn mdiodrv(&self) -> Option<mdio_driver_common> {
        unsafe { crate::bpf_probe_read(&self.mdiodrv) }.ok()
    }
    pub fn phy_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phy_id) }.ok()
    }
    pub fn name(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phy_id_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phy_id_mask) }.ok()
    }
    pub fn features(&self) -> Option<*const ::aya_bpf_cty::c_ulong> {
        let v = unsafe { crate::bpf_probe_read(&self.features) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn driver_data(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.driver_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn soft_reset(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.soft_reset) }.ok()
    }
    pub fn config_init(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.config_init) }.ok()
    }
    pub fn probe(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.probe) }.ok()
    }
    pub fn get_features(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_features) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn config_aneg(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.config_aneg) }.ok()
    }
    pub fn aneg_done(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.aneg_done) }.ok()
    }
    pub fn read_status(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.read_status) }.ok()
    }
    pub fn config_intr(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.config_intr) }.ok()
    }
    pub fn handle_interrupt(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> irqreturn_t>>
    {
        unsafe { crate::bpf_probe_read(&self.handle_interrupt) }.ok()
    }
    pub fn remove(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>> {
        unsafe { crate::bpf_probe_read(&self.remove) }.ok()
    }
    pub fn match_phy_device(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.match_phy_device) }.ok()
    }
    pub fn set_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *mut ethtool_wolinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_wol) }.ok()
    }
    pub fn get_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_wolinfo),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_wol) }.ok()
    }
    pub fn link_change_notify(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>> {
        unsafe { crate::bpf_probe_read(&self.link_change_notify) }.ok()
    }
    pub fn read_mmd(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.read_mmd) }.ok()
    }
    pub fn write_mmd(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u16_,
                arg4: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_mmd) }.ok()
    }
    pub fn read_page(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.read_page) }.ok()
    }
    pub fn write_page(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.write_page) }.ok()
    }
    pub fn module_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *mut ethtool_modinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_info) }.ok()
    }
    pub fn module_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_eeprom) }.ok()
    }
    pub fn cable_test_start(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.cable_test_start) }.ok()
    }
    pub fn cable_test_tdr_start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *const phy_tdr_config,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cable_test_tdr_start) }.ok()
    }
    pub fn cable_test_get_status(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cable_test_get_status) }.ok()
    }
    pub fn get_sset_count(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sset_count) }.ok()
    }
    pub fn get_strings(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut u8_)>>
    {
        unsafe { crate::bpf_probe_read(&self.get_strings) }.ok()
    }
    pub fn get_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_stats) }.ok()
    }
    pub fn get_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *mut ethtool_tunable,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_tunable) }.ok()
    }
    pub fn set_tunable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut phy_device,
                arg2: *mut ethtool_tunable,
                arg3: *const ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_tunable) }.ok()
    }
    pub fn set_loopback(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_loopback) }.ok()
    }
    pub fn get_sqi(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sqi) }.ok()
    }
    pub fn get_sqi_max(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sqi_max) }.ok()
    }
}
impl platform_msi_priv_data {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn host_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.host_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn arg(&self) -> Option<msi_alloc_info_t> {
        unsafe { crate::bpf_probe_read(&self.arg) }.ok()
    }
    pub fn write_msg(&self) -> Option<irq_write_msi_msg_t> {
        unsafe { crate::bpf_probe_read(&self.write_msg) }.ok()
    }
    pub fn devid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.devid) }.ok()
    }
}
impl phy_led_trigger {
    pub fn trigger(&self) -> Option<led_trigger> {
        unsafe { crate::bpf_probe_read(&self.trigger) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 76usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn speed(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.speed) }.ok()
    }
}
impl sfp_eeprom_base {
    pub fn phys_id(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.phys_id) }.ok()
    }
    pub fn phys_ext_id(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.phys_ext_id) }.ok()
    }
    pub fn connector(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.connector) }.ok()
    }
    pub fn encoding(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.encoding) }.ok()
    }
    pub fn br_nominal(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.br_nominal) }.ok()
    }
    pub fn rate_id(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rate_id) }.ok()
    }
    pub fn link_len(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.link_len) }.ok()
    }
    pub fn vendor_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.vendor_name) }.ok()
    }
    pub fn extended_cc(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.extended_cc) }.ok()
    }
    pub fn vendor_oui(&self) -> Option<[::aya_bpf_cty::c_char; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.vendor_oui) }.ok()
    }
    pub fn vendor_pn(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.vendor_pn) }.ok()
    }
    pub fn vendor_rev(&self) -> Option<[::aya_bpf_cty::c_char; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.vendor_rev) }.ok()
    }
    pub fn optical_wavelength(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.optical_wavelength) }.ok()
    }
    pub fn cable_compliance(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.cable_compliance) }.ok()
    }
    pub fn passive(&self) -> Option<sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.passive) }.ok()
    }
    pub fn active(&self) -> Option<sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.active) }.ok()
    }
    pub fn reserved62(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.reserved62) }.ok()
    }
    pub fn cc_base(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.cc_base) }.ok()
    }
}
impl sfp_eeprom_base__bindgen_ty_1 {
    pub fn optical_wavelength(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.optical_wavelength) }.ok()
    }
    pub fn cable_compliance(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.cable_compliance) }.ok()
    }
    pub fn passive(&self) -> Option<sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.passive) }.ok()
    }
    pub fn active(&self) -> Option<sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.active) }.ok()
    }
}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1 {}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2 {}
impl sfp_eeprom_ext {
    pub fn options(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.options) }.ok()
    }
    pub fn br_max(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.br_max) }.ok()
    }
    pub fn br_min(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.br_min) }.ok()
    }
    pub fn vendor_sn(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.vendor_sn) }.ok()
    }
    pub fn datecode(&self) -> Option<[::aya_bpf_cty::c_char; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.datecode) }.ok()
    }
    pub fn diagmon(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.diagmon) }.ok()
    }
    pub fn enhopts(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.enhopts) }.ok()
    }
    pub fn sff8472_compliance(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sff8472_compliance) }.ok()
    }
    pub fn cc_ext(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.cc_ext) }.ok()
    }
}
impl sfp_eeprom_id {
    pub fn base(&self) -> Option<sfp_eeprom_base> {
        unsafe { crate::bpf_probe_read(&self.base) }.ok()
    }
    pub fn ext(&self) -> Option<sfp_eeprom_ext> {
        unsafe { crate::bpf_probe_read(&self.ext) }.ok()
    }
}
impl sfp_upstream_ops {
    pub fn attach(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void, arg2: *mut sfp_bus),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.attach) }.ok()
    }
    pub fn detach(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void, arg2: *mut sfp_bus),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.detach) }.ok()
    }
    pub fn module_insert(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_void,
                arg2: *const sfp_eeprom_id,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_insert) }.ok()
    }
    pub fn module_remove(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.module_remove) }.ok()
    }
    pub fn module_start(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_start) }.ok()
    }
    pub fn module_stop(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.module_stop) }.ok()
    }
    pub fn link_down(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.link_down) }.ok()
    }
    pub fn link_up(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.link_up) }.ok()
    }
    pub fn connect_phy(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_void,
                arg2: *mut phy_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.connect_phy) }.ok()
    }
    pub fn disconnect_phy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf_cty::c_void)>>
    {
        unsafe { crate::bpf_probe_read(&self.disconnect_phy) }.ok()
    }
}
impl sfp {}
impl sfp_bus {
    pub fn kref(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.kref) }.ok()
    }
    pub fn node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn fwnode(&self) -> Option<*mut fwnode_handle> {
        let v = unsafe { crate::bpf_probe_read(&self.fwnode) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn socket_ops(&self) -> Option<*const sfp_socket_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.socket_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sfp_dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.sfp_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sfp(&self) -> Option<*mut sfp> {
        let v = unsafe { crate::bpf_probe_read(&self.sfp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sfp_quirk(&self) -> Option<*const sfp_quirk> {
        let v = unsafe { crate::bpf_probe_read(&self.sfp_quirk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn upstream_ops(&self) -> Option<*const sfp_upstream_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.upstream_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn upstream(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.upstream) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phydev(&self) -> Option<*mut phy_device> {
        let v = unsafe { crate::bpf_probe_read(&self.phydev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn registered(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.registered) }.ok()
    }
    pub fn started(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.started) }.ok()
    }
}
impl sfp_socket_ops {
    pub fn attach(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>> {
        unsafe { crate::bpf_probe_read(&self.attach) }.ok()
    }
    pub fn detach(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>> {
        unsafe { crate::bpf_probe_read(&self.detach) }.ok()
    }
    pub fn start(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn stop(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>> {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn module_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sfp,
                arg2: *mut ethtool_modinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_info) }.ok()
    }
    pub fn module_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sfp,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.module_eeprom) }.ok()
    }
}
impl sfp_quirk {
    pub fn vendor(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.vendor) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn part(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.part) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn modes(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sfp_eeprom_id, arg2: *mut ::aya_bpf_cty::c_ulong),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.modes) }.ok()
    }
}
impl flow_dissector {
    pub fn used_keys(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.used_keys) }.ok()
    }
    pub fn offset(&self) -> Option<[::aya_bpf_cty::c_ushort; 28usize]> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
}
impl nf_conntrack {
    pub fn use_(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.use_) }.ok()
    }
}
impl mmpin {
    pub fn user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_pg(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_pg) }.ok()
    }
}
impl ubuf_info {
    pub fn callback(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut ubuf_info, arg2: bool_)>>
    {
        unsafe { crate::bpf_probe_read(&self.callback) }.ok()
    }
    pub fn desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.desc) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v =
            unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.id) }.ok()
    }
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.len) }.ok()
    }
    pub fn bytelen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_2.bytelen) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn mmp(&self) -> Option<mmpin> {
        unsafe { crate::bpf_probe_read(&self.mmp) }.ok()
    }
}
impl ubuf_info__bindgen_ty_1 {
    pub fn desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.desc) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.id) }.ok()
    }
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.len) }.ok()
    }
    pub fn bytelen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.bytelen) }.ok()
    }
}
impl ubuf_info__bindgen_ty_1__bindgen_ty_1 {
    pub fn desc(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.desc) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ubuf_info__bindgen_ty_1__bindgen_ty_2 {
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn bytelen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bytelen) }.ok()
    }
}
impl ip_tunnel_parm {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn link(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn i_flags(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.i_flags) }.ok()
    }
    pub fn o_flags(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.o_flags) }.ok()
    }
    pub fn i_key(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.i_key) }.ok()
    }
    pub fn o_key(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.o_key) }.ok()
    }
    pub fn iph(&self) -> Option<iphdr> {
        unsafe { crate::bpf_probe_read(&self.iph) }.ok()
    }
}
impl wpan_dev {
    pub fn wpan_phy(&self) -> Option<*mut wpan_phy> {
        let v = unsafe { crate::bpf_probe_read(&self.wpan_phy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iftype(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.iftype) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn header_ops(&self) -> Option<*const wpan_dev_header_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.header_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lowpan_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.lowpan_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn identifier(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.identifier) }.ok()
    }
    pub fn pan_id(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.pan_id) }.ok()
    }
    pub fn short_addr(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.short_addr) }.ok()
    }
    pub fn extended_addr(&self) -> Option<__le64> {
        unsafe { crate::bpf_probe_read(&self.extended_addr) }.ok()
    }
    pub fn bsn(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.bsn) }.ok()
    }
    pub fn dsn(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.dsn) }.ok()
    }
    pub fn min_be(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.min_be) }.ok()
    }
    pub fn max_be(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_be) }.ok()
    }
    pub fn csma_retries(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.csma_retries) }.ok()
    }
    pub fn frame_retries(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.frame_retries) }.ok()
    }
    pub fn lbt(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.lbt) }.ok()
    }
    pub fn promiscuous_mode(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.promiscuous_mode) }.ok()
    }
    pub fn ackreq(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ackreq) }.ok()
    }
}
impl lwtunnel_state {
    pub fn type_(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn headroom(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.headroom) }.ok()
    }
    pub fn refcnt(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn orig_output(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sock,
                arg3: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.orig_output) }.ok()
    }
    pub fn orig_input(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.orig_input) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl fib_nh {
    pub fn nh_common(&self) -> Option<fib_nh_common> {
        unsafe { crate::bpf_probe_read(&self.nh_common) }.ok()
    }
    pub fn nh_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.nh_hash) }.ok()
    }
    pub fn nh_parent(&self) -> Option<*mut fib_info> {
        let v = unsafe { crate::bpf_probe_read(&self.nh_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nh_tclassid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nh_tclassid) }.ok()
    }
    pub fn nh_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.nh_saddr) }.ok()
    }
    pub fn nh_saddr_genid(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nh_saddr_genid) }.ok()
    }
}
impl fib_info {
    pub fn fib_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.fib_hash) }.ok()
    }
    pub fn fib_lhash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.fib_lhash) }.ok()
    }
    pub fn nh_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.nh_list) }.ok()
    }
    pub fn fib_net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_treeref(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fib_treeref) }.ok()
    }
    pub fn fib_clntref(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.fib_clntref) }.ok()
    }
    pub fn fib_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fib_flags) }.ok()
    }
    pub fn fib_dead(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.fib_dead) }.ok()
    }
    pub fn fib_protocol(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.fib_protocol) }.ok()
    }
    pub fn fib_scope(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.fib_scope) }.ok()
    }
    pub fn fib_type(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.fib_type) }.ok()
    }
    pub fn fib_prefsrc(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.fib_prefsrc) }.ok()
    }
    pub fn fib_tb_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fib_tb_id) }.ok()
    }
    pub fn fib_priority(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.fib_priority) }.ok()
    }
    pub fn fib_metrics(&self) -> Option<*mut dst_metrics> {
        let v = unsafe { crate::bpf_probe_read(&self.fib_metrics) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fib_nhs(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.fib_nhs) }.ok()
    }
    pub fn fib_nh_is_v6(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fib_nh_is_v6) }.ok()
    }
    pub fn nh_updated(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.nh_updated) }.ok()
    }
    pub fn nh(&self) -> Option<*mut nexthop> {
        let v = unsafe { crate::bpf_probe_read(&self.nh) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn fib_nh(&self) -> Option<__IncompleteArrayField<fib_nh>> {
        unsafe { crate::bpf_probe_read(&self.fib_nh) }.ok()
    }
}
impl nexthop {
    pub fn rb_node(&self) -> Option<rb_node> {
        unsafe { crate::bpf_probe_read(&self.rb_node) }.ok()
    }
    pub fn fi_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fi_list) }.ok()
    }
    pub fn f6i_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.f6i_list) }.ok()
    }
    pub fn fdb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.fdb_list) }.ok()
    }
    pub fn grp_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.grp_list) }.ok()
    }
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn protocol(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn nh_flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.nh_flags) }.ok()
    }
    pub fn is_group(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_group) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn nh_info(&self) -> Option<*mut nh_info> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nh_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nh_grp(&self) -> Option<*mut nh_group> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.nh_grp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nexthop__bindgen_ty_1 {
    pub fn nh_info(&self) -> Option<*mut nh_info> {
        let v = unsafe { crate::bpf_probe_read(&self.nh_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nh_grp(&self) -> Option<*mut nh_group> {
        let v = unsafe { crate::bpf_probe_read(&self.nh_grp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nh_info {
    pub fn dev_hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.dev_hash) }.ok()
    }
    pub fn nh_parent(&self) -> Option<*mut nexthop> {
        let v = unsafe { crate::bpf_probe_read(&self.nh_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn reject_nh(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.reject_nh) }.ok()
    }
    pub fn fdb_nh(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fdb_nh) }.ok()
    }
    pub fn fib_nhc(&self) -> Option<fib_nh_common> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fib_nhc) }.ok()
    }
    pub fn fib_nh(&self) -> Option<fib_nh> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fib_nh) }.ok()
    }
    pub fn fib6_nh(&self) -> Option<fib6_nh> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.fib6_nh) }.ok()
    }
}
impl nh_info__bindgen_ty_1 {
    pub fn fib_nhc(&self) -> Option<fib_nh_common> {
        unsafe { crate::bpf_probe_read(&self.fib_nhc) }.ok()
    }
    pub fn fib_nh(&self) -> Option<fib_nh> {
        unsafe { crate::bpf_probe_read(&self.fib_nh) }.ok()
    }
    pub fn fib6_nh(&self) -> Option<fib6_nh> {
        unsafe { crate::bpf_probe_read(&self.fib6_nh) }.ok()
    }
}
impl nh_grp_entry {
    pub fn nh(&self) -> Option<*mut nexthop> {
        let v = unsafe { crate::bpf_probe_read(&self.nh) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn weight(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.weight) }.ok()
    }
    pub fn upper_bound(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.upper_bound) }.ok()
    }
    pub fn nh_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.nh_list) }.ok()
    }
    pub fn nh_parent(&self) -> Option<*mut nexthop> {
        let v = unsafe { crate::bpf_probe_read(&self.nh_parent) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl nh_group {
    pub fn spare(&self) -> Option<*mut nh_group> {
        let v = unsafe { crate::bpf_probe_read(&self.spare) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_nh(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.num_nh) }.ok()
    }
    pub fn mpath(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.mpath) }.ok()
    }
    pub fn fdb_nh(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fdb_nh) }.ok()
    }
    pub fn has_v4(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_v4) }.ok()
    }
    pub fn nh_entries(&self) -> Option<__IncompleteArrayField<nh_grp_entry>> {
        unsafe { crate::bpf_probe_read(&self.nh_entries) }.ok()
    }
}
impl wpan_phy_supported {
    pub fn channels(&self) -> Option<[u32_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.channels) }.ok()
    }
    pub fn cca_modes(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cca_modes) }.ok()
    }
    pub fn cca_opts(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cca_opts) }.ok()
    }
    pub fn iftypes(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.iftypes) }.ok()
    }
    pub fn lbt(&self) -> Option<nl802154_supported_bool_states::Type> {
        unsafe { crate::bpf_probe_read(&self.lbt) }.ok()
    }
    pub fn min_minbe(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.min_minbe) }.ok()
    }
    pub fn max_minbe(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_minbe) }.ok()
    }
    pub fn min_maxbe(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.min_maxbe) }.ok()
    }
    pub fn max_maxbe(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_maxbe) }.ok()
    }
    pub fn min_csma_backoffs(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.min_csma_backoffs) }.ok()
    }
    pub fn max_csma_backoffs(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_csma_backoffs) }.ok()
    }
    pub fn min_frame_retries(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.min_frame_retries) }.ok()
    }
    pub fn max_frame_retries(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.max_frame_retries) }.ok()
    }
    pub fn tx_powers_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.tx_powers_size) }.ok()
    }
    pub fn cca_ed_levels_size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.cca_ed_levels_size) }.ok()
    }
    pub fn tx_powers(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.tx_powers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cca_ed_levels(&self) -> Option<*const s32> {
        let v = unsafe { crate::bpf_probe_read(&self.cca_ed_levels) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl wpan_phy_cca {
    pub fn mode(&self) -> Option<nl802154_cca_modes::Type> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn opt(&self) -> Option<nl802154_cca_opts::Type> {
        unsafe { crate::bpf_probe_read(&self.opt) }.ok()
    }
}
impl wpan_phy {
    pub fn privid(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.privid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn current_channel(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.current_channel) }.ok()
    }
    pub fn current_page(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.current_page) }.ok()
    }
    pub fn supported(&self) -> Option<wpan_phy_supported> {
        unsafe { crate::bpf_probe_read(&self.supported) }.ok()
    }
    pub fn transmit_power(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.transmit_power) }.ok()
    }
    pub fn cca(&self) -> Option<wpan_phy_cca> {
        unsafe { crate::bpf_probe_read(&self.cca) }.ok()
    }
    pub fn perm_extended_addr(&self) -> Option<__le64> {
        unsafe { crate::bpf_probe_read(&self.perm_extended_addr) }.ok()
    }
    pub fn cca_ed_level(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.cca_ed_level) }.ok()
    }
    pub fn symbol_duration(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.symbol_duration) }.ok()
    }
    pub fn lifs_period(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.lifs_period) }.ok()
    }
    pub fn sifs_period(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sifs_period) }.ok()
    }
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn _net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self._net) }.ok()
    }
    pub fn priv_(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.priv_) }.ok()
    }
}
impl ieee802154_addr {
    pub fn mode(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn pan_id(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.pan_id) }.ok()
    }
    pub fn short_addr(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.short_addr) }.ok()
    }
    pub fn extended_addr(&self) -> Option<__le64> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.extended_addr) }.ok()
    }
}
impl ieee802154_addr__bindgen_ty_1 {
    pub fn short_addr(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.short_addr) }.ok()
    }
    pub fn extended_addr(&self) -> Option<__le64> {
        unsafe { crate::bpf_probe_read(&self.extended_addr) }.ok()
    }
}
impl wpan_dev_header_ops {
    pub fn create(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: *const ieee802154_addr,
                arg4: *const ieee802154_addr,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.create) }.ok()
    }
}
impl cpuidle_state_kobj {
    pub fn state(&self) -> Option<*mut cpuidle_state> {
        let v = unsafe { crate::bpf_probe_read(&self.state) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state_usage(&self) -> Option<*mut cpuidle_state_usage> {
        let v = unsafe { crate::bpf_probe_read(&self.state_usage) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj_unregister(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.kobj_unregister) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
    pub fn device(&self) -> Option<*mut cpuidle_device> {
        let v = unsafe { crate::bpf_probe_read(&self.device) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cpuidle_device_kobj {
    pub fn dev(&self) -> Option<*mut cpuidle_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn kobj_unregister(&self) -> Option<completion> {
        unsafe { crate::bpf_probe_read(&self.kobj_unregister) }.ok()
    }
    pub fn kobj(&self) -> Option<kobject> {
        unsafe { crate::bpf_probe_read(&self.kobj) }.ok()
    }
}
impl libipw_device {}
impl iw_public_data {
    pub fn spy_data(&self) -> Option<*mut iw_spy_data> {
        let v = unsafe { crate::bpf_probe_read(&self.spy_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn libipw(&self) -> Option<*mut libipw_device> {
        let v = unsafe { crate::bpf_probe_read(&self.libipw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl iw_param {
    pub fn value(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.value) }.ok()
    }
    pub fn fixed(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.fixed) }.ok()
    }
    pub fn disabled(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.disabled) }.ok()
    }
    pub fn flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl iw_point {
    pub fn pointer(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.pointer) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn length(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.length) }.ok()
    }
    pub fn flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl iw_freq {
    pub fn m(&self) -> Option<__s32> {
        unsafe { crate::bpf_probe_read(&self.m) }.ok()
    }
    pub fn e(&self) -> Option<__s16> {
        unsafe { crate::bpf_probe_read(&self.e) }.ok()
    }
    pub fn i(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.i) }.ok()
    }
    pub fn flags(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl iw_quality {
    pub fn qual(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.qual) }.ok()
    }
    pub fn level(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn noise(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.noise) }.ok()
    }
    pub fn updated(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.updated) }.ok()
    }
}
impl iw_discarded {
    pub fn nwid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nwid) }.ok()
    }
    pub fn code(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
    pub fn fragment(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.fragment) }.ok()
    }
    pub fn retries(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.retries) }.ok()
    }
    pub fn misc(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.misc) }.ok()
    }
}
impl iw_missed {
    pub fn beacon(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.beacon) }.ok()
    }
}
impl iw_statistics {
    pub fn status(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
    pub fn qual(&self) -> Option<iw_quality> {
        unsafe { crate::bpf_probe_read(&self.qual) }.ok()
    }
    pub fn discard(&self) -> Option<iw_discarded> {
        unsafe { crate::bpf_probe_read(&self.discard) }.ok()
    }
    pub fn miss(&self) -> Option<iw_missed> {
        unsafe { crate::bpf_probe_read(&self.miss) }.ok()
    }
}
impl iwreq_data {
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn essid(&self) -> Option<iw_point> {
        unsafe { crate::bpf_probe_read(&self.essid) }.ok()
    }
    pub fn nwid(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.nwid) }.ok()
    }
    pub fn freq(&self) -> Option<iw_freq> {
        unsafe { crate::bpf_probe_read(&self.freq) }.ok()
    }
    pub fn sens(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.sens) }.ok()
    }
    pub fn bitrate(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.bitrate) }.ok()
    }
    pub fn txpower(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.txpower) }.ok()
    }
    pub fn rts(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.rts) }.ok()
    }
    pub fn frag(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.frag) }.ok()
    }
    pub fn mode(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
    pub fn retry(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.retry) }.ok()
    }
    pub fn encoding(&self) -> Option<iw_point> {
        unsafe { crate::bpf_probe_read(&self.encoding) }.ok()
    }
    pub fn power(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.power) }.ok()
    }
    pub fn qual(&self) -> Option<iw_quality> {
        unsafe { crate::bpf_probe_read(&self.qual) }.ok()
    }
    pub fn ap_addr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.ap_addr) }.ok()
    }
    pub fn addr(&self) -> Option<sockaddr> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn param(&self) -> Option<iw_param> {
        unsafe { crate::bpf_probe_read(&self.param) }.ok()
    }
    pub fn data(&self) -> Option<iw_point> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl iw_priv_args {
    pub fn cmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn set_args(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.set_args) }.ok()
    }
    pub fn get_args(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.get_args) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
}
impl iw_request_info {
    pub fn cmd(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.cmd) }.ok()
    }
    pub fn flags(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl iw_spy_data {
    pub fn spy_number(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.spy_number) }.ok()
    }
    pub fn spy_address(&self) -> Option<[u_char; 48usize]> {
        unsafe { crate::bpf_probe_read(&self.spy_address) }.ok()
    }
    pub fn spy_stat(&self) -> Option<[iw_quality; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.spy_stat) }.ok()
    }
    pub fn spy_thr_low(&self) -> Option<iw_quality> {
        unsafe { crate::bpf_probe_read(&self.spy_thr_low) }.ok()
    }
    pub fn spy_thr_high(&self) -> Option<iw_quality> {
        unsafe { crate::bpf_probe_read(&self.spy_thr_high) }.ok()
    }
    pub fn spy_thr_under(&self) -> Option<[u_char; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.spy_thr_under) }.ok()
    }
}
impl prot_inuse {
    pub fn val(&self) -> Option<[::aya_bpf_cty::c_int; 64usize]> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl fastopen_queue {
    pub fn rskq_rst_head(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.rskq_rst_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rskq_rst_tail(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.rskq_rst_tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn qlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn max_qlen(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_qlen) }.ok()
    }
    pub fn ctx(&self) -> Option<*mut tcp_fastopen_context> {
        let v = unsafe { crate::bpf_probe_read(&self.ctx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl request_sock_queue {
    pub fn rskq_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.rskq_lock) }.ok()
    }
    pub fn rskq_defer_accept(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.rskq_defer_accept) }.ok()
    }
    pub fn synflood_warned(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.synflood_warned) }.ok()
    }
    pub fn qlen(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.qlen) }.ok()
    }
    pub fn young(&self) -> Option<atomic_t> {
        unsafe { crate::bpf_probe_read(&self.young) }.ok()
    }
    pub fn rskq_accept_head(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.rskq_accept_head) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rskq_accept_tail(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.rskq_accept_tail) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fastopenq(&self) -> Option<fastopen_queue> {
        unsafe { crate::bpf_probe_read(&self.fastopenq) }.ok()
    }
}
impl inet_connection_sock_af_ops {
    pub fn queue_xmit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sk_buff,
                arg3: *mut flowi,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.queue_xmit) }.ok()
    }
    pub fn send_check(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff)>>
    {
        unsafe { crate::bpf_probe_read(&self.send_check) }.ok()
    }
    pub fn rebuild_header(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.rebuild_header) }.ok()
    }
    pub fn sk_rx_dst_set(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const sk_buff)>>
    {
        unsafe { crate::bpf_probe_read(&self.sk_rx_dst_set) }.ok()
    }
    pub fn conn_request(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.conn_request) }.ok()
    }
    pub fn syn_recv_sock(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sock,
                arg2: *mut sk_buff,
                arg3: *mut request_sock,
                arg4: *mut dst_entry,
                arg5: *mut request_sock,
                arg6: *mut bool_,
            ) -> *mut sock,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.syn_recv_sock) }.ok()
    }
    pub fn net_header_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.net_header_len) }.ok()
    }
    pub fn net_frag_header_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.net_frag_header_len) }.ok()
    }
    pub fn sockaddr_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.sockaddr_len) }.ok()
    }
    pub fn setsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: sockptr_t,
                arg5: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.setsockopt) }.ok()
    }
    pub fn getsockopt(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: *mut ::aya_bpf_cty::c_char,
                arg5: *mut ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.getsockopt) }.ok()
    }
    pub fn addr2sockaddr(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sockaddr)>>
    {
        unsafe { crate::bpf_probe_read(&self.addr2sockaddr) }.ok()
    }
    pub fn mtu_reduced(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.mtu_reduced) }.ok()
    }
}
impl inet_connection_sock {
    pub fn icsk_inet(&self) -> Option<inet_sock> {
        unsafe { crate::bpf_probe_read(&self.icsk_inet) }.ok()
    }
    pub fn icsk_accept_queue(&self) -> Option<request_sock_queue> {
        unsafe { crate::bpf_probe_read(&self.icsk_accept_queue) }.ok()
    }
    pub fn icsk_bind_hash(&self) -> Option<*mut inet_bind_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.icsk_bind_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icsk_timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.icsk_timeout) }.ok()
    }
    pub fn icsk_retransmit_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.icsk_retransmit_timer) }.ok()
    }
    pub fn icsk_delack_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.icsk_delack_timer) }.ok()
    }
    pub fn icsk_rto(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.icsk_rto) }.ok()
    }
    pub fn icsk_rto_min(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.icsk_rto_min) }.ok()
    }
    pub fn icsk_delack_max(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.icsk_delack_max) }.ok()
    }
    pub fn icsk_pmtu_cookie(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.icsk_pmtu_cookie) }.ok()
    }
    pub fn icsk_ca_ops(&self) -> Option<*const tcp_congestion_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.icsk_ca_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icsk_af_ops(&self) -> Option<*const inet_connection_sock_af_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.icsk_af_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icsk_ulp_ops(&self) -> Option<*const tcp_ulp_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.icsk_ulp_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icsk_ulp_data(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.icsk_ulp_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn icsk_clean_acked(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_)>> {
        unsafe { crate::bpf_probe_read(&self.icsk_clean_acked) }.ok()
    }
    pub fn icsk_listen_portaddr_node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.icsk_listen_portaddr_node) }.ok()
    }
    pub fn icsk_sync_mss(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: u32_) -> ::aya_bpf_cty::c_uint,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.icsk_sync_mss) }.ok()
    }
    pub fn icsk_retransmits(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.icsk_retransmits) }.ok()
    }
    pub fn icsk_pending(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.icsk_pending) }.ok()
    }
    pub fn icsk_backoff(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.icsk_backoff) }.ok()
    }
    pub fn icsk_syn_retries(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.icsk_syn_retries) }.ok()
    }
    pub fn icsk_probes_out(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.icsk_probes_out) }.ok()
    }
    pub fn icsk_ext_hdr_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.icsk_ext_hdr_len) }.ok()
    }
    pub fn icsk_ack(&self) -> Option<inet_connection_sock__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.icsk_ack) }.ok()
    }
    pub fn icsk_mtup(&self) -> Option<inet_connection_sock__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.icsk_mtup) }.ok()
    }
    pub fn icsk_probes_tstamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.icsk_probes_tstamp) }.ok()
    }
    pub fn icsk_user_timeout(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.icsk_user_timeout) }.ok()
    }
    pub fn icsk_ca_priv(&self) -> Option<[u64_; 13usize]> {
        unsafe { crate::bpf_probe_read(&self.icsk_ca_priv) }.ok()
    }
}
impl inet_connection_sock__bindgen_ty_1 {
    pub fn pending(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
    pub fn quick(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.quick) }.ok()
    }
    pub fn pingpong(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pingpong) }.ok()
    }
    pub fn retry(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.retry) }.ok()
    }
    pub fn ato(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ato) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn lrcvtime(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.lrcvtime) }.ok()
    }
    pub fn last_seg_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.last_seg_size) }.ok()
    }
    pub fn rcv_mss(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.rcv_mss) }.ok()
    }
}
impl inet_connection_sock__bindgen_ty_2 {
    pub fn enabled(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.enabled) }.ok()
    }
    pub fn search_high(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.search_high) }.ok()
    }
    pub fn search_low(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.search_low) }.ok()
    }
    pub fn probe_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.probe_size) }.ok()
    }
    pub fn probe_timestamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.probe_timestamp) }.ok()
    }
}
impl inet_bind_bucket {
    pub fn ib_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.ib_net) }.ok()
    }
    pub fn l3mdev(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.l3mdev) }.ok()
    }
    pub fn port(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn fastreuse(&self) -> Option<::aya_bpf_cty::c_schar> {
        unsafe { crate::bpf_probe_read(&self.fastreuse) }.ok()
    }
    pub fn fastreuseport(&self) -> Option<::aya_bpf_cty::c_schar> {
        unsafe { crate::bpf_probe_read(&self.fastreuseport) }.ok()
    }
    pub fn fastuid(&self) -> Option<kuid_t> {
        unsafe { crate::bpf_probe_read(&self.fastuid) }.ok()
    }
    pub fn fast_v6_rcv_saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.fast_v6_rcv_saddr) }.ok()
    }
    pub fn fast_rcv_saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.fast_rcv_saddr) }.ok()
    }
    pub fn fast_sk_family(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.fast_sk_family) }.ok()
    }
    pub fn fast_ipv6_only(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.fast_ipv6_only) }.ok()
    }
    pub fn node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn owners(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.owners) }.ok()
    }
}
impl tcp_ulp_ops {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn init(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.init) }.ok()
    }
    pub fn update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut proto,
                arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.update) }.ok()
    }
    pub fn release(&self) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.release) }.ok()
    }
    pub fn get_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_info) }.ok()
    }
    pub fn get_info_size(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const sock) -> size_t>> {
        unsafe { crate::bpf_probe_read(&self.get_info_size) }.ok()
    }
    pub fn clone(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const request_sock, arg2: *mut sock, arg3: gfp_t),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.clone) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
    pub fn owner(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.owner) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcp_fastopen_cookie {
    pub fn val(&self) -> Option<[__le64; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn len(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn exp(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.exp) }.ok()
    }
}
impl tcp_sack_block {
    pub fn start_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start_seq) }.ok()
    }
    pub fn end_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.end_seq) }.ok()
    }
}
impl tcp_options_received {
    pub fn ts_recent_stamp(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ts_recent_stamp) }.ok()
    }
    pub fn ts_recent(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ts_recent) }.ok()
    }
    pub fn rcv_tsval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_tsval) }.ok()
    }
    pub fn rcv_tsecr(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_tsecr) }.ok()
    }
    pub fn num_sacks(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.num_sacks) }.ok()
    }
    pub fn user_mss(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.user_mss) }.ok()
    }
    pub fn mss_clamp(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.mss_clamp) }.ok()
    }
}
impl tcp_rack {
    pub fn mstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.mstamp) }.ok()
    }
    pub fn rtt_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rtt_us) }.ok()
    }
    pub fn end_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.end_seq) }.ok()
    }
    pub fn last_delivered(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_delivered) }.ok()
    }
    pub fn reo_wnd_steps(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.reo_wnd_steps) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<u16> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl tcp_sock {
    pub fn inet_conn(&self) -> Option<inet_connection_sock> {
        unsafe { crate::bpf_probe_read(&self.inet_conn) }.ok()
    }
    pub fn tcp_header_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.tcp_header_len) }.ok()
    }
    pub fn gso_segs(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.gso_segs) }.ok()
    }
    pub fn pred_flags(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.pred_flags) }.ok()
    }
    pub fn bytes_received(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bytes_received) }.ok()
    }
    pub fn segs_in(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.segs_in) }.ok()
    }
    pub fn data_segs_in(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_segs_in) }.ok()
    }
    pub fn rcv_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_nxt) }.ok()
    }
    pub fn copied_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.copied_seq) }.ok()
    }
    pub fn rcv_wup(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_wup) }.ok()
    }
    pub fn snd_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_nxt) }.ok()
    }
    pub fn segs_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.segs_out) }.ok()
    }
    pub fn data_segs_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_segs_out) }.ok()
    }
    pub fn bytes_sent(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bytes_sent) }.ok()
    }
    pub fn bytes_acked(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bytes_acked) }.ok()
    }
    pub fn dsack_dups(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dsack_dups) }.ok()
    }
    pub fn snd_una(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_una) }.ok()
    }
    pub fn snd_sml(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_sml) }.ok()
    }
    pub fn rcv_tstamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_tstamp) }.ok()
    }
    pub fn lsndtime(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.lsndtime) }.ok()
    }
    pub fn last_oow_ack_time(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_oow_ack_time) }.ok()
    }
    pub fn compressed_ack_rcv_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.compressed_ack_rcv_nxt) }.ok()
    }
    pub fn tsoffset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tsoffset) }.ok()
    }
    pub fn tsq_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tsq_node) }.ok()
    }
    pub fn tsorted_sent_queue(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.tsorted_sent_queue) }.ok()
    }
    pub fn snd_wl1(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_wl1) }.ok()
    }
    pub fn snd_wnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_wnd) }.ok()
    }
    pub fn max_window(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_window) }.ok()
    }
    pub fn mss_cache(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mss_cache) }.ok()
    }
    pub fn window_clamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.window_clamp) }.ok()
    }
    pub fn rcv_ssthresh(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_ssthresh) }.ok()
    }
    pub fn rack(&self) -> Option<tcp_rack> {
        unsafe { crate::bpf_probe_read(&self.rack) }.ok()
    }
    pub fn advmss(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.advmss) }.ok()
    }
    pub fn compressed_ack(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.compressed_ack) }.ok()
    }
    pub fn chrono_start(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chrono_start) }.ok()
    }
    pub fn chrono_stat(&self) -> Option<[u32_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.chrono_stat) }.ok()
    }
    pub fn repair_queue(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.repair_queue) }.ok()
    }
    pub fn tlp_high_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tlp_high_seq) }.ok()
    }
    pub fn tcp_tx_delay(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tcp_tx_delay) }.ok()
    }
    pub fn tcp_wstamp_ns(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tcp_wstamp_ns) }.ok()
    }
    pub fn tcp_clock_cache(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tcp_clock_cache) }.ok()
    }
    pub fn tcp_mstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.tcp_mstamp) }.ok()
    }
    pub fn srtt_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.srtt_us) }.ok()
    }
    pub fn mdev_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mdev_us) }.ok()
    }
    pub fn mdev_max_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mdev_max_us) }.ok()
    }
    pub fn rttvar_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rttvar_us) }.ok()
    }
    pub fn rtt_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rtt_seq) }.ok()
    }
    pub fn rtt_min(&self) -> Option<minmax> {
        unsafe { crate::bpf_probe_read(&self.rtt_min) }.ok()
    }
    pub fn packets_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.packets_out) }.ok()
    }
    pub fn retrans_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.retrans_out) }.ok()
    }
    pub fn max_packets_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_packets_out) }.ok()
    }
    pub fn max_packets_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_packets_seq) }.ok()
    }
    pub fn urg_data(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.urg_data) }.ok()
    }
    pub fn ecn_flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ecn_flags) }.ok()
    }
    pub fn keepalive_probes(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.keepalive_probes) }.ok()
    }
    pub fn reordering(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reordering) }.ok()
    }
    pub fn reord_seen(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.reord_seen) }.ok()
    }
    pub fn snd_up(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_up) }.ok()
    }
    pub fn rx_opt(&self) -> Option<tcp_options_received> {
        unsafe { crate::bpf_probe_read(&self.rx_opt) }.ok()
    }
    pub fn snd_ssthresh(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_ssthresh) }.ok()
    }
    pub fn snd_cwnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd) }.ok()
    }
    pub fn snd_cwnd_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd_cnt) }.ok()
    }
    pub fn snd_cwnd_clamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd_clamp) }.ok()
    }
    pub fn snd_cwnd_used(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd_used) }.ok()
    }
    pub fn snd_cwnd_stamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd_stamp) }.ok()
    }
    pub fn prior_cwnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prior_cwnd) }.ok()
    }
    pub fn prr_delivered(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prr_delivered) }.ok()
    }
    pub fn prr_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prr_out) }.ok()
    }
    pub fn delivered(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.delivered) }.ok()
    }
    pub fn delivered_ce(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.delivered_ce) }.ok()
    }
    pub fn lost(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.lost) }.ok()
    }
    pub fn app_limited(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.app_limited) }.ok()
    }
    pub fn first_tx_mstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.first_tx_mstamp) }.ok()
    }
    pub fn delivered_mstamp(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.delivered_mstamp) }.ok()
    }
    pub fn rate_delivered(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rate_delivered) }.ok()
    }
    pub fn rate_interval_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rate_interval_us) }.ok()
    }
    pub fn rcv_wnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_wnd) }.ok()
    }
    pub fn write_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.write_seq) }.ok()
    }
    pub fn notsent_lowat(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.notsent_lowat) }.ok()
    }
    pub fn pushed_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pushed_seq) }.ok()
    }
    pub fn lost_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.lost_out) }.ok()
    }
    pub fn sacked_out(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.sacked_out) }.ok()
    }
    pub fn pacing_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.pacing_timer) }.ok()
    }
    pub fn compressed_ack_timer(&self) -> Option<hrtimer> {
        unsafe { crate::bpf_probe_read(&self.compressed_ack_timer) }.ok()
    }
    pub fn lost_skb_hint(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.lost_skb_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn retransmit_skb_hint(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.retransmit_skb_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn out_of_order_queue(&self) -> Option<rb_root> {
        unsafe { crate::bpf_probe_read(&self.out_of_order_queue) }.ok()
    }
    pub fn ooo_last_skb(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.ooo_last_skb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn duplicate_sack(&self) -> Option<[tcp_sack_block; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.duplicate_sack) }.ok()
    }
    pub fn selective_acks(&self) -> Option<[tcp_sack_block; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.selective_acks) }.ok()
    }
    pub fn recv_sack_cache(&self) -> Option<[tcp_sack_block; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.recv_sack_cache) }.ok()
    }
    pub fn highest_sack(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.highest_sack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn lost_cnt_hint(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.lost_cnt_hint) }.ok()
    }
    pub fn prior_ssthresh(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prior_ssthresh) }.ok()
    }
    pub fn high_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.high_seq) }.ok()
    }
    pub fn retrans_stamp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.retrans_stamp) }.ok()
    }
    pub fn undo_marker(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.undo_marker) }.ok()
    }
    pub fn undo_retrans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.undo_retrans) }.ok()
    }
    pub fn bytes_retrans(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bytes_retrans) }.ok()
    }
    pub fn total_retrans(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.total_retrans) }.ok()
    }
    pub fn urg_seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.urg_seq) }.ok()
    }
    pub fn keepalive_time(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.keepalive_time) }.ok()
    }
    pub fn keepalive_intvl(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.keepalive_intvl) }.ok()
    }
    pub fn linger2(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.linger2) }.ok()
    }
    pub fn bpf_sock_ops_cb_flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.bpf_sock_ops_cb_flags) }.ok()
    }
    pub fn timeout_rehash(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.timeout_rehash) }.ok()
    }
    pub fn rcv_ooopack(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_ooopack) }.ok()
    }
    pub fn rcv_rtt_last_tsecr(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_rtt_last_tsecr) }.ok()
    }
    pub fn rcv_rtt_est(&self) -> Option<tcp_sock__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.rcv_rtt_est) }.ok()
    }
    pub fn rcvq_space(&self) -> Option<tcp_sock__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.rcvq_space) }.ok()
    }
    pub fn mtu_probe(&self) -> Option<tcp_sock__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.mtu_probe) }.ok()
    }
    pub fn mtu_info(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mtu_info) }.ok()
    }
    pub fn is_mptcp(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_mptcp) }.ok()
    }
    pub fn syn_smc(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.syn_smc) }.ok()
    }
    pub fn af_specific(&self) -> Option<*const tcp_sock_af_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.af_specific) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn md5sig_info(&self) -> Option<*mut tcp_md5sig_info> {
        let v = unsafe { crate::bpf_probe_read(&self.md5sig_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fastopen_req(&self) -> Option<*mut tcp_fastopen_request> {
        let v = unsafe { crate::bpf_probe_read(&self.fastopen_req) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fastopen_rsk(&self) -> Option<*mut request_sock> {
        let v = unsafe { crate::bpf_probe_read(&self.fastopen_rsk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn saved_syn(&self) -> Option<*mut saved_syn> {
        let v = unsafe { crate::bpf_probe_read(&self.saved_syn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcp_sock__bindgen_ty_1 {
    pub fn rtt_us(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rtt_us) }.ok()
    }
    pub fn seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
}
impl tcp_sock__bindgen_ty_2 {
    pub fn space(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.space) }.ok()
    }
    pub fn seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn time(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.time) }.ok()
    }
}
impl tcp_sock__bindgen_ty_3 {
    pub fn probe_seq_start(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.probe_seq_start) }.ok()
    }
    pub fn probe_seq_end(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.probe_seq_end) }.ok()
    }
}
impl tcp_sock_af_ops {
    pub fn md5_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sock, arg2: *const sock) -> *mut tcp_md5sig_key,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.md5_lookup) }.ok()
    }
    pub fn calc_md5_hash(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_char,
                arg2: *const tcp_md5sig_key,
                arg3: *const sock,
                arg4: *const sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.calc_md5_hash) }.ok()
    }
    pub fn md5_parse(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
                arg3: sockptr_t,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.md5_parse) }.ok()
    }
}
impl tcp_md5sig_info {
    pub fn head(&self) -> Option<hlist_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl tcp_fastopen_request {
    pub fn cookie(&self) -> Option<tcp_fastopen_cookie> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn data(&self) -> Option<*mut msghdr> {
        let v = unsafe { crate::bpf_probe_read(&self.data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn copied(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.copied) }.ok()
    }
    pub fn uarg(&self) -> Option<*mut ubuf_info> {
        let v = unsafe { crate::bpf_probe_read(&self.uarg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcp_md5_addr {
    pub fn a4(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.a4) }.ok()
    }
    pub fn a6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.a6) }.ok()
    }
}
impl tcp_md5sig_key {
    pub fn node(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.node) }.ok()
    }
    pub fn keylen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.keylen) }.ok()
    }
    pub fn family(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn prefixlen(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.prefixlen) }.ok()
    }
    pub fn addr(&self) -> Option<tcp_md5_addr> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn l3index(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.l3index) }.ok()
    }
    pub fn key(&self) -> Option<[u8_; 80usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl inet_request_sock {
    pub fn req(&self) -> Option<request_sock> {
        unsafe { crate::bpf_probe_read(&self.req) }.ok()
    }
    pub fn ir_mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ir_mark) }.ok()
    }
    pub fn ireq_opt(&self) -> Option<*mut ip_options_rcu> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ireq_opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6_opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.ipv6_opt) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pktopts(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.pktopts) }
            .ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl inet_request_sock__bindgen_ty_1 {
    pub fn ireq_opt(&self) -> Option<*mut ip_options_rcu> {
        let v = unsafe { crate::bpf_probe_read(&self.ireq_opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ipv6_opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv6_opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pktopts(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pktopts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl inet_request_sock__bindgen_ty_1__bindgen_ty_1 {
    pub fn ipv6_opt(&self) -> Option<*mut ipv6_txoptions> {
        let v = unsafe { crate::bpf_probe_read(&self.ipv6_opt) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pktopts(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.pktopts) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcp_request_sock {
    pub fn req(&self) -> Option<inet_request_sock> {
        unsafe { crate::bpf_probe_read(&self.req) }.ok()
    }
    pub fn af_specific(&self) -> Option<*const tcp_request_sock_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.af_specific) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn snt_synack(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.snt_synack) }.ok()
    }
    pub fn tfo_listener(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tfo_listener) }.ok()
    }
    pub fn is_mptcp(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_mptcp) }.ok()
    }
    pub fn drop_req(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.drop_req) }.ok()
    }
    pub fn txhash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.txhash) }.ok()
    }
    pub fn rcv_isn(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_isn) }.ok()
    }
    pub fn snt_isn(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.snt_isn) }.ok()
    }
    pub fn ts_off(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ts_off) }.ok()
    }
    pub fn last_oow_ack_time(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.last_oow_ack_time) }.ok()
    }
    pub fn rcv_nxt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rcv_nxt) }.ok()
    }
    pub fn syn_tos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.syn_tos) }.ok()
    }
}
impl tcp_request_sock_ops {
    pub fn mss_clamp(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.mss_clamp) }.ok()
    }
    pub fn req_md5_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sock, arg2: *const sock) -> *mut tcp_md5sig_key,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.req_md5_lookup) }.ok()
    }
    pub fn calc_md5_hash(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::aya_bpf_cty::c_char,
                arg2: *const tcp_md5sig_key,
                arg3: *const sock,
                arg4: *const sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.calc_md5_hash) }.ok()
    }
    pub fn cookie_init_seq(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut __u16) -> __u32,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cookie_init_seq) }.ok()
    }
    pub fn route_req(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sock,
                arg2: *mut sk_buff,
                arg3: *mut flowi,
                arg4: *mut request_sock,
            ) -> *mut dst_entry,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.route_req) }.ok()
    }
    pub fn init_seq(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *const sk_buff) -> u32_>> {
        unsafe { crate::bpf_probe_read(&self.init_seq) }.ok()
    }
    pub fn init_ts_off(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const net, arg2: *const sk_buff) -> u32_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.init_ts_off) }.ok()
    }
    pub fn send_synack(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sock,
                arg2: *mut dst_entry,
                arg3: *mut flowi,
                arg4: *mut request_sock,
                arg5: *mut tcp_fastopen_cookie,
                arg6: tcp_synack_type::Type,
                arg7: *mut sk_buff,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.send_synack) }.ok()
    }
}
impl qdisc_walker {
    pub fn stop(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn skip(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.skip) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn fn_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Qdisc,
                arg2: ::aya_bpf_cty::c_ulong,
                arg3: *mut qdisc_walker,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
}
impl net_rate_estimator {
    pub fn bstats(&self) -> Option<*mut gnet_stats_basic_packed> {
        let v = unsafe { crate::bpf_probe_read(&self.bstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stats_lock(&self) -> Option<*mut spinlock_t> {
        let v = unsafe { crate::bpf_probe_read(&self.stats_lock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn running(&self) -> Option<*mut seqcount_t> {
        let v = unsafe { crate::bpf_probe_read(&self.running) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_bstats(&self) -> Option<*mut gnet_stats_basic_cpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_bstats) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ewma_log(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ewma_log) }.ok()
    }
    pub fn intvl_log(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.intvl_log) }.ok()
    }
    pub fn seq(&self) -> Option<seqcount_t> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn last_packets(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_packets) }.ok()
    }
    pub fn last_bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.last_bytes) }.ok()
    }
    pub fn avpps(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avpps) }.ok()
    }
    pub fn avbps(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.avbps) }.ok()
    }
    pub fn next_jiffies(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.next_jiffies) }.ok()
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl xt_table {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn valid_hooks(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.valid_hooks) }.ok()
    }
    pub fn private(&self) -> Option<*mut xt_table_info> {
        let v = unsafe { crate::bpf_probe_read(&self.private) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn me(&self) -> Option<*mut module> {
        let v = unsafe { crate::bpf_probe_read(&self.me) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn af(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.af) }.ok()
    }
    pub fn priority(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn table_init(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut net) -> ::aya_bpf_cty::c_int>>
    {
        unsafe { crate::bpf_probe_read(&self.table_init) }.ok()
    }
    pub fn name(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.name) }.ok()
    }
}
impl nf_inet_addr {
    pub fn all(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn ip(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip) }.ok()
    }
    pub fn ip6(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6) }.ok()
    }
    pub fn in_(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.in_) }.ok()
    }
    pub fn in6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.in6) }.ok()
    }
}
impl ip_ct_tcp_state {
    pub fn td_end(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.td_end) }.ok()
    }
    pub fn td_maxend(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.td_maxend) }.ok()
    }
    pub fn td_maxwin(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.td_maxwin) }.ok()
    }
    pub fn td_maxack(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.td_maxack) }.ok()
    }
    pub fn td_scale(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.td_scale) }.ok()
    }
    pub fn flags(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl ip_ct_tcp {
    pub fn seen(&self) -> Option<[ip_ct_tcp_state; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.seen) }.ok()
    }
    pub fn state(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn last_dir(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_dir) }.ok()
    }
    pub fn retrans(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.retrans) }.ok()
    }
    pub fn last_index(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_index) }.ok()
    }
    pub fn last_seq(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.last_seq) }.ok()
    }
    pub fn last_ack(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.last_ack) }.ok()
    }
    pub fn last_end(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.last_end) }.ok()
    }
    pub fn last_win(&self) -> Option<u_int16_t> {
        unsafe { crate::bpf_probe_read(&self.last_win) }.ok()
    }
    pub fn last_wscale(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_wscale) }.ok()
    }
    pub fn last_flags(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_flags) }.ok()
    }
}
impl nf_conntrack_man_proto {
    pub fn all(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn tcp(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.tcp) }.ok()
    }
    pub fn udp(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.udp) }.ok()
    }
    pub fn icmp(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.icmp) }.ok()
    }
    pub fn dccp(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.dccp) }.ok()
    }
    pub fn sctp(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.sctp) }.ok()
    }
    pub fn gre(&self) -> Option<nf_conntrack_man_proto__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.gre) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_1 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_2 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_3 {
    pub fn id(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_4 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_5 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_man_proto__bindgen_ty_6 {
    pub fn key(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl nf_ct_dccp {
    pub fn role(&self) -> Option<[u_int8_t; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.role) }.ok()
    }
    pub fn state(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn last_pkt(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_pkt) }.ok()
    }
    pub fn last_dir(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.last_dir) }.ok()
    }
    pub fn handshake_seq(&self) -> Option<u_int64_t> {
        unsafe { crate::bpf_probe_read(&self.handshake_seq) }.ok()
    }
}
impl ip_ct_sctp {
    pub fn state(&self) -> Option<sctp_conntrack::Type> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn vtag(&self) -> Option<[__be32; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.vtag) }.ok()
    }
    pub fn last_dir(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.last_dir) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl nf_ct_event_notifier {
    pub fn fcn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_bpf_cty::c_uint,
                arg2: *mut nf_ct_event,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fcn) }.ok()
    }
}
impl nf_exp_event_notifier {
    pub fn fcn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_bpf_cty::c_uint,
                arg2: *mut nf_exp_event,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fcn) }.ok()
    }
}
impl devlink_port_phys_attrs {
    pub fn port_number(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.port_number) }.ok()
    }
    pub fn split_subport_number(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.split_subport_number) }.ok()
    }
}
impl devlink_port_pci_pf_attrs {
    pub fn controller(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.controller) }.ok()
    }
    pub fn pf(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.pf) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<u8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl devlink_port_pci_vf_attrs {
    pub fn controller(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.controller) }.ok()
    }
    pub fn pf(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.pf) }.ok()
    }
    pub fn vf(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vf) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl devlink_port_attrs {
    pub fn lanes(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.lanes) }.ok()
    }
    pub fn flavour(&self) -> Option<devlink_port_flavour::Type> {
        unsafe { crate::bpf_probe_read(&self.flavour) }.ok()
    }
    pub fn switch_id(&self) -> Option<netdev_phys_item_id> {
        unsafe { crate::bpf_probe_read(&self.switch_id) }.ok()
    }
    pub fn phys(&self) -> Option<devlink_port_phys_attrs> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.phys) }.ok()
    }
    pub fn pci_pf(&self) -> Option<devlink_port_pci_pf_attrs> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pci_pf) }.ok()
    }
    pub fn pci_vf(&self) -> Option<devlink_port_pci_vf_attrs> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.pci_vf) }.ok()
    }
}
impl devlink_port_attrs__bindgen_ty_1 {
    pub fn phys(&self) -> Option<devlink_port_phys_attrs> {
        unsafe { crate::bpf_probe_read(&self.phys) }.ok()
    }
    pub fn pci_pf(&self) -> Option<devlink_port_pci_pf_attrs> {
        unsafe { crate::bpf_probe_read(&self.pci_pf) }.ok()
    }
    pub fn pci_vf(&self) -> Option<devlink_port_pci_vf_attrs> {
        unsafe { crate::bpf_probe_read(&self.pci_vf) }.ok()
    }
}
impl devlink_port {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn param_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.param_list) }.ok()
    }
    pub fn region_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.region_list) }.ok()
    }
    pub fn devlink(&self) -> Option<*mut devlink> {
        let v = unsafe { crate::bpf_probe_read(&self.devlink) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn registered(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.registered) }.ok()
    }
    pub fn type_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.type_lock) }.ok()
    }
    pub fn type_(&self) -> Option<devlink_port_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn desired_type(&self) -> Option<devlink_port_type::Type> {
        unsafe { crate::bpf_probe_read(&self.desired_type) }.ok()
    }
    pub fn type_dev(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.type_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn attrs(&self) -> Option<devlink_port_attrs> {
        unsafe { crate::bpf_probe_read(&self.attrs) }.ok()
    }
    pub fn type_warn_dw(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.type_warn_dw) }.ok()
    }
    pub fn reporter_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.reporter_list) }.ok()
    }
    pub fn reporters_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.reporters_lock) }.ok()
    }
}
impl phylink_config {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn type_(&self) -> Option<phylink_op_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn pcs_poll(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.pcs_poll) }.ok()
    }
    pub fn poll_fixed_state(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.poll_fixed_state) }.ok()
    }
    pub fn get_fixed_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut phylink_config, arg2: *mut phylink_link_state),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_fixed_state) }.ok()
    }
}
impl dsa_port {
    pub fn master(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.master) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn slave(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.slave) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tag_ops(&self) -> Option<*const dsa_device_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.tag_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst(&self) -> Option<*mut dsa_switch_tree> {
        let v = unsafe { crate::bpf_probe_read(&self.dst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: *mut packet_type,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rcv) }.ok()
    }
    pub fn filter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut net_device) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.filter) }.ok()
    }
    pub fn type_(&self) -> Option<dsa_port__bindgen_ty_2::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn ds(&self) -> Option<*mut dsa_switch> {
        let v = unsafe { crate::bpf_probe_read(&self.ds) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cpu_dp(&self) -> Option<*mut dsa_port> {
        let v = unsafe { crate::bpf_probe_read(&self.cpu_dp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mac(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.mac) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dn(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.dn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ageing_time(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ageing_time) }.ok()
    }
    pub fn vlan_filtering(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.vlan_filtering) }.ok()
    }
    pub fn stp_state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.stp_state) }.ok()
    }
    pub fn bridge_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.bridge_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devlink_port(&self) -> Option<devlink_port> {
        unsafe { crate::bpf_probe_read(&self.devlink_port) }.ok()
    }
    pub fn devlink_port_setup(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.devlink_port_setup) }.ok()
    }
    pub fn pl(&self) -> Option<*mut phylink> {
        let v = unsafe { crate::bpf_probe_read(&self.pl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pl_config(&self) -> Option<phylink_config> {
        unsafe { crate::bpf_probe_read(&self.pl_config) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn orig_ethtool_ops(&self) -> Option<*const ethtool_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.orig_ethtool_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev_ops(&self) -> Option<*const dsa_netdevice_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev_ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn setup(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
}
impl dsa_port__bindgen_ty_1 {
    pub fn master(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.master) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn slave(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.slave) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl packet_type {
    pub fn type_(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn ignore_outgoing(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ignore_outgoing) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn func(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: *mut packet_type,
                arg4: *mut net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.func) }.ok()
    }
    pub fn list_func(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut list_head,
                arg2: *mut packet_type,
                arg3: *mut net_device,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.list_func) }.ok()
    }
    pub fn id_match(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut packet_type, arg2: *mut sock) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.id_match) }.ok()
    }
    pub fn af_packet_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.af_packet_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl netdev_notifier_changeupper_info {
    pub fn info(&self) -> Option<netdev_notifier_info> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn upper_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.upper_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn master(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.master) }.ok()
    }
    pub fn linking(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.linking) }.ok()
    }
    pub fn upper_info(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.upper_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_match {
    pub fn dissector(&self) -> Option<*mut flow_dissector> {
        let v = unsafe { crate::bpf_probe_read(&self.dissector) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mask(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_action_cookie {
    pub fn cookie_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cookie_len) }.ok()
    }
    pub fn cookie(&self) -> Option<__IncompleteArrayField<u8_>> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
}
impl nf_flowtable {}
impl ip_tunnel_key {
    pub fn tun_id(&self) -> Option<__be64> {
        unsafe { crate::bpf_probe_read(&self.tun_id) }.ok()
    }
    pub fn u(&self) -> Option<ip_tunnel_key__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
    pub fn tun_flags(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.tun_flags) }.ok()
    }
    pub fn tos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn ttl(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ttl) }.ok()
    }
    pub fn label(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.label) }.ok()
    }
    pub fn tp_src(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.tp_src) }.ok()
    }
    pub fn tp_dst(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.tp_dst) }.ok()
    }
}
impl ip_tunnel_key__bindgen_ty_1 {
    pub fn ipv4(&self) -> Option<ip_tunnel_key__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ipv4) }.ok()
    }
    pub fn ipv6(&self) -> Option<ip_tunnel_key__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()
    }
}
impl ip_tunnel_key__bindgen_ty_1__bindgen_ty_1 {
    pub fn src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
    pub fn dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
}
impl ip_tunnel_key__bindgen_ty_1__bindgen_ty_2 {
    pub fn src(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
    pub fn dst(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
}
impl dst_cache {
    pub fn cache(&self) -> Option<*mut dst_cache_pcpu> {
        let v = unsafe { crate::bpf_probe_read(&self.cache) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn reset_ts(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reset_ts) }.ok()
    }
}
impl ip_tunnel_info {
    pub fn key(&self) -> Option<ip_tunnel_key> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn dst_cache(&self) -> Option<dst_cache> {
        unsafe { crate::bpf_probe_read(&self.dst_cache) }.ok()
    }
    pub fn options_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.options_len) }.ok()
    }
    pub fn mode(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
}
impl flow_action_entry {
    pub fn id(&self) -> Option<flow_action_id::Type> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn hw_stats(&self) -> Option<flow_action_hw_stats::Type> {
        unsafe { crate::bpf_probe_read(&self.hw_stats) }.ok()
    }
    pub fn destructor(&self) -> Option<action_destr> {
        unsafe { crate::bpf_probe_read(&self.destructor) }.ok()
    }
    pub fn destructor_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.destructor_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chain_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.chain_index) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vlan(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.vlan) }.ok()
    }
    pub fn mangle(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mangle) }.ok()
    }
    pub fn tunnel(&self) -> Option<*mut ip_tunnel_info> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tunnel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn csum_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.csum_flags) }.ok()
    }
    pub fn mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mark) }.ok()
    }
    pub fn ptype(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ptype) }.ok()
    }
    pub fn priority(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.priority) }.ok()
    }
    pub fn queue(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.queue) }.ok()
    }
    pub fn sample(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.sample) }.ok()
    }
    pub fn police(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.police) }.ok()
    }
    pub fn ct(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ct) }.ok()
    }
    pub fn ct_metadata(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ct_metadata) }.ok()
    }
    pub fn mpls_push(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mpls_push) }.ok()
    }
    pub fn mpls_pop(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_9> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mpls_pop) }.ok()
    }
    pub fn mpls_mangle(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_10> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.mpls_mangle) }.ok()
    }
    pub fn gate(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_11> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.gate) }.ok()
    }
    pub fn cookie(&self) -> Option<*mut flow_action_cookie> {
        let v = unsafe { crate::bpf_probe_read(&self.cookie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_action_entry__bindgen_ty_1 {
    pub fn chain_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chain_index) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vlan(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.vlan) }.ok()
    }
    pub fn mangle(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.mangle) }.ok()
    }
    pub fn tunnel(&self) -> Option<*mut ip_tunnel_info> {
        let v = unsafe { crate::bpf_probe_read(&self.tunnel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn csum_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.csum_flags) }.ok()
    }
    pub fn mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn ptype(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.ptype) }.ok()
    }
    pub fn priority(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.priority) }.ok()
    }
    pub fn queue(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.queue) }.ok()
    }
    pub fn sample(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.sample) }.ok()
    }
    pub fn police(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.police) }.ok()
    }
    pub fn ct(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.ct) }.ok()
    }
    pub fn ct_metadata(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_7> {
        unsafe { crate::bpf_probe_read(&self.ct_metadata) }.ok()
    }
    pub fn mpls_push(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_8> {
        unsafe { crate::bpf_probe_read(&self.mpls_push) }.ok()
    }
    pub fn mpls_pop(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_9> {
        unsafe { crate::bpf_probe_read(&self.mpls_pop) }.ok()
    }
    pub fn mpls_mangle(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_10> {
        unsafe { crate::bpf_probe_read(&self.mpls_mangle) }.ok()
    }
    pub fn gate(&self) -> Option<flow_action_entry__bindgen_ty_1__bindgen_ty_11> {
        unsafe { crate::bpf_probe_read(&self.gate) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_1 {
    pub fn vid(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vid) }.ok()
    }
    pub fn proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn prio(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_2 {
    pub fn htype(&self) -> Option<flow_action_mangle_base::Type> {
        unsafe { crate::bpf_probe_read(&self.htype) }.ok()
    }
    pub fn offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn val(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_3 {
    pub fn ctx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ctx) }.ok()
    }
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn vf(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.vf) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_4 {
    pub fn psample_group(&self) -> Option<*mut psample_group> {
        let v = unsafe { crate::bpf_probe_read(&self.psample_group) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rate(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rate) }.ok()
    }
    pub fn trunc_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.trunc_size) }.ok()
    }
    pub fn truncate(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.truncate) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_5 {
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn burst(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.burst) }.ok()
    }
    pub fn rate_bytes_ps(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rate_bytes_ps) }.ok()
    }
    pub fn mtu(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mtu) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_6 {
    pub fn action(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
    pub fn zone(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.zone) }.ok()
    }
    pub fn flow_table(&self) -> Option<*mut nf_flowtable> {
        let v = unsafe { crate::bpf_probe_read(&self.flow_table) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_7 {
    pub fn cookie(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn mark(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn labels(&self) -> Option<[u32_; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.labels) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_8 {
    pub fn label(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.label) }.ok()
    }
    pub fn proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn tc(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tc) }.ok()
    }
    pub fn bos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.bos) }.ok()
    }
    pub fn ttl(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ttl) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_9 {
    pub fn proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_10 {
    pub fn label(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.label) }.ok()
    }
    pub fn tc(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tc) }.ok()
    }
    pub fn bos(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.bos) }.ok()
    }
    pub fn ttl(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ttl) }.ok()
    }
}
impl flow_action_entry__bindgen_ty_1__bindgen_ty_11 {
    pub fn index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn prio(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn basetime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.basetime) }.ok()
    }
    pub fn cycletime(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cycletime) }.ok()
    }
    pub fn cycletimeext(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.cycletimeext) }.ok()
    }
    pub fn num_entries(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_entries) }.ok()
    }
    pub fn entries(&self) -> Option<*mut action_gate_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.entries) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_action {
    pub fn num_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_entries) }.ok()
    }
    pub fn entries(&self) -> Option<__IncompleteArrayField<flow_action_entry>> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
}
impl flow_rule {
    pub fn match_(&self) -> Option<flow_match> {
        unsafe { crate::bpf_probe_read(&self.match_) }.ok()
    }
    pub fn action(&self) -> Option<flow_action> {
        unsafe { crate::bpf_probe_read(&self.action) }.ok()
    }
}
impl flow_stats {
    pub fn pkts(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.pkts) }.ok()
    }
    pub fn bytes(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.bytes) }.ok()
    }
    pub fn drops(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.drops) }.ok()
    }
    pub fn lastused(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.lastused) }.ok()
    }
    pub fn used_hw_stats(&self) -> Option<flow_action_hw_stats::Type> {
        unsafe { crate::bpf_probe_read(&self.used_hw_stats) }.ok()
    }
    pub fn used_hw_stats_valid(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.used_hw_stats_valid) }.ok()
    }
}
impl flow_cls_common_offload {
    pub fn chain_index(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chain_index) }.ok()
    }
    pub fn protocol(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.protocol) }.ok()
    }
    pub fn prio(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.prio) }.ok()
    }
    pub fn extack(&self) -> Option<*mut netlink_ext_ack> {
        let v = unsafe { crate::bpf_probe_read(&self.extack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl flow_cls_offload {
    pub fn common(&self) -> Option<flow_cls_common_offload> {
        unsafe { crate::bpf_probe_read(&self.common) }.ok()
    }
    pub fn command(&self) -> Option<flow_cls_command::Type> {
        unsafe { crate::bpf_probe_read(&self.command) }.ok()
    }
    pub fn cookie(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn rule(&self) -> Option<*mut flow_rule> {
        let v = unsafe { crate::bpf_probe_read(&self.rule) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn stats(&self) -> Option<flow_stats> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn classid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.classid) }.ok()
    }
}
impl dsa_chip_data {
    pub fn host_dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.host_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sw_addr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.sw_addr) }.ok()
    }
    pub fn netdev(&self) -> Option<[*mut device; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.netdev) }.ok()
    }
    pub fn eeprom_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.eeprom_len) }.ok()
    }
    pub fn of_node(&self) -> Option<*mut device_node> {
        let v = unsafe { crate::bpf_probe_read(&self.of_node) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn port_names(&self) -> Option<[*mut ::aya_bpf_cty::c_char; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.port_names) }.ok()
    }
    pub fn port_dn(&self) -> Option<[*mut device_node; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.port_dn) }.ok()
    }
    pub fn rtable(&self) -> Option<[s8; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.rtable) }.ok()
    }
}
impl dsa_platform_data {
    pub fn netdev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn of_netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.of_netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn nr_chips(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.nr_chips) }.ok()
    }
    pub fn chip(&self) -> Option<*mut dsa_chip_data> {
        let v = unsafe { crate::bpf_probe_read(&self.chip) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl phylink_link_state {
    pub fn advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.advertising) }.ok()
    }
    pub fn lp_advertising(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.lp_advertising) }.ok()
    }
    pub fn interface(&self) -> Option<phy_interface_t::Type> {
        unsafe { crate::bpf_probe_read(&self.interface) }.ok()
    }
    pub fn speed(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.speed) }.ok()
    }
    pub fn duplex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.duplex) }.ok()
    }
    pub fn pause(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pause) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<[u8; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl devlink_dev_stats {
    pub fn reload_stats(&self) -> Option<[u32_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.reload_stats) }.ok()
    }
    pub fn remote_reload_stats(&self) -> Option<[u32_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_reload_stats) }.ok()
    }
}
impl devlink {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn port_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.port_list) }.ok()
    }
    pub fn sb_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.sb_list) }.ok()
    }
    pub fn dpipe_table_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.dpipe_table_list) }.ok()
    }
    pub fn resource_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.resource_list) }.ok()
    }
    pub fn param_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.param_list) }.ok()
    }
    pub fn region_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.region_list) }.ok()
    }
    pub fn reporter_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.reporter_list) }.ok()
    }
    pub fn reporters_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.reporters_lock) }.ok()
    }
    pub fn dpipe_headers(&self) -> Option<*mut devlink_dpipe_headers> {
        let v = unsafe { crate::bpf_probe_read(&self.dpipe_headers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn trap_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.trap_list) }.ok()
    }
    pub fn trap_group_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.trap_group_list) }.ok()
    }
    pub fn trap_policer_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.trap_policer_list) }.ok()
    }
    pub fn ops(&self) -> Option<*const devlink_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn snapshot_ids(&self) -> Option<xarray> {
        unsafe { crate::bpf_probe_read(&self.snapshot_ids) }.ok()
    }
    pub fn stats(&self) -> Option<devlink_dev_stats> {
        unsafe { crate::bpf_probe_read(&self.stats) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn _net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self._net) }.ok()
    }
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn priv_(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.priv_) }.ok()
    }
}
impl devlink_dpipe_headers {
    pub fn headers(&self) -> Option<*mut *mut devlink_dpipe_header> {
        let v = unsafe { crate::bpf_probe_read(&self.headers) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn headers_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.headers_count) }.ok()
    }
}
impl devlink_ops {
    pub fn supported_flash_update_params(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.supported_flash_update_params) }.ok()
    }
    pub fn reload_actions(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reload_actions) }.ok()
    }
    pub fn reload_limits(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.reload_limits) }.ok()
    }
    pub fn reload_down(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: bool_,
                arg3: devlink_reload_action::Type,
                arg4: devlink_reload_limit::Type,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reload_down) }.ok()
    }
    pub fn reload_up(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: devlink_reload_action::Type,
                arg3: devlink_reload_limit::Type,
                arg4: *mut u32_,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reload_up) }.ok()
    }
    pub fn port_type_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: devlink_port_type::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_type_set) }.ok()
    }
    pub fn port_split(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_split) }.ok()
    }
    pub fn port_unsplit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_unsplit) }.ok()
    }
    pub fn sb_pool_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: *mut devlink_sb_pool_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_pool_get) }.ok()
    }
    pub fn sb_pool_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: u32_,
                arg5: devlink_sb_threshold_type::Type,
                arg6: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_pool_set) }.ok()
    }
    pub fn sb_port_pool_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_port_pool_get) }.ok()
    }
    pub fn sb_port_pool_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: u32_,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_port_pool_set) }.ok()
    }
    pub fn sb_tc_pool_bind_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: devlink_sb_pool_type::Type,
                arg5: *mut u16_,
                arg6: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_tc_pool_bind_get) }.ok()
    }
    pub fn sb_tc_pool_bind_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: devlink_sb_pool_type::Type,
                arg5: u16_,
                arg6: u32_,
                arg7: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_tc_pool_bind_set) }.ok()
    }
    pub fn sb_occ_snapshot(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_occ_snapshot) }.ok()
    }
    pub fn sb_occ_max_clear(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_occ_max_clear) }.ok()
    }
    pub fn sb_occ_port_pool_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: *mut u32_,
                arg5: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_occ_port_pool_get) }.ok()
    }
    pub fn sb_occ_tc_port_bind_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink_port,
                arg2: ::aya_bpf_cty::c_uint,
                arg3: u16_,
                arg4: devlink_sb_pool_type::Type,
                arg5: *mut u32_,
                arg6: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.sb_occ_tc_port_bind_get) }.ok()
    }
    pub fn eswitch_mode_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u16_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_mode_get) }.ok()
    }
    pub fn eswitch_mode_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: u16_,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_mode_set) }.ok()
    }
    pub fn eswitch_inline_mode_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u8_) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_inline_mode_get) }.ok()
    }
    pub fn eswitch_inline_mode_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: u8_,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_inline_mode_set) }.ok()
    }
    pub fn eswitch_encap_mode_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *mut devlink_eswitch_encap_mode::Type,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_encap_mode_get) }.ok()
    }
    pub fn eswitch_encap_mode_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: devlink_eswitch_encap_mode::Type,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.eswitch_encap_mode_set) }.ok()
    }
    pub fn info_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *mut devlink_info_req,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.info_get) }.ok()
    }
    pub fn flash_update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *mut devlink_flash_update_params,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flash_update) }.ok()
    }
    pub fn trap_init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap,
                arg3: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_init) }.ok()
    }
    pub fn trap_fini(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap,
                arg3: *mut ::aya_bpf_cty::c_void,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_fini) }.ok()
    }
    pub fn trap_action_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap,
                arg3: devlink_trap_action::Type,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_action_set) }.ok()
    }
    pub fn trap_group_init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_group,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_group_init) }.ok()
    }
    pub fn trap_group_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_group,
                arg3: *const devlink_trap_policer,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_group_set) }.ok()
    }
    pub fn trap_group_action_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_group,
                arg3: devlink_trap_action::Type,
                arg4: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_group_action_set) }.ok()
    }
    pub fn trap_policer_init(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_policer,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_policer_init) }.ok()
    }
    pub fn trap_policer_fini(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut devlink, arg2: *const devlink_trap_policer),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_policer_fini) }.ok()
    }
    pub fn trap_policer_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_policer,
                arg3: u64_,
                arg4: u64_,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_policer_set) }.ok()
    }
    pub fn trap_policer_counter_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *const devlink_trap_policer,
                arg3: *mut u64_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.trap_policer_counter_get) }.ok()
    }
    pub fn port_function_hw_addr_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *mut devlink_port,
                arg3: *mut u8_,
                arg4: *mut ::aya_bpf_cty::c_int,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_function_hw_addr_get) }.ok()
    }
    pub fn port_function_hw_addr_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut devlink,
                arg2: *mut devlink_port,
                arg3: *const u8_,
                arg4: ::aya_bpf_cty::c_int,
                arg5: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_function_hw_addr_set) }.ok()
    }
}
impl devlink_sb_pool_info {
    pub fn pool_type(&self) -> Option<devlink_sb_pool_type::Type> {
        unsafe { crate::bpf_probe_read(&self.pool_type) }.ok()
    }
    pub fn size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn threshold_type(&self) -> Option<devlink_sb_threshold_type::Type> {
        unsafe { crate::bpf_probe_read(&self.threshold_type) }.ok()
    }
    pub fn cell_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cell_size) }.ok()
    }
}
impl devlink_dpipe_field {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn bitwidth(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.bitwidth) }.ok()
    }
    pub fn mapping_type(&self) -> Option<devlink_dpipe_field_mapping_type::Type> {
        unsafe { crate::bpf_probe_read(&self.mapping_type) }.ok()
    }
}
impl devlink_dpipe_header {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn fields(&self) -> Option<*mut devlink_dpipe_field> {
        let v = unsafe { crate::bpf_probe_read(&self.fields) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fields_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.fields_count) }.ok()
    }
    pub fn global(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.global) }.ok()
    }
}
impl devlink_param_value {
    pub fn vu8(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.vu8) }.ok()
    }
    pub fn vu16(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vu16) }.ok()
    }
    pub fn vu32(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.vu32) }.ok()
    }
    pub fn vstr(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.vstr) }.ok()
    }
    pub fn vbool(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.vbool) }.ok()
    }
}
impl devlink_param_gset_ctx {
    pub fn val(&self) -> Option<devlink_param_value> {
        unsafe { crate::bpf_probe_read(&self.val) }.ok()
    }
    pub fn cmode(&self) -> Option<devlink_param_cmode::Type> {
        unsafe { crate::bpf_probe_read(&self.cmode) }.ok()
    }
}
impl devlink_flash_update_params {
    pub fn fw(&self) -> Option<*const firmware> {
        let v = unsafe { crate::bpf_probe_read(&self.fw) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn component(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.component) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn overwrite_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.overwrite_mask) }.ok()
    }
}
impl devlink_trap_policer {
    pub fn id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn init_rate(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.init_rate) }.ok()
    }
    pub fn init_burst(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.init_burst) }.ok()
    }
    pub fn max_rate(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max_rate) }.ok()
    }
    pub fn min_rate(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.min_rate) }.ok()
    }
    pub fn max_burst(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.max_burst) }.ok()
    }
    pub fn min_burst(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.min_burst) }.ok()
    }
}
impl devlink_trap_group {
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn generic(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.generic) }.ok()
    }
    pub fn init_policer_id(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.init_policer_id) }.ok()
    }
}
impl devlink_trap {
    pub fn type_(&self) -> Option<devlink_trap_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn init_action(&self) -> Option<devlink_trap_action::Type> {
        unsafe { crate::bpf_probe_read(&self.init_action) }.ok()
    }
    pub fn generic(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.generic) }.ok()
    }
    pub fn id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn init_group_id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.init_group_id) }.ok()
    }
    pub fn metadata_cap(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.metadata_cap) }.ok()
    }
}
impl switchdev_trans {
    pub fn ph_prepare(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ph_prepare) }.ok()
    }
}
impl switchdev_obj {
    pub fn orig_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.orig_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<switchdev_obj_id::Type> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn complete_priv(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.complete_priv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn complete(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_void,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.complete) }.ok()
    }
}
impl switchdev_obj_port_vlan {
    pub fn obj(&self) -> Option<switchdev_obj> {
        unsafe { crate::bpf_probe_read(&self.obj) }.ok()
    }
    pub fn flags(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn vid_begin(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vid_begin) }.ok()
    }
    pub fn vid_end(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vid_end) }.ok()
    }
}
impl switchdev_obj_port_mdb {
    pub fn obj(&self) -> Option<switchdev_obj> {
        unsafe { crate::bpf_probe_read(&self.obj) }.ok()
    }
    pub fn addr(&self) -> Option<[::aya_bpf_cty::c_uchar; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
    pub fn vid(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vid) }.ok()
    }
}
impl dsa_device_ops {
    pub fn xmit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.xmit) }.ok()
    }
    pub fn rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut net_device,
                arg3: *mut packet_type,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.rcv) }.ok()
    }
    pub fn flow_dissect(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const sk_buff,
                arg2: *mut __be16,
                arg3: *mut ::aya_bpf_cty::c_int,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.flow_dissect) }.ok()
    }
    pub fn filter(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *const sk_buff, arg2: *mut net_device) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.filter) }.ok()
    }
    pub fn overhead(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.overhead) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proto(&self) -> Option<dsa_tag_protocol::Type> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
    pub fn promisc_on_master(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.promisc_on_master) }.ok()
    }
    pub fn tail_tag(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.tail_tag) }.ok()
    }
}
impl dsa_netdevice_ops {
    pub fn ndo_do_ioctl(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut ifreq,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.ndo_do_ioctl) }.ok()
    }
}
impl dsa_switch_tree {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn nh(&self) -> Option<raw_notifier_head> {
        unsafe { crate::bpf_probe_read(&self.nh) }.ok()
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn refcount(&self) -> Option<kref> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn setup(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
    pub fn pd(&self) -> Option<*mut dsa_platform_data> {
        let v = unsafe { crate::bpf_probe_read(&self.pd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ports(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.ports) }.ok()
    }
    pub fn rtable(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.rtable) }.ok()
    }
}
impl dsa_mall_mirror_tc_entry {
    pub fn to_local_port(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.to_local_port) }.ok()
    }
    pub fn ingress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ingress) }.ok()
    }
}
impl dsa_mall_policer_tc_entry {
    pub fn burst(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.burst) }.ok()
    }
    pub fn rate_bytes_per_sec(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.rate_bytes_per_sec) }.ok()
    }
}
impl dsa_switch {
    pub fn setup(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dst(&self) -> Option<*mut dsa_switch_tree> {
        let v = unsafe { crate::bpf_probe_read(&self.dst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.index) }.ok()
    }
    pub fn nb(&self) -> Option<notifier_block> {
        unsafe { crate::bpf_probe_read(&self.nb) }.ok()
    }
    pub fn priv_(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cd(&self) -> Option<*mut dsa_chip_data> {
        let v = unsafe { crate::bpf_probe_read(&self.cd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ops(&self) -> Option<*const dsa_switch_ops> {
        let v = unsafe { crate::bpf_probe_read(&self.ops) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn phys_mii_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.phys_mii_mask) }.ok()
    }
    pub fn slave_mii_bus(&self) -> Option<*mut mii_bus> {
        let v = unsafe { crate::bpf_probe_read(&self.slave_mii_bus) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ageing_time_min(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ageing_time_min) }.ok()
    }
    pub fn ageing_time_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.ageing_time_max) }.ok()
    }
    pub fn devlink(&self) -> Option<*mut devlink> {
        let v = unsafe { crate::bpf_probe_read(&self.devlink) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_tx_queues(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_tx_queues) }.ok()
    }
    pub fn vlan_filtering_is_global(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.vlan_filtering_is_global) }.ok()
    }
    pub fn configure_vlan_while_not_filtering(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.configure_vlan_while_not_filtering) }.ok()
    }
    pub fn untag_bridge_pvid(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.untag_bridge_pvid) }.ok()
    }
    pub fn vlan_filtering(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.vlan_filtering) }.ok()
    }
    pub fn pcs_poll(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.pcs_poll) }.ok()
    }
    pub fn mtu_enforcement_ingress(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.mtu_enforcement_ingress) }.ok()
    }
    pub fn num_ports(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.num_ports) }.ok()
    }
}
impl fixed_phy_status___2 {}
impl dsa_switch_ops {
    pub fn get_tag_protocol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: dsa_tag_protocol::Type,
            ) -> dsa_tag_protocol::Type,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_tag_protocol) }.ok()
    }
    pub fn setup(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.setup) }.ok()
    }
    pub fn teardown(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch)>> {
        unsafe { crate::bpf_probe_read(&self.teardown) }.ok()
    }
    pub fn get_phy_flags(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int) -> u32_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_phy_flags) }.ok()
    }
    pub fn phy_read(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phy_read) }.ok()
    }
    pub fn phy_write(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phy_write) }.ok()
    }
    pub fn adjust_link(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut phy_device,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.adjust_link) }.ok()
    }
    pub fn fixed_link_update(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut fixed_phy_status___2,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fixed_link_update) }.ok()
    }
    pub fn phylink_validate(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ::aya_bpf_cty::c_ulong,
                arg4: *mut phylink_link_state,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_validate) }.ok()
    }
    pub fn phylink_mac_link_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut phylink_link_state,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_mac_link_state) }.ok()
    }
    pub fn phylink_mac_config(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: *const phylink_link_state,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_mac_config) }.ok()
    }
    pub fn phylink_mac_an_restart(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_mac_an_restart) }.ok()
    }
    pub fn phylink_mac_link_down(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: phy_interface_t::Type,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_mac_link_down) }.ok()
    }
    pub fn phylink_mac_link_up(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_uint,
                arg4: phy_interface_t::Type,
                arg5: *mut phy_device,
                arg6: ::aya_bpf_cty::c_int,
                arg7: ::aya_bpf_cty::c_int,
                arg8: bool_,
                arg9: bool_,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_mac_link_up) }.ok()
    }
    pub fn phylink_fixed_state(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut phylink_link_state,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.phylink_fixed_state) }.ok()
    }
    pub fn get_strings(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: u32_,
                arg4: *mut u8,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_strings) }.ok()
    }
    pub fn get_ethtool_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: *mut u64),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ethtool_stats) }.ok()
    }
    pub fn get_sset_count(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_sset_count) }.ok()
    }
    pub fn get_ethtool_phy_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: *mut u64),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ethtool_phy_stats) }.ok()
    }
    pub fn get_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_wolinfo,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_wol) }.ok()
    }
    pub fn set_wol(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_wolinfo,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_wol) }.ok()
    }
    pub fn get_ts_info(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_ts_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_ts_info) }.ok()
    }
    pub fn suspend(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.suspend) }.ok()
    }
    pub fn resume(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.resume) }.ok()
    }
    pub fn port_enable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut phy_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_enable) }.ok()
    }
    pub fn port_disable(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_disable) }.ok()
    }
    pub fn set_mac_eee(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_eee,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_mac_eee) }.ok()
    }
    pub fn get_mac_eee(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_eee,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_mac_eee) }.ok()
    }
    pub fn get_eeprom_len(
        &self,
    ) -> Option<
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf_cty::c_int>,
    > {
        unsafe { crate::bpf_probe_read(&self.get_eeprom_len) }.ok()
    }
    pub fn get_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_eeprom) }.ok()
    }
    pub fn set_eeprom(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: *mut ethtool_eeprom,
                arg3: *mut u8_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_eeprom) }.ok()
    }
    pub fn get_regs_len(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_regs_len) }.ok()
    }
    pub fn get_regs(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_regs,
                arg4: *mut ::aya_bpf_cty::c_void,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_regs) }.ok()
    }
    pub fn port_prechangeupper(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut netdev_notifier_changeupper_info,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_prechangeupper) }.ok()
    }
    pub fn set_ageing_time(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_uint,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_ageing_time) }.ok()
    }
    pub fn port_bridge_join(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_bridge_join) }.ok()
    }
    pub fn port_bridge_leave(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut net_device,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_bridge_leave) }.ok()
    }
    pub fn port_stp_state_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int, arg3: u8_),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_stp_state_set) }.ok()
    }
    pub fn port_fast_age(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_fast_age) }.ok()
    }
    pub fn port_egress_floods(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bool_,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_egress_floods) }.ok()
    }
    pub fn port_vlan_filtering(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: bool_,
                arg4: *mut switchdev_trans,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_vlan_filtering) }.ok()
    }
    pub fn port_vlan_prepare(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_vlan,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_vlan_prepare) }.ok()
    }
    pub fn port_vlan_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_vlan,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_vlan_add) }.ok()
    }
    pub fn port_vlan_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_vlan,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_vlan_del) }.ok()
    }
    pub fn port_fdb_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const ::aya_bpf_cty::c_uchar,
                arg4: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_fdb_add) }.ok()
    }
    pub fn port_fdb_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const ::aya_bpf_cty::c_uchar,
                arg4: u16_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_fdb_del) }.ok()
    }
    pub fn port_fdb_dump(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: dsa_fdb_dump_cb_t,
                arg4: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_fdb_dump) }.ok()
    }
    pub fn port_mdb_prepare(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_mdb,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_mdb_prepare) }.ok()
    }
    pub fn port_mdb_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_mdb,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_mdb_add) }.ok()
    }
    pub fn port_mdb_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *const switchdev_obj_port_mdb,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_mdb_del) }.ok()
    }
    pub fn get_rxnfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_rxnfc,
                arg4: *mut u32_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.get_rxnfc) }.ok()
    }
    pub fn set_rxnfc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ethtool_rxnfc,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.set_rxnfc) }.ok()
    }
    pub fn cls_flower_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut flow_cls_offload,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cls_flower_add) }.ok()
    }
    pub fn cls_flower_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut flow_cls_offload,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cls_flower_del) }.ok()
    }
    pub fn cls_flower_stats(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut flow_cls_offload,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.cls_flower_stats) }.ok()
    }
    pub fn port_mirror_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut dsa_mall_mirror_tc_entry,
                arg4: bool_,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_mirror_add) }.ok()
    }
    pub fn port_mirror_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut dsa_mall_mirror_tc_entry,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_mirror_del) }.ok()
    }
    pub fn port_policer_add(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut dsa_mall_policer_tc_entry,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_policer_add) }.ok()
    }
    pub fn port_policer_del(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf_cty::c_int),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_policer_del) }.ok()
    }
    pub fn port_setup_tc(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: tc_setup_type::Type,
                arg4: *mut ::aya_bpf_cty::c_void,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_setup_tc) }.ok()
    }
    pub fn crosschip_bridge_join(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
                arg5: *mut net_device,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.crosschip_bridge_join) }.ok()
    }
    pub fn crosschip_bridge_leave(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
                arg4: ::aya_bpf_cty::c_int,
                arg5: *mut net_device,
            ),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.crosschip_bridge_leave) }.ok()
    }
    pub fn port_hwtstamp_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ifreq,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_hwtstamp_get) }.ok()
    }
    pub fn port_hwtstamp_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut ifreq,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_hwtstamp_set) }.ok()
    }
    pub fn port_txtstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut sk_buff,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_txtstamp) }.ok()
    }
    pub fn port_rxtstamp(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: *mut sk_buff,
                arg4: ::aya_bpf_cty::c_uint,
            ) -> bool_,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_rxtstamp) }.ok()
    }
    pub fn devlink_param_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: u32_,
                arg3: *mut devlink_param_gset_ctx,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devlink_param_get) }.ok()
    }
    pub fn devlink_param_set(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: u32_,
                arg3: *mut devlink_param_gset_ctx,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devlink_param_set) }.ok()
    }
    pub fn devlink_info_get(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: *mut devlink_info_req,
                arg3: *mut netlink_ext_ack,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.devlink_info_get) }.ok()
    }
    pub fn port_change_mtu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_change_mtu) }.ok()
    }
    pub fn port_max_mtu(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dsa_switch,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.port_max_mtu) }.ok()
    }
}
impl nf_conntrack_zone {
    pub fn id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn dir(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.dir) }.ok()
    }
}
impl nf_conntrack_man {
    pub fn u3(&self) -> Option<nf_inet_addr> {
        unsafe { crate::bpf_probe_read(&self.u3) }.ok()
    }
    pub fn u(&self) -> Option<nf_conntrack_man_proto> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
    pub fn l3num(&self) -> Option<u_int16_t> {
        unsafe { crate::bpf_probe_read(&self.l3num) }.ok()
    }
}
impl nf_conntrack_tuple {
    pub fn src(&self) -> Option<nf_conntrack_man> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
    pub fn dst(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1 {
    pub fn u3(&self) -> Option<nf_inet_addr> {
        unsafe { crate::bpf_probe_read(&self.u3) }.ok()
    }
    pub fn u(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
    pub fn protonum(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.protonum) }.ok()
    }
    pub fn dir(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.dir) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub fn all(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn tcp(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.tcp) }.ok()
    }
    pub fn udp(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.udp) }.ok()
    }
    pub fn icmp(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3> {
        unsafe { crate::bpf_probe_read(&self.icmp) }.ok()
    }
    pub fn dccp(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4> {
        unsafe { crate::bpf_probe_read(&self.dccp) }.ok()
    }
    pub fn sctp(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5> {
        unsafe { crate::bpf_probe_read(&self.sctp) }.ok()
    }
    pub fn gre(&self) -> Option<nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6> {
        unsafe { crate::bpf_probe_read(&self.gre) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub fn type_(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn code(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.code) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5 {
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
}
impl nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6 {
    pub fn key(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
}
impl nf_conntrack_tuple_hash {
    pub fn hnnode(&self) -> Option<hlist_nulls_node> {
        unsafe { crate::bpf_probe_read(&self.hnnode) }.ok()
    }
    pub fn tuple(&self) -> Option<nf_conntrack_tuple> {
        unsafe { crate::bpf_probe_read(&self.tuple) }.ok()
    }
}
impl nf_ct_udp {
    pub fn stream_ts(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.stream_ts) }.ok()
    }
}
impl nf_ct_gre {
    pub fn stream_timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.stream_timeout) }.ok()
    }
    pub fn timeout(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
}
impl nf_conntrack_proto {
    pub fn dccp(&self) -> Option<nf_ct_dccp> {
        unsafe { crate::bpf_probe_read(&self.dccp) }.ok()
    }
    pub fn sctp(&self) -> Option<ip_ct_sctp> {
        unsafe { crate::bpf_probe_read(&self.sctp) }.ok()
    }
    pub fn tcp(&self) -> Option<ip_ct_tcp> {
        unsafe { crate::bpf_probe_read(&self.tcp) }.ok()
    }
    pub fn udp(&self) -> Option<nf_ct_udp> {
        unsafe { crate::bpf_probe_read(&self.udp) }.ok()
    }
    pub fn gre(&self) -> Option<nf_ct_gre> {
        unsafe { crate::bpf_probe_read(&self.gre) }.ok()
    }
    pub fn tmpl_padto(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.tmpl_padto) }.ok()
    }
}
impl nf_conn {
    pub fn ct_general(&self) -> Option<nf_conntrack> {
        unsafe { crate::bpf_probe_read(&self.ct_general) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn timeout(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn zone(&self) -> Option<nf_conntrack_zone> {
        unsafe { crate::bpf_probe_read(&self.zone) }.ok()
    }
    pub fn tuplehash(&self) -> Option<[nf_conntrack_tuple_hash; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.tuplehash) }.ok()
    }
    pub fn status(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.status) }.ok()
    }
    pub fn cpu(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cpu) }.ok()
    }
    pub fn ct_net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self.ct_net) }.ok()
    }
    pub fn nat_bysource(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.nat_bysource) }.ok()
    }
    pub fn __nfct_init_offset(&self) -> Option<nf_conn__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__nfct_init_offset) }.ok()
    }
    pub fn master(&self) -> Option<*mut nf_conn> {
        let v = unsafe { crate::bpf_probe_read(&self.master) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mark(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.mark) }.ok()
    }
    pub fn secmark(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.secmark) }.ok()
    }
    pub fn ext(&self) -> Option<*mut nf_ct_ext> {
        let v = unsafe { crate::bpf_probe_read(&self.ext) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn proto(&self) -> Option<nf_conntrack_proto> {
        unsafe { crate::bpf_probe_read(&self.proto) }.ok()
    }
}
impl nf_conn__bindgen_ty_1 {}
impl xt_table_info {
    pub fn size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn number(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.number) }.ok()
    }
    pub fn initial_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.initial_entries) }.ok()
    }
    pub fn hook_entry(&self) -> Option<[::aya_bpf_cty::c_uint; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.hook_entry) }.ok()
    }
    pub fn underflow(&self) -> Option<[::aya_bpf_cty::c_uint; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.underflow) }.ok()
    }
    pub fn stacksize(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.stacksize) }.ok()
    }
    pub fn jumpstack(&self) -> Option<*mut *mut *mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.jumpstack) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn entries(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_uchar>> {
        unsafe { crate::bpf_probe_read(&self.entries) }.ok()
    }
}
impl nf_conntrack_tuple_mask {
    pub fn src(&self) -> Option<nf_conntrack_tuple_mask__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
}
impl nf_conntrack_tuple_mask__bindgen_ty_1 {
    pub fn u3(&self) -> Option<nf_inet_addr> {
        unsafe { crate::bpf_probe_read(&self.u3) }.ok()
    }
    pub fn u(&self) -> Option<nf_conntrack_man_proto> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
}
impl nf_ct_ext {
    pub fn offset(&self) -> Option<[u8_; 9usize]> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn data(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
}
impl nf_conntrack_helper {}
impl nf_conntrack_expect {
    pub fn lnode(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.lnode) }.ok()
    }
    pub fn hnode(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hnode) }.ok()
    }
    pub fn tuple(&self) -> Option<nf_conntrack_tuple> {
        unsafe { crate::bpf_probe_read(&self.tuple) }.ok()
    }
    pub fn mask(&self) -> Option<nf_conntrack_tuple_mask> {
        unsafe { crate::bpf_probe_read(&self.mask) }.ok()
    }
    pub fn expectfn(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut nf_conn, arg2: *mut nf_conntrack_expect),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.expectfn) }.ok()
    }
    pub fn helper(&self) -> Option<*mut nf_conntrack_helper> {
        let v = unsafe { crate::bpf_probe_read(&self.helper) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn master(&self) -> Option<*mut nf_conn> {
        let v = unsafe { crate::bpf_probe_read(&self.master) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn timeout(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timeout) }.ok()
    }
    pub fn use_(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.use_) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn class(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.class) }.ok()
    }
    pub fn saved_addr(&self) -> Option<nf_inet_addr> {
        unsafe { crate::bpf_probe_read(&self.saved_addr) }.ok()
    }
    pub fn saved_proto(&self) -> Option<nf_conntrack_man_proto> {
        unsafe { crate::bpf_probe_read(&self.saved_proto) }.ok()
    }
    pub fn dir(&self) -> Option<ip_conntrack_dir::Type> {
        unsafe { crate::bpf_probe_read(&self.dir) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl nf_ct_event {
    pub fn ct(&self) -> Option<*mut nf_conn> {
        let v = unsafe { crate::bpf_probe_read(&self.ct) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn portid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.portid) }.ok()
    }
    pub fn report(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.report) }.ok()
    }
}
impl nf_exp_event {
    pub fn exp(&self) -> Option<*mut nf_conntrack_expect> {
        let v = unsafe { crate::bpf_probe_read(&self.exp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn portid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.portid) }.ok()
    }
    pub fn report(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.report) }.ok()
    }
}
impl ipv4_devconf {
    pub fn sysctl(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.sysctl) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data(&self) -> Option<[::aya_bpf_cty::c_int; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.data) }.ok()
    }
    pub fn state(&self) -> Option<[::aya_bpf_cty::c_ulong; 1usize]> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
}
impl bpf_xdp_link {
    pub fn link(&self) -> Option<bpf_link> {
        unsafe { crate::bpf_probe_read(&self.link) }.ok()
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl netpoll_info {
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn dev_lock(&self) -> Option<semaphore> {
        unsafe { crate::bpf_probe_read(&self.dev_lock) }.ok()
    }
    pub fn txq(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.txq) }.ok()
    }
    pub fn tx_work(&self) -> Option<delayed_work> {
        unsafe { crate::bpf_probe_read(&self.tx_work) }.ok()
    }
    pub fn netpoll(&self) -> Option<*mut netpoll> {
        let v = unsafe { crate::bpf_probe_read(&self.netpoll) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl udp_tunnel_info {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_ushort> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn sa_family(&self) -> Option<sa_family_t> {
        unsafe { crate::bpf_probe_read(&self.sa_family) }.ok()
    }
    pub fn port(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.port) }.ok()
    }
    pub fn hw_priv(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.hw_priv) }.ok()
    }
}
impl in_device {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn dead(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.dead) }.ok()
    }
    pub fn ifa_list(&self) -> Option<*mut in_ifaddr> {
        let v = unsafe { crate::bpf_probe_read(&self.ifa_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_list(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_list) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_hash(&self) -> Option<*mut *mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mc_count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.mc_count) }.ok()
    }
    pub fn mc_tomb_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mc_tomb_lock) }.ok()
    }
    pub fn mc_tomb(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.mc_tomb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mr_v1_seen(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mr_v1_seen) }.ok()
    }
    pub fn mr_v2_seen(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mr_v2_seen) }.ok()
    }
    pub fn mr_maxdelay(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mr_maxdelay) }.ok()
    }
    pub fn mr_qi(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mr_qi) }.ok()
    }
    pub fn mr_qri(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.mr_qri) }.ok()
    }
    pub fn mr_qrv(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mr_qrv) }.ok()
    }
    pub fn mr_gq_running(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mr_gq_running) }.ok()
    }
    pub fn mr_ifc_count(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.mr_ifc_count) }.ok()
    }
    pub fn mr_gq_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mr_gq_timer) }.ok()
    }
    pub fn mr_ifc_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.mr_ifc_timer) }.ok()
    }
    pub fn arp_parms(&self) -> Option<*mut neigh_parms> {
        let v = unsafe { crate::bpf_probe_read(&self.arp_parms) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cnf(&self) -> Option<ipv4_devconf> {
        unsafe { crate::bpf_probe_read(&self.cnf) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
}
impl inet_addr {
    pub fn all(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.all) }.ok()
    }
    pub fn ip(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ip) }.ok()
    }
    pub fn ip6(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ip6) }.ok()
    }
    pub fn in_(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.in_) }.ok()
    }
    pub fn in6(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.in6) }.ok()
    }
}
impl netpoll {
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev_name(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.dev_name) }.ok()
    }
    pub fn name(&self) -> Option<*const ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.name) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn local_ip(&self) -> Option<inet_addr> {
        unsafe { crate::bpf_probe_read(&self.local_ip) }.ok()
    }
    pub fn remote_ip(&self) -> Option<inet_addr> {
        unsafe { crate::bpf_probe_read(&self.remote_ip) }.ok()
    }
    pub fn ipv6(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()
    }
    pub fn local_port(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.local_port) }.ok()
    }
    pub fn remote_port(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.remote_port) }.ok()
    }
    pub fn remote_mac(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_mac) }.ok()
    }
}
impl tcf_walker {
    pub fn stop(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.stop) }.ok()
    }
    pub fn skip(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.skip) }.ok()
    }
    pub fn count(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.count) }.ok()
    }
    pub fn nonempty(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.nonempty) }.ok()
    }
    pub fn cookie(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn fn_(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut tcf_proto,
                arg2: *mut ::aya_bpf_cty::c_void,
                arg3: *mut tcf_walker,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.fn_) }.ok()
    }
}
impl in_ifaddr {
    pub fn hash(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hash) }.ok()
    }
    pub fn ifa_next(&self) -> Option<*mut in_ifaddr> {
        let v = unsafe { crate::bpf_probe_read(&self.ifa_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ifa_dev(&self) -> Option<*mut in_device> {
        let v = unsafe { crate::bpf_probe_read(&self.ifa_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn ifa_local(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ifa_local) }.ok()
    }
    pub fn ifa_address(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ifa_address) }.ok()
    }
    pub fn ifa_mask(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ifa_mask) }.ok()
    }
    pub fn ifa_rt_priority(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifa_rt_priority) }.ok()
    }
    pub fn ifa_broadcast(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ifa_broadcast) }.ok()
    }
    pub fn ifa_scope(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.ifa_scope) }.ok()
    }
    pub fn ifa_prefixlen(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.ifa_prefixlen) }.ok()
    }
    pub fn ifa_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifa_flags) }.ok()
    }
    pub fn ifa_label(&self) -> Option<[::aya_bpf_cty::c_char; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.ifa_label) }.ok()
    }
    pub fn ifa_valid_lft(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifa_valid_lft) }.ok()
    }
    pub fn ifa_preferred_lft(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifa_preferred_lft) }.ok()
    }
    pub fn ifa_cstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ifa_cstamp) }.ok()
    }
    pub fn ifa_tstamp(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.ifa_tstamp) }.ok()
    }
}
impl udp_tunnel_nic_shared {
    pub fn udp_tunnel_nic_info(&self) -> Option<*mut udp_tunnel_nic> {
        let v = unsafe { crate::bpf_probe_read(&self.udp_tunnel_nic_info) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn devices(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.devices) }.ok()
    }
}
impl seg6_pernet_data {
    pub fn lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn tun_src(&self) -> Option<*mut in6_addr> {
        let v = unsafe { crate::bpf_probe_read(&self.tun_src) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn hmac_infos(&self) -> Option<rhashtable> {
        unsafe { crate::bpf_probe_read(&self.hmac_infos) }.ok()
    }
}
impl bpf_tunnel_key {
    pub fn tunnel_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tunnel_id) }.ok()
    }
    pub fn remote_ipv4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.remote_ipv4) }.ok()
    }
    pub fn remote_ipv6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.remote_ipv6) }.ok()
    }
    pub fn tunnel_tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tunnel_tos) }.ok()
    }
    pub fn tunnel_ttl(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tunnel_ttl) }.ok()
    }
    pub fn tunnel_ext(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.tunnel_ext) }.ok()
    }
    pub fn tunnel_label(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tunnel_label) }.ok()
    }
}
impl bpf_tunnel_key__bindgen_ty_1 {
    pub fn remote_ipv4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_ipv4) }.ok()
    }
    pub fn remote_ipv6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_ipv6) }.ok()
    }
}
impl bpf_xfrm_state {
    pub fn reqid(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.reqid) }.ok()
    }
    pub fn spi(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.spi) }.ok()
    }
    pub fn family(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn ext(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.ext) }.ok()
    }
    pub fn remote_ipv4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.remote_ipv4) }.ok()
    }
    pub fn remote_ipv6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.remote_ipv6) }.ok()
    }
}
impl bpf_xfrm_state__bindgen_ty_1 {
    pub fn remote_ipv4(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.remote_ipv4) }.ok()
    }
    pub fn remote_ipv6(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.remote_ipv6) }.ok()
    }
}
impl bpf_tcp_sock {
    pub fn snd_cwnd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_cwnd) }.ok()
    }
    pub fn srtt_us(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.srtt_us) }.ok()
    }
    pub fn rtt_min(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rtt_min) }.ok()
    }
    pub fn snd_ssthresh(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_ssthresh) }.ok()
    }
    pub fn rcv_nxt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rcv_nxt) }.ok()
    }
    pub fn snd_nxt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_nxt) }.ok()
    }
    pub fn snd_una(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.snd_una) }.ok()
    }
    pub fn mss_cache(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.mss_cache) }.ok()
    }
    pub fn ecn_flags(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ecn_flags) }.ok()
    }
    pub fn rate_delivered(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rate_delivered) }.ok()
    }
    pub fn rate_interval_us(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rate_interval_us) }.ok()
    }
    pub fn packets_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.packets_out) }.ok()
    }
    pub fn retrans_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.retrans_out) }.ok()
    }
    pub fn total_retrans(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.total_retrans) }.ok()
    }
    pub fn segs_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.segs_in) }.ok()
    }
    pub fn data_segs_in(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_segs_in) }.ok()
    }
    pub fn segs_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.segs_out) }.ok()
    }
    pub fn data_segs_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.data_segs_out) }.ok()
    }
    pub fn lost_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.lost_out) }.ok()
    }
    pub fn sacked_out(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.sacked_out) }.ok()
    }
    pub fn bytes_received(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes_received) }.ok()
    }
    pub fn bytes_acked(&self) -> Option<__u64> {
        unsafe { crate::bpf_probe_read(&self.bytes_acked) }.ok()
    }
    pub fn dsack_dups(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dsack_dups) }.ok()
    }
    pub fn delivered(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.delivered) }.ok()
    }
    pub fn delivered_ce(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.delivered_ce) }.ok()
    }
    pub fn icsk_retransmits(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.icsk_retransmits) }.ok()
    }
}
impl bpf_sock_tuple {
    pub fn ipv4(&self) -> Option<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv4) }.ok()
    }
    pub fn ipv6(&self) -> Option<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv6) }.ok()
    }
}
impl bpf_sock_tuple__bindgen_ty_1 {
    pub fn ipv4(&self) -> Option<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ipv4) }.ok()
    }
    pub fn ipv6(&self) -> Option<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.ipv6) }.ok()
    }
}
impl bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub fn saddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
}
impl bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
    pub fn saddr(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.saddr) }.ok()
    }
    pub fn daddr(&self) -> Option<[__be32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.daddr) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
}
impl bpf_fib_lookup {
    pub fn family(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.family) }.ok()
    }
    pub fn l4_protocol(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.l4_protocol) }.ok()
    }
    pub fn sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.sport) }.ok()
    }
    pub fn dport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.dport) }.ok()
    }
    pub fn tot_len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.tot_len) }.ok()
    }
    pub fn ifindex(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.ifindex) }.ok()
    }
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.tos) }.ok()
    }
    pub fn flowinfo(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.flowinfo) }.ok()
    }
    pub fn rt_metric(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.rt_metric) }.ok()
    }
    pub fn ipv4_src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ipv4_src) }.ok()
    }
    pub fn ipv6_src(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_2.ipv6_src) }.ok()
    }
    pub fn ipv4_dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.ipv4_dst) }.ok()
    }
    pub fn ipv6_dst(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_3.ipv6_dst) }.ok()
    }
    pub fn h_vlan_proto(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.h_vlan_proto) }.ok()
    }
    pub fn h_vlan_TCI(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.h_vlan_TCI) }.ok()
    }
    pub fn smac(&self) -> Option<[__u8; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.smac) }.ok()
    }
    pub fn dmac(&self) -> Option<[__u8; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.dmac) }.ok()
    }
}
impl bpf_fib_lookup__bindgen_ty_1 {
    pub fn tos(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.tos) }.ok()
    }
    pub fn flowinfo(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.flowinfo) }.ok()
    }
    pub fn rt_metric(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.rt_metric) }.ok()
    }
}
impl bpf_fib_lookup__bindgen_ty_2 {
    pub fn ipv4_src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4_src) }.ok()
    }
    pub fn ipv6_src(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ipv6_src) }.ok()
    }
}
impl bpf_fib_lookup__bindgen_ty_3 {
    pub fn ipv4_dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4_dst) }.ok()
    }
    pub fn ipv6_dst(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ipv6_dst) }.ok()
    }
}
impl bpf_redir_neigh {
    pub fn nh_family(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.nh_family) }.ok()
    }
    pub fn ipv4_nh(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv4_nh) }.ok()
    }
    pub fn ipv6_nh(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.ipv6_nh) }.ok()
    }
}
impl bpf_redir_neigh__bindgen_ty_1 {
    pub fn ipv4_nh(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.ipv4_nh) }.ok()
    }
    pub fn ipv6_nh(&self) -> Option<[__u32; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ipv6_nh) }.ok()
    }
}
impl inet_timewait_sock {
    pub fn __tw_common(&self) -> Option<sock_common> {
        unsafe { crate::bpf_probe_read(&self.__tw_common) }.ok()
    }
    pub fn tw_mark(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tw_mark) }.ok()
    }
    pub fn tw_substate(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tw_substate) }.ok()
    }
    pub fn tw_rcv_wscale(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.tw_rcv_wscale) }.ok()
    }
    pub fn tw_sport(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.tw_sport) }.ok()
    }
    pub fn tw_txhash(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_txhash) }.ok()
    }
    pub fn tw_priority(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_priority) }.ok()
    }
    pub fn tw_timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.tw_timer) }.ok()
    }
    pub fn tw_tb(&self) -> Option<*mut inet_bind_bucket> {
        let v = unsafe { crate::bpf_probe_read(&self.tw_tb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tcp_timewait_sock {
    pub fn tw_sk(&self) -> Option<inet_timewait_sock> {
        unsafe { crate::bpf_probe_read(&self.tw_sk) }.ok()
    }
    pub fn tw_rcv_wnd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_rcv_wnd) }.ok()
    }
    pub fn tw_ts_offset(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_ts_offset) }.ok()
    }
    pub fn tw_ts_recent(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_ts_recent) }.ok()
    }
    pub fn tw_last_oow_ack_time(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_last_oow_ack_time) }.ok()
    }
    pub fn tw_ts_recent_stamp(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.tw_ts_recent_stamp) }.ok()
    }
    pub fn tw_tx_delay(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tw_tx_delay) }.ok()
    }
    pub fn tw_md5_key(&self) -> Option<*mut tcp_md5sig_key> {
        let v = unsafe { crate::bpf_probe_read(&self.tw_md5_key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl udp_sock {
    pub fn inet(&self) -> Option<inet_sock> {
        unsafe { crate::bpf_probe_read(&self.inet) }.ok()
    }
    pub fn pending(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pending) }.ok()
    }
    pub fn corkflag(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.corkflag) }.ok()
    }
    pub fn encap_type(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.encap_type) }.ok()
    }
    pub fn len(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn gso_size(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.gso_size) }.ok()
    }
    pub fn pcslen(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.pcslen) }.ok()
    }
    pub fn pcrlen(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.pcrlen) }.ok()
    }
    pub fn pcflag(&self) -> Option<__u8> {
        unsafe { crate::bpf_probe_read(&self.pcflag) }.ok()
    }
    pub fn unused(&self) -> Option<[__u8; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.unused) }.ok()
    }
    pub fn encap_rcv(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.encap_rcv) }.ok()
    }
    pub fn encap_err_lookup(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.encap_err_lookup) }.ok()
    }
    pub fn encap_destroy(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.encap_destroy) }.ok()
    }
    pub fn gro_receive(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut list_head,
                arg3: *mut sk_buff,
            ) -> *mut sk_buff,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.gro_receive) }.ok()
    }
    pub fn gro_complete(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: *mut sk_buff,
                arg3: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.gro_complete) }.ok()
    }
    pub fn reader_queue(&self) -> Option<sk_buff_head> {
        unsafe { crate::bpf_probe_read(&self.reader_queue) }.ok()
    }
    pub fn forward_deficit(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.forward_deficit) }.ok()
    }
}
impl udp6_sock {
    pub fn udp(&self) -> Option<udp_sock> {
        unsafe { crate::bpf_probe_read(&self.udp) }.ok()
    }
    pub fn inet6(&self) -> Option<ipv6_pinfo> {
        unsafe { crate::bpf_probe_read(&self.inet6) }.ok()
    }
}
impl tcp6_sock {
    pub fn tcp(&self) -> Option<tcp_sock> {
        unsafe { crate::bpf_probe_read(&self.tcp) }.ok()
    }
    pub fn inet6(&self) -> Option<ipv6_pinfo> {
        unsafe { crate::bpf_probe_read(&self.inet6) }.ok()
    }
}
impl xdp_umem {
    pub fn addrs(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn size(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
    pub fn headroom(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.headroom) }.ok()
    }
    pub fn chunk_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chunk_size) }.ok()
    }
    pub fn chunks(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chunks) }.ok()
    }
    pub fn npgs(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.npgs) }.ok()
    }
    pub fn user(&self) -> Option<*mut user_struct> {
        let v = unsafe { crate::bpf_probe_read(&self.user) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn flags(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn zc(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.zc) }.ok()
    }
    pub fn pgs(&self) -> Option<*mut *mut page> {
        let v = unsafe { crate::bpf_probe_read(&self.pgs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn xsk_dma_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.xsk_dma_list) }.ok()
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
}
impl tls_crypto_info {
    pub fn version(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn cipher_type(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.cipher_type) }.ok()
    }
}
impl tls12_crypto_info_aes_gcm_128 {
    pub fn info(&self) -> Option<tls_crypto_info> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn iv(&self) -> Option<[::aya_bpf_cty::c_uchar; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.iv) }.ok()
    }
    pub fn key(&self) -> Option<[::aya_bpf_cty::c_uchar; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn salt(&self) -> Option<[::aya_bpf_cty::c_uchar; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.salt) }.ok()
    }
    pub fn rec_seq(&self) -> Option<[::aya_bpf_cty::c_uchar; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rec_seq) }.ok()
    }
}
impl tls12_crypto_info_aes_gcm_256 {
    pub fn info(&self) -> Option<tls_crypto_info> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn iv(&self) -> Option<[::aya_bpf_cty::c_uchar; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.iv) }.ok()
    }
    pub fn key(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn salt(&self) -> Option<[::aya_bpf_cty::c_uchar; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.salt) }.ok()
    }
    pub fn rec_seq(&self) -> Option<[::aya_bpf_cty::c_uchar; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rec_seq) }.ok()
    }
}
impl tls12_crypto_info_chacha20_poly1305 {
    pub fn info(&self) -> Option<tls_crypto_info> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn iv(&self) -> Option<[::aya_bpf_cty::c_uchar; 12usize]> {
        unsafe { crate::bpf_probe_read(&self.iv) }.ok()
    }
    pub fn key(&self) -> Option<[::aya_bpf_cty::c_uchar; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.key) }.ok()
    }
    pub fn salt(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_uchar>> {
        unsafe { crate::bpf_probe_read(&self.salt) }.ok()
    }
    pub fn rec_seq(&self) -> Option<[::aya_bpf_cty::c_uchar; 8usize]> {
        unsafe { crate::bpf_probe_read(&self.rec_seq) }.ok()
    }
}
impl cipher_context {
    pub fn iv(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.iv) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rec_seq(&self) -> Option<*mut ::aya_bpf_cty::c_char> {
        let v = unsafe { crate::bpf_probe_read(&self.rec_seq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl tls_crypto_context {
    pub fn info(&self) -> Option<__BindgenUnionField<tls_crypto_info>> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u16; 28usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl tls_crypto_context__bindgen_ty_1 {
    pub fn aes_gcm_128(&self) -> Option<__BindgenUnionField<tls12_crypto_info_aes_gcm_128>> {
        unsafe { crate::bpf_probe_read(&self.aes_gcm_128) }.ok()
    }
    pub fn aes_gcm_256(&self) -> Option<__BindgenUnionField<tls12_crypto_info_aes_gcm_256>> {
        unsafe { crate::bpf_probe_read(&self.aes_gcm_256) }.ok()
    }
    pub fn chacha20_poly1305(
        &self,
    ) -> Option<__BindgenUnionField<tls12_crypto_info_chacha20_poly1305>> {
        unsafe { crate::bpf_probe_read(&self.chacha20_poly1305) }.ok()
    }
    pub fn bindgen_union_field(&self) -> Option<[u16; 28usize]> {
        unsafe { crate::bpf_probe_read(&self.bindgen_union_field) }.ok()
    }
}
impl tls_prot_info {
    pub fn version(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.version) }.ok()
    }
    pub fn cipher_type(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cipher_type) }.ok()
    }
    pub fn prepend_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.prepend_size) }.ok()
    }
    pub fn tag_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.tag_size) }.ok()
    }
    pub fn overhead_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.overhead_size) }.ok()
    }
    pub fn iv_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.iv_size) }.ok()
    }
    pub fn salt_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.salt_size) }.ok()
    }
    pub fn rec_seq_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.rec_seq_size) }.ok()
    }
    pub fn aad_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.aad_size) }.ok()
    }
    pub fn tail_size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.tail_size) }.ok()
    }
}
impl tls_context {
    pub fn prot_info(&self) -> Option<tls_prot_info> {
        unsafe { crate::bpf_probe_read(&self.prot_info) }.ok()
    }
    pub fn push_pending_record(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sock,
                arg2: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.push_pending_record) }.ok()
    }
    pub fn sk_write_space(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_write_space) }.ok()
    }
    pub fn priv_ctx_tx(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_ctx_tx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_ctx_rx(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.priv_ctx_rx) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tx(&self) -> Option<cipher_context> {
        unsafe { crate::bpf_probe_read(&self.tx) }.ok()
    }
    pub fn rx(&self) -> Option<cipher_context> {
        unsafe { crate::bpf_probe_read(&self.rx) }.ok()
    }
    pub fn partially_sent_record(&self) -> Option<*mut scatterlist> {
        let v = unsafe { crate::bpf_probe_read(&self.partially_sent_record) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn partially_sent_offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.partially_sent_offset) }.ok()
    }
    pub fn in_tcp_sendpages(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.in_tcp_sendpages) }.ok()
    }
    pub fn pending_open_record_frags(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.pending_open_record_frags) }.ok()
    }
    pub fn tx_lock(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.tx_lock) }.ok()
    }
    pub fn flags(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn sk_proto(&self) -> Option<*mut proto> {
        let v = unsafe { crate::bpf_probe_read(&self.sk_proto) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sk_destruct(
        &self,
    ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>> {
        unsafe { crate::bpf_probe_read(&self.sk_destruct) }.ok()
    }
    pub fn crypto_send(&self) -> Option<tls_crypto_context> {
        unsafe { crate::bpf_probe_read(&self.crypto_send) }.ok()
    }
    pub fn crypto_recv(&self) -> Option<tls_crypto_context> {
        unsafe { crate::bpf_probe_read(&self.crypto_recv) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn refcount(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl xsk_buff_pool {
    pub fn dev(&self) -> Option<*mut device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn xsk_tx_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.xsk_tx_list) }.ok()
    }
    pub fn xsk_tx_list_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.xsk_tx_list_lock) }.ok()
    }
    pub fn users(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn umem(&self) -> Option<*mut xdp_umem> {
        let v = unsafe { crate::bpf_probe_read(&self.umem) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn work(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.work) }.ok()
    }
    pub fn free_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.free_list) }.ok()
    }
    pub fn heads_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.heads_cnt) }.ok()
    }
    pub fn queue_id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.queue_id) }.ok()
    }
    pub fn fq(&self) -> Option<*mut xsk_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.fq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cq(&self) -> Option<*mut xsk_queue> {
        let v = unsafe { crate::bpf_probe_read(&self.cq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dma_pages(&self) -> Option<*mut dma_addr_t> {
        let v = unsafe { crate::bpf_probe_read(&self.dma_pages) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn heads(&self) -> Option<*mut xdp_buff_xsk> {
        let v = unsafe { crate::bpf_probe_read(&self.heads) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chunk_mask(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.chunk_mask) }.ok()
    }
    pub fn addrs_cnt(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.addrs_cnt) }.ok()
    }
    pub fn free_list_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.free_list_cnt) }.ok()
    }
    pub fn dma_pages_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dma_pages_cnt) }.ok()
    }
    pub fn free_heads_cnt(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.free_heads_cnt) }.ok()
    }
    pub fn headroom(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.headroom) }.ok()
    }
    pub fn chunk_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.chunk_size) }.ok()
    }
    pub fn frame_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.frame_len) }.ok()
    }
    pub fn cached_need_wakeup(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.cached_need_wakeup) }.ok()
    }
    pub fn uses_need_wakeup(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.uses_need_wakeup) }.ok()
    }
    pub fn dma_need_sync(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.dma_need_sync) }.ok()
    }
    pub fn unaligned(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.unaligned) }.ok()
    }
    pub fn addrs(&self) -> Option<*mut ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.addrs) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cq_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.cq_lock) }.ok()
    }
    pub fn free_heads(&self) -> Option<__IncompleteArrayField<*mut xdp_buff_xsk>> {
        unsafe { crate::bpf_probe_read(&self.free_heads) }.ok()
    }
}
impl xdp_buff_xsk {
    pub fn xdp(&self) -> Option<xdp_buff> {
        unsafe { crate::bpf_probe_read(&self.xdp) }.ok()
    }
    pub fn dma(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.dma) }.ok()
    }
    pub fn frame_dma(&self) -> Option<dma_addr_t> {
        unsafe { crate::bpf_probe_read(&self.frame_dma) }.ok()
    }
    pub fn pool(&self) -> Option<*mut xsk_buff_pool> {
        let v = unsafe { crate::bpf_probe_read(&self.pool) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn unaligned(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.unaligned) }.ok()
    }
    pub fn orig_addr(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.orig_addr) }.ok()
    }
    pub fn free_list_node(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.free_list_node) }.ok()
    }
}
impl dst_cache_pcpu {
    pub fn refresh_ts(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.refresh_ts) }.ok()
    }
    pub fn dst(&self) -> Option<*mut dst_entry> {
        let v = unsafe { crate::bpf_probe_read(&self.dst) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn cookie(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cookie) }.ok()
    }
    pub fn in_saddr(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.in_saddr) }.ok()
    }
    pub fn in6_saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.in6_saddr) }.ok()
    }
}
impl dst_cache_pcpu__bindgen_ty_1 {
    pub fn in_saddr(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.in_saddr) }.ok()
    }
    pub fn in6_saddr(&self) -> Option<in6_addr> {
        unsafe { crate::bpf_probe_read(&self.in6_saddr) }.ok()
    }
}
impl devlink_info_req {
    pub fn msg(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.msg) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl psample_group {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn net(&self) -> Option<*mut net> {
        let v = unsafe { crate::bpf_probe_read(&self.net) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn group_num(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.group_num) }.ok()
    }
    pub fn refcount(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.refcount) }.ok()
    }
    pub fn seq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl action_gate_entry {
    pub fn gate_state(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.gate_state) }.ok()
    }
    pub fn interval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.interval) }.ok()
    }
    pub fn ipv(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.ipv) }.ok()
    }
    pub fn maxoctets(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.maxoctets) }.ok()
    }
}
impl nf_queue_entry {
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn skb(&self) -> Option<*mut sk_buff> {
        let v = unsafe { crate::bpf_probe_read(&self.skb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn id(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.id) }.ok()
    }
    pub fn hook_index(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.hook_index) }.ok()
    }
    pub fn physin(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.physin) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn physout(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.physout) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn state(&self) -> Option<nf_hook_state> {
        unsafe { crate::bpf_probe_read(&self.state) }.ok()
    }
    pub fn size(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.size) }.ok()
    }
}
impl nf_loginfo {
    pub fn type_(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn u(&self) -> Option<nf_loginfo__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.u) }.ok()
    }
}
impl nf_loginfo__bindgen_ty_1 {
    pub fn ulog(&self) -> Option<nf_loginfo__bindgen_ty_1__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ulog) }.ok()
    }
    pub fn log(&self) -> Option<nf_loginfo__bindgen_ty_1__bindgen_ty_2> {
        unsafe { crate::bpf_probe_read(&self.log) }.ok()
    }
}
impl nf_loginfo__bindgen_ty_1__bindgen_ty_1 {
    pub fn copy_len(&self) -> Option<u_int32_t> {
        unsafe { crate::bpf_probe_read(&self.copy_len) }.ok()
    }
    pub fn group(&self) -> Option<u_int16_t> {
        unsafe { crate::bpf_probe_read(&self.group) }.ok()
    }
    pub fn qthreshold(&self) -> Option<u_int16_t> {
        unsafe { crate::bpf_probe_read(&self.qthreshold) }.ok()
    }
    pub fn flags(&self) -> Option<u_int16_t> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
}
impl nf_loginfo__bindgen_ty_1__bindgen_ty_2 {
    pub fn level(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.level) }.ok()
    }
    pub fn logflags(&self) -> Option<u_int8_t> {
        unsafe { crate::bpf_probe_read(&self.logflags) }.ok()
    }
}
impl ip_mreqn {
    pub fn imr_multiaddr(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.imr_multiaddr) }.ok()
    }
    pub fn imr_address(&self) -> Option<in_addr> {
        unsafe { crate::bpf_probe_read(&self.imr_address) }.ok()
    }
    pub fn imr_ifindex(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.imr_ifindex) }.ok()
    }
}
impl ip_mc_list {
    pub fn interface(&self) -> Option<*mut in_device> {
        let v = unsafe { crate::bpf_probe_read(&self.interface) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn multiaddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.multiaddr) }.ok()
    }
    pub fn sfmode(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sfmode) }.ok()
    }
    pub fn sources(&self) -> Option<*mut ip_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.sources) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tomb(&self) -> Option<*mut ip_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.tomb) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sfcount(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.sfcount) }.ok()
    }
    pub fn next(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next_rcu(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.__bindgen_anon_1.next_rcu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next_hash(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.next_hash) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn timer(&self) -> Option<timer_list> {
        unsafe { crate::bpf_probe_read(&self.timer) }.ok()
    }
    pub fn users(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.users) }.ok()
    }
    pub fn refcnt(&self) -> Option<refcount_t> {
        unsafe { crate::bpf_probe_read(&self.refcnt) }.ok()
    }
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn tm_running(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.tm_running) }.ok()
    }
    pub fn reporter(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.reporter) }.ok()
    }
    pub fn unsolicit_count(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.unsolicit_count) }.ok()
    }
    pub fn loaded(&self) -> Option<::aya_bpf_cty::c_char> {
        unsafe { crate::bpf_probe_read(&self.loaded) }.ok()
    }
    pub fn gsquery(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.gsquery) }.ok()
    }
    pub fn crcount(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.crcount) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ip_mc_list__bindgen_ty_1 {
    pub fn next(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn next_rcu(&self) -> Option<*mut ip_mc_list> {
        let v = unsafe { crate::bpf_probe_read(&self.next_rcu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ip_sf_socklist {
    pub fn sl_max(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sl_max) }.ok()
    }
    pub fn sl_count(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sl_count) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
    pub fn sl_addr(&self) -> Option<__IncompleteArrayField<__be32>> {
        unsafe { crate::bpf_probe_read(&self.sl_addr) }.ok()
    }
}
impl ip_mc_socklist {
    pub fn next_rcu(&self) -> Option<*mut ip_mc_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.next_rcu) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn multi(&self) -> Option<ip_mreqn> {
        unsafe { crate::bpf_probe_read(&self.multi) }.ok()
    }
    pub fn sfmode(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.sfmode) }.ok()
    }
    pub fn sflist(&self) -> Option<*mut ip_sf_socklist> {
        let v = unsafe { crate::bpf_probe_read(&self.sflist) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl ip_sf_list {
    pub fn sf_next(&self) -> Option<*mut ip_sf_list> {
        let v = unsafe { crate::bpf_probe_read(&self.sf_next) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sf_count(&self) -> Option<[::aya_bpf_cty::c_ulong; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.sf_count) }.ok()
    }
    pub fn sf_inaddr(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.sf_inaddr) }.ok()
    }
    pub fn sf_gsresp(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_gsresp) }.ok()
    }
    pub fn sf_oldin(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_oldin) }.ok()
    }
    pub fn sf_crcount(&self) -> Option<::aya_bpf_cty::c_uchar> {
        unsafe { crate::bpf_probe_read(&self.sf_crcount) }.ok()
    }
}
impl uncached_list {
    pub fn lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn head(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.head) }.ok()
    }
}
impl raw_hashinfo {
    pub fn lock(&self) -> Option<rwlock_t> {
        unsafe { crate::bpf_probe_read(&self.lock) }.ok()
    }
    pub fn ht(&self) -> Option<[hlist_head; 256usize]> {
        unsafe { crate::bpf_probe_read(&self.ht) }.ok()
    }
}
impl tcpvegas_info {
    pub fn tcpv_enabled(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcpv_enabled) }.ok()
    }
    pub fn tcpv_rttcnt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcpv_rttcnt) }.ok()
    }
    pub fn tcpv_rtt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcpv_rtt) }.ok()
    }
    pub fn tcpv_minrtt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.tcpv_minrtt) }.ok()
    }
}
impl tcp_dctcp_info {
    pub fn dctcp_enabled(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.dctcp_enabled) }.ok()
    }
    pub fn dctcp_ce_state(&self) -> Option<__u16> {
        unsafe { crate::bpf_probe_read(&self.dctcp_ce_state) }.ok()
    }
    pub fn dctcp_alpha(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dctcp_alpha) }.ok()
    }
    pub fn dctcp_ab_ecn(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dctcp_ab_ecn) }.ok()
    }
    pub fn dctcp_ab_tot(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.dctcp_ab_tot) }.ok()
    }
}
impl tcp_bbr_info {
    pub fn bbr_bw_lo(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bbr_bw_lo) }.ok()
    }
    pub fn bbr_bw_hi(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bbr_bw_hi) }.ok()
    }
    pub fn bbr_min_rtt(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bbr_min_rtt) }.ok()
    }
    pub fn bbr_pacing_gain(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bbr_pacing_gain) }.ok()
    }
    pub fn bbr_cwnd_gain(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bbr_cwnd_gain) }.ok()
    }
}
impl tcp_cc_info {
    pub fn vegas(&self) -> Option<tcpvegas_info> {
        unsafe { crate::bpf_probe_read(&self.vegas) }.ok()
    }
    pub fn dctcp(&self) -> Option<tcp_dctcp_info> {
        unsafe { crate::bpf_probe_read(&self.dctcp) }.ok()
    }
    pub fn bbr(&self) -> Option<tcp_bbr_info> {
        unsafe { crate::bpf_probe_read(&self.bbr) }.ok()
    }
}
impl vlan_group {
    pub fn nr_vlan_devs(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_vlan_devs) }.ok()
    }
    pub fn hlist(&self) -> Option<hlist_node> {
        unsafe { crate::bpf_probe_read(&self.hlist) }.ok()
    }
    pub fn vlan_devices_arrays(&self) -> Option<[*mut *mut net_device; 16usize]> {
        unsafe { crate::bpf_probe_read(&self.vlan_devices_arrays) }.ok()
    }
}
impl vlan_info {
    pub fn real_dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.real_dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn grp(&self) -> Option<vlan_group> {
        unsafe { crate::bpf_probe_read(&self.grp) }.ok()
    }
    pub fn vid_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.vid_list) }.ok()
    }
    pub fn nr_vids(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.nr_vids) }.ok()
    }
    pub fn rcu(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.rcu) }.ok()
    }
}
impl cfg80211_conn {}
impl cfg80211_cached_keys {}
impl cfg80211_internal_bss {}
impl ieee80211_edmg {
    pub fn channels(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.channels) }.ok()
    }
    pub fn bw_config(&self) -> Option<ieee80211_edmg_bw_config::Type> {
        unsafe { crate::bpf_probe_read(&self.bw_config) }.ok()
    }
}
impl cfg80211_chan_def {
    pub fn chan(&self) -> Option<*mut ieee80211_channel> {
        let v = unsafe { crate::bpf_probe_read(&self.chan) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn width(&self) -> Option<nl80211_chan_width::Type> {
        unsafe { crate::bpf_probe_read(&self.width) }.ok()
    }
    pub fn center_freq1(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.center_freq1) }.ok()
    }
    pub fn center_freq2(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.center_freq2) }.ok()
    }
    pub fn edmg(&self) -> Option<ieee80211_edmg> {
        unsafe { crate::bpf_probe_read(&self.edmg) }.ok()
    }
    pub fn freq1_offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.freq1_offset) }.ok()
    }
}
impl ieee80211_mcs_info {
    pub fn rx_mask(&self) -> Option<[u8_; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.rx_mask) }.ok()
    }
    pub fn rx_highest(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_highest) }.ok()
    }
    pub fn tx_params(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.tx_params) }.ok()
    }
    pub fn reserved(&self) -> Option<[u8_; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.reserved) }.ok()
    }
}
impl ieee80211_ht_cap {
    pub fn cap_info(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.cap_info) }.ok()
    }
    pub fn ampdu_params_info(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ampdu_params_info) }.ok()
    }
    pub fn mcs(&self) -> Option<ieee80211_mcs_info> {
        unsafe { crate::bpf_probe_read(&self.mcs) }.ok()
    }
    pub fn extended_ht_cap_info(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.extended_ht_cap_info) }.ok()
    }
    pub fn tx_BF_cap_info(&self) -> Option<__le32> {
        unsafe { crate::bpf_probe_read(&self.tx_BF_cap_info) }.ok()
    }
    pub fn antenna_selection_info(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.antenna_selection_info) }.ok()
    }
}
impl cfg80211_ibss_params {
    pub fn ssid(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ssid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bssid(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.bssid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn chandef(&self) -> Option<cfg80211_chan_def> {
        unsafe { crate::bpf_probe_read(&self.chandef) }.ok()
    }
    pub fn ie(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ssid_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ssid_len) }.ok()
    }
    pub fn ie_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ie_len) }.ok()
    }
    pub fn beacon_interval(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.beacon_interval) }.ok()
    }
    pub fn basic_rates(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.basic_rates) }.ok()
    }
    pub fn channel_fixed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.channel_fixed) }.ok()
    }
    pub fn privacy(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.privacy) }.ok()
    }
    pub fn control_port(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port) }.ok()
    }
    pub fn control_port_over_nl80211(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port_over_nl80211) }.ok()
    }
    pub fn userspace_handles_dfs(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.userspace_handles_dfs) }.ok()
    }
    pub fn mcast_rate(&self) -> Option<[::aya_bpf_cty::c_int; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.mcast_rate) }.ok()
    }
    pub fn ht_capa(&self) -> Option<ieee80211_ht_cap> {
        unsafe { crate::bpf_probe_read(&self.ht_capa) }.ok()
    }
    pub fn ht_capa_mask(&self) -> Option<ieee80211_ht_cap> {
        unsafe { crate::bpf_probe_read(&self.ht_capa_mask) }.ok()
    }
    pub fn wep_keys(&self) -> Option<*mut key_params> {
        let v = unsafe { crate::bpf_probe_read(&self.wep_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wep_tx_key(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wep_tx_key) }.ok()
    }
}
impl cfg80211_crypto_settings {
    pub fn wpa_versions(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.wpa_versions) }.ok()
    }
    pub fn cipher_group(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cipher_group) }.ok()
    }
    pub fn n_ciphers_pairwise(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_ciphers_pairwise) }.ok()
    }
    pub fn ciphers_pairwise(&self) -> Option<[u32_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.ciphers_pairwise) }.ok()
    }
    pub fn n_akm_suites(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_akm_suites) }.ok()
    }
    pub fn akm_suites(&self) -> Option<[u32_; 2usize]> {
        unsafe { crate::bpf_probe_read(&self.akm_suites) }.ok()
    }
    pub fn control_port(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port) }.ok()
    }
    pub fn control_port_ethertype(&self) -> Option<__be16> {
        unsafe { crate::bpf_probe_read(&self.control_port_ethertype) }.ok()
    }
    pub fn control_port_no_encrypt(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port_no_encrypt) }.ok()
    }
    pub fn control_port_over_nl80211(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port_over_nl80211) }.ok()
    }
    pub fn control_port_no_preauth(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.control_port_no_preauth) }.ok()
    }
    pub fn wep_keys(&self) -> Option<*mut key_params> {
        let v = unsafe { crate::bpf_probe_read(&self.wep_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wep_tx_key(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wep_tx_key) }.ok()
    }
    pub fn psk(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.psk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sae_pwd(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.sae_pwd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn sae_pwd_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.sae_pwd_len) }.ok()
    }
    pub fn sae_pwe(&self) -> Option<nl80211_sae_pwe_mechanism::Type> {
        unsafe { crate::bpf_probe_read(&self.sae_pwe) }.ok()
    }
}
impl ieee80211_vht_mcs_info {
    pub fn rx_mcs_map(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_mcs_map) }.ok()
    }
    pub fn rx_highest(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_highest) }.ok()
    }
    pub fn tx_mcs_map(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.tx_mcs_map) }.ok()
    }
    pub fn tx_highest(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.tx_highest) }.ok()
    }
}
impl ieee80211_vht_cap {
    pub fn vht_cap_info(&self) -> Option<__le32> {
        unsafe { crate::bpf_probe_read(&self.vht_cap_info) }.ok()
    }
    pub fn supp_mcs(&self) -> Option<ieee80211_vht_mcs_info> {
        unsafe { crate::bpf_probe_read(&self.supp_mcs) }.ok()
    }
}
impl cfg80211_bss_select_adjust {
    pub fn band(&self) -> Option<nl80211_band::Type> {
        unsafe { crate::bpf_probe_read(&self.band) }.ok()
    }
    pub fn delta(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.delta) }.ok()
    }
}
impl cfg80211_bss_selection {
    pub fn behaviour(&self) -> Option<nl80211_bss_select_attr::Type> {
        unsafe { crate::bpf_probe_read(&self.behaviour) }.ok()
    }
    pub fn param(&self) -> Option<cfg80211_bss_selection__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.param) }.ok()
    }
}
impl cfg80211_bss_selection__bindgen_ty_1 {
    pub fn band_pref(&self) -> Option<nl80211_band::Type> {
        unsafe { crate::bpf_probe_read(&self.band_pref) }.ok()
    }
    pub fn adjust(&self) -> Option<cfg80211_bss_select_adjust> {
        unsafe { crate::bpf_probe_read(&self.adjust) }.ok()
    }
}
impl cfg80211_connect_params {
    pub fn channel(&self) -> Option<*mut ieee80211_channel> {
        let v = unsafe { crate::bpf_probe_read(&self.channel) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn channel_hint(&self) -> Option<*mut ieee80211_channel> {
        let v = unsafe { crate::bpf_probe_read(&self.channel_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bssid(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.bssid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bssid_hint(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.bssid_hint) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ssid(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ssid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ssid_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.ssid_len) }.ok()
    }
    pub fn auth_type(&self) -> Option<nl80211_auth_type::Type> {
        unsafe { crate::bpf_probe_read(&self.auth_type) }.ok()
    }
    pub fn ie(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ie_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.ie_len) }.ok()
    }
    pub fn privacy(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.privacy) }.ok()
    }
    pub fn mfp(&self) -> Option<nl80211_mfp::Type> {
        unsafe { crate::bpf_probe_read(&self.mfp) }.ok()
    }
    pub fn crypto(&self) -> Option<cfg80211_crypto_settings> {
        unsafe { crate::bpf_probe_read(&self.crypto) }.ok()
    }
    pub fn key(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.key_len) }.ok()
    }
    pub fn key_idx(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.key_idx) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn bg_scan_period(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bg_scan_period) }.ok()
    }
    pub fn ht_capa(&self) -> Option<ieee80211_ht_cap> {
        unsafe { crate::bpf_probe_read(&self.ht_capa) }.ok()
    }
    pub fn ht_capa_mask(&self) -> Option<ieee80211_ht_cap> {
        unsafe { crate::bpf_probe_read(&self.ht_capa_mask) }.ok()
    }
    pub fn vht_capa(&self) -> Option<ieee80211_vht_cap> {
        unsafe { crate::bpf_probe_read(&self.vht_capa) }.ok()
    }
    pub fn vht_capa_mask(&self) -> Option<ieee80211_vht_cap> {
        unsafe { crate::bpf_probe_read(&self.vht_capa_mask) }.ok()
    }
    pub fn pbss(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.pbss) }.ok()
    }
    pub fn bss_select(&self) -> Option<cfg80211_bss_selection> {
        unsafe { crate::bpf_probe_read(&self.bss_select) }.ok()
    }
    pub fn prev_bssid(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.prev_bssid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fils_erp_username(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.fils_erp_username) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fils_erp_username_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.fils_erp_username_len) }.ok()
    }
    pub fn fils_erp_realm(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.fils_erp_realm) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fils_erp_realm_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.fils_erp_realm_len) }.ok()
    }
    pub fn fils_erp_next_seq_num(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.fils_erp_next_seq_num) }.ok()
    }
    pub fn fils_erp_rrk(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.fils_erp_rrk) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn fils_erp_rrk_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.fils_erp_rrk_len) }.ok()
    }
    pub fn want_1x(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.want_1x) }.ok()
    }
    pub fn edmg(&self) -> Option<ieee80211_edmg> {
        unsafe { crate::bpf_probe_read(&self.edmg) }.ok()
    }
}
impl cfg80211_cqm_config {}
impl wireless_dev {
    pub fn wiphy(&self) -> Option<*mut wiphy> {
        let v = unsafe { crate::bpf_probe_read(&self.wiphy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iftype(&self) -> Option<nl80211_iftype::Type> {
        unsafe { crate::bpf_probe_read(&self.iftype) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn netdev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.netdev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn identifier(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.identifier) }.ok()
    }
    pub fn mgmt_registrations(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.mgmt_registrations) }.ok()
    }
    pub fn mgmt_registrations_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.mgmt_registrations_lock) }.ok()
    }
    pub fn mtx(&self) -> Option<mutex> {
        unsafe { crate::bpf_probe_read(&self.mtx) }.ok()
    }
    pub fn use_4addr(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.use_4addr) }.ok()
    }
    pub fn is_running(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.is_running) }.ok()
    }
    pub fn address(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.address) }.ok()
    }
    pub fn ssid(&self) -> Option<[u8_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.ssid) }.ok()
    }
    pub fn ssid_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ssid_len) }.ok()
    }
    pub fn mesh_id_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mesh_id_len) }.ok()
    }
    pub fn mesh_id_up_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.mesh_id_up_len) }.ok()
    }
    pub fn conn(&self) -> Option<*mut cfg80211_conn> {
        let v = unsafe { crate::bpf_probe_read(&self.conn) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn connect_keys(&self) -> Option<*mut cfg80211_cached_keys> {
        let v = unsafe { crate::bpf_probe_read(&self.connect_keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn conn_bss_type(&self) -> Option<ieee80211_bss_type::Type> {
        unsafe { crate::bpf_probe_read(&self.conn_bss_type) }.ok()
    }
    pub fn conn_owner_nlportid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.conn_owner_nlportid) }.ok()
    }
    pub fn disconnect_wk(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.disconnect_wk) }.ok()
    }
    pub fn disconnect_bssid(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.disconnect_bssid) }.ok()
    }
    pub fn event_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.event_list) }.ok()
    }
    pub fn event_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.event_lock) }.ok()
    }
    pub fn current_bss(&self) -> Option<*mut cfg80211_internal_bss> {
        let v = unsafe { crate::bpf_probe_read(&self.current_bss) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn preset_chandef(&self) -> Option<cfg80211_chan_def> {
        unsafe { crate::bpf_probe_read(&self.preset_chandef) }.ok()
    }
    pub fn chandef(&self) -> Option<cfg80211_chan_def> {
        unsafe { crate::bpf_probe_read(&self.chandef) }.ok()
    }
    pub fn ibss_fixed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ibss_fixed) }.ok()
    }
    pub fn ibss_dfs_possible(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ibss_dfs_possible) }.ok()
    }
    pub fn ps(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ps) }.ok()
    }
    pub fn ps_timeout(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.ps_timeout) }.ok()
    }
    pub fn beacon_interval(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.beacon_interval) }.ok()
    }
    pub fn ap_unexpected_nlportid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ap_unexpected_nlportid) }.ok()
    }
    pub fn owner_nlportid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.owner_nlportid) }.ok()
    }
    pub fn nl_owner_dead(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.nl_owner_dead) }.ok()
    }
    pub fn cac_started(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.cac_started) }.ok()
    }
    pub fn cac_start_time(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.cac_start_time) }.ok()
    }
    pub fn cac_time_ms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.cac_time_ms) }.ok()
    }
    pub fn wext(&self) -> Option<wireless_dev__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.wext) }.ok()
    }
    pub fn cqm_config(&self) -> Option<*mut cfg80211_cqm_config> {
        let v = unsafe { crate::bpf_probe_read(&self.cqm_config) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pmsr_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.pmsr_list) }.ok()
    }
    pub fn pmsr_lock(&self) -> Option<spinlock_t> {
        unsafe { crate::bpf_probe_read(&self.pmsr_lock) }.ok()
    }
    pub fn pmsr_free_wk(&self) -> Option<work_struct> {
        unsafe { crate::bpf_probe_read(&self.pmsr_free_wk) }.ok()
    }
    pub fn unprot_beacon_reported(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.unprot_beacon_reported) }.ok()
    }
}
impl wireless_dev__bindgen_ty_1 {
    pub fn ibss(&self) -> Option<cfg80211_ibss_params> {
        unsafe { crate::bpf_probe_read(&self.ibss) }.ok()
    }
    pub fn connect(&self) -> Option<cfg80211_connect_params> {
        unsafe { crate::bpf_probe_read(&self.connect) }.ok()
    }
    pub fn keys(&self) -> Option<*mut cfg80211_cached_keys> {
        let v = unsafe { crate::bpf_probe_read(&self.keys) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ie(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ie_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.ie_len) }.ok()
    }
    pub fn bssid(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.bssid) }.ok()
    }
    pub fn prev_bssid(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.prev_bssid) }.ok()
    }
    pub fn ssid(&self) -> Option<[u8_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.ssid) }.ok()
    }
    pub fn default_key(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.default_key) }.ok()
    }
    pub fn default_mgmt_key(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.default_mgmt_key) }.ok()
    }
    pub fn prev_bssid_valid(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.prev_bssid_valid) }.ok()
    }
}
impl nl80211_wowlan_tcp_data_seq {
    pub fn start(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.start) }.ok()
    }
    pub fn offset(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
}
impl nl80211_wowlan_tcp_data_token {
    pub fn offset(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.offset) }.ok()
    }
    pub fn len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.len) }.ok()
    }
    pub fn token_stream(&self) -> Option<__IncompleteArrayField<__u8>> {
        unsafe { crate::bpf_probe_read(&self.token_stream) }.ok()
    }
}
impl nl80211_wowlan_tcp_data_token_feature {
    pub fn min_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.min_len) }.ok()
    }
    pub fn max_len(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.max_len) }.ok()
    }
    pub fn bufsize(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.bufsize) }.ok()
    }
}
impl nl80211_vendor_cmd_info {
    pub fn vendor_id(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.vendor_id) }.ok()
    }
    pub fn subcmd(&self) -> Option<__u32> {
        unsafe { crate::bpf_probe_read(&self.subcmd) }.ok()
    }
}
impl ieee80211_he_cap_elem {
    pub fn mac_cap_info(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.mac_cap_info) }.ok()
    }
    pub fn phy_cap_info(&self) -> Option<[u8_; 11usize]> {
        unsafe { crate::bpf_probe_read(&self.phy_cap_info) }.ok()
    }
}
impl ieee80211_he_mcs_nss_supp {
    pub fn rx_mcs_80(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_mcs_80) }.ok()
    }
    pub fn tx_mcs_80(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.tx_mcs_80) }.ok()
    }
    pub fn rx_mcs_160(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_mcs_160) }.ok()
    }
    pub fn tx_mcs_160(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.tx_mcs_160) }.ok()
    }
    pub fn rx_mcs_80p80(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.rx_mcs_80p80) }.ok()
    }
    pub fn tx_mcs_80p80(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.tx_mcs_80p80) }.ok()
    }
}
impl ieee80211_he_6ghz_capa {
    pub fn capa(&self) -> Option<__le16> {
        unsafe { crate::bpf_probe_read(&self.capa) }.ok()
    }
}
impl regulatory_request {
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn wiphy_idx(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.wiphy_idx) }.ok()
    }
    pub fn initiator(&self) -> Option<nl80211_reg_initiator::Type> {
        unsafe { crate::bpf_probe_read(&self.initiator) }.ok()
    }
    pub fn user_reg_hint_type(&self) -> Option<nl80211_user_reg_hint_type::Type> {
        unsafe { crate::bpf_probe_read(&self.user_reg_hint_type) }.ok()
    }
    pub fn alpha2(&self) -> Option<[::aya_bpf_cty::c_char; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.alpha2) }.ok()
    }
    pub fn dfs_region(&self) -> Option<nl80211_dfs_regions::Type> {
        unsafe { crate::bpf_probe_read(&self.dfs_region) }.ok()
    }
    pub fn intersect(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.intersect) }.ok()
    }
    pub fn processed(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.processed) }.ok()
    }
    pub fn country_ie_env(&self) -> Option<environment_cap::Type> {
        unsafe { crate::bpf_probe_read(&self.country_ie_env) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
}
impl ieee80211_freq_range {
    pub fn start_freq_khz(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start_freq_khz) }.ok()
    }
    pub fn end_freq_khz(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.end_freq_khz) }.ok()
    }
    pub fn max_bandwidth_khz(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_bandwidth_khz) }.ok()
    }
}
impl ieee80211_power_rule {
    pub fn max_antenna_gain(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_antenna_gain) }.ok()
    }
    pub fn max_eirp(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_eirp) }.ok()
    }
}
impl ieee80211_wmm_ac {
    pub fn cw_min(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cw_min) }.ok()
    }
    pub fn cw_max(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cw_max) }.ok()
    }
    pub fn cot(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cot) }.ok()
    }
    pub fn aifsn(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.aifsn) }.ok()
    }
}
impl ieee80211_wmm_rule {
    pub fn client(&self) -> Option<[ieee80211_wmm_ac; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.client) }.ok()
    }
    pub fn ap(&self) -> Option<[ieee80211_wmm_ac; 4usize]> {
        unsafe { crate::bpf_probe_read(&self.ap) }.ok()
    }
}
impl ieee80211_reg_rule {
    pub fn freq_range(&self) -> Option<ieee80211_freq_range> {
        unsafe { crate::bpf_probe_read(&self.freq_range) }.ok()
    }
    pub fn power_rule(&self) -> Option<ieee80211_power_rule> {
        unsafe { crate::bpf_probe_read(&self.power_rule) }.ok()
    }
    pub fn wmm_rule(&self) -> Option<ieee80211_wmm_rule> {
        unsafe { crate::bpf_probe_read(&self.wmm_rule) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn dfs_cac_ms(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.dfs_cac_ms) }.ok()
    }
    pub fn has_wmm(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_wmm) }.ok()
    }
}
impl ieee80211_regdomain {
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn n_reg_rules(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.n_reg_rules) }.ok()
    }
    pub fn alpha2(&self) -> Option<[::aya_bpf_cty::c_char; 3usize]> {
        unsafe { crate::bpf_probe_read(&self.alpha2) }.ok()
    }
    pub fn dfs_region(&self) -> Option<nl80211_dfs_regions::Type> {
        unsafe { crate::bpf_probe_read(&self.dfs_region) }.ok()
    }
    pub fn reg_rules(&self) -> Option<__IncompleteArrayField<ieee80211_reg_rule>> {
        unsafe { crate::bpf_probe_read(&self.reg_rules) }.ok()
    }
}
impl ieee80211_channel {
    pub fn band(&self) -> Option<nl80211_band::Type> {
        unsafe { crate::bpf_probe_read(&self.band) }.ok()
    }
    pub fn center_freq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.center_freq) }.ok()
    }
    pub fn freq_offset(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.freq_offset) }.ok()
    }
    pub fn hw_value(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.hw_value) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn max_antenna_gain(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_antenna_gain) }.ok()
    }
    pub fn max_power(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_power) }.ok()
    }
    pub fn max_reg_power(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_reg_power) }.ok()
    }
    pub fn beacon_found(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.beacon_found) }.ok()
    }
    pub fn orig_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.orig_flags) }.ok()
    }
    pub fn orig_mag(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.orig_mag) }.ok()
    }
    pub fn orig_mpwr(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.orig_mpwr) }.ok()
    }
    pub fn dfs_state(&self) -> Option<nl80211_dfs_state::Type> {
        unsafe { crate::bpf_probe_read(&self.dfs_state) }.ok()
    }
    pub fn dfs_state_entered(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.dfs_state_entered) }.ok()
    }
    pub fn dfs_cac_ms(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.dfs_cac_ms) }.ok()
    }
}
impl ieee80211_rate {
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn bitrate(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.bitrate) }.ok()
    }
    pub fn hw_value(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.hw_value) }.ok()
    }
    pub fn hw_value_short(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.hw_value_short) }.ok()
    }
}
impl ieee80211_sta_ht_cap {
    pub fn cap(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.cap) }.ok()
    }
    pub fn ht_supported(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.ht_supported) }.ok()
    }
    pub fn ampdu_factor(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ampdu_factor) }.ok()
    }
    pub fn ampdu_density(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ampdu_density) }.ok()
    }
    pub fn mcs(&self) -> Option<ieee80211_mcs_info> {
        unsafe { crate::bpf_probe_read(&self.mcs) }.ok()
    }
}
impl ieee80211_sta_vht_cap {
    pub fn vht_supported(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.vht_supported) }.ok()
    }
    pub fn cap(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cap) }.ok()
    }
    pub fn vht_mcs(&self) -> Option<ieee80211_vht_mcs_info> {
        unsafe { crate::bpf_probe_read(&self.vht_mcs) }.ok()
    }
}
impl ieee80211_sta_he_cap {
    pub fn has_he(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.has_he) }.ok()
    }
    pub fn he_cap_elem(&self) -> Option<ieee80211_he_cap_elem> {
        unsafe { crate::bpf_probe_read(&self.he_cap_elem) }.ok()
    }
    pub fn he_mcs_nss_supp(&self) -> Option<ieee80211_he_mcs_nss_supp> {
        unsafe { crate::bpf_probe_read(&self.he_mcs_nss_supp) }.ok()
    }
    pub fn ppe_thres(&self) -> Option<[u8_; 25usize]> {
        unsafe { crate::bpf_probe_read(&self.ppe_thres) }.ok()
    }
}
impl ieee80211_sband_iftype_data {
    pub fn types_mask(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.types_mask) }.ok()
    }
    pub fn he_cap(&self) -> Option<ieee80211_sta_he_cap> {
        unsafe { crate::bpf_probe_read(&self.he_cap) }.ok()
    }
    pub fn he_6ghz_capa(&self) -> Option<ieee80211_he_6ghz_capa> {
        unsafe { crate::bpf_probe_read(&self.he_6ghz_capa) }.ok()
    }
}
impl ieee80211_sta_s1g_cap {
    pub fn s1g(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.s1g) }.ok()
    }
    pub fn cap(&self) -> Option<[u8_; 10usize]> {
        unsafe { crate::bpf_probe_read(&self.cap) }.ok()
    }
    pub fn nss_mcs(&self) -> Option<[u8_; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.nss_mcs) }.ok()
    }
}
impl ieee80211_supported_band {
    pub fn channels(&self) -> Option<*mut ieee80211_channel> {
        let v = unsafe { crate::bpf_probe_read(&self.channels) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bitrates(&self) -> Option<*mut ieee80211_rate> {
        let v = unsafe { crate::bpf_probe_read(&self.bitrates) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn band(&self) -> Option<nl80211_band::Type> {
        unsafe { crate::bpf_probe_read(&self.band) }.ok()
    }
    pub fn n_channels(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_channels) }.ok()
    }
    pub fn n_bitrates(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_bitrates) }.ok()
    }
    pub fn ht_cap(&self) -> Option<ieee80211_sta_ht_cap> {
        unsafe { crate::bpf_probe_read(&self.ht_cap) }.ok()
    }
    pub fn vht_cap(&self) -> Option<ieee80211_sta_vht_cap> {
        unsafe { crate::bpf_probe_read(&self.vht_cap) }.ok()
    }
    pub fn s1g_cap(&self) -> Option<ieee80211_sta_s1g_cap> {
        unsafe { crate::bpf_probe_read(&self.s1g_cap) }.ok()
    }
    pub fn edmg_cap(&self) -> Option<ieee80211_edmg> {
        unsafe { crate::bpf_probe_read(&self.edmg_cap) }.ok()
    }
    pub fn n_iftype_data(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.n_iftype_data) }.ok()
    }
    pub fn iftype_data(&self) -> Option<*const ieee80211_sband_iftype_data> {
        let v = unsafe { crate::bpf_probe_read(&self.iftype_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl key_params {
    pub fn key(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.key) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn seq(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.seq) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn key_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.key_len) }.ok()
    }
    pub fn seq_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.seq_len) }.ok()
    }
    pub fn vlan_id(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.vlan_id) }.ok()
    }
    pub fn cipher(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cipher) }.ok()
    }
    pub fn mode(&self) -> Option<nl80211_key_mode::Type> {
        unsafe { crate::bpf_probe_read(&self.mode) }.ok()
    }
}
impl mac_address {
    pub fn addr(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.addr) }.ok()
    }
}
impl cfg80211_sar_freq_ranges {
    pub fn start_freq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.start_freq) }.ok()
    }
    pub fn end_freq(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.end_freq) }.ok()
    }
}
impl cfg80211_sar_capa {
    pub fn type_(&self) -> Option<nl80211_sar_type::Type> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn num_freq_ranges(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_freq_ranges) }.ok()
    }
    pub fn freq_ranges(&self) -> Option<*const cfg80211_sar_freq_ranges> {
        let v = unsafe { crate::bpf_probe_read(&self.freq_ranges) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl cfg80211_ssid {
    pub fn ssid(&self) -> Option<[u8_; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.ssid) }.ok()
    }
    pub fn ssid_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.ssid_len) }.ok()
    }
}
impl wiphy {
    pub fn perm_addr(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.perm_addr) }.ok()
    }
    pub fn addr_mask(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.addr_mask) }.ok()
    }
    pub fn addresses(&self) -> Option<*mut mac_address> {
        let v = unsafe { crate::bpf_probe_read(&self.addresses) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn mgmt_stypes(&self) -> Option<*const ieee80211_txrx_stypes> {
        let v = unsafe { crate::bpf_probe_read(&self.mgmt_stypes) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iface_combinations(&self) -> Option<*const ieee80211_iface_combination> {
        let v = unsafe { crate::bpf_probe_read(&self.iface_combinations) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_iface_combinations(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_iface_combinations) }.ok()
    }
    pub fn software_iftypes(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.software_iftypes) }.ok()
    }
    pub fn n_addresses(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.n_addresses) }.ok()
    }
    pub fn interface_modes(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.interface_modes) }.ok()
    }
    pub fn max_acl_mac_addrs(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_acl_mac_addrs) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn regulatory_flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.regulatory_flags) }.ok()
    }
    pub fn features(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.features) }.ok()
    }
    pub fn ext_features(&self) -> Option<[u8_; 7usize]> {
        unsafe { crate::bpf_probe_read(&self.ext_features) }.ok()
    }
    pub fn ap_sme_capa(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ap_sme_capa) }.ok()
    }
    pub fn signal_type(&self) -> Option<cfg80211_signal_type::Type> {
        unsafe { crate::bpf_probe_read(&self.signal_type) }.ok()
    }
    pub fn bss_priv_size(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.bss_priv_size) }.ok()
    }
    pub fn max_scan_ssids(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_scan_ssids) }.ok()
    }
    pub fn max_sched_scan_reqs(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_reqs) }.ok()
    }
    pub fn max_sched_scan_ssids(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_ssids) }.ok()
    }
    pub fn max_match_sets(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_match_sets) }.ok()
    }
    pub fn max_scan_ie_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_scan_ie_len) }.ok()
    }
    pub fn max_sched_scan_ie_len(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_ie_len) }.ok()
    }
    pub fn max_sched_scan_plans(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_plans) }.ok()
    }
    pub fn max_sched_scan_plan_interval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_plan_interval) }.ok()
    }
    pub fn max_sched_scan_plan_iterations(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.max_sched_scan_plan_iterations) }.ok()
    }
    pub fn n_cipher_suites(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_cipher_suites) }.ok()
    }
    pub fn cipher_suites(&self) -> Option<*const u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.cipher_suites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_akm_suites(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_akm_suites) }.ok()
    }
    pub fn akm_suites(&self) -> Option<*const u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.akm_suites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn iftype_akm_suites(&self) -> Option<*const wiphy_iftype_akm_suites> {
        let v = unsafe { crate::bpf_probe_read(&self.iftype_akm_suites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_iftype_akm_suites(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_iftype_akm_suites) }.ok()
    }
    pub fn retry_short(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.retry_short) }.ok()
    }
    pub fn retry_long(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.retry_long) }.ok()
    }
    pub fn frag_threshold(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.frag_threshold) }.ok()
    }
    pub fn rts_threshold(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.rts_threshold) }.ok()
    }
    pub fn coverage_class(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.coverage_class) }.ok()
    }
    pub fn fw_version(&self) -> Option<[::aya_bpf_cty::c_char; 32usize]> {
        unsafe { crate::bpf_probe_read(&self.fw_version) }.ok()
    }
    pub fn hw_version(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.hw_version) }.ok()
    }
    pub fn wowlan(&self) -> Option<*const wiphy_wowlan_support> {
        let v = unsafe { crate::bpf_probe_read(&self.wowlan) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wowlan_config(&self) -> Option<*mut cfg80211_wowlan> {
        let v = unsafe { crate::bpf_probe_read(&self.wowlan_config) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn max_remain_on_channel_duration(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_remain_on_channel_duration) }.ok()
    }
    pub fn max_num_pmkids(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_num_pmkids) }.ok()
    }
    pub fn available_antennas_tx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.available_antennas_tx) }.ok()
    }
    pub fn available_antennas_rx(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.available_antennas_rx) }.ok()
    }
    pub fn probe_resp_offload(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.probe_resp_offload) }.ok()
    }
    pub fn extended_capabilities(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.extended_capabilities) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extended_capabilities_mask(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.extended_capabilities_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extended_capabilities_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.extended_capabilities_len) }.ok()
    }
    pub fn iftype_ext_capab(&self) -> Option<*const wiphy_iftype_ext_capab> {
        let v = unsafe { crate::bpf_probe_read(&self.iftype_ext_capab) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_iftype_ext_capab(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.num_iftype_ext_capab) }.ok()
    }
    pub fn privid(&self) -> Option<*const ::aya_bpf_cty::c_void> {
        let v = unsafe { crate::bpf_probe_read(&self.privid) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn bands(&self) -> Option<[*mut ieee80211_supported_band; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.bands) }.ok()
    }
    pub fn reg_notifier(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut wiphy, arg2: *mut regulatory_request),
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.reg_notifier) }.ok()
    }
    pub fn regd(&self) -> Option<*const ieee80211_regdomain> {
        let v = unsafe { crate::bpf_probe_read(&self.regd) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<device> {
        unsafe { crate::bpf_probe_read(&self.dev) }.ok()
    }
    pub fn registered(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.registered) }.ok()
    }
    pub fn debugfsdir(&self) -> Option<*mut dentry> {
        let v = unsafe { crate::bpf_probe_read(&self.debugfsdir) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ht_capa_mod_mask(&self) -> Option<*const ieee80211_ht_cap> {
        let v = unsafe { crate::bpf_probe_read(&self.ht_capa_mod_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vht_capa_mod_mask(&self) -> Option<*const ieee80211_vht_cap> {
        let v = unsafe { crate::bpf_probe_read(&self.vht_capa_mod_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wdev_list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.wdev_list) }.ok()
    }
    pub fn _net(&self) -> Option<possible_net_t> {
        unsafe { crate::bpf_probe_read(&self._net) }.ok()
    }
    pub fn wext(&self) -> Option<*const iw_handler_def> {
        let v = unsafe { crate::bpf_probe_read(&self.wext) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn coalesce(&self) -> Option<*const wiphy_coalesce_support> {
        let v = unsafe { crate::bpf_probe_read(&self.coalesce) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vendor_commands(&self) -> Option<*const wiphy_vendor_command> {
        let v = unsafe { crate::bpf_probe_read(&self.vendor_commands) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn vendor_events(&self) -> Option<*const nl80211_vendor_cmd_info> {
        let v = unsafe { crate::bpf_probe_read(&self.vendor_events) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_vendor_commands(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_vendor_commands) }.ok()
    }
    pub fn n_vendor_events(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_vendor_events) }.ok()
    }
    pub fn max_ap_assoc_sta(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_ap_assoc_sta) }.ok()
    }
    pub fn max_num_csa_counters(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_num_csa_counters) }.ok()
    }
    pub fn bss_select_support(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bss_select_support) }.ok()
    }
    pub fn nan_supported_bands(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.nan_supported_bands) }.ok()
    }
    pub fn txq_limit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.txq_limit) }.ok()
    }
    pub fn txq_memory_limit(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.txq_memory_limit) }.ok()
    }
    pub fn txq_quantum(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.txq_quantum) }.ok()
    }
    pub fn tx_queue_len(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.tx_queue_len) }.ok()
    }
    pub fn pmsr_capa(&self) -> Option<*const cfg80211_pmsr_capabilities> {
        let v = unsafe { crate::bpf_probe_read(&self.pmsr_capa) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tid_config_support(&self) -> Option<wiphy__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.tid_config_support) }.ok()
    }
    pub fn max_data_retry_count(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_data_retry_count) }.ok()
    }
    pub fn sar_capa(&self) -> Option<*const cfg80211_sar_capa> {
        let v = unsafe { crate::bpf_probe_read(&self.sar_capa) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn priv_(&self) -> Option<__IncompleteArrayField<::aya_bpf_cty::c_char>> {
        unsafe { crate::bpf_probe_read(&self.priv_) }.ok()
    }
}
impl wiphy__bindgen_ty_1 {
    pub fn peer(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.peer) }.ok()
    }
    pub fn vif(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.vif) }.ok()
    }
    pub fn max_retry(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_retry) }.ok()
    }
}
impl cfg80211_match_set {
    pub fn ssid(&self) -> Option<cfg80211_ssid> {
        unsafe { crate::bpf_probe_read(&self.ssid) }.ok()
    }
    pub fn bssid(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.bssid) }.ok()
    }
    pub fn rssi_thold(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.rssi_thold) }.ok()
    }
    pub fn per_band_rssi_thold(&self) -> Option<[s32; 5usize]> {
        unsafe { crate::bpf_probe_read(&self.per_band_rssi_thold) }.ok()
    }
}
impl cfg80211_sched_scan_plan {
    pub fn interval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.interval) }.ok()
    }
    pub fn iterations(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.iterations) }.ok()
    }
}
impl cfg80211_sched_scan_request {
    pub fn reqid(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.reqid) }.ok()
    }
    pub fn ssids(&self) -> Option<*mut cfg80211_ssid> {
        let v = unsafe { crate::bpf_probe_read(&self.ssids) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_ssids(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_ssids) }.ok()
    }
    pub fn n_channels(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.n_channels) }.ok()
    }
    pub fn scan_width(&self) -> Option<nl80211_bss_scan_width::Type> {
        unsafe { crate::bpf_probe_read(&self.scan_width) }.ok()
    }
    pub fn ie(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.ie) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn ie_len(&self) -> Option<size_t> {
        unsafe { crate::bpf_probe_read(&self.ie_len) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn match_sets(&self) -> Option<*mut cfg80211_match_set> {
        let v = unsafe { crate::bpf_probe_read(&self.match_sets) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_match_sets(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_match_sets) }.ok()
    }
    pub fn min_rssi_thold(&self) -> Option<s32> {
        unsafe { crate::bpf_probe_read(&self.min_rssi_thold) }.ok()
    }
    pub fn delay(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.delay) }.ok()
    }
    pub fn scan_plans(&self) -> Option<*mut cfg80211_sched_scan_plan> {
        let v = unsafe { crate::bpf_probe_read(&self.scan_plans) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_scan_plans(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_scan_plans) }.ok()
    }
    pub fn mac_addr(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.mac_addr) }.ok()
    }
    pub fn mac_addr_mask(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.mac_addr_mask) }.ok()
    }
    pub fn relative_rssi_set(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.relative_rssi_set) }.ok()
    }
    pub fn relative_rssi(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.relative_rssi) }.ok()
    }
    pub fn rssi_adjust(&self) -> Option<cfg80211_bss_select_adjust> {
        unsafe { crate::bpf_probe_read(&self.rssi_adjust) }.ok()
    }
    pub fn wiphy(&self) -> Option<*mut wiphy> {
        let v = unsafe { crate::bpf_probe_read(&self.wiphy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn dev(&self) -> Option<*mut net_device> {
        let v = unsafe { crate::bpf_probe_read(&self.dev) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn scan_start(&self) -> Option<::aya_bpf_cty::c_ulong> {
        unsafe { crate::bpf_probe_read(&self.scan_start) }.ok()
    }
    pub fn report_results(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.report_results) }.ok()
    }
    pub fn callback_head(&self) -> Option<callback_head> {
        unsafe { crate::bpf_probe_read(&self.callback_head) }.ok()
    }
    pub fn owner_nlportid(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.owner_nlportid) }.ok()
    }
    pub fn nl_owner_dead(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.nl_owner_dead) }.ok()
    }
    pub fn list(&self) -> Option<list_head> {
        unsafe { crate::bpf_probe_read(&self.list) }.ok()
    }
    pub fn channels(&self) -> Option<__IncompleteArrayField<*mut ieee80211_channel>> {
        unsafe { crate::bpf_probe_read(&self.channels) }.ok()
    }
}
impl cfg80211_pkt_pattern {
    pub fn mask(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pattern(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.pattern) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn pattern_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pattern_len) }.ok()
    }
    pub fn pkt_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pkt_offset) }.ok()
    }
}
impl cfg80211_wowlan_tcp {
    pub fn sock(&self) -> Option<*mut socket> {
        let v = unsafe { crate::bpf_probe_read(&self.sock) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn src(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.src) }.ok()
    }
    pub fn dst(&self) -> Option<__be32> {
        unsafe { crate::bpf_probe_read(&self.dst) }.ok()
    }
    pub fn src_port(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.src_port) }.ok()
    }
    pub fn dst_port(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.dst_port) }.ok()
    }
    pub fn dst_mac(&self) -> Option<[u8_; 6usize]> {
        unsafe { crate::bpf_probe_read(&self.dst_mac) }.ok()
    }
    pub fn payload_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.payload_len) }.ok()
    }
    pub fn payload(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.payload) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn payload_seq(&self) -> Option<nl80211_wowlan_tcp_data_seq> {
        unsafe { crate::bpf_probe_read(&self.payload_seq) }.ok()
    }
    pub fn data_interval(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_interval) }.ok()
    }
    pub fn wake_len(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.wake_len) }.ok()
    }
    pub fn wake_data(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.wake_data) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn wake_mask(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.wake_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tokens_size(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.tokens_size) }.ok()
    }
    pub fn payload_tok(&self) -> Option<nl80211_wowlan_tcp_data_token> {
        unsafe { crate::bpf_probe_read(&self.payload_tok) }.ok()
    }
}
impl cfg80211_wowlan {
    pub fn any(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.any) }.ok()
    }
    pub fn disconnect(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.disconnect) }.ok()
    }
    pub fn magic_pkt(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.magic_pkt) }.ok()
    }
    pub fn gtk_rekey_failure(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.gtk_rekey_failure) }.ok()
    }
    pub fn eap_identity_req(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.eap_identity_req) }.ok()
    }
    pub fn four_way_handshake(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.four_way_handshake) }.ok()
    }
    pub fn rfkill_release(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.rfkill_release) }.ok()
    }
    pub fn patterns(&self) -> Option<*mut cfg80211_pkt_pattern> {
        let v = unsafe { crate::bpf_probe_read(&self.patterns) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn tcp(&self) -> Option<*mut cfg80211_wowlan_tcp> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_patterns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_patterns) }.ok()
    }
    pub fn nd_config(&self) -> Option<*mut cfg80211_sched_scan_request> {
        let v = unsafe { crate::bpf_probe_read(&self.nd_config) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl ieee80211_iface_limit {
    pub fn max(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max) }.ok()
    }
    pub fn types(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.types) }.ok()
    }
}
impl ieee80211_iface_combination {
    pub fn limits(&self) -> Option<*const ieee80211_iface_limit> {
        let v = unsafe { crate::bpf_probe_read(&self.limits) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn num_different_channels(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.num_different_channels) }.ok()
    }
    pub fn max_interfaces(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.max_interfaces) }.ok()
    }
    pub fn n_limits(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.n_limits) }.ok()
    }
    pub fn beacon_int_infra_match(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.beacon_int_infra_match) }.ok()
    }
    pub fn radar_detect_widths(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.radar_detect_widths) }.ok()
    }
    pub fn radar_detect_regions(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.radar_detect_regions) }.ok()
    }
    pub fn beacon_int_min_gcd(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.beacon_int_min_gcd) }.ok()
    }
}
impl ieee80211_txrx_stypes {
    pub fn tx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.tx) }.ok()
    }
    pub fn rx(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.rx) }.ok()
    }
}
impl wiphy_wowlan_tcp_support {
    pub fn tok(&self) -> Option<*const nl80211_wowlan_tcp_data_token_feature> {
        let v = unsafe { crate::bpf_probe_read(&self.tok) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn data_payload_max(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_payload_max) }.ok()
    }
    pub fn data_interval_max(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.data_interval_max) }.ok()
    }
    pub fn wake_payload_max(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.wake_payload_max) }.ok()
    }
    pub fn seq(&self) -> Option<bool_> {
        unsafe { crate::bpf_probe_read(&self.seq) }.ok()
    }
}
impl wiphy_wowlan_support {
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn n_patterns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_patterns) }.ok()
    }
    pub fn pattern_max_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pattern_max_len) }.ok()
    }
    pub fn pattern_min_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pattern_min_len) }.ok()
    }
    pub fn max_pkt_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_pkt_offset) }.ok()
    }
    pub fn max_nd_match_sets(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_nd_match_sets) }.ok()
    }
    pub fn tcp(&self) -> Option<*const wiphy_wowlan_tcp_support> {
        let v = unsafe { crate::bpf_probe_read(&self.tcp) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
}
impl wiphy_coalesce_support {
    pub fn n_rules(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_rules) }.ok()
    }
    pub fn max_delay(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_delay) }.ok()
    }
    pub fn n_patterns(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_patterns) }.ok()
    }
    pub fn pattern_max_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pattern_max_len) }.ok()
    }
    pub fn pattern_min_len(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.pattern_min_len) }.ok()
    }
    pub fn max_pkt_offset(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.max_pkt_offset) }.ok()
    }
}
impl wiphy_vendor_command {
    pub fn info(&self) -> Option<nl80211_vendor_cmd_info> {
        unsafe { crate::bpf_probe_read(&self.info) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn doit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut wiphy,
                arg2: *mut wireless_dev,
                arg3: *const ::aya_bpf_cty::c_void,
                arg4: ::aya_bpf_cty::c_int,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.doit) }.ok()
    }
    pub fn dumpit(
        &self,
    ) -> Option<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut wiphy,
                arg2: *mut wireless_dev,
                arg3: *mut sk_buff,
                arg4: *const ::aya_bpf_cty::c_void,
                arg5: ::aya_bpf_cty::c_int,
                arg6: *mut ::aya_bpf_cty::c_ulong,
            ) -> ::aya_bpf_cty::c_int,
        >,
    > {
        unsafe { crate::bpf_probe_read(&self.dumpit) }.ok()
    }
    pub fn policy(&self) -> Option<*const nla_policy> {
        let v = unsafe { crate::bpf_probe_read(&self.policy) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn maxattr(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.maxattr) }.ok()
    }
}
impl wiphy_iftype_ext_capab {
    pub fn iftype(&self) -> Option<nl80211_iftype::Type> {
        unsafe { crate::bpf_probe_read(&self.iftype) }.ok()
    }
    pub fn extended_capabilities(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.extended_capabilities) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extended_capabilities_mask(&self) -> Option<*const u8_> {
        let v = unsafe { crate::bpf_probe_read(&self.extended_capabilities_mask) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn extended_capabilities_len(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.extended_capabilities_len) }.ok()
    }
}
impl cfg80211_pmsr_capabilities {
    pub fn max_peers(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_peers) }.ok()
    }
    pub fn ftm(&self) -> Option<cfg80211_pmsr_capabilities__bindgen_ty_1> {
        unsafe { crate::bpf_probe_read(&self.ftm) }.ok()
    }
}
impl cfg80211_pmsr_capabilities__bindgen_ty_1 {
    pub fn preambles(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.preambles) }.ok()
    }
    pub fn bandwidths(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.bandwidths) }.ok()
    }
    pub fn max_bursts_exponent(&self) -> Option<s8> {
        unsafe { crate::bpf_probe_read(&self.max_bursts_exponent) }.ok()
    }
    pub fn max_ftms_per_burst(&self) -> Option<u8_> {
        unsafe { crate::bpf_probe_read(&self.max_ftms_per_burst) }.ok()
    }
    pub fn __bindgen_padding_0(&self) -> Option<u8> {
        unsafe { crate::bpf_probe_read(&self.__bindgen_padding_0) }.ok()
    }
}
impl wiphy_iftype_akm_suites {
    pub fn iftypes_mask(&self) -> Option<u16_> {
        unsafe { crate::bpf_probe_read(&self.iftypes_mask) }.ok()
    }
    pub fn akm_suites(&self) -> Option<*const u32_> {
        let v = unsafe { crate::bpf_probe_read(&self.akm_suites) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn n_akm_suites(&self) -> Option<::aya_bpf_cty::c_int> {
        unsafe { crate::bpf_probe_read(&self.n_akm_suites) }.ok()
    }
}
impl xsk_queue {
    pub fn ring_mask(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.ring_mask) }.ok()
    }
    pub fn nentries(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.nentries) }.ok()
    }
    pub fn cached_prod(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cached_prod) }.ok()
    }
    pub fn cached_cons(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.cached_cons) }.ok()
    }
    pub fn ring(&self) -> Option<*mut xdp_ring> {
        let v = unsafe { crate::bpf_probe_read(&self.ring) }.ok()?;
        if v.is_null() {
            None
        } else {
            Some(v)
        }
    }
    pub fn invalid_descs(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.invalid_descs) }.ok()
    }
    pub fn queue_empty_descs(&self) -> Option<u64_> {
        unsafe { crate::bpf_probe_read(&self.queue_empty_descs) }.ok()
    }
}
impl xdp_ring {
    pub fn producer(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.producer) }.ok()
    }
    pub fn pad1(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pad1) }.ok()
    }
    pub fn consumer(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.consumer) }.ok()
    }
    pub fn pad2(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pad2) }.ok()
    }
    pub fn flags(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.flags) }.ok()
    }
    pub fn pad3(&self) -> Option<u32_> {
        unsafe { crate::bpf_probe_read(&self.pad3) }.ok()
    }
}
impl mptcp_mib {
    pub fn mibs(&self) -> Option<[::aya_bpf_cty::c_ulong; 23usize]> {
        unsafe { crate::bpf_probe_read(&self.mibs) }.ok()
    }
}
impl bpf_map_def {
    pub fn type_(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.type_) }.ok()
    }
    pub fn key_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.key_size) }.ok()
    }
    pub fn value_size(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.value_size) }.ok()
    }
    pub fn max_entries(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.max_entries) }.ok()
    }
    pub fn map_flags(&self) -> Option<::aya_bpf_cty::c_uint> {
        unsafe { crate::bpf_probe_read(&self.map_flags) }.ok()
    }
}
