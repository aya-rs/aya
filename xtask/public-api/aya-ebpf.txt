pub mod aya_ebpf
pub use aya_ebpf::bindings
pub use aya_ebpf::cty
pub use aya_ebpf::macros
pub mod aya_ebpf::helpers
pub use aya_ebpf::helpers::gen
pub macro aya_ebpf::helpers::bpf_printk!
#[repr(transparent)] pub struct aya_ebpf::helpers::PrintkArg(_)
impl aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from_raw(x: u64) -> Self
impl core::clone::Clone for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::clone(&self) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<char> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: char) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<i16> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: i16) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<i32> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: i32) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<i64> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: i64) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<i8> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: i8) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<isize> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: isize) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<u16> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: u16) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<u32> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: u32) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<u64> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: u64) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<u8> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: u8) -> aya_ebpf::helpers::PrintkArg
impl core::convert::From<usize> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: usize) -> aya_ebpf::helpers::PrintkArg
impl core::marker::Copy for aya_ebpf::helpers::PrintkArg
impl<T> core::convert::From<*const T> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: *const T) -> Self
impl<T> core::convert::From<*mut T> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(x: *mut T) -> Self
impl core::marker::Freeze for aya_ebpf::helpers::PrintkArg
impl core::marker::Send for aya_ebpf::helpers::PrintkArg
impl core::marker::Sync for aya_ebpf::helpers::PrintkArg
impl core::marker::Unpin for aya_ebpf::helpers::PrintkArg
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::helpers::PrintkArg
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::helpers::PrintkArg
impl<T, U> core::convert::Into<U> for aya_ebpf::helpers::PrintkArg where U: core::convert::From<T>
pub fn aya_ebpf::helpers::PrintkArg::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::helpers::PrintkArg where U: core::convert::Into<T>
pub type aya_ebpf::helpers::PrintkArg::Error = core::convert::Infallible
pub fn aya_ebpf::helpers::PrintkArg::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::helpers::PrintkArg where U: core::convert::TryFrom<T>
pub type aya_ebpf::helpers::PrintkArg::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::helpers::PrintkArg::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::helpers::PrintkArg where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::helpers::PrintkArg::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::helpers::PrintkArg where T: ?core::marker::Sized
pub fn aya_ebpf::helpers::PrintkArg::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::helpers::PrintkArg where T: ?core::marker::Sized
pub fn aya_ebpf::helpers::PrintkArg::borrow_mut(&mut self) -> &mut T
impl<T> core::clone::CloneToUninit for aya_ebpf::helpers::PrintkArg where T: core::clone::Clone
pub unsafe fn aya_ebpf::helpers::PrintkArg::clone_to_uninit(&self, dst: *mut u8)
impl<T> core::convert::From<T> for aya_ebpf::helpers::PrintkArg
pub fn aya_ebpf::helpers::PrintkArg::from(t: T) -> T
pub fn aya_ebpf::helpers::bpf_get_current_comm() -> core::result::Result<[u8; 16], aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::helpers::bpf_get_current_pid_tgid() -> u64
pub fn aya_ebpf::helpers::bpf_get_current_uid_gid() -> u64
pub unsafe fn aya_ebpf::helpers::bpf_probe_read<T>(src: *const T) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_buf(src: *const u8, dst: &mut [u8]) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_kernel<T>(src: *const T) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_kernel_buf(src: *const u8, dst: &mut [u8]) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_kernel_str(src: *const u8, dest: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_kernel_str_bytes(src: *const u8, dest: &mut [u8]) -> core::result::Result<&[u8], aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_str(src: *const u8, dest: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_user<T>(src: *const T) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_user_buf(src: *const u8, dst: &mut [u8]) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_user_str(src: *const u8, dest: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_read_user_str_bytes(src: *const u8, dest: &mut [u8]) -> core::result::Result<&[u8], aya_ebpf_cty::od::c_long>
pub unsafe fn aya_ebpf::helpers::bpf_probe_write_user<T>(dst: *mut T, src: *const T) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::helpers::bpf_strncmp<const N: usize>(s1: &[u8; N], s2: &core::ffi::c_str::CStr) -> core::cmp::Ordering
pub mod aya_ebpf::maps
pub mod aya_ebpf::maps::array
#[repr(transparent)] pub struct aya_ebpf::maps::array::Array<T>
impl<T> aya_ebpf::maps::array::Array<T>
pub fn aya_ebpf::maps::array::Array<T>::get(&self, index: u32) -> core::option::Option<&T>
pub fn aya_ebpf::maps::array::Array<T>::get_ptr(&self, index: u32) -> core::option::Option<*const T>
pub fn aya_ebpf::maps::array::Array<T>::get_ptr_mut(&self, index: u32) -> core::option::Option<*mut T>
pub const fn aya_ebpf::maps::array::Array<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::array::Array<T>
pub const fn aya_ebpf::maps::array::Array<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::array::Array<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::array::Array<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::array::Array<T>
impl<T> core::marker::Send for aya_ebpf::maps::array::Array<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::array::Array<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::array::Array<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::array::Array<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::array::Array<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::array::Array<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::array::Array<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::array::Array<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::array::Array<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::array::Array<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::array::Array<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::array::Array<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::array::Array<T>
pub fn aya_ebpf::maps::array::Array<T>::from(t: T) -> T
pub mod aya_ebpf::maps::bloom_filter
#[repr(transparent)] pub struct aya_ebpf::maps::bloom_filter::BloomFilter<T>
impl<T> aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::contains(&mut self, value: &T) -> core::result::Result<(), i64>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::insert(&mut self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub const fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::bloom_filter::BloomFilter<T>
impl<T> core::marker::Freeze for aya_ebpf::maps::bloom_filter::BloomFilter<T>
impl<T> core::marker::Send for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Send
impl<T> core::marker::Sync for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::bloom_filter::BloomFilter<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::bloom_filter::BloomFilter<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::from(t: T) -> T
pub mod aya_ebpf::maps::hash_map
#[repr(transparent)] pub struct aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::HashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::HashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::HashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::HashMap<K, V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::HashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::HashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::HashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::HashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::HashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::HashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::HashMap<K, V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::LruHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::LruHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::marker::Sync for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::marker::Sync for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::from(t: T) -> T
pub mod aya_ebpf::maps::lpm_trie
#[repr(packed)] pub struct aya_ebpf::maps::lpm_trie::Key<K>
pub aya_ebpf::maps::lpm_trie::Key::data: K
pub aya_ebpf::maps::lpm_trie::Key::prefix_len: u32
impl<K> aya_ebpf::maps::lpm_trie::Key<K>
pub fn aya_ebpf::maps::lpm_trie::Key<K>::new(prefix_len: u32, data: K) -> Self
impl<K> core::marker::Freeze for aya_ebpf::maps::lpm_trie::Key<K> where K: core::marker::Freeze
impl<K> core::marker::Send for aya_ebpf::maps::lpm_trie::Key<K> where K: core::marker::Send
impl<K> core::marker::Sync for aya_ebpf::maps::lpm_trie::Key<K> where K: core::marker::Sync
impl<K> core::marker::Unpin for aya_ebpf::maps::lpm_trie::Key<K> where K: core::marker::Unpin
impl<K> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::lpm_trie::Key<K> where K: core::panic::unwind_safe::RefUnwindSafe
impl<K> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::lpm_trie::Key<K> where K: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::lpm_trie::Key<K> where U: core::convert::From<T>
pub fn aya_ebpf::maps::lpm_trie::Key<K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::lpm_trie::Key<K> where U: core::convert::Into<T>
pub type aya_ebpf::maps::lpm_trie::Key<K>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::lpm_trie::Key<K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::lpm_trie::Key<K> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::lpm_trie::Key<K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::lpm_trie::Key<K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::lpm_trie::Key<K> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::Key<K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::lpm_trie::Key<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::Key<K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::lpm_trie::Key<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::Key<K>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::lpm_trie::Key<K>
pub fn aya_ebpf::maps::lpm_trie::Key<K>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::get(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>) -> core::option::Option<&V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::insert(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::remove(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::from(t: T) -> T
pub mod aya_ebpf::maps::per_cpu_array
#[repr(transparent)] pub struct aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get(&self, index: u32) -> core::option::Option<&T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get_ptr(&self, index: u32) -> core::option::Option<*const T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get_ptr_mut(&self, index: u32) -> core::option::Option<*mut T>
pub const fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub const fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::marker::Sync for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::marker::Send for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::from(t: T) -> T
pub mod aya_ebpf::maps::perf
#[repr(transparent)] pub struct aya_ebpf::maps::perf::PerfEventArray<T>
impl<T> aya_ebpf::maps::PerfEventArray<T>
pub const fn aya_ebpf::maps::PerfEventArray<T>::new(flags: u32) -> aya_ebpf::maps::PerfEventArray<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::output<C: aya_ebpf::EbpfContext>(&self, ctx: &C, data: &T, flags: u32)
pub fn aya_ebpf::maps::PerfEventArray<T>::output_at_index<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32, data: &T, flags: u32)
pub const fn aya_ebpf::maps::PerfEventArray<T>::pinned(flags: u32) -> aya_ebpf::maps::PerfEventArray<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::PerfEventArray<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::PerfEventArray<T>
impl<T> core::marker::Send for aya_ebpf::maps::PerfEventArray<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::PerfEventArray<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::PerfEventArray<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::PerfEventArray<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::PerfEventArray<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::PerfEventArray<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::PerfEventArray<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::PerfEventArray<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::PerfEventArray<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::PerfEventArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::PerfEventArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::PerfEventArray<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::perf::PerfEventByteArray
impl aya_ebpf::maps::PerfEventByteArray
pub const fn aya_ebpf::maps::PerfEventByteArray::new(flags: u32) -> aya_ebpf::maps::PerfEventByteArray
pub fn aya_ebpf::maps::PerfEventByteArray::output<C: aya_ebpf::EbpfContext>(&self, ctx: &C, data: &[u8], flags: u32)
pub fn aya_ebpf::maps::PerfEventByteArray::output_at_index<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32, data: &[u8], flags: u32)
pub const fn aya_ebpf::maps::PerfEventByteArray::pinned(flags: u32) -> aya_ebpf::maps::PerfEventByteArray
impl core::marker::Sync for aya_ebpf::maps::PerfEventByteArray
impl !core::marker::Freeze for aya_ebpf::maps::PerfEventByteArray
impl core::marker::Send for aya_ebpf::maps::PerfEventByteArray
impl core::marker::Unpin for aya_ebpf::maps::PerfEventByteArray
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::PerfEventByteArray
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::PerfEventByteArray
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::From<T>
pub fn aya_ebpf::maps::PerfEventByteArray::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::Into<T>
pub type aya_ebpf::maps::PerfEventByteArray::Error = core::convert::Infallible
pub fn aya_ebpf::maps::PerfEventByteArray::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::PerfEventByteArray::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::PerfEventByteArray::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::PerfEventByteArray where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::PerfEventByteArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::PerfEventByteArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::PerfEventByteArray
pub fn aya_ebpf::maps::PerfEventByteArray::from(t: T) -> T
pub mod aya_ebpf::maps::program_array
#[repr(transparent)] pub struct aya_ebpf::maps::program_array::ProgramArray
impl aya_ebpf::maps::program_array::ProgramArray
pub const fn aya_ebpf::maps::program_array::ProgramArray::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::program_array::ProgramArray
pub unsafe fn aya_ebpf::maps::program_array::ProgramArray::tail_call<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32) -> core::result::Result<never, aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::program_array::ProgramArray::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Sync for aya_ebpf::maps::program_array::ProgramArray
impl !core::marker::Freeze for aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Send for aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Unpin for aya_ebpf::maps::program_array::ProgramArray
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::program_array::ProgramArray
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::program_array::ProgramArray
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::From<T>
pub fn aya_ebpf::maps::program_array::ProgramArray::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::Into<T>
pub type aya_ebpf::maps::program_array::ProgramArray::Error = core::convert::Infallible
pub fn aya_ebpf::maps::program_array::ProgramArray::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::program_array::ProgramArray::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::program_array::ProgramArray::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::program_array::ProgramArray where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::program_array::ProgramArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::program_array::ProgramArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::program_array::ProgramArray
pub fn aya_ebpf::maps::program_array::ProgramArray::from(t: T) -> T
pub mod aya_ebpf::maps::queue
#[repr(transparent)] pub struct aya_ebpf::maps::queue::Queue<T>
impl<T> aya_ebpf::maps::queue::Queue<T>
pub const fn aya_ebpf::maps::queue::Queue<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::queue::Queue<T>
pub fn aya_ebpf::maps::queue::Queue<T>::pop(&self) -> core::option::Option<T>
pub fn aya_ebpf::maps::queue::Queue<T>::push(&self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::queue::Queue<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::queue::Queue<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::queue::Queue<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::queue::Queue<T>
impl<T> core::marker::Send for aya_ebpf::maps::queue::Queue<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::queue::Queue<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::queue::Queue<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::queue::Queue<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::queue::Queue<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::queue::Queue<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::queue::Queue<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::queue::Queue<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::queue::Queue<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::queue::Queue<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::queue::Queue<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::queue::Queue<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::queue::Queue<T>
pub fn aya_ebpf::maps::queue::Queue<T>::from(t: T) -> T
pub mod aya_ebpf::maps::ring_buf
#[repr(transparent)] pub struct aya_ebpf::maps::ring_buf::RingBuf
impl aya_ebpf::maps::ring_buf::RingBuf
pub fn aya_ebpf::maps::ring_buf::RingBuf::output<T: ?core::marker::Sized>(&self, data: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::ring_buf::RingBuf::pinned(byte_size: u32, flags: u32) -> Self
pub fn aya_ebpf::maps::ring_buf::RingBuf::query(&self, flags: u64) -> u64
pub fn aya_ebpf::maps::ring_buf::RingBuf::reserve<T: 'static>(&self, flags: u64) -> core::option::Option<aya_ebpf::maps::ring_buf::RingBufEntry<T>> where const_assert::Assert<{ _ }>: const_assert::IsTrue
pub const fn aya_ebpf::maps::ring_buf::RingBuf::with_byte_size(byte_size: u32, flags: u32) -> Self
impl core::marker::Sync for aya_ebpf::maps::ring_buf::RingBuf
impl !core::marker::Freeze for aya_ebpf::maps::ring_buf::RingBuf
impl core::marker::Send for aya_ebpf::maps::ring_buf::RingBuf
impl core::marker::Unpin for aya_ebpf::maps::ring_buf::RingBuf
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::ring_buf::RingBuf
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::ring_buf::RingBuf
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::From<T>
pub fn aya_ebpf::maps::ring_buf::RingBuf::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::Into<T>
pub type aya_ebpf::maps::ring_buf::RingBuf::Error = core::convert::Infallible
pub fn aya_ebpf::maps::ring_buf::RingBuf::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::ring_buf::RingBuf::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::ring_buf::RingBuf::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::ring_buf::RingBuf where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::ring_buf::RingBuf where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::ring_buf::RingBuf where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::ring_buf::RingBuf
pub fn aya_ebpf::maps::ring_buf::RingBuf::from(t: T) -> T
pub struct aya_ebpf::maps::ring_buf::RingBufEntry<T: 'static>(_)
impl<T> aya_ebpf::maps::ring_buf::RingBufEntry<T>
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::discard(self, flags: u64)
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::submit(self, flags: u64)
impl<T> core::ops::deref::Deref for aya_ebpf::maps::ring_buf::RingBufEntry<T>
pub type aya_ebpf::maps::ring_buf::RingBufEntry<T>::Target = core::mem::maybe_uninit::MaybeUninit<T>
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::deref(&self) -> &Self::Target
impl<T> core::ops::deref::DerefMut for aya_ebpf::maps::ring_buf::RingBufEntry<T>
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::deref_mut(&mut self) -> &mut Self::Target
impl<T> core::marker::Freeze for aya_ebpf::maps::ring_buf::RingBufEntry<T>
impl<T> core::marker::Send for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: core::marker::Send
impl<T> core::marker::Sync for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for aya_ebpf::maps::ring_buf::RingBufEntry<T>
impl<T> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> !core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::ring_buf::RingBufEntry<T>
impl<P, T> core::ops::deref::Receiver for aya_ebpf::maps::ring_buf::RingBufEntry<T> where P: core::ops::deref::Deref<Target = T> + ?core::marker::Sized, T: ?core::marker::Sized
pub type aya_ebpf::maps::ring_buf::RingBufEntry<T>::Target = T
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::ring_buf::RingBufEntry<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::ring_buf::RingBufEntry<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::ring_buf::RingBufEntry<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::ring_buf::RingBufEntry<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::ring_buf::RingBufEntry<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::ring_buf::RingBufEntry<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::ring_buf::RingBufEntry<T>
pub fn aya_ebpf::maps::ring_buf::RingBufEntry<T>::from(t: T) -> T
pub mod aya_ebpf::maps::sock_hash
#[repr(transparent)] pub struct aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> aya_ebpf::maps::sock_hash::SockHash<K>
pub const fn aya_ebpf::maps::sock_hash::SockHash<K>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_hash::SockHash<K>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_msg(&self, ctx: &aya_ebpf::programs::sk_msg::SkMsgContext, key: &mut K, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_sk_lookup(&mut self, ctx: &aya_ebpf::programs::sk_lookup::SkLookupContext, key: impl core::borrow::Borrow<K>, flags: u64) -> core::result::Result<(), u32>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_skb(&self, ctx: &aya_ebpf::programs::sk_buff::SkBuffContext, key: &mut K, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::update(&self, key: &mut K, sk_ops: &mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::sock_hash::SockHash<K>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_hash::SockHash<K>
impl<K: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> !core::marker::Freeze for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> core::marker::Send for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::marker::Send
impl<K> core::marker::Unpin for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::marker::Unpin
impl<K> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::From<T>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::Into<T>
pub type aya_ebpf::maps::sock_hash::SockHash<K>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::sock_hash::SockHash<K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::sock_hash::SockHash<K> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::sock_hash::SockHash<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::sock_hash::SockHash<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::sock_hash::SockHash<K>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::from(t: T) -> T
pub mod aya_ebpf::maps::sock_map
#[repr(transparent)] pub struct aya_ebpf::maps::sock_map::SockMap
impl aya_ebpf::maps::sock_map::SockMap
pub const fn aya_ebpf::maps::sock_map::SockMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_map::SockMap
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::redirect_msg(&self, ctx: &aya_ebpf::programs::sk_msg::SkMsgContext, index: u32, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_map::SockMap::redirect_sk_lookup(&mut self, ctx: &aya_ebpf::programs::sk_lookup::SkLookupContext, index: u32, flags: u64) -> core::result::Result<(), u32>
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::redirect_skb(&self, ctx: &aya_ebpf::programs::sk_buff::SkBuffContext, index: u32, flags: u64) -> i64
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::update(&self, index: u32, sk_ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::sock_map::SockMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_map::SockMap
impl core::marker::Sync for aya_ebpf::maps::sock_map::SockMap
impl !core::marker::Freeze for aya_ebpf::maps::sock_map::SockMap
impl core::marker::Send for aya_ebpf::maps::sock_map::SockMap
impl core::marker::Unpin for aya_ebpf::maps::sock_map::SockMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::sock_map::SockMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::sock_map::SockMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::sock_map::SockMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::sock_map::SockMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::sock_map::SockMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::sock_map::SockMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::sock_map::SockMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::sock_map::SockMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::sock_map::SockMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::sock_map::SockMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::sock_map::SockMap
pub fn aya_ebpf::maps::sock_map::SockMap::from(t: T) -> T
pub mod aya_ebpf::maps::stack
#[repr(transparent)] pub struct aya_ebpf::maps::stack::Stack<T>
impl<T> aya_ebpf::maps::stack::Stack<T>
pub const fn aya_ebpf::maps::stack::Stack<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack::Stack<T>
pub fn aya_ebpf::maps::stack::Stack<T>::pop(&mut self) -> core::option::Option<T>
pub fn aya_ebpf::maps::stack::Stack<T>::push(&mut self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::stack::Stack<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack::Stack<T>
impl<T> core::marker::Freeze for aya_ebpf::maps::stack::Stack<T>
impl<T> core::marker::Send for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Send
impl<T> core::marker::Sync for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::stack::Stack<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::stack::Stack<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::stack::Stack<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::stack::Stack<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::stack::Stack<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::stack::Stack<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::stack::Stack<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::stack::Stack<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::stack::Stack<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::stack::Stack<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::stack::Stack<T>
pub fn aya_ebpf::maps::stack::Stack<T>::from(t: T) -> T
pub mod aya_ebpf::maps::stack_trace
#[repr(transparent)] pub struct aya_ebpf::maps::stack_trace::StackTrace
impl aya_ebpf::maps::stack_trace::StackTrace
pub unsafe fn aya_ebpf::maps::stack_trace::StackTrace::get_stackid<C: aya_ebpf::EbpfContext>(&self, ctx: &C, flags: u64) -> core::result::Result<i64, i64>
pub const fn aya_ebpf::maps::stack_trace::StackTrace::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack_trace::StackTrace
pub const fn aya_ebpf::maps::stack_trace::StackTrace::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Sync for aya_ebpf::maps::stack_trace::StackTrace
impl !core::marker::Freeze for aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Send for aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Unpin for aya_ebpf::maps::stack_trace::StackTrace
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::stack_trace::StackTrace
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::stack_trace::StackTrace
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::From<T>
pub fn aya_ebpf::maps::stack_trace::StackTrace::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::Into<T>
pub type aya_ebpf::maps::stack_trace::StackTrace::Error = core::convert::Infallible
pub fn aya_ebpf::maps::stack_trace::StackTrace::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::stack_trace::StackTrace::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::stack_trace::StackTrace::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::stack_trace::StackTrace where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::stack_trace::StackTrace where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::stack_trace::StackTrace where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::stack_trace::StackTrace
pub fn aya_ebpf::maps::stack_trace::StackTrace::from(t: T) -> T
pub mod aya_ebpf::maps::xdp
#[repr(transparent)] pub struct aya_ebpf::maps::xdp::CpuMap
impl aya_ebpf::maps::CpuMap
pub const fn aya_ebpf::maps::CpuMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::CpuMap
pub fn aya_ebpf::maps::CpuMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::CpuMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::CpuMap
impl core::marker::Sync for aya_ebpf::maps::CpuMap
impl !core::marker::Freeze for aya_ebpf::maps::CpuMap
impl core::marker::Send for aya_ebpf::maps::CpuMap
impl core::marker::Unpin for aya_ebpf::maps::CpuMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::CpuMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::CpuMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::CpuMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::CpuMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::CpuMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::CpuMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::CpuMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::CpuMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::CpuMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::CpuMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::CpuMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::CpuMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::CpuMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::CpuMap
pub fn aya_ebpf::maps::CpuMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::xdp::DevMap
impl aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::get(&self, index: u32) -> core::option::Option<DevMapValue>
pub const fn aya_ebpf::maps::DevMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::DevMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMap
impl core::marker::Sync for aya_ebpf::maps::DevMap
impl !core::marker::Freeze for aya_ebpf::maps::DevMap
impl core::marker::Send for aya_ebpf::maps::DevMap
impl core::marker::Unpin for aya_ebpf::maps::DevMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::DevMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::DevMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::DevMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::DevMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::DevMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::DevMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::DevMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::DevMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::DevMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::DevMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::DevMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::DevMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::DevMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::xdp::DevMapHash
impl aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::get(&self, key: u32) -> core::option::Option<DevMapValue>
pub const fn aya_ebpf::maps::DevMapHash::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::redirect(&self, key: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::DevMapHash::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMapHash
impl core::marker::Sync for aya_ebpf::maps::DevMapHash
impl !core::marker::Freeze for aya_ebpf::maps::DevMapHash
impl core::marker::Send for aya_ebpf::maps::DevMapHash
impl core::marker::Unpin for aya_ebpf::maps::DevMapHash
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::DevMapHash
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::DevMapHash
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::DevMapHash where U: core::convert::From<T>
pub fn aya_ebpf::maps::DevMapHash::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::DevMapHash where U: core::convert::Into<T>
pub type aya_ebpf::maps::DevMapHash::Error = core::convert::Infallible
pub fn aya_ebpf::maps::DevMapHash::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::DevMapHash where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::DevMapHash::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::DevMapHash::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::DevMapHash where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::DevMapHash where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::DevMapHash where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::xdp::XskMap
impl aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::get(&self, index: u32) -> core::option::Option<u32>
pub const fn aya_ebpf::maps::XskMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::XskMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::XskMap
impl core::marker::Sync for aya_ebpf::maps::XskMap
impl !core::marker::Freeze for aya_ebpf::maps::XskMap
impl core::marker::Send for aya_ebpf::maps::XskMap
impl core::marker::Unpin for aya_ebpf::maps::XskMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::XskMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::XskMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::XskMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::XskMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::XskMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::XskMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::XskMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::XskMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::XskMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::XskMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::XskMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::XskMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::XskMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::Array<T>
impl<T> aya_ebpf::maps::array::Array<T>
pub fn aya_ebpf::maps::array::Array<T>::get(&self, index: u32) -> core::option::Option<&T>
pub fn aya_ebpf::maps::array::Array<T>::get_ptr(&self, index: u32) -> core::option::Option<*const T>
pub fn aya_ebpf::maps::array::Array<T>::get_ptr_mut(&self, index: u32) -> core::option::Option<*mut T>
pub const fn aya_ebpf::maps::array::Array<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::array::Array<T>
pub const fn aya_ebpf::maps::array::Array<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::array::Array<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::array::Array<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::array::Array<T>
impl<T> core::marker::Send for aya_ebpf::maps::array::Array<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::array::Array<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::array::Array<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::array::Array<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::array::Array<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::array::Array<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::array::Array<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::array::Array<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::array::Array<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::array::Array<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::array::Array<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::array::Array<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::array::Array<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::array::Array<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::array::Array<T>
pub fn aya_ebpf::maps::array::Array<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::BloomFilter<T>
impl<T> aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::contains(&mut self, value: &T) -> core::result::Result<(), i64>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::insert(&mut self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub const fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::bloom_filter::BloomFilter<T>
impl<T> core::marker::Freeze for aya_ebpf::maps::bloom_filter::BloomFilter<T>
impl<T> core::marker::Send for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Send
impl<T> core::marker::Sync for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::bloom_filter::BloomFilter<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::bloom_filter::BloomFilter<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::bloom_filter::BloomFilter<T>
pub fn aya_ebpf::maps::bloom_filter::BloomFilter<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::CpuMap
impl aya_ebpf::maps::CpuMap
pub const fn aya_ebpf::maps::CpuMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::CpuMap
pub fn aya_ebpf::maps::CpuMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::CpuMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::CpuMap
impl core::marker::Sync for aya_ebpf::maps::CpuMap
impl !core::marker::Freeze for aya_ebpf::maps::CpuMap
impl core::marker::Send for aya_ebpf::maps::CpuMap
impl core::marker::Unpin for aya_ebpf::maps::CpuMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::CpuMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::CpuMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::CpuMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::CpuMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::CpuMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::CpuMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::CpuMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::CpuMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::CpuMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::CpuMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::CpuMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::CpuMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::CpuMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::CpuMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::CpuMap
pub fn aya_ebpf::maps::CpuMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::DevMap
impl aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::get(&self, index: u32) -> core::option::Option<DevMapValue>
pub const fn aya_ebpf::maps::DevMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::DevMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMap
impl core::marker::Sync for aya_ebpf::maps::DevMap
impl !core::marker::Freeze for aya_ebpf::maps::DevMap
impl core::marker::Send for aya_ebpf::maps::DevMap
impl core::marker::Unpin for aya_ebpf::maps::DevMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::DevMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::DevMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::DevMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::DevMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::DevMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::DevMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::DevMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::DevMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::DevMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::DevMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::DevMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::DevMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::DevMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::DevMap
pub fn aya_ebpf::maps::DevMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::DevMapHash
impl aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::get(&self, key: u32) -> core::option::Option<DevMapValue>
pub const fn aya_ebpf::maps::DevMapHash::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::redirect(&self, key: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::DevMapHash::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::DevMapHash
impl core::marker::Sync for aya_ebpf::maps::DevMapHash
impl !core::marker::Freeze for aya_ebpf::maps::DevMapHash
impl core::marker::Send for aya_ebpf::maps::DevMapHash
impl core::marker::Unpin for aya_ebpf::maps::DevMapHash
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::DevMapHash
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::DevMapHash
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::DevMapHash where U: core::convert::From<T>
pub fn aya_ebpf::maps::DevMapHash::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::DevMapHash where U: core::convert::Into<T>
pub type aya_ebpf::maps::DevMapHash::Error = core::convert::Infallible
pub fn aya_ebpf::maps::DevMapHash::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::DevMapHash where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::DevMapHash::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::DevMapHash::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::DevMapHash where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::DevMapHash where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::DevMapHash where T: ?core::marker::Sized
pub fn aya_ebpf::maps::DevMapHash::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::DevMapHash
pub fn aya_ebpf::maps::DevMapHash::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::HashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::HashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::HashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::HashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::HashMap<K, V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::HashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::HashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::HashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::HashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::HashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::HashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::HashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::HashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::HashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::HashMap<K, V>
pub fn aya_ebpf::maps::hash_map::HashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::LpmTrie<K, V>
impl<K, V> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::get(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>) -> core::option::Option<&V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::insert(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::remove(&self, key: &aya_ebpf::maps::lpm_trie::Key<K>) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::lpm_trie::LpmTrie<K, V>
pub fn aya_ebpf::maps::lpm_trie::LpmTrie<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::LruHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K: core::marker::Sync, V: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::LruHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::LruHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::LruHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::LruHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::LruHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruHashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::LruPerCpuHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::marker::Sync for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::LruPerCpuHashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::PerCpuArray<T>
impl<T> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get(&self, index: u32) -> core::option::Option<&T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get_ptr(&self, index: u32) -> core::option::Option<*const T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::get_ptr_mut(&self, index: u32) -> core::option::Option<*mut T>
pub const fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub const fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::marker::Sync for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::marker::Send for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::per_cpu_array::PerCpuArray<T>
pub fn aya_ebpf::maps::per_cpu_array::PerCpuArray<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::PerCpuHashMap<K, V>
impl<K, V> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub unsafe fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get(&self, key: &K) -> core::option::Option<&V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get_ptr(&self, key: &K) -> core::option::Option<*const V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::get_ptr_mut(&self, key: &K) -> core::option::Option<*mut V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::insert(&self, key: &K, value: &V, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::remove(&self, key: &K) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::marker::Sync for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> !core::marker::Freeze for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::marker::Send for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::marker::Send, V: core::marker::Send
impl<K, V> core::marker::Unpin for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::marker::Unpin, V: core::marker::Unpin
impl<K, V> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
impl<K, V> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where K: core::panic::unwind_safe::UnwindSafe, V: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::From<T>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::Into<T>
pub type aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>
pub fn aya_ebpf::maps::hash_map::PerCpuHashMap<K, V>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::PerfEventArray<T>
impl<T> aya_ebpf::maps::PerfEventArray<T>
pub const fn aya_ebpf::maps::PerfEventArray<T>::new(flags: u32) -> aya_ebpf::maps::PerfEventArray<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::output<C: aya_ebpf::EbpfContext>(&self, ctx: &C, data: &T, flags: u32)
pub fn aya_ebpf::maps::PerfEventArray<T>::output_at_index<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32, data: &T, flags: u32)
pub const fn aya_ebpf::maps::PerfEventArray<T>::pinned(flags: u32) -> aya_ebpf::maps::PerfEventArray<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::PerfEventArray<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::PerfEventArray<T>
impl<T> core::marker::Send for aya_ebpf::maps::PerfEventArray<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::PerfEventArray<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::PerfEventArray<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::PerfEventArray<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::PerfEventArray<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::PerfEventArray<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::PerfEventArray<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::PerfEventArray<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::PerfEventArray<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::PerfEventArray<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::PerfEventArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::PerfEventArray<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventArray<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::PerfEventArray<T>
pub fn aya_ebpf::maps::PerfEventArray<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::PerfEventByteArray
impl aya_ebpf::maps::PerfEventByteArray
pub const fn aya_ebpf::maps::PerfEventByteArray::new(flags: u32) -> aya_ebpf::maps::PerfEventByteArray
pub fn aya_ebpf::maps::PerfEventByteArray::output<C: aya_ebpf::EbpfContext>(&self, ctx: &C, data: &[u8], flags: u32)
pub fn aya_ebpf::maps::PerfEventByteArray::output_at_index<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32, data: &[u8], flags: u32)
pub const fn aya_ebpf::maps::PerfEventByteArray::pinned(flags: u32) -> aya_ebpf::maps::PerfEventByteArray
impl core::marker::Sync for aya_ebpf::maps::PerfEventByteArray
impl !core::marker::Freeze for aya_ebpf::maps::PerfEventByteArray
impl core::marker::Send for aya_ebpf::maps::PerfEventByteArray
impl core::marker::Unpin for aya_ebpf::maps::PerfEventByteArray
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::PerfEventByteArray
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::PerfEventByteArray
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::From<T>
pub fn aya_ebpf::maps::PerfEventByteArray::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::Into<T>
pub type aya_ebpf::maps::PerfEventByteArray::Error = core::convert::Infallible
pub fn aya_ebpf::maps::PerfEventByteArray::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::PerfEventByteArray where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::PerfEventByteArray::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::PerfEventByteArray::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::PerfEventByteArray where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::PerfEventByteArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::PerfEventByteArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::PerfEventByteArray::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::PerfEventByteArray
pub fn aya_ebpf::maps::PerfEventByteArray::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::ProgramArray
impl aya_ebpf::maps::program_array::ProgramArray
pub const fn aya_ebpf::maps::program_array::ProgramArray::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::program_array::ProgramArray
pub unsafe fn aya_ebpf::maps::program_array::ProgramArray::tail_call<C: aya_ebpf::EbpfContext>(&self, ctx: &C, index: u32) -> core::result::Result<never, aya_ebpf_cty::od::c_long>
pub const fn aya_ebpf::maps::program_array::ProgramArray::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Sync for aya_ebpf::maps::program_array::ProgramArray
impl !core::marker::Freeze for aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Send for aya_ebpf::maps::program_array::ProgramArray
impl core::marker::Unpin for aya_ebpf::maps::program_array::ProgramArray
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::program_array::ProgramArray
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::program_array::ProgramArray
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::From<T>
pub fn aya_ebpf::maps::program_array::ProgramArray::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::Into<T>
pub type aya_ebpf::maps::program_array::ProgramArray::Error = core::convert::Infallible
pub fn aya_ebpf::maps::program_array::ProgramArray::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::program_array::ProgramArray where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::program_array::ProgramArray::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::program_array::ProgramArray::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::program_array::ProgramArray where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::program_array::ProgramArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::program_array::ProgramArray where T: ?core::marker::Sized
pub fn aya_ebpf::maps::program_array::ProgramArray::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::program_array::ProgramArray
pub fn aya_ebpf::maps::program_array::ProgramArray::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::Queue<T>
impl<T> aya_ebpf::maps::queue::Queue<T>
pub const fn aya_ebpf::maps::queue::Queue<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::queue::Queue<T>
pub fn aya_ebpf::maps::queue::Queue<T>::pop(&self) -> core::option::Option<T>
pub fn aya_ebpf::maps::queue::Queue<T>::push(&self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::queue::Queue<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::queue::Queue<T>
impl<T: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::queue::Queue<T>
impl<T> !core::marker::Freeze for aya_ebpf::maps::queue::Queue<T>
impl<T> core::marker::Send for aya_ebpf::maps::queue::Queue<T> where T: core::marker::Send
impl<T> core::marker::Unpin for aya_ebpf::maps::queue::Queue<T> where T: core::marker::Unpin
impl<T> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::queue::Queue<T>
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::queue::Queue<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::queue::Queue<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::queue::Queue<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::queue::Queue<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::queue::Queue<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::queue::Queue<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::queue::Queue<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::queue::Queue<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::queue::Queue<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::queue::Queue<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::queue::Queue<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::queue::Queue<T>
pub fn aya_ebpf::maps::queue::Queue<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::RingBuf
impl aya_ebpf::maps::ring_buf::RingBuf
pub fn aya_ebpf::maps::ring_buf::RingBuf::output<T: ?core::marker::Sized>(&self, data: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::ring_buf::RingBuf::pinned(byte_size: u32, flags: u32) -> Self
pub fn aya_ebpf::maps::ring_buf::RingBuf::query(&self, flags: u64) -> u64
pub fn aya_ebpf::maps::ring_buf::RingBuf::reserve<T: 'static>(&self, flags: u64) -> core::option::Option<aya_ebpf::maps::ring_buf::RingBufEntry<T>> where const_assert::Assert<{ _ }>: const_assert::IsTrue
pub const fn aya_ebpf::maps::ring_buf::RingBuf::with_byte_size(byte_size: u32, flags: u32) -> Self
impl core::marker::Sync for aya_ebpf::maps::ring_buf::RingBuf
impl !core::marker::Freeze for aya_ebpf::maps::ring_buf::RingBuf
impl core::marker::Send for aya_ebpf::maps::ring_buf::RingBuf
impl core::marker::Unpin for aya_ebpf::maps::ring_buf::RingBuf
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::ring_buf::RingBuf
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::ring_buf::RingBuf
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::From<T>
pub fn aya_ebpf::maps::ring_buf::RingBuf::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::Into<T>
pub type aya_ebpf::maps::ring_buf::RingBuf::Error = core::convert::Infallible
pub fn aya_ebpf::maps::ring_buf::RingBuf::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::ring_buf::RingBuf where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::ring_buf::RingBuf::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::ring_buf::RingBuf::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::ring_buf::RingBuf where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::ring_buf::RingBuf where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::ring_buf::RingBuf where T: ?core::marker::Sized
pub fn aya_ebpf::maps::ring_buf::RingBuf::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::ring_buf::RingBuf
pub fn aya_ebpf::maps::ring_buf::RingBuf::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::SockHash<K>
impl<K> aya_ebpf::maps::sock_hash::SockHash<K>
pub const fn aya_ebpf::maps::sock_hash::SockHash<K>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_hash::SockHash<K>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_msg(&self, ctx: &aya_ebpf::programs::sk_msg::SkMsgContext, key: &mut K, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_sk_lookup(&mut self, ctx: &aya_ebpf::programs::sk_lookup::SkLookupContext, key: impl core::borrow::Borrow<K>, flags: u64) -> core::result::Result<(), u32>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::redirect_skb(&self, ctx: &aya_ebpf::programs::sk_buff::SkBuffContext, key: &mut K, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::update(&self, key: &mut K, sk_ops: &mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::sock_hash::SockHash<K>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_hash::SockHash<K>
impl<K: core::marker::Sync> core::marker::Sync for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> !core::marker::Freeze for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> core::marker::Send for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::marker::Send
impl<K> core::marker::Unpin for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::marker::Unpin
impl<K> !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::sock_hash::SockHash<K>
impl<K> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::sock_hash::SockHash<K> where K: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::From<T>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::Into<T>
pub type aya_ebpf::maps::sock_hash::SockHash<K>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::sock_hash::SockHash<K> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::sock_hash::SockHash<K>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::sock_hash::SockHash<K> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::sock_hash::SockHash<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::sock_hash::SockHash<K> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::sock_hash::SockHash<K>
pub fn aya_ebpf::maps::sock_hash::SockHash<K>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::SockMap
impl aya_ebpf::maps::sock_map::SockMap
pub const fn aya_ebpf::maps::sock_map::SockMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_map::SockMap
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::redirect_msg(&self, ctx: &aya_ebpf::programs::sk_msg::SkMsgContext, index: u32, flags: u64) -> i64
pub fn aya_ebpf::maps::sock_map::SockMap::redirect_sk_lookup(&mut self, ctx: &aya_ebpf::programs::sk_lookup::SkLookupContext, index: u32, flags: u64) -> core::result::Result<(), u32>
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::redirect_skb(&self, ctx: &aya_ebpf::programs::sk_buff::SkBuffContext, index: u32, flags: u64) -> i64
pub unsafe fn aya_ebpf::maps::sock_map::SockMap::update(&self, index: u32, sk_ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::sock_map::SockMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::sock_map::SockMap
impl core::marker::Sync for aya_ebpf::maps::sock_map::SockMap
impl !core::marker::Freeze for aya_ebpf::maps::sock_map::SockMap
impl core::marker::Send for aya_ebpf::maps::sock_map::SockMap
impl core::marker::Unpin for aya_ebpf::maps::sock_map::SockMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::sock_map::SockMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::sock_map::SockMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::sock_map::SockMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::sock_map::SockMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::sock_map::SockMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::sock_map::SockMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::sock_map::SockMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::sock_map::SockMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::sock_map::SockMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::sock_map::SockMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::sock_map::SockMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::sock_map::SockMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::sock_map::SockMap
pub fn aya_ebpf::maps::sock_map::SockMap::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::Stack<T>
impl<T> aya_ebpf::maps::stack::Stack<T>
pub const fn aya_ebpf::maps::stack::Stack<T>::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack::Stack<T>
pub fn aya_ebpf::maps::stack::Stack<T>::pop(&mut self) -> core::option::Option<T>
pub fn aya_ebpf::maps::stack::Stack<T>::push(&mut self, value: &T, flags: u64) -> core::result::Result<(), i64>
pub const fn aya_ebpf::maps::stack::Stack<T>::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack::Stack<T>
impl<T> core::marker::Freeze for aya_ebpf::maps::stack::Stack<T>
impl<T> core::marker::Send for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Send
impl<T> core::marker::Sync for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Sync
impl<T> core::marker::Unpin for aya_ebpf::maps::stack::Stack<T> where T: core::marker::Unpin
impl<T> core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::stack::Stack<T> where T: core::panic::unwind_safe::RefUnwindSafe
impl<T> core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::stack::Stack<T> where T: core::panic::unwind_safe::UnwindSafe
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::From<T>
pub fn aya_ebpf::maps::stack::Stack<T>::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::Into<T>
pub type aya_ebpf::maps::stack::Stack<T>::Error = core::convert::Infallible
pub fn aya_ebpf::maps::stack::Stack<T>::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::stack::Stack<T> where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::stack::Stack<T>::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::stack::Stack<T>::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::stack::Stack<T> where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::stack::Stack<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::stack::Stack<T> where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack::Stack<T>::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::stack::Stack<T>
pub fn aya_ebpf::maps::stack::Stack<T>::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::StackTrace
impl aya_ebpf::maps::stack_trace::StackTrace
pub unsafe fn aya_ebpf::maps::stack_trace::StackTrace::get_stackid<C: aya_ebpf::EbpfContext>(&self, ctx: &C, flags: u64) -> core::result::Result<i64, i64>
pub const fn aya_ebpf::maps::stack_trace::StackTrace::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack_trace::StackTrace
pub const fn aya_ebpf::maps::stack_trace::StackTrace::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Sync for aya_ebpf::maps::stack_trace::StackTrace
impl !core::marker::Freeze for aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Send for aya_ebpf::maps::stack_trace::StackTrace
impl core::marker::Unpin for aya_ebpf::maps::stack_trace::StackTrace
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::stack_trace::StackTrace
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::stack_trace::StackTrace
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::From<T>
pub fn aya_ebpf::maps::stack_trace::StackTrace::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::Into<T>
pub type aya_ebpf::maps::stack_trace::StackTrace::Error = core::convert::Infallible
pub fn aya_ebpf::maps::stack_trace::StackTrace::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::stack_trace::StackTrace where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::stack_trace::StackTrace::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::stack_trace::StackTrace::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::stack_trace::StackTrace where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::stack_trace::StackTrace where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::stack_trace::StackTrace where T: ?core::marker::Sized
pub fn aya_ebpf::maps::stack_trace::StackTrace::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::stack_trace::StackTrace
pub fn aya_ebpf::maps::stack_trace::StackTrace::from(t: T) -> T
#[repr(transparent)] pub struct aya_ebpf::maps::XskMap
impl aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::get(&self, index: u32) -> core::option::Option<u32>
pub const fn aya_ebpf::maps::XskMap::pinned(max_entries: u32, flags: u32) -> aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::redirect(&self, index: u32, flags: u64) -> core::result::Result<u32, u32>
pub const fn aya_ebpf::maps::XskMap::with_max_entries(max_entries: u32, flags: u32) -> aya_ebpf::maps::XskMap
impl core::marker::Sync for aya_ebpf::maps::XskMap
impl !core::marker::Freeze for aya_ebpf::maps::XskMap
impl core::marker::Send for aya_ebpf::maps::XskMap
impl core::marker::Unpin for aya_ebpf::maps::XskMap
impl !core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::maps::XskMap
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::maps::XskMap
impl<T, U> core::convert::Into<U> for aya_ebpf::maps::XskMap where U: core::convert::From<T>
pub fn aya_ebpf::maps::XskMap::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::maps::XskMap where U: core::convert::Into<T>
pub type aya_ebpf::maps::XskMap::Error = core::convert::Infallible
pub fn aya_ebpf::maps::XskMap::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::maps::XskMap where U: core::convert::TryFrom<T>
pub type aya_ebpf::maps::XskMap::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::maps::XskMap::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::maps::XskMap where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::maps::XskMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::maps::XskMap where T: ?core::marker::Sized
pub fn aya_ebpf::maps::XskMap::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::maps::XskMap
pub fn aya_ebpf::maps::XskMap::from(t: T) -> T
pub mod aya_ebpf::programs
pub mod aya_ebpf::programs::device
pub struct aya_ebpf::programs::device::DeviceContext
pub aya_ebpf::programs::device::DeviceContext::device: *mut aya_ebpf_bindings::x86_64::bindings::bpf_cgroup_dev_ctx
impl aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::new(device: *mut aya_ebpf_bindings::x86_64::bindings::bpf_cgroup_dev_ctx) -> aya_ebpf::programs::device::DeviceContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::device::DeviceContext
impl !core::marker::Send for aya_ebpf::programs::device::DeviceContext
impl !core::marker::Sync for aya_ebpf::programs::device::DeviceContext
impl core::marker::Unpin for aya_ebpf::programs::device::DeviceContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::device::DeviceContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::device::DeviceContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::device::DeviceContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::device::DeviceContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::device::DeviceContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::device::DeviceContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::device::DeviceContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::device::DeviceContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::device::DeviceContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::device::DeviceContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::from(t: T) -> T
pub mod aya_ebpf::programs::fentry
pub struct aya_ebpf::programs::fentry::FEntryContext
impl aya_ebpf::programs::fentry::FEntryContext
pub unsafe fn aya_ebpf::programs::fentry::FEntryContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::fentry::FEntryContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::fentry::FEntryContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fentry::FEntryContext
pub fn aya_ebpf::programs::fentry::FEntryContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::fentry::FEntryContext
impl !core::marker::Send for aya_ebpf::programs::fentry::FEntryContext
impl !core::marker::Sync for aya_ebpf::programs::fentry::FEntryContext
impl core::marker::Unpin for aya_ebpf::programs::fentry::FEntryContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::fentry::FEntryContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::fentry::FEntryContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::fentry::FEntryContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::fentry::FEntryContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::fentry::FEntryContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::fentry::FEntryContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::fentry::FEntryContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::fentry::FEntryContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::fentry::FEntryContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::fentry::FEntryContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::fentry::FEntryContext
pub fn aya_ebpf::programs::fentry::FEntryContext::from(t: T) -> T
pub mod aya_ebpf::programs::fexit
pub struct aya_ebpf::programs::fexit::FExitContext
impl aya_ebpf::programs::fexit::FExitContext
pub unsafe fn aya_ebpf::programs::fexit::FExitContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::fexit::FExitContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::fexit::FExitContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fexit::FExitContext
pub fn aya_ebpf::programs::fexit::FExitContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::fexit::FExitContext
impl !core::marker::Send for aya_ebpf::programs::fexit::FExitContext
impl !core::marker::Sync for aya_ebpf::programs::fexit::FExitContext
impl core::marker::Unpin for aya_ebpf::programs::fexit::FExitContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::fexit::FExitContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::fexit::FExitContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::fexit::FExitContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::fexit::FExitContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::fexit::FExitContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::fexit::FExitContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::fexit::FExitContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::fexit::FExitContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::fexit::FExitContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::fexit::FExitContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::fexit::FExitContext
pub fn aya_ebpf::programs::fexit::FExitContext::from(t: T) -> T
pub mod aya_ebpf::programs::lsm
pub struct aya_ebpf::programs::lsm::LsmContext
impl aya_ebpf::programs::lsm::LsmContext
pub unsafe fn aya_ebpf::programs::lsm::LsmContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::lsm::LsmContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::lsm::LsmContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::lsm::LsmContext
pub fn aya_ebpf::programs::lsm::LsmContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::lsm::LsmContext
impl !core::marker::Send for aya_ebpf::programs::lsm::LsmContext
impl !core::marker::Sync for aya_ebpf::programs::lsm::LsmContext
impl core::marker::Unpin for aya_ebpf::programs::lsm::LsmContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::lsm::LsmContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::lsm::LsmContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::lsm::LsmContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::lsm::LsmContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::lsm::LsmContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::lsm::LsmContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::lsm::LsmContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::lsm::LsmContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::lsm::LsmContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::lsm::LsmContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::lsm::LsmContext
pub fn aya_ebpf::programs::lsm::LsmContext::from(t: T) -> T
pub mod aya_ebpf::programs::perf_event
pub struct aya_ebpf::programs::perf_event::PerfEventContext
impl aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::perf_event::PerfEventContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::perf_event::PerfEventContext
impl !core::marker::Send for aya_ebpf::programs::perf_event::PerfEventContext
impl !core::marker::Sync for aya_ebpf::programs::perf_event::PerfEventContext
impl core::marker::Unpin for aya_ebpf::programs::perf_event::PerfEventContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::perf_event::PerfEventContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::perf_event::PerfEventContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::perf_event::PerfEventContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::perf_event::PerfEventContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::perf_event::PerfEventContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::perf_event::PerfEventContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::perf_event::PerfEventContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::perf_event::PerfEventContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::perf_event::PerfEventContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::perf_event::PerfEventContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::from(t: T) -> T
pub mod aya_ebpf::programs::probe
pub struct aya_ebpf::programs::probe::ProbeContext
pub aya_ebpf::programs::probe::ProbeContext::regs: *mut aya_ebpf_bindings::x86_64::bindings::pt_regs
impl aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::arg<T: FromPtRegs>(&self, n: usize) -> core::option::Option<T>
pub fn aya_ebpf::programs::probe::ProbeContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::probe::ProbeContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::probe::ProbeContext
impl !core::marker::Send for aya_ebpf::programs::probe::ProbeContext
impl !core::marker::Sync for aya_ebpf::programs::probe::ProbeContext
impl core::marker::Unpin for aya_ebpf::programs::probe::ProbeContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::probe::ProbeContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::probe::ProbeContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::probe::ProbeContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::probe::ProbeContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::probe::ProbeContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::probe::ProbeContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::probe::ProbeContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::probe::ProbeContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::probe::ProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::probe::ProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::from(t: T) -> T
pub mod aya_ebpf::programs::raw_tracepoint
pub struct aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl !core::marker::Send for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl !core::marker::Sync for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::marker::Unpin for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::raw_tracepoint::RawTracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::raw_tracepoint::RawTracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::from(t: T) -> T
pub mod aya_ebpf::programs::retprobe
pub struct aya_ebpf::programs::retprobe::RetProbeContext
pub aya_ebpf::programs::retprobe::RetProbeContext::regs: *mut aya_ebpf_bindings::x86_64::bindings::pt_regs
impl aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::ret<T: FromPtRegs>(&self) -> core::option::Option<T>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::retprobe::RetProbeContext
impl !core::marker::Send for aya_ebpf::programs::retprobe::RetProbeContext
impl !core::marker::Sync for aya_ebpf::programs::retprobe::RetProbeContext
impl core::marker::Unpin for aya_ebpf::programs::retprobe::RetProbeContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::retprobe::RetProbeContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::retprobe::RetProbeContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::retprobe::RetProbeContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::retprobe::RetProbeContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::retprobe::RetProbeContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::retprobe::RetProbeContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::retprobe::RetProbeContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::retprobe::RetProbeContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::retprobe::RetProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::retprobe::RetProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::from(t: T) -> T
pub mod aya_ebpf::programs::sk_buff
pub struct aya_ebpf::programs::sk_buff::SkBuff
pub aya_ebpf::programs::sk_buff::SkBuff::skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff
impl aya_ebpf::programs::sk_buff::SkBuff
pub fn aya_ebpf::programs::sk_buff::SkBuff::adjust_room(&self, len_diff: i32, mode: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::cb(&self) -> &[u32]
pub fn aya_ebpf::programs::sk_buff::SkBuff::cb_mut(&mut self) -> &mut [u32]
pub fn aya_ebpf::programs::sk_buff::SkBuff::change_proto(&self, proto: u16, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::change_type(&self, ty: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::clone_redirect(&self, if_index: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::family(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::get_socket_uid(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::l3_csum_replace(&self, offset: usize, from: u64, to: u64, size: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::l4_csum_replace(&self, offset: usize, from: u64, to: u64, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::len(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::load<T>(&self, offset: usize) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::load_bytes(&self, offset: usize, dst: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::local_ipv4(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::local_ipv6(&self) -> &[u32; 4]
pub fn aya_ebpf::programs::sk_buff::SkBuff::local_port(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::new(skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff) -> aya_ebpf::programs::sk_buff::SkBuff
pub fn aya_ebpf::programs::sk_buff::SkBuff::protocol(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::pull_data(&self, len: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuff::remote_ipv4(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::remote_ipv6(&self) -> &[u32; 4]
pub fn aya_ebpf::programs::sk_buff::SkBuff::remote_port(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuff::set_mark(&mut self, mark: u32)
pub fn aya_ebpf::programs::sk_buff::SkBuff::store<T>(&mut self, offset: usize, v: &T, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
impl core::marker::Freeze for aya_ebpf::programs::sk_buff::SkBuff
impl !core::marker::Send for aya_ebpf::programs::sk_buff::SkBuff
impl !core::marker::Sync for aya_ebpf::programs::sk_buff::SkBuff
impl core::marker::Unpin for aya_ebpf::programs::sk_buff::SkBuff
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_buff::SkBuff
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_buff::SkBuff
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_buff::SkBuff where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_buff::SkBuff::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_buff::SkBuff where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_buff::SkBuff::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_buff::SkBuff::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_buff::SkBuff where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_buff::SkBuff::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_buff::SkBuff::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_buff::SkBuff where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuff::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_buff::SkBuff where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuff::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_buff::SkBuff where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuff::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_buff::SkBuff
pub fn aya_ebpf::programs::sk_buff::SkBuff::from(t: T) -> T
pub struct aya_ebpf::programs::sk_buff::SkBuffContext
pub aya_ebpf::programs::sk_buff::SkBuffContext::skb: aya_ebpf::programs::sk_buff::SkBuff
impl aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::adjust_room(&self, len_diff: i32, mode: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::cb(&self) -> &[u32]
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::cb_mut(&mut self) -> &mut [u32]
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::change_type(&self, ty: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::clone_redirect(&self, if_index: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::get_socket_uid(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::l3_csum_replace(&self, offset: usize, from: u64, to: u64, size: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::l4_csum_replace(&self, offset: usize, from: u64, to: u64, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::len(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::load<T>(&self, offset: usize) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::load_bytes(&self, offset: usize, dst: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::new(skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff) -> aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::pull_data(&self, len: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::set_mark(&mut self, mark: u32)
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::store<T>(&mut self, offset: usize, v: &T, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_buff::SkBuffContext
impl !core::marker::Send for aya_ebpf::programs::sk_buff::SkBuffContext
impl !core::marker::Sync for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::marker::Unpin for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_buff::SkBuffContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_buff::SkBuffContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_buff::SkBuffContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_buff::SkBuffContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_buff::SkBuffContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_buff::SkBuffContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::from(t: T) -> T
pub mod aya_ebpf::programs::sk_lookup
pub struct aya_ebpf::programs::sk_lookup::SkLookupContext
pub aya_ebpf::programs::sk_lookup::SkLookupContext::lookup: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sk_lookup
impl aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::new(lookup: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sk_lookup) -> aya_ebpf::programs::sk_lookup::SkLookupContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_lookup::SkLookupContext
impl !core::marker::Send for aya_ebpf::programs::sk_lookup::SkLookupContext
impl !core::marker::Sync for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::marker::Unpin for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_lookup::SkLookupContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_lookup::SkLookupContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_lookup::SkLookupContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_lookup::SkLookupContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_lookup::SkLookupContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_lookup::SkLookupContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::from(t: T) -> T
pub mod aya_ebpf::programs::sk_msg
pub struct aya_ebpf::programs::sk_msg::SkMsgContext
pub aya_ebpf::programs::sk_msg::SkMsgContext::msg: *mut aya_ebpf_bindings::x86_64::bindings::sk_msg_md
impl aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::data(&self) -> usize
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::new(msg: *mut aya_ebpf_bindings::x86_64::bindings::sk_msg_md) -> aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::pop_data(&self, start: u32, len: u32, flags: u64) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::push_data(&self, start: u32, len: u32, flags: u64) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::size(&self) -> u32
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_msg::SkMsgContext
impl !core::marker::Send for aya_ebpf::programs::sk_msg::SkMsgContext
impl !core::marker::Sync for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::marker::Unpin for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_msg::SkMsgContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_msg::SkMsgContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_msg::SkMsgContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_msg::SkMsgContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_msg::SkMsgContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_msg::SkMsgContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::from(t: T) -> T
pub mod aya_ebpf::programs::sock
pub struct aya_ebpf::programs::sock::SockContext
pub aya_ebpf::programs::sock::SockContext::sock: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock
impl aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::new(sock: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock) -> aya_ebpf::programs::sock::SockContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock::SockContext
impl !core::marker::Send for aya_ebpf::programs::sock::SockContext
impl !core::marker::Sync for aya_ebpf::programs::sock::SockContext
impl core::marker::Unpin for aya_ebpf::programs::sock::SockContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock::SockContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock::SockContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock::SockContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock::SockContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock::SockContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock::SockContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock::SockContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock::SockContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock::SockContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock::SockContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::from(t: T) -> T
pub mod aya_ebpf::programs::sock_addr
pub struct aya_ebpf::programs::sock_addr::SockAddrContext
pub aya_ebpf::programs::sock_addr::SockAddrContext::sock_addr: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_addr
impl aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::new(sock_addr: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_addr) -> aya_ebpf::programs::sock_addr::SockAddrContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock_addr::SockAddrContext
impl !core::marker::Send for aya_ebpf::programs::sock_addr::SockAddrContext
impl !core::marker::Sync for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::marker::Unpin for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock_addr::SockAddrContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock_addr::SockAddrContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock_addr::SockAddrContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock_addr::SockAddrContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock_addr::SockAddrContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock_addr::SockAddrContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::from(t: T) -> T
pub mod aya_ebpf::programs::sock_ops
pub struct aya_ebpf::programs::sock_ops::SockOpsContext
pub aya_ebpf::programs::sock_ops::SockOpsContext::ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops
impl aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::arg(&self, n: usize) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::cb_flags(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::family(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_ip4(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_ip6(&self) -> [u32; 4]
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_port(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::new(ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops) -> aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::op(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_ip4(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_ip6(&self) -> [u32; 4]
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_port(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::set_cb_flags(&self, flags: i32) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::set_reply(&mut self, reply: u32)
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock_ops::SockOpsContext
impl !core::marker::Send for aya_ebpf::programs::sock_ops::SockOpsContext
impl !core::marker::Sync for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::marker::Unpin for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock_ops::SockOpsContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock_ops::SockOpsContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock_ops::SockOpsContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock_ops::SockOpsContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock_ops::SockOpsContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock_ops::SockOpsContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::from(t: T) -> T
pub mod aya_ebpf::programs::sockopt
pub struct aya_ebpf::programs::sockopt::SockoptContext
pub aya_ebpf::programs::sockopt::SockoptContext::sockopt: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sockopt
impl aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::new(sockopt: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sockopt) -> aya_ebpf::programs::sockopt::SockoptContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sockopt::SockoptContext
impl !core::marker::Send for aya_ebpf::programs::sockopt::SockoptContext
impl !core::marker::Sync for aya_ebpf::programs::sockopt::SockoptContext
impl core::marker::Unpin for aya_ebpf::programs::sockopt::SockoptContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sockopt::SockoptContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sockopt::SockoptContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sockopt::SockoptContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sockopt::SockoptContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sockopt::SockoptContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sockopt::SockoptContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sockopt::SockoptContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sockopt::SockoptContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sockopt::SockoptContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sockopt::SockoptContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::from(t: T) -> T
pub mod aya_ebpf::programs::sysctl
pub struct aya_ebpf::programs::sysctl::SysctlContext
pub aya_ebpf::programs::sysctl::SysctlContext::sysctl: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sysctl
impl aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::new(sysctl: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sysctl) -> aya_ebpf::programs::sysctl::SysctlContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sysctl::SysctlContext
impl !core::marker::Send for aya_ebpf::programs::sysctl::SysctlContext
impl !core::marker::Sync for aya_ebpf::programs::sysctl::SysctlContext
impl core::marker::Unpin for aya_ebpf::programs::sysctl::SysctlContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sysctl::SysctlContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sysctl::SysctlContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sysctl::SysctlContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sysctl::SysctlContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sysctl::SysctlContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sysctl::SysctlContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sysctl::SysctlContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sysctl::SysctlContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sysctl::SysctlContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sysctl::SysctlContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::from(t: T) -> T
pub mod aya_ebpf::programs::tc
pub struct aya_ebpf::programs::tc::TcContext
pub aya_ebpf::programs::tc::TcContext::skb: aya_ebpf::programs::sk_buff::SkBuff
impl aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::adjust_room(&self, len_diff: i32, mode: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::cb(&self) -> &[u32]
pub fn aya_ebpf::programs::tc::TcContext::cb_mut(&mut self) -> &mut [u32]
pub fn aya_ebpf::programs::tc::TcContext::change_proto(&self, proto: u16, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::change_type(&self, ty: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::clone_redirect(&self, if_index: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::data(&self) -> usize
pub fn aya_ebpf::programs::tc::TcContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::tc::TcContext::get_socket_uid(&self) -> u32
pub fn aya_ebpf::programs::tc::TcContext::l3_csum_replace(&self, offset: usize, from: u64, to: u64, size: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::l4_csum_replace(&self, offset: usize, from: u64, to: u64, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::len(&self) -> u32
pub fn aya_ebpf::programs::tc::TcContext::load<T>(&self, offset: usize) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::load_bytes(&self, offset: usize, dst: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::new(skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff) -> aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::pull_data(&self, len: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::set_mark(&mut self, mark: u32)
pub fn aya_ebpf::programs::tc::TcContext::store<T>(&mut self, offset: usize, v: &T, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::as_ptr(&self) -> *mut aya_ebpf_cty::c_void
impl core::marker::Freeze for aya_ebpf::programs::tc::TcContext
impl !core::marker::Send for aya_ebpf::programs::tc::TcContext
impl !core::marker::Sync for aya_ebpf::programs::tc::TcContext
impl core::marker::Unpin for aya_ebpf::programs::tc::TcContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tc::TcContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tc::TcContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tc::TcContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tc::TcContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tc::TcContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tc::TcContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tc::TcContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tc::TcContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tc::TcContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tc::TcContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::from(t: T) -> T
pub mod aya_ebpf::programs::tp_btf
pub struct aya_ebpf::programs::tp_btf::BtfTracePointContext
impl aya_ebpf::programs::tp_btf::BtfTracePointContext
pub unsafe fn aya_ebpf::programs::tp_btf::BtfTracePointContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::tp_btf::BtfTracePointContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tp_btf::BtfTracePointContext
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl !core::marker::Send for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl !core::marker::Sync for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::marker::Unpin for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tp_btf::BtfTracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tp_btf::BtfTracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::from(t: T) -> T
pub mod aya_ebpf::programs::tracepoint
pub struct aya_ebpf::programs::tracepoint::TracePointContext
impl aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::tracepoint::TracePointContext
pub unsafe fn aya_ebpf::programs::tracepoint::TracePointContext::read_at<T>(&self, offset: usize) -> core::result::Result<T, i64>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::tracepoint::TracePointContext
impl !core::marker::Send for aya_ebpf::programs::tracepoint::TracePointContext
impl !core::marker::Sync for aya_ebpf::programs::tracepoint::TracePointContext
impl core::marker::Unpin for aya_ebpf::programs::tracepoint::TracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tracepoint::TracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tracepoint::TracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tracepoint::TracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tracepoint::TracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tracepoint::TracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tracepoint::TracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tracepoint::TracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tracepoint::TracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tracepoint::TracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tracepoint::TracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::from(t: T) -> T
pub mod aya_ebpf::programs::xdp
pub struct aya_ebpf::programs::xdp::XdpContext
pub aya_ebpf::programs::xdp::XdpContext::ctx: *mut aya_ebpf_bindings::x86_64::bindings::xdp_md
impl aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::data(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::metadata(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::metadata_end(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::new(ctx: *mut aya_ebpf_bindings::x86_64::bindings::xdp_md) -> aya_ebpf::programs::xdp::XdpContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::xdp::XdpContext
impl !core::marker::Send for aya_ebpf::programs::xdp::XdpContext
impl !core::marker::Sync for aya_ebpf::programs::xdp::XdpContext
impl core::marker::Unpin for aya_ebpf::programs::xdp::XdpContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::xdp::XdpContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::xdp::XdpContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::xdp::XdpContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::xdp::XdpContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::xdp::XdpContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::xdp::XdpContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::xdp::XdpContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::xdp::XdpContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::xdp::XdpContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::xdp::XdpContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::from(t: T) -> T
pub struct aya_ebpf::programs::BtfTracePointContext
impl aya_ebpf::programs::tp_btf::BtfTracePointContext
pub unsafe fn aya_ebpf::programs::tp_btf::BtfTracePointContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::tp_btf::BtfTracePointContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tp_btf::BtfTracePointContext
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl !core::marker::Send for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl !core::marker::Sync for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::marker::Unpin for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tp_btf::BtfTracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tp_btf::BtfTracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tp_btf::BtfTracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tp_btf::BtfTracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tp_btf::BtfTracePointContext
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::from(t: T) -> T
pub struct aya_ebpf::programs::DeviceContext
pub aya_ebpf::programs::DeviceContext::device: *mut aya_ebpf_bindings::x86_64::bindings::bpf_cgroup_dev_ctx
impl aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::new(device: *mut aya_ebpf_bindings::x86_64::bindings::bpf_cgroup_dev_ctx) -> aya_ebpf::programs::device::DeviceContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::device::DeviceContext
impl !core::marker::Send for aya_ebpf::programs::device::DeviceContext
impl !core::marker::Sync for aya_ebpf::programs::device::DeviceContext
impl core::marker::Unpin for aya_ebpf::programs::device::DeviceContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::device::DeviceContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::device::DeviceContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::device::DeviceContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::device::DeviceContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::device::DeviceContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::device::DeviceContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::device::DeviceContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::device::DeviceContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::device::DeviceContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::device::DeviceContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::device::DeviceContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::device::DeviceContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::from(t: T) -> T
pub struct aya_ebpf::programs::FEntryContext
impl aya_ebpf::programs::fentry::FEntryContext
pub unsafe fn aya_ebpf::programs::fentry::FEntryContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::fentry::FEntryContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::fentry::FEntryContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fentry::FEntryContext
pub fn aya_ebpf::programs::fentry::FEntryContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::fentry::FEntryContext
impl !core::marker::Send for aya_ebpf::programs::fentry::FEntryContext
impl !core::marker::Sync for aya_ebpf::programs::fentry::FEntryContext
impl core::marker::Unpin for aya_ebpf::programs::fentry::FEntryContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::fentry::FEntryContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::fentry::FEntryContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::fentry::FEntryContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::fentry::FEntryContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::fentry::FEntryContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::fentry::FEntryContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::fentry::FEntryContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::fentry::FEntryContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::fentry::FEntryContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::fentry::FEntryContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::fentry::FEntryContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fentry::FEntryContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::fentry::FEntryContext
pub fn aya_ebpf::programs::fentry::FEntryContext::from(t: T) -> T
pub struct aya_ebpf::programs::FExitContext
impl aya_ebpf::programs::fexit::FExitContext
pub unsafe fn aya_ebpf::programs::fexit::FExitContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::fexit::FExitContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::fexit::FExitContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fexit::FExitContext
pub fn aya_ebpf::programs::fexit::FExitContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::fexit::FExitContext
impl !core::marker::Send for aya_ebpf::programs::fexit::FExitContext
impl !core::marker::Sync for aya_ebpf::programs::fexit::FExitContext
impl core::marker::Unpin for aya_ebpf::programs::fexit::FExitContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::fexit::FExitContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::fexit::FExitContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::fexit::FExitContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::fexit::FExitContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::fexit::FExitContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::fexit::FExitContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::fexit::FExitContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::fexit::FExitContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::fexit::FExitContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::fexit::FExitContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::fexit::FExitContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::fexit::FExitContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::fexit::FExitContext
pub fn aya_ebpf::programs::fexit::FExitContext::from(t: T) -> T
pub struct aya_ebpf::programs::LsmContext
impl aya_ebpf::programs::lsm::LsmContext
pub unsafe fn aya_ebpf::programs::lsm::LsmContext::arg<T: FromBtfArgument>(&self, n: usize) -> T
pub fn aya_ebpf::programs::lsm::LsmContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::lsm::LsmContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::lsm::LsmContext
pub fn aya_ebpf::programs::lsm::LsmContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::lsm::LsmContext
impl !core::marker::Send for aya_ebpf::programs::lsm::LsmContext
impl !core::marker::Sync for aya_ebpf::programs::lsm::LsmContext
impl core::marker::Unpin for aya_ebpf::programs::lsm::LsmContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::lsm::LsmContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::lsm::LsmContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::lsm::LsmContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::lsm::LsmContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::lsm::LsmContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::lsm::LsmContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::lsm::LsmContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::lsm::LsmContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::lsm::LsmContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::lsm::LsmContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::lsm::LsmContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::lsm::LsmContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::lsm::LsmContext
pub fn aya_ebpf::programs::lsm::LsmContext::from(t: T) -> T
pub struct aya_ebpf::programs::PerfEventContext
impl aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::perf_event::PerfEventContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::perf_event::PerfEventContext
impl !core::marker::Send for aya_ebpf::programs::perf_event::PerfEventContext
impl !core::marker::Sync for aya_ebpf::programs::perf_event::PerfEventContext
impl core::marker::Unpin for aya_ebpf::programs::perf_event::PerfEventContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::perf_event::PerfEventContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::perf_event::PerfEventContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::perf_event::PerfEventContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::perf_event::PerfEventContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::perf_event::PerfEventContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::perf_event::PerfEventContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::perf_event::PerfEventContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::perf_event::PerfEventContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::perf_event::PerfEventContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::perf_event::PerfEventContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::perf_event::PerfEventContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::perf_event::PerfEventContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::from(t: T) -> T
pub struct aya_ebpf::programs::ProbeContext
pub aya_ebpf::programs::ProbeContext::regs: *mut aya_ebpf_bindings::x86_64::bindings::pt_regs
impl aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::arg<T: FromPtRegs>(&self, n: usize) -> core::option::Option<T>
pub fn aya_ebpf::programs::probe::ProbeContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::probe::ProbeContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::probe::ProbeContext
impl !core::marker::Send for aya_ebpf::programs::probe::ProbeContext
impl !core::marker::Sync for aya_ebpf::programs::probe::ProbeContext
impl core::marker::Unpin for aya_ebpf::programs::probe::ProbeContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::probe::ProbeContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::probe::ProbeContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::probe::ProbeContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::probe::ProbeContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::probe::ProbeContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::probe::ProbeContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::probe::ProbeContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::probe::ProbeContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::probe::ProbeContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::probe::ProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::probe::ProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::probe::ProbeContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::from(t: T) -> T
pub struct aya_ebpf::programs::RawTracePointContext
impl aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl !core::marker::Send for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl !core::marker::Sync for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::marker::Unpin for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::raw_tracepoint::RawTracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::raw_tracepoint::RawTracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::from(t: T) -> T
pub struct aya_ebpf::programs::RetProbeContext
pub aya_ebpf::programs::RetProbeContext::regs: *mut aya_ebpf_bindings::x86_64::bindings::pt_regs
impl aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::ret<T: FromPtRegs>(&self) -> core::option::Option<T>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::retprobe::RetProbeContext
impl !core::marker::Send for aya_ebpf::programs::retprobe::RetProbeContext
impl !core::marker::Sync for aya_ebpf::programs::retprobe::RetProbeContext
impl core::marker::Unpin for aya_ebpf::programs::retprobe::RetProbeContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::retprobe::RetProbeContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::retprobe::RetProbeContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::retprobe::RetProbeContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::retprobe::RetProbeContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::retprobe::RetProbeContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::retprobe::RetProbeContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::retprobe::RetProbeContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::retprobe::RetProbeContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::retprobe::RetProbeContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::retprobe::RetProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::retprobe::RetProbeContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::retprobe::RetProbeContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::from(t: T) -> T
pub struct aya_ebpf::programs::SkBuffContext
pub aya_ebpf::programs::SkBuffContext::skb: aya_ebpf::programs::sk_buff::SkBuff
impl aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::adjust_room(&self, len_diff: i32, mode: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::cb(&self) -> &[u32]
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::cb_mut(&mut self) -> &mut [u32]
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::change_type(&self, ty: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::clone_redirect(&self, if_index: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::get_socket_uid(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::l3_csum_replace(&self, offset: usize, from: u64, to: u64, size: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::l4_csum_replace(&self, offset: usize, from: u64, to: u64, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::len(&self) -> u32
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::load<T>(&self, offset: usize) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::load_bytes(&self, offset: usize, dst: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::new(skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff) -> aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::pull_data(&self, len: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::set_mark(&mut self, mark: u32)
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::store<T>(&mut self, offset: usize, v: &T, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_buff::SkBuffContext
impl !core::marker::Send for aya_ebpf::programs::sk_buff::SkBuffContext
impl !core::marker::Sync for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::marker::Unpin for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_buff::SkBuffContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_buff::SkBuffContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_buff::SkBuffContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_buff::SkBuffContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_buff::SkBuffContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_buff::SkBuffContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_buff::SkBuffContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_buff::SkBuffContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::from(t: T) -> T
pub struct aya_ebpf::programs::SkLookupContext
pub aya_ebpf::programs::SkLookupContext::lookup: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sk_lookup
impl aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::new(lookup: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sk_lookup) -> aya_ebpf::programs::sk_lookup::SkLookupContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_lookup::SkLookupContext
impl !core::marker::Send for aya_ebpf::programs::sk_lookup::SkLookupContext
impl !core::marker::Sync for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::marker::Unpin for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_lookup::SkLookupContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_lookup::SkLookupContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_lookup::SkLookupContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_lookup::SkLookupContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_lookup::SkLookupContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_lookup::SkLookupContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_lookup::SkLookupContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_lookup::SkLookupContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::from(t: T) -> T
pub struct aya_ebpf::programs::SkMsgContext
pub aya_ebpf::programs::SkMsgContext::msg: *mut aya_ebpf_bindings::x86_64::bindings::sk_msg_md
impl aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::data(&self) -> usize
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::new(msg: *mut aya_ebpf_bindings::x86_64::bindings::sk_msg_md) -> aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::pop_data(&self, start: u32, len: u32, flags: u64) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::push_data(&self, start: u32, len: u32, flags: u64) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::size(&self) -> u32
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sk_msg::SkMsgContext
impl !core::marker::Send for aya_ebpf::programs::sk_msg::SkMsgContext
impl !core::marker::Sync for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::marker::Unpin for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sk_msg::SkMsgContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sk_msg::SkMsgContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sk_msg::SkMsgContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sk_msg::SkMsgContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sk_msg::SkMsgContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sk_msg::SkMsgContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sk_msg::SkMsgContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sk_msg::SkMsgContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::from(t: T) -> T
pub struct aya_ebpf::programs::SockAddrContext
pub aya_ebpf::programs::SockAddrContext::sock_addr: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_addr
impl aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::new(sock_addr: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_addr) -> aya_ebpf::programs::sock_addr::SockAddrContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock_addr::SockAddrContext
impl !core::marker::Send for aya_ebpf::programs::sock_addr::SockAddrContext
impl !core::marker::Sync for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::marker::Unpin for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock_addr::SockAddrContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock_addr::SockAddrContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock_addr::SockAddrContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock_addr::SockAddrContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock_addr::SockAddrContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock_addr::SockAddrContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock_addr::SockAddrContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock_addr::SockAddrContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::from(t: T) -> T
pub struct aya_ebpf::programs::SockContext
pub aya_ebpf::programs::SockContext::sock: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock
impl aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::new(sock: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock) -> aya_ebpf::programs::sock::SockContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock::SockContext
impl !core::marker::Send for aya_ebpf::programs::sock::SockContext
impl !core::marker::Sync for aya_ebpf::programs::sock::SockContext
impl core::marker::Unpin for aya_ebpf::programs::sock::SockContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock::SockContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock::SockContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock::SockContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock::SockContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock::SockContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock::SockContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock::SockContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock::SockContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock::SockContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock::SockContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock::SockContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock::SockContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::from(t: T) -> T
pub struct aya_ebpf::programs::SockOpsContext
pub aya_ebpf::programs::SockOpsContext::ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops
impl aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::arg(&self, n: usize) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::cb_flags(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::family(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_ip4(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_ip6(&self) -> [u32; 4]
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::local_port(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::new(ops: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sock_ops) -> aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::op(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_ip4(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_ip6(&self) -> [u32; 4]
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::remote_port(&self) -> u32
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::set_cb_flags(&self, flags: i32) -> core::result::Result<(), i64>
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::set_reply(&mut self, reply: u32)
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sock_ops::SockOpsContext
impl !core::marker::Send for aya_ebpf::programs::sock_ops::SockOpsContext
impl !core::marker::Sync for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::marker::Unpin for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sock_ops::SockOpsContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sock_ops::SockOpsContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sock_ops::SockOpsContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sock_ops::SockOpsContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sock_ops::SockOpsContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sock_ops::SockOpsContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sock_ops::SockOpsContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sock_ops::SockOpsContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::from(t: T) -> T
pub struct aya_ebpf::programs::SockoptContext
pub aya_ebpf::programs::SockoptContext::sockopt: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sockopt
impl aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::new(sockopt: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sockopt) -> aya_ebpf::programs::sockopt::SockoptContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sockopt::SockoptContext
impl !core::marker::Send for aya_ebpf::programs::sockopt::SockoptContext
impl !core::marker::Sync for aya_ebpf::programs::sockopt::SockoptContext
impl core::marker::Unpin for aya_ebpf::programs::sockopt::SockoptContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sockopt::SockoptContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sockopt::SockoptContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sockopt::SockoptContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sockopt::SockoptContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sockopt::SockoptContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sockopt::SockoptContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sockopt::SockoptContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sockopt::SockoptContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sockopt::SockoptContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sockopt::SockoptContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sockopt::SockoptContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sockopt::SockoptContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::from(t: T) -> T
pub struct aya_ebpf::programs::SysctlContext
pub aya_ebpf::programs::SysctlContext::sysctl: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sysctl
impl aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::new(sysctl: *mut aya_ebpf_bindings::x86_64::bindings::bpf_sysctl) -> aya_ebpf::programs::sysctl::SysctlContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::sysctl::SysctlContext
impl !core::marker::Send for aya_ebpf::programs::sysctl::SysctlContext
impl !core::marker::Sync for aya_ebpf::programs::sysctl::SysctlContext
impl core::marker::Unpin for aya_ebpf::programs::sysctl::SysctlContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::sysctl::SysctlContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::sysctl::SysctlContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::sysctl::SysctlContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::sysctl::SysctlContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::sysctl::SysctlContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::sysctl::SysctlContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::sysctl::SysctlContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::sysctl::SysctlContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::sysctl::SysctlContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::sysctl::SysctlContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::sysctl::SysctlContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::sysctl::SysctlContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::from(t: T) -> T
pub struct aya_ebpf::programs::TcContext
pub aya_ebpf::programs::TcContext::skb: aya_ebpf::programs::sk_buff::SkBuff
impl aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::adjust_room(&self, len_diff: i32, mode: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::cb(&self) -> &[u32]
pub fn aya_ebpf::programs::tc::TcContext::cb_mut(&mut self) -> &mut [u32]
pub fn aya_ebpf::programs::tc::TcContext::change_proto(&self, proto: u16, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::change_type(&self, ty: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::clone_redirect(&self, if_index: u32, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::data(&self) -> usize
pub fn aya_ebpf::programs::tc::TcContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::tc::TcContext::get_socket_uid(&self) -> u32
pub fn aya_ebpf::programs::tc::TcContext::l3_csum_replace(&self, offset: usize, from: u64, to: u64, size: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::l4_csum_replace(&self, offset: usize, from: u64, to: u64, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::len(&self) -> u32
pub fn aya_ebpf::programs::tc::TcContext::load<T>(&self, offset: usize) -> core::result::Result<T, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::load_bytes(&self, offset: usize, dst: &mut [u8]) -> core::result::Result<usize, aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::new(skb: *mut aya_ebpf_bindings::x86_64::bindings::__sk_buff) -> aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::pull_data(&self, len: u32) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::programs::tc::TcContext::set_mark(&mut self, mark: u32)
pub fn aya_ebpf::programs::tc::TcContext::store<T>(&mut self, offset: usize, v: &T, flags: u64) -> core::result::Result<(), aya_ebpf_cty::od::c_long>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::as_ptr(&self) -> *mut aya_ebpf_cty::c_void
impl core::marker::Freeze for aya_ebpf::programs::tc::TcContext
impl !core::marker::Send for aya_ebpf::programs::tc::TcContext
impl !core::marker::Sync for aya_ebpf::programs::tc::TcContext
impl core::marker::Unpin for aya_ebpf::programs::tc::TcContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tc::TcContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tc::TcContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tc::TcContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tc::TcContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tc::TcContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tc::TcContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tc::TcContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tc::TcContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tc::TcContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tc::TcContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tc::TcContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tc::TcContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::from(t: T) -> T
pub struct aya_ebpf::programs::TracePointContext
impl aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::new(ctx: *mut core::ffi::c_void) -> aya_ebpf::programs::tracepoint::TracePointContext
pub unsafe fn aya_ebpf::programs::tracepoint::TracePointContext::read_at<T>(&self, offset: usize) -> core::result::Result<T, i64>
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::tracepoint::TracePointContext
impl !core::marker::Send for aya_ebpf::programs::tracepoint::TracePointContext
impl !core::marker::Sync for aya_ebpf::programs::tracepoint::TracePointContext
impl core::marker::Unpin for aya_ebpf::programs::tracepoint::TracePointContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::tracepoint::TracePointContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::tracepoint::TracePointContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::tracepoint::TracePointContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::tracepoint::TracePointContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::tracepoint::TracePointContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::tracepoint::TracePointContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::tracepoint::TracePointContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::tracepoint::TracePointContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::tracepoint::TracePointContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::tracepoint::TracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::tracepoint::TracePointContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::tracepoint::TracePointContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::from(t: T) -> T
pub struct aya_ebpf::programs::XdpContext
pub aya_ebpf::programs::XdpContext::ctx: *mut aya_ebpf_bindings::x86_64::bindings::xdp_md
impl aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::data(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::data_end(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::metadata(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::metadata_end(&self) -> usize
pub fn aya_ebpf::programs::xdp::XdpContext::new(ctx: *mut aya_ebpf_bindings::x86_64::bindings::xdp_md) -> aya_ebpf::programs::xdp::XdpContext
impl aya_ebpf::EbpfContext for aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::as_ptr(&self) -> *mut core::ffi::c_void
impl core::marker::Freeze for aya_ebpf::programs::xdp::XdpContext
impl !core::marker::Send for aya_ebpf::programs::xdp::XdpContext
impl !core::marker::Sync for aya_ebpf::programs::xdp::XdpContext
impl core::marker::Unpin for aya_ebpf::programs::xdp::XdpContext
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::programs::xdp::XdpContext
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::programs::xdp::XdpContext
impl<T, U> core::convert::Into<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::From<T>
pub fn aya_ebpf::programs::xdp::XdpContext::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::Into<T>
pub type aya_ebpf::programs::xdp::XdpContext::Error = core::convert::Infallible
pub fn aya_ebpf::programs::xdp::XdpContext::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::programs::xdp::XdpContext where U: core::convert::TryFrom<T>
pub type aya_ebpf::programs::xdp::XdpContext::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::programs::xdp::XdpContext::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::programs::xdp::XdpContext where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::programs::xdp::XdpContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::programs::xdp::XdpContext where T: ?core::marker::Sized
pub fn aya_ebpf::programs::xdp::XdpContext::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::from(t: T) -> T
pub macro aya_ebpf::bpf_printk!
pub struct aya_ebpf::PtRegs
impl aya_ebpf::PtRegs
pub fn aya_ebpf::PtRegs::arg<T: FromPtRegs>(&self, n: usize) -> core::option::Option<T>
pub fn aya_ebpf::PtRegs::as_ptr(&self) -> *mut aya_ebpf_bindings::x86_64::bindings::pt_regs
pub fn aya_ebpf::PtRegs::new(regs: *mut aya_ebpf_bindings::x86_64::bindings::pt_regs) -> Self
pub fn aya_ebpf::PtRegs::ret<T: FromPtRegs>(&self) -> core::option::Option<T>
impl core::marker::Freeze for aya_ebpf::PtRegs
impl !core::marker::Send for aya_ebpf::PtRegs
impl !core::marker::Sync for aya_ebpf::PtRegs
impl core::marker::Unpin for aya_ebpf::PtRegs
impl core::panic::unwind_safe::RefUnwindSafe for aya_ebpf::PtRegs
impl core::panic::unwind_safe::UnwindSafe for aya_ebpf::PtRegs
impl<T, U> core::convert::Into<U> for aya_ebpf::PtRegs where U: core::convert::From<T>
pub fn aya_ebpf::PtRegs::into(self) -> U
impl<T, U> core::convert::TryFrom<U> for aya_ebpf::PtRegs where U: core::convert::Into<T>
pub type aya_ebpf::PtRegs::Error = core::convert::Infallible
pub fn aya_ebpf::PtRegs::try_from(value: U) -> core::result::Result<T, <T as core::convert::TryFrom<U>>::Error>
impl<T, U> core::convert::TryInto<U> for aya_ebpf::PtRegs where U: core::convert::TryFrom<T>
pub type aya_ebpf::PtRegs::Error = <U as core::convert::TryFrom<T>>::Error
pub fn aya_ebpf::PtRegs::try_into(self) -> core::result::Result<U, <U as core::convert::TryFrom<T>>::Error>
impl<T> core::any::Any for aya_ebpf::PtRegs where T: 'static + ?core::marker::Sized
pub fn aya_ebpf::PtRegs::type_id(&self) -> core::any::TypeId
impl<T> core::borrow::Borrow<T> for aya_ebpf::PtRegs where T: ?core::marker::Sized
pub fn aya_ebpf::PtRegs::borrow(&self) -> &T
impl<T> core::borrow::BorrowMut<T> for aya_ebpf::PtRegs where T: ?core::marker::Sized
pub fn aya_ebpf::PtRegs::borrow_mut(&mut self) -> &mut T
impl<T> core::convert::From<T> for aya_ebpf::PtRegs
pub fn aya_ebpf::PtRegs::from(t: T) -> T
pub const aya_ebpf::TASK_COMM_LEN: usize
pub trait aya_ebpf::EbpfContext
pub fn aya_ebpf::EbpfContext::as_ptr(&self) -> *mut core::ffi::c_void
pub fn aya_ebpf::EbpfContext::command(&self) -> core::result::Result<[u8; 16], aya_ebpf_cty::od::c_long>
pub fn aya_ebpf::EbpfContext::gid(&self) -> u32
pub fn aya_ebpf::EbpfContext::pid(&self) -> u32
pub fn aya_ebpf::EbpfContext::tgid(&self) -> u32
pub fn aya_ebpf::EbpfContext::uid(&self) -> u32
impl aya_ebpf::EbpfContext for aya_ebpf::programs::device::DeviceContext
pub fn aya_ebpf::programs::device::DeviceContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fentry::FEntryContext
pub fn aya_ebpf::programs::fentry::FEntryContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::fexit::FExitContext
pub fn aya_ebpf::programs::fexit::FExitContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::lsm::LsmContext
pub fn aya_ebpf::programs::lsm::LsmContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::perf_event::PerfEventContext
pub fn aya_ebpf::programs::perf_event::PerfEventContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::probe::ProbeContext
pub fn aya_ebpf::programs::probe::ProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::raw_tracepoint::RawTracePointContext
pub fn aya_ebpf::programs::raw_tracepoint::RawTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::retprobe::RetProbeContext
pub fn aya_ebpf::programs::retprobe::RetProbeContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_buff::SkBuffContext
pub fn aya_ebpf::programs::sk_buff::SkBuffContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_lookup::SkLookupContext
pub fn aya_ebpf::programs::sk_lookup::SkLookupContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sk_msg::SkMsgContext
pub fn aya_ebpf::programs::sk_msg::SkMsgContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock::SockContext
pub fn aya_ebpf::programs::sock::SockContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_addr::SockAddrContext
pub fn aya_ebpf::programs::sock_addr::SockAddrContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sock_ops::SockOpsContext
pub fn aya_ebpf::programs::sock_ops::SockOpsContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sockopt::SockoptContext
pub fn aya_ebpf::programs::sockopt::SockoptContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::sysctl::SysctlContext
pub fn aya_ebpf::programs::sysctl::SysctlContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tc::TcContext
pub fn aya_ebpf::programs::tc::TcContext::as_ptr(&self) -> *mut aya_ebpf_cty::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tp_btf::BtfTracePointContext
pub fn aya_ebpf::programs::tp_btf::BtfTracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::tracepoint::TracePointContext
pub fn aya_ebpf::programs::tracepoint::TracePointContext::as_ptr(&self) -> *mut core::ffi::c_void
impl aya_ebpf::EbpfContext for aya_ebpf::programs::xdp::XdpContext
pub fn aya_ebpf::programs::xdp::XdpContext::as_ptr(&self) -> *mut core::ffi::c_void
pub fn aya_ebpf::check_bounds_signed(value: i64, lower: i64, upper: i64) -> bool
#[no_mangle] pub unsafe c fn aya_ebpf::memcpy(dest: *mut u8, src: *mut u8, n: usize)
#[no_mangle] pub unsafe c fn aya_ebpf::memmove(dest: *mut u8, src: *mut u8, n: usize)
#[no_mangle] pub unsafe c fn aya_ebpf::memset(s: *mut u8, c: aya_ebpf_cty::ad::c_int, n: usize)
